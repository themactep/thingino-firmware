
--- /dev/null
+++ b/drivers/net/wireless/mt7601u/hw_atomic
@@ -0,0 +1,18382 @@
+ap/ap_sanity.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+ap/ap_sanity.c:					if ((pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.WscV2Info.bWpsEnable) ||
+ap/ap_sanity.c:						(pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.WscV2Info.bEnableWpsV2 == FALSE))
+ap/ap_sanity.c:									pAd->ApCfg.MBSSID[\
+ap/ap_sanity.c:                if (pAd->ApCfg.MBSSID[pEntry->apidx].AuthMode < Ndis802_11AuthModeWPA)
+ap/ap_sanity.c:				if ((pAd->ApCfg.MBSSID[pEntry->apidx].AuthMode != Ndis802_11AuthModeWAICERT) &&
+ap/ap_sanity.c:					(pAd->ApCfg.MBSSID[pEntry->apidx].AuthMode != Ndis802_11AuthModeWAIPSK))
+ap/ap_autoChSel.c:	PBSSINFO pBssInfoTab = pAd->pBssInfoTab;
+ap/ap_autoChSel.c:		DBGPRINT(RT_DEBUG_ERROR, ("pAd->pBssInfoTab equal NULL.\n"));
+ap/ap_autoChSel.c:	if (pAd->pBssInfoTab)
+ap/ap_autoChSel.c:		NdisZeroMemory(pAd->pBssInfoTab, sizeof(BSSINFO));
+ap/ap_autoChSel.c:		DBGPRINT(RT_DEBUG_ERROR, ("pAd->pBssInfoTab equal NULL.\n"));
+ap/ap_autoChSel.c:	if (pAd->pChannelInfo)
+ap/ap_autoChSel.c:		NdisZeroMemory(pAd->pChannelInfo, sizeof(CHANNELINFO));
+ap/ap_autoChSel.c:		DBGPRINT(RT_DEBUG_ERROR, ("pAd->pChannelInfo equal NULL.\n"));
+ap/ap_autoChSel.c:	if(pAd->pChannelInfo != NULL)
+ap/ap_autoChSel.c:			pAd->RalinkCounters.OneSecFalseCCACnt += RxStaCnt1.field.FalseCca;
+ap/ap_autoChSel.c:			pAd->pChannelInfo->FalseCCA[ch_index] = RxStaCnt1.field.FalseCca;
+ap/ap_autoChSel.c:		pAd->pChannelInfo->chanbusytime[ch_index] = (BusyTime * 100) / AUTO_CHANNEL_SEL_TIMEOUT;
+ap/ap_autoChSel.c:		DBGPRINT(RT_DEBUG_ERROR, ("pAd->pChannelInfo equal NULL.\n"));
+ap/ap_autoChSel.c:	for (Idx = 0; Idx < pAd->ChannelListNum; Idx++)
+ap/ap_autoChSel.c:		if (Channel == pAd->ChannelList[Idx].Channel)
+ap/ap_autoChSel.c:	for (i=0; i < pAd->ApCfg.AutoChannelSkipListNum ; i++)
+ap/ap_autoChSel.c:			UCHAR channel_idx = GetChIdx(pAd, pAd->ApCfg.AutoChannelSkipList[i]);
+ap/ap_autoChSel.c:			if ( channel_idx != pAd->ChannelListNum )
+ap/ap_autoChSel.c:				pAd->pChannelInfo->SkipList[channel_idx] = TRUE;
+ap/ap_autoChSel.c:	for (i=0; i < pAd->ApCfg.AutoChannelSkipListNum ; i++)
+ap/ap_autoChSel.c:		if (Ch == pAd->ApCfg.AutoChannelSkipList[i])
+ap/ap_autoChSel.c:	if (pAd->CommonCfg.bIEEE80211H)
+ap/ap_autoChSel.c:		for (i = 0; i < pAd->ChannelListNum; i++)
+ap/ap_autoChSel.c:			if (pAd->ChannelList[i].RemainingTimeForUse)
+ap/ap_autoChSel.c:			if (AutoChannelSkipListCheck(pAd, pAd->ChannelList[i].Channel) == TRUE)
+ap/ap_autoChSel.c:			if (pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40 &&
+ap/ap_autoChSel.c:				!(pAd->ChannelList[i].Flags & CHANNEL_40M_CAP))
+ap/ap_autoChSel.c:			TempChList[cnt++] = pAd->ChannelList[i].Channel;
+ap/ap_autoChSel.c:		ch = pAd->ChannelList[RandomByte2(pAd)%pAd->ChannelListNum].Channel;
+ap/ap_autoChSel.c:	PBSSINFO pBssInfoTab = pAd->pBssInfoTab;
+ap/ap_autoChSel.c:	PCHANNELINFO pChannelInfo = pAd->pChannelInfo;
+ap/ap_autoChSel.c:		DBGPRINT(RT_DEBUG_ERROR, ("pAd->pBssInfoTab equal NULL.\n"));
+ap/ap_autoChSel.c:		DBGPRINT(RT_DEBUG_ERROR, ("pAd->pChannelInfo equal NULL.\n"));
+ap/ap_autoChSel.c:				if (pAd->ChannelList[loop].Channel - pAd->ChannelList[loop-1].Channel > 4)
+ap/ap_autoChSel.c:				if (pAd->ChannelList[loop+1].Channel - pAd->ChannelList[loop].Channel > 4)
+ap/ap_autoChSel.c:	for (channel_idx = 0; channel_idx < pAd->ChannelListNum; channel_idx++)
+ap/ap_autoChSel.c:					pAd->ChannelList[channel_idx].Channel,
+ap/ap_autoChSel.c:	for (channel_idx = 0; channel_idx < pAd->ChannelListNum; channel_idx++)
+ap/ap_autoChSel.c:			ch = pAd->ChannelList[channel_idx].Channel;
+ap/ap_autoChSel.c:			if ((pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)
+ap/ap_autoChSel.c:			if (pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)
+ap/ap_autoChSel.c:				if (pAd->pChannelInfo->IsABand)
+ap/ap_autoChSel.c:						&& ((channel_idx + GetABandChOffset(ch)) < pAd->ChannelListNum))
+ap/ap_autoChSel.c:					if (pAd->ChannelList[channel_idx].Channel == 14)
+ap/ap_autoChSel.c:						if (((channel_idx - 4) >=0) && ((channel_idx - 4) < pAd->ChannelListNum))
+ap/ap_autoChSel.c:							ExChannel[ExChannel_idx++] = pAd->ChannelList[channel_idx - 4].Channel;
+ap/ap_autoChSel.c:						if (((channel_idx + 4) >=0) && ((channel_idx + 4) < pAd->ChannelListNum))
+ap/ap_autoChSel.c:						    ExChannel[ExChannel_idx++] = pAd->ChannelList[channel_idx + 4].Channel;
+ap/ap_autoChSel.c:		ch = pAd->ChannelList[candidate_ch].Channel;
+ap/ap_autoChSel.c:		DBGPRINT(RT_DEBUG_TRACE, ("BW        = %s\n", (pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)? "40" : "20"));
+ap/ap_autoChSel.c:	for (channel_idx = 0; channel_idx < pAd->ChannelListNum; channel_idx++)
+ap/ap_autoChSel.c:			ch = pAd->ChannelList[channel_idx].Channel;
+ap/ap_autoChSel.c:			if ((pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)
+ap/ap_autoChSel.c:					&& ((channel_idx + GetABandChOffset(ch)) < pAd->ChannelListNum))
+ap/ap_autoChSel.c:		ch = pAd->ChannelList[candidate_ch].Channel;
+ap/ap_autoChSel.c:	for (channel_idx=0 ; channel_idx < pAd->ChannelListNum ; channel_idx++)
+ap/ap_autoChSel.c:		ch = pAd->ChannelList[(base + channel_idx) % pAd->ChannelListNum].Channel;
+ap/ap_autoChSel.c:		if ((pAd->ApCfg.bAvoidDfsChannel == TRUE)
+ap/ap_autoChSel.c:    /*PBSSINFO pBssInfoTab = pAd->pBssInfoTab; */
+ap/ap_autoChSel.c:	PCHANNELINFO pChannelInfo = pAd->pChannelInfo;
+ap/ap_autoChSel.c:		DBGPRINT(RT_DEBUG_ERROR, ("pAd->pChannelInfo equal NULL.\n"));
+ap/ap_autoChSel.c:	for (channel_index=0 ; channel_index < pAd->ChannelListNum ; channel_index++)
+ap/ap_autoChSel.c:			    int Channel = pAd->ChannelList[channel_index].Channel;
+ap/ap_autoChSel.c:			    if(pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)
+ap/ap_autoChSel.c:								if(pAd->ChannelList[channel_index+1].Channel - pAd->ChannelList[channel_index].Channel == 4)
+ap/ap_autoChSel.c:								if(pAd->ChannelList[channel_index].Channel - pAd->ChannelList[channel_index-1].Channel == 4)
+ap/ap_autoChSel.c:				if((pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)&&
+ap/ap_autoChSel.c:				(pAd->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_BELOW)) 
+ap/ap_autoChSel.c:				if((pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)&&
+ap/ap_autoChSel.c:					(pAd->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_ABOVE)) 
+ap/ap_autoChSel.c:   for (channel_index=0 ; channel_index < pAd->ChannelListNum ; channel_index++)
+ap/ap_autoChSel.c:				pAd->ChannelList[channel_index].Channel,
+ap/ap_autoChSel.c:   pAd->ApCfg.AutoChannel_Channel = 0;
+ap/ap_autoChSel.c:	for (channel_index=0 ; channel_index < pAd->ChannelListNum ; channel_index++)
+ap/ap_autoChSel.c:	     if ((pAd->ApCfg.bAvoidDfsChannel == TRUE)
+ap/ap_autoChSel.c:				&& RadarChannelCheck(pAd, pAd->ChannelList[channel_index].Channel))
+ap/ap_autoChSel.c:	if (channel_index < pAd->ChannelListNum)
+ap/ap_autoChSel.c:		DBGPRINT(RT_DEBUG_TRACE,("Rule 1 APCnt : dirtiness == 0 (no one used and no interference) ==> Select Channel %d\n", pAd->ChannelList[channel_index].Channel));
+ap/ap_autoChSel.c:		return pAd->ChannelList[channel_index].Channel;
+ap/ap_autoChSel.c:		for (channel_index=0 ; channel_index < pAd->ChannelListNum ; channel_index++)
+ap/ap_autoChSel.c:			for (channel_index=0 ; channel_index < pAd->ChannelListNum ; channel_index++)
+ap/ap_autoChSel.c:					if((pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)
+ap/ap_autoChSel.c:						&& (BW40_ChannelCheck(pAd->ChannelList[channel_index].Channel) == FALSE))
+ap/ap_autoChSel.c:					if ((pAd->ApCfg.bAvoidDfsChannel == TRUE)
+ap/ap_autoChSel.c:							&& RadarChannelCheck(pAd, pAd->ChannelList[channel_index].Channel))
+ap/ap_autoChSel.c:					final_channel = pAd->ChannelList[channel_index].Channel;
+ap/ap_autoChSel.c:	for (channel_index=0 ; channel_index < pAd->ChannelListNum ; channel_index++)
+ap/ap_autoChSel.c:		final_channel = pAd->ChannelList[(base + channel_index) % pAd->ChannelListNum].Channel;
+ap/ap_autoChSel.c:		if ((pAd->ApCfg.bAvoidDfsChannel == TRUE)
+ap/ap_autoChSel.c:	PBSSINFO pBssInfoTab = pAd->pBssInfoTab;
+ap/ap_autoChSel.c:		DBGPRINT(RT_DEBUG_ERROR, ("pAd->pBssInfoTab equal NULL.\n"));
+ap/ap_autoChSel.c:/*	pAd->pBssInfoTab = (PBSSINFO)kmalloc(sizeof(BSSINFO), GFP_ATOMIC); */
+ap/ap_autoChSel.c:	os_alloc_mem(pAd, (UCHAR **)&pAd->pBssInfoTab, sizeof(BSSINFO));
+ap/ap_autoChSel.c:	if (pAd->pBssInfoTab)
+ap/ap_autoChSel.c:		NdisZeroMemory(pAd->pBssInfoTab, sizeof(BSSINFO));
+ap/ap_autoChSel.c:		DBGPRINT(RT_DEBUG_ERROR, ("%s Fail to alloc memory for pAd->pBssInfoTab", __FUNCTION__));
+ap/ap_autoChSel.c:/*	pAd->pChannelInfo = (PCHANNELINFO)kmalloc(sizeof(CHANNELINFO), GFP_ATOMIC); */
+ap/ap_autoChSel.c:	os_alloc_mem(pAd, (UCHAR **)&pAd->pChannelInfo, sizeof(CHANNELINFO));
+ap/ap_autoChSel.c:	if (pAd->pChannelInfo)
+ap/ap_autoChSel.c:		NdisZeroMemory(pAd->pChannelInfo, sizeof(CHANNELINFO));
+ap/ap_autoChSel.c:		DBGPRINT(RT_DEBUG_ERROR, ("%s Fail to alloc memory for pAd->pChannelInfo", __FUNCTION__));
+ap/ap_autoChSel.c:	if (pAd->pBssInfoTab)
+ap/ap_autoChSel.c:/*		kfree(pAd->pBssInfoTab); */
+ap/ap_autoChSel.c:		os_free_mem(NULL, pAd->pBssInfoTab);
+ap/ap_autoChSel.c:		pAd->pBssInfoTab = NULL;
+ap/ap_autoChSel.c:	if (pAd->pChannelInfo)
+ap/ap_autoChSel.c:/*		kfree(pAd->pChannelInfo); */
+ap/ap_autoChSel.c:		os_free_mem(NULL, pAd->pChannelInfo);
+ap/ap_autoChSel.c:		pAd->pChannelInfo = NULL;
+ap/ap_autoChSel.c:	pAd->pChannelInfo->IsABand = (WMODE_CAP_5G(pAd->CommonCfg.PhyMode)) ? TRUE : FALSE;
+ap/ap_autoChSel.c:	/* init pAd->pChannelInfo->IsABand */
+ap/ap_autoChSel.c:	/* init pAd->pChannelInfo->IsABand */
+ap/ap_autoChSel.c:	pAd->ApCfg.current_channel_index = 0;
+ap/ap_autoChSel.c:		domain that recorded in pAd->CommonCfg.CountryRegion
+ap/ap_autoChSel.c:	if (( Alg == ChannelAlgRandom ) && (pAd->pChannelInfo->IsABand == TRUE))
+ap/ap_autoChSel.c:		for (i=0; i<pAd->ChannelListNum; i++)
+ap/ap_autoChSel.c:			AsicSwitchChannel(pAd, pAd->ChannelList[i].Channel, TRUE);
+ap/ap_autoChSel.c:			AsicLockChannel(pAd, pAd->ChannelList[i].Channel);/*do nothing */
+ap/ap_autoChSel.c:			pAd->ApCfg.current_channel_index = i;
+ap/ap_autoChSel.c:			pAd->ApCfg.AutoChannel_Channel = pAd->ChannelList[i].Channel;
+ap/ap_qload.c:	pAd->QloadAlarmNumber ++;
+ap/ap_qload.c:	if ((pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset != 0) &&
+ap/ap_qload.c:		(pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth != 0))
+ap/ap_qload.c:		pMacTable = &pAd->MacTab;
+ap/ap_qload.c:						/*NdisReleaseSpinLock(&pAd->MacTabLock); */
+ap/ap_qload.c:									pAd->ApCfg.MBSSID[pEntry->apidx].Bssid,
+ap/ap_qload.c:									pAd->ApCfg.MBSSID[pEntry->apidx].Bssid);				
+ap/ap_qload.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 0;
+ap/ap_qload.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = 0;
+ap/ap_qload.c:		pAd->CommonCfg.RegTransmitSetting.field.BW = BW_20;
+ap/ap_qload.c:		pAd->FlgQloadAlarm = TRUE;
+ap/ap_qload.c:	EX: TBTT=100ms, 90%, pAd->QloadBusyTimeThreshold = 90ms
+ap/ap_qload.c:	pAd->QloadBusyTimeThreshold = TimePeriod;
+ap/ap_qload.c:	pAd->QloadBusyTimeThreshold *= pAd->QloadAlarmBusyTimeThreshold;
+ap/ap_qload.c:	pAd->QloadBusyTimeThreshold /= 100;
+ap/ap_qload.c:	pAd->QloadBusyTimeThreshold <<= 10; /* translate mini-sec to micro-sec */
+ap/ap_qload.c:	for(IdBss=0; IdBss<pAd->ApCfg.BssidNum; IdBss++)
+ap/ap_qload.c:		if ((pAd->ApCfg.MBSSID[IdBss].bWmmCapable)
+ap/ap_qload.c:			pAd->FlgQloadEnable = TRUE;
+ap/ap_qload.c:	if (pAd->FlgQloadEnable == TRUE)
+ap/ap_qload.c:		pAd->QloadChanUtilBeaconInt = 50;
+ap/ap_qload.c:	pAd->QloadChanUtilTotal = 0;
+ap/ap_qload.c:	pAd->QloadUpTimeLast = 0;
+ap/ap_qload.c:	NdisZeroMemory(pAd->QloadBusyCountPri, sizeof(pAd->QloadBusyCountPri));
+ap/ap_qload.c:	NdisZeroMemory(pAd->QloadBusyCountSec, sizeof(pAd->QloadBusyCountSec));
+ap/ap_qload.c:	pAd->QloadAlarmBusyTimeThreshold = QBSS_LOAD_ALRAM_BUSY_TIME_THRESHOLD;
+ap/ap_qload.c:	pAd->QloadAlarmBusyNumThreshold = QBSS_LOAD_ALRAM_BUSY_NUM_THRESHOLD;
+ap/ap_qload.c:	pAd->FlgQloadAlarm = FALSE;
+ap/ap_qload.c:	pAd->QloadAlarmDuration = 0;
+ap/ap_qload.c:	pAd->QloadAlarmNumber = 0;
+ap/ap_qload.c:	pAd->FlgQloadAlarmIsSuspended = FALSE;
+ap/ap_qload.c:	QBSS_LoadAlarmBusyTimeThresholdReset(pAd, pAd->CommonCfg.BeaconPeriod);
+ap/ap_qload.c:	pAd->FlgQloadAlarmIsSuspended = FALSE;
+ap/ap_qload.c:	pAd->FlgQloadAlarmIsSuspended = TRUE;
+ap/ap_qload.c:	if (pAd->QloadChanUtilBeaconCnt == 0)
+ap/ap_qload.c:		return pAd->QloadChanUtilTotal;
+ap/ap_qload.c:	return (pAd->QloadChanUtilTotal / pAd->QloadChanUtilBeaconCnt);
+ap/ap_qload.c:	BOOLEAN FlgQloadAlarm = pAd->FlgQloadAlarm;
+ap/ap_qload.c:	pAd->FlgQloadAlarm = FALSE;
+ap/ap_qload.c:	if (pAd->QloadAlarmBusyTimeThreshold == 0)
+ap/ap_qload.c:	if (BusyTime >= pAd->QloadBusyTimeThreshold)
+ap/ap_qload.c:	if (pAd->FlgQloadEnable == 0)
+ap/ap_qload.c:	pLoad->ChanUtil = pAd->QloadChanUtil;
+ap/ap_qload.c:	UINT32 TimePeriod = pAd->CommonCfg.BeaconPeriod;
+ap/ap_qload.c:	if ((pAd->FlgQloadEnable == 0) ||
+ap/ap_qload.c:		(pAd->FlgQloadAlarmIsSuspended == TRUE))
+ap/ap_qload.c:		(pAd->QloadUpTimeLast > 0) &&
+ap/ap_qload.c:		(UpTime > pAd->QloadUpTimeLast))
+ap/ap_qload.c:		TimePeriod = (UINT32)(UpTime - pAd->QloadUpTimeLast);
+ap/ap_qload.c:		if (TimePeriod != pAd->QloadTimePeriodLast)
+ap/ap_qload.c:		pAd->QloadTimePeriodLast = TimePeriod;
+ap/ap_qload.c:	pAd->QloadUpTimeLast = UpTime;
+ap/ap_qload.c:	if ((pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset != 0) &&
+ap/ap_qload.c:		(pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth != 0))
+ap/ap_qload.c:		pAd->QloadLatestChannelBusyTimeSec = BusyTime;
+ap/ap_qload.c:		pAd->QloadBusyCountSec[BusyTimeId] ++;
+ap/ap_qload.c:		if ((pAd->FlgQloadAlarmIsSuspended == FALSE) &&
+ap/ap_qload.c:			(pAd->QloadAlarmBusyTimeThreshold > 0))
+ap/ap_qload.c:			if ((pAd->QloadBusyTimeThreshold != 0) &&
+ap/ap_qload.c:				(BusyTime >= pAd->QloadBusyTimeThreshold))
+ap/ap_qload.c:	pAd->QloadLatestChannelBusyTimePri = BusyTime;
+ap/ap_qload.c:	pAd->QloadBusyCountPri[BusyTimeId] ++;
+ap/ap_qload.c:	if ((pAd->FlgQloadAlarmIsSuspended == FALSE) &&
+ap/ap_qload.c:		(pAd->QloadAlarmBusyTimeThreshold > 0))
+ap/ap_qload.c:		if ((pAd->QloadBusyTimeThreshold != 0) &&
+ap/ap_qload.c:			(BusyTime >= pAd->QloadBusyTimeThreshold))
+ap/ap_qload.c:	pAd->QloadChanUtilTotal += BusyTime;
+ap/ap_qload.c:	if (++pAd->QloadChanUtilBeaconCnt >= pAd->QloadChanUtilBeaconInt)
+ap/ap_qload.c:		ChanUtilNu = pAd->QloadChanUtilTotal;
+ap/ap_qload.c:		ChanUtilDe = pAd->QloadChanUtilBeaconInt;
+ap/ap_qload.c:			Still use pAd->CommonCfg.BeaconPeriod.
+ap/ap_qload.c:		ChanUtilDe *= pAd->CommonCfg.BeaconPeriod;
+ap/ap_qload.c:		pAd->QloadChanUtil = (UINT8)(ChanUtilNu/ChanUtilDe);
+ap/ap_qload.c:		pAd->QloadChanUtilBeaconCnt = 0;
+ap/ap_qload.c:		pAd->QloadChanUtilTotal = 0;
+ap/ap_qload.c:	if ((pAd->FlgQloadAlarmIsSuspended == FALSE) &&
+ap/ap_qload.c:		(pAd->QloadAlarmBusyTimeThreshold > 0))
+ap/ap_qload.c:			if (pAd->QloadAlarmDuration == 0)
+ap/ap_qload.c:				pAd->QloadAlarmBusyNum ++;
+ap/ap_qload.c:				if (pAd->QloadAlarmBusyNum >= pAd->QloadAlarmBusyNumThreshold)
+ap/ap_qload.c:					pAd->QloadAlarmDuration ++;
+ap/ap_qload.c:			pAd->QloadAlarmBusyNum = 0;
+ap/ap_qload.c:		if (pAd->QloadAlarmDuration > 0)
+ap/ap_qload.c:			if (++pAd->QloadAlarmDuration >= QBSS_LOAD_ALARM_DURATION)
+ap/ap_qload.c:				pAd->QloadAlarmDuration = 0;
+ap/ap_qload.c:				pAd->QloadAlarmBusyNum = 0;
+ap/ap_qload.c:		pAd->QloadAlarmBusyNum = 0;
+ap/ap_qload.c:		pAd->QloadAlarmDuration = 0;
+ap/ap_qload.c:		pAd->FlgQloadAlarm = FALSE;
+ap/ap_qload.c:	NdisZeroMemory(pAd->QloadBusyCountPri, sizeof(pAd->QloadBusyCountPri));
+ap/ap_qload.c:	NdisZeroMemory(pAd->QloadBusyCountSec, sizeof(pAd->QloadBusyCountSec));
+ap/ap_qload.c:	pAd->QloadChanUtilTotal = 0;
+ap/ap_qload.c:	pAd->FlgQloadAlarm = FALSE;
+ap/ap_qload.c:	pAd->QloadAlarmBusyNum = 0;
+ap/ap_qload.c:	Time = pAd->CommonCfg.BeaconPeriod / QLOAD_BUSY_INTERVALS;
+ap/ap_qload.c:				pAd->QloadBusyCountPri[BusyTimeId]);
+ap/ap_qload.c:				pAd->QloadBusyCountSec[BusyTimeId]);
+ap/ap_qload.c:	pAd->QloadAlarmBusyTimeThreshold = (UCHAR)simple_strtol(Arg, 0, 10);
+ap/ap_qload.c:	pAd->QloadTimePeriodLast = pAd->CommonCfg.BeaconPeriod;
+ap/ap_qload.c:	pAd->QloadAlarmBusyNumThreshold = (UCHAR)simple_strtol(Arg, 0, 10);
+ap/ap_mbss_inf.c:    6. BSS Index (0 ~ 15) of IOCTL command is put in pAd->OS_Cookie->ioctl_if
+ap/ap_auth.c:		pEntry = &pAd->MacTab.Content[Elem->Wcid];
+ap/ap_auth.c:						pAd->ApCfg.MBSSID[apidx].Bssid,
+ap/ap_auth.c:						pAd->ApCfg.MBSSID[apidx].Bssid);
+ap/ap_auth.c:		pEntry = &pAd->MacTab.Content[Elem->Wcid];
+ap/ap_auth.c:			pAd->ApCfg.MBSSID[pEntry->apidx].IEEE8021X)
+ap/ap_auth.c:            pAd->ApCfg.aMICFailTime = pAd->ApCfg.PrevaMICFailTime;
+ap/ap_auth.c:	if (P2P_GO_ON(pAd) && (pAd->P2pCfg.bStopAuthRsp == TRUE))
+ap/ap_auth.c:	for (apidx=0; apidx<pAd->ApCfg.BssidNum; apidx++)
+ap/ap_auth.c:		if (RTMPEqualMemory(Addr1, pAd->ApCfg.MBSSID[apidx].Bssid, MAC_ADDR_LEN))
+ap/ap_auth.c:	if (apidx >= pAd->ApCfg.BssidNum)
+ap/ap_auth.c:	if ((pAd->ApCfg.MBSSID[apidx].MSSIDDev != NULL) &&
+ap/ap_auth.c:		!(RTMP_OS_NETDEV_STATE_RUNNING(pAd->ApCfg.MBSSID[apidx].MSSIDDev)))
+ap/ap_auth.c:		if (!RTMPEqualMemory(Addr1, pAd->ApCfg.MBSSID[pEntry->apidx].Bssid, MAC_ADDR_LEN))
+ap/ap_auth.c:	if ((pAd->ApCfg.MBSSID[apidx].WscControl.WscConfMode != WSC_DISABLE) &&
+ap/ap_auth.c:		(pAd->ApCfg.MBSSID[apidx].WscControl.WscV2Info.bEnableWpsV2) &&
+ap/ap_auth.c:		(pAd->ApCfg.MBSSID[apidx].WscControl.WscV2Info.bWpsEnable) &&
+ap/ap_auth.c:		(pAd->ApCfg.MBSSID[apidx].AccessControlList.Policy == 1))
+ap/ap_auth.c:		(pAd->ApCfg.MBSSID[apidx].AuthMode != Ndis802_11AuthModeShared)) 
+ap/ap_auth.c:				((pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeShared)
+ap/ap_auth.c:				|| (pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeAutoSwitch)))
+ap/ap_auth.c:			COPY_MAC_ADDR(&pAd->ApMlmeAux.Addr, Addr2);
+ap/ap_auth.c:				pAd->ApMlmeAux.Challenge[i] = RandomByte(pAd);
+ap/ap_auth.c:								pAd->ApCfg.MBSSID[apidx].Bssid,
+ap/ap_auth.c:								pAd->ApCfg.MBSSID[apidx].Bssid);
+ap/ap_auth.c:								CIPHER_TEXT_LEN,       pAd->ApMlmeAux.Challenge,
+ap/ap_auth.c:				Alg, Seq, pAd->ApCfg.MBSSID[apidx].AuthMode));
+ap/ap_auth.c:	for (apidx=0; apidx<pAd->ApCfg.BssidNum; apidx++)
+ap/ap_auth.c:		if (RTMPEqualMemory(Addr1, pAd->ApCfg.MBSSID[apidx].Bssid, MAC_ADDR_LEN))
+ap/ap_auth.c:	if (apidx >= pAd->ApCfg.BssidNum)
+ap/ap_auth.c:	if ((pAd->ApCfg.MBSSID[apidx].MSSIDDev != NULL) &&
+ap/ap_auth.c:		!(RTMP_OS_NETDEV_STATE_RUNNING(pAd->ApCfg.MBSSID[apidx].MSSIDDev)))
+ap/ap_auth.c:	pEntry = &pAd->MacTab.Content[Elem->Wcid];
+ap/ap_auth.c:		if (!RTMPEqualMemory(Addr1, pAd->ApCfg.MBSSID[pEntry->apidx].Bssid, MAC_ADDR_LEN))
+ap/ap_auth.c:	if (pEntry && MAC_ADDR_EQUAL(Addr2, pAd->ApMlmeAux.Addr)) 
+ap/ap_auth.c:			NdisEqualMemory(Chtxt, pAd->ApMlmeAux.Challenge, CIPHER_TEXT_LEN)) 
+ap/ap_auth.c:			/*pAd->ApMlmeAux.Challenge[127]='\0'; */
+ap/ap_auth.c:			/*DBGPRINT(RT_DEBUG_TRACE, ("Sent Challenge = %s\n",&pAd->ApMlmeAux.Challenge[100])); */
+ap/ap_auth.c:		pEntry = &(pAd->MacTab.Content[Wcid]);
+ap/ap_auth.c:		bssid[5] &= pAd->ApCfg.MacMask;
+ap/ap_auth.c:		if (NdisEqualMemory(pAd->CurrentAddress, bssid, MAC_ADDR_LEN) == 0)
+ap/ap_mbss.c:    6. BSS Index (0 ~ 15) of IOCTL command is put in pAd->OS_Cookie->ioctl_if
+ap/ap_mbss.c:	if (pAd->FlgMbssInit != FALSE)
+ap/ap_mbss.c:	MaxNumBss = pAd->ApCfg.BssidNum;
+ap/ap_mbss.c:		pAd->ApCfg.MBSSID[IdBss].MSSIDDev = NULL;
+ap/ap_mbss.c:		MC_RowID = pAd->MC_RowID;
+ap/ap_mbss.c:		IoctlIF = pAd->IoctlIF;
+ap/ap_mbss.c:		pAd->IoctlIF = IoctlIF;
+ap/ap_mbss.c:			pAd->ApCfg.BssidNum = IdBss; /* re-assign new MBSS number */
+ap/ap_mbss.c:		NdisMoveMemory(&netDevHook.devAddr[0], &pAd->ApCfg.MBSSID[IdBss].Bssid[0], MAC_ADDR_LEN);
+ap/ap_mbss.c:		pAd->ApCfg.MBSSID[IdBss].MSSIDDev = pDevNew;
+ap/ap_mbss.c:		status = RtmpOSNetDevAttach(pAd->OpMode, pDevNew, &netDevHook);
+ap/ap_mbss.c:	pAd->FlgMbssInit = TRUE;
+ap/ap_mbss.c:		pMbss = &pAd->ApCfg.MBSSID[IdBss];
+ap/ap_mbss.c:	for(IdBss=0; IdBss<pAd->ApCfg.BssidNum; IdBss++)
+ap/ap_mbss.c:		if (pAd->ApCfg.MBSSID[IdBss].MSSIDDev == pDev)
+ap/ap_mbss.c:    pAd->ApCfg.MBSSID[BssId].bBcnSntReq = TRUE;
+ap/ap_mbss.c:	pAd->ApCfg.MBSSID[BssId].bBcnSntReq = FALSE;
+ap/ap_mbss.c:    pMbss = pAd->ApCfg.MBSSID;
+ap/ap_mbss.c:    for(IdBss=FIRST_MBSSID; IdBss<pAd->ApCfg.BssidNum; IdBss++)
+Binary file ap/ap_wpa.o matches
+ap/ap_dls.c:	else if (!pAd->ApCfg.MBSSID[pSAEntry->apidx].bDLSCapable)
+ap/ap_dls.c:		NdisMoveMemory(Fr->Hdr.Addr2, pAd->ApCfg.MBSSID[pSAEntry->apidx].Bssid, MAC_ADDR_LEN);
+ap/ap_dls.c:						pAd->ApCfg.MBSSID[pSAEntry->apidx].Bssid,
+ap/ap_dls.c:						pAd->ApCfg.MBSSID[pSAEntry->apidx].Bssid);
+ap/ap_dls.c:	NdisMoveMemory(Fr->Hdr.Addr2, pAd->ApCfg.MBSSID[pSAEntry->apidx].Bssid, MAC_ADDR_LEN);
+ap/ap_dls.c:	NdisMoveMemory(Fr->Hdr.Addr2, pAd->ApCfg.MBSSID[pSAEntry->apidx].Bssid, MAC_ADDR_LEN);
+ap/ap_mlme.c:	pAd->CommonCfg.Bss2040CoexistFlag &= (~BSS_2040_COEXIST_TIMER_FIRED);
+ap/ap_mlme.c:	NdisZeroMemory(&pAd->CommonCfg.LastBSSCoexist2040, sizeof(BSS_2040_COEXIST_IE));
+ap/ap_mlme.c:	pAd->CommonCfg.Bss2040CoexistFlag |= BSS_2040_COEXIST_INFO_SYNC;
+ap/ap_mlme.c:	if (pAd->CommonCfg.bBssCoexEnable == FALSE)
+ap/ap_mlme.c:	for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+ap/ap_mlme.c:		if ((pAd->CommonCfg.Channel <=14) && (pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth == BW_40))
+ap/ap_mlme.c:			pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 1;
+ap/ap_mlme.c:			pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = pAd->CommonCfg.RegTransmitSetting.field.EXTCHA;
+ap/ap_mlme.c:   			if ((pAd->CommonCfg.Channel <=14) && (pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth==BW_40))
+ap/ap_mlme.c:		PCARRIER_DETECTION_STRUCT pCarrierDetect = &pAd->CommonCfg.CarrierDetect;
+ap/ap_mlme.c:	RTMP_CHIP_HIGH_POWER_TUNING(pAd, &pAd->ApCfg.RssiSample);
+ap/ap_mlme.c:/*	if (pAd->CommonCfg.bWiFiTest == FALSE) */
+ap/ap_mlme.c:/*	if (pAd->MacTab.Size > 0) */
+ap/ap_mlme.c:	if (pAd->Mlme.PeriodicRound % MLME_TASK_EXEC_MULTIPLE == 0)
+ap/ap_mlme.c:	if (pAd->Mlme.OneSecPeriodicRound % 2 == 0)
+ap/ap_mlme.c:	if (pAd->Mlme.OneSecPeriodicRound % 2 == 1)
+ap/ap_mlme.c:			PAPCLI_STRUCT pApCliEntry = &pAd->ApCfg.ApCliTab[loop];
+ap/ap_mlme.c:					&pAd->MacTab.Content[pApCliEntry->MacTabWCID], Now32);
+ap/ap_mlme.c:    if (pAd->CommonCfg.bHTProtect)
+ap/ap_mlme.c:		if (pAd->CommonCfg.IOTestParm.bRTSLongProtOn == FALSE)
+ap/ap_mlme.c:        	AsicUpdateProtect(pAd, (USHORT)pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode, ALLN_SETPROTECT, FALSE, pAd->MacTab.fAnyStationNonGF);
+ap/ap_mlme.c:	if ( (pAd->CommonCfg.Channel > 14)
+ap/ap_mlme.c:		&& (pAd->CommonCfg.bIEEE80211H == 1)
+ap/ap_mlme.c:		pAd->Dot11_H.InServiceMonitorCount++;
+ap/ap_mlme.c:		if (pAd->Dot11_H.RDMode == RD_SILENCE_MODE)
+ap/ap_mlme.c:			if (pAd->Dot11_H.RDCount++ > pAd->Dot11_H.ChMovingTime)
+ap/ap_mlme.c:				pAd->Dot11_H.RDMode = RD_NORMAL_MODE;
+ap/ap_mlme.c:			(pAd->ApCfg.MBSSID[pEntry->apidx].AuthMode < Ndis802_11AuthModeWPA)))
+ap/ap_mlme.c:			if ((MAC_ADDR_EQUAL(pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryAddr, pEntry->Addr) || 
+ap/ap_mlme.c:				 MAC_ADDR_EQUAL(pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryAddr, ZERO_MAC_ADDR)) &&
+ap/ap_mlme.c:	            (pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.WscConfMode != WSC_DISABLE))
+ap/ap_mlme.c:	if(pAd->CommonCfg.CarrierDetect.CD_State == CD_SILENCE)
+ap/ap_mlme.c:	if (pAd->ApCfg.bGreenAPActive == TRUE)
+ap/ap_mlme.c:		rtmp_bbp_set_rxpath(pAd, pAd->Antenna.field.RxPath);
+ap/ap_mlme.c:	TxTotalCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount + 
+ap/ap_mlme.c:					pAd->RalinkCounters.OneSecTxRetryOkCount + 
+ap/ap_mlme.c:					pAd->RalinkCounters.OneSecTxFailCount;
+ap/ap_mlme.c:		RTMPSetTimer(&pAd->Mlme.RxAntEvalTimer, 20);
+ap/ap_mlme.c:		pAd->Mlme.bLowThroughput = FALSE;
+ap/ap_mlme.c:		RTMPSetTimer(&pAd->Mlme.RxAntEvalTimer, 300);
+ap/ap_mlme.c:		pAd->Mlme.bLowThroughput = TRUE;
+ap/ap_mlme.c:	if (pAd->Mlme.bLowThroughput == TRUE)
+ap/ap_mlme.c:		rssi0 = pAd->ApCfg.RssiSample.LastRssi0;
+ap/ap_mlme.c:		rssi1 = pAd->ApCfg.RssiSample.LastRssi1;
+ap/ap_mlme.c:		rssi2 = pAd->ApCfg.RssiSample.LastRssi2;
+ap/ap_mlme.c:		rssi0 = pAd->ApCfg.RssiSample.AvgRssi0;
+ap/ap_mlme.c:		rssi1 = pAd->ApCfg.RssiSample.AvgRssi1;
+ap/ap_mlme.c:		rssi2 = pAd->ApCfg.RssiSample.AvgRssi2;
+ap/ap_mlme.c:	if(pAd->Antenna.field.RxPath == 3)
+ap/ap_mlme.c:		if (pAd->CommonCfg.RxStream >= 3)
+ap/ap_mlme.c:			pAd->Mlme.RealRxPath = 3;
+ap/ap_mlme.c:			pAd->Mlme.RealRxPath = 2;
+ap/ap_mlme.c:			pAd->Mlme.RealRxPath = 3;
+ap/ap_mlme.c:	if (pAd->ApCfg.bGreenAPActive == TRUE)
+ap/ap_mlme.c:		rtmp_bbp_set_rxpath(pAd, pAd->Mlme.RealRxPath);
+ap/ap_mlme.c:		    ULONG	recvPktNum = pAd->RxAnt.RcvPktNum[AntSelect];
+ap/ap_mlme.c:		    realavgrssi1 = pAd->RxAnt.Pair1AvgRssiGroup1[AntSelect];
+ap/ap_mlme.c:		    pAd->RxAnt.Pair1AvgRssiGroup1[0] = 0;
+ap/ap_mlme.c:		    pAd->RxAnt.Pair1AvgRssiGroup1[1] = 0;
+ap/ap_mlme.c:		    pAd->RxAnt.Pair1AvgRssiGroup2[0] = 0;
+ap/ap_mlme.c:		    pAd->RxAnt.Pair1AvgRssiGroup2[1] = 0;
+ap/ap_mlme.c:		    pAd->RxAnt.RcvPktNum[0] = 0;
+ap/ap_mlme.c:		    pAd->RxAnt.RcvPktNum[1] = 0;
+Binary file ap/ap.o matches
+ap/ap_wpa.c:		pEntry = &(pAd->MacTab.Content[Wcid]);
+ap/ap_wpa.c:		/*if (IS_ENTRY_CLIENT(&pAd->MacTab.Content[Wcid])) */
+ap/ap_wpa.c:		/*ASSERT(IS_ENTRY_CLIENT(&pAd->MacTab.Content[Wcid])); */
+ap/ap_wpa.c:	ASSERT(pEntry->apidx < pAd->ApCfg.BssidNum);
+ap/ap_wpa.c:    pEntry->AuthMode = pAd->ApCfg.MBSSID[apidx].AuthMode;
+ap/ap_wpa.c:            if (pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1WPA2)
+ap/ap_wpa.c:            else if (pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK)
+ap/ap_wpa.c:            if (NdisEqualMemory(&eid_ptr->Octet[6], &pAd->ApCfg.MBSSID[apidx].RSN_IE[0][6], 4))
+ap/ap_wpa.c:            if ((pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1WPA2) || 
+ap/ap_wpa.c:                (pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK))
+ap/ap_wpa.c:            if (pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1WPA2)
+ap/ap_wpa.c:            else if (pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK)
+ap/ap_wpa.c:            if (NdisEqualMemory(&eid_ptr->Octet[2], &pAd->ApCfg.MBSSID[apidx].RSN_IE[IE_Idx][2], 4))
+ap/ap_wpa.c:	ASSERT(pEntry->apidx < pAd->ApCfg.BssidNum);
+ap/ap_wpa.c:	pEntry->WepStatus = pAd->ApCfg.MBSSID[apidx].WepStatus;
+ap/ap_wpa.c:    		if (pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11Encryption4Enabled)
+ap/ap_wpa.c:					if (MIX_CIPHER_WPA_TKIP_ON(pAd->ApCfg.MBSSID[apidx].WpaMixPairCipher))
+ap/ap_wpa.c:					if (RTMPEqualMemory(pStaTmp, &pAd->ApCfg.MBSSID[apidx].RSN_IE[0][12], 4))
+ap/ap_wpa.c:						if (MIX_CIPHER_WPA_AES_ON(pAd->ApCfg.MBSSID[apidx].WpaMixPairCipher))
+ap/ap_wpa.c:							if (RTMPEqualMemory(pStaTmp, &pAd->ApCfg.MBSSID[apidx].RSN_IE[0][16], 4))
+ap/ap_wpa.c:						if (RTMPEqualMemory(pStaTmp, &pAd->ApCfg.MBSSID[apidx].RSN_IE[0][12], 4))
+ap/ap_wpa.c:    				if (RTMPEqualMemory(pStaTmp , &pAd->ApCfg.MBSSID[apidx].RSN_IE[0][12], 4))
+ap/ap_wpa.c:			if ((pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1WPA2) || (pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK))
+ap/ap_wpa.c:			if (pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11Encryption4Enabled)
+ap/ap_wpa.c:					if (MIX_CIPHER_WPA2_TKIP_ON(pAd->ApCfg.MBSSID[apidx].WpaMixPairCipher))
+ap/ap_wpa.c:					if (RTMPEqualMemory(pStaTmp, &pAd->ApCfg.MBSSID[apidx].RSN_IE[IE_Idx][8], 4))
+ap/ap_wpa.c:						if (MIX_CIPHER_WPA2_AES_ON(pAd->ApCfg.MBSSID[apidx].WpaMixPairCipher))
+ap/ap_wpa.c:							if (RTMPEqualMemory(pStaTmp, &pAd->ApCfg.MBSSID[apidx].RSN_IE[IE_Idx][12], 4))
+ap/ap_wpa.c:						if (RTMPEqualMemory(pStaTmp, &pAd->ApCfg.MBSSID[apidx].RSN_IE[IE_Idx][8], 4))
+ap/ap_wpa.c:					if (RTMPEqualMemory(pStaTmp, &pAd->ApCfg.MBSSID[apidx].RSN_IE[IE_Idx][8], 4))
+ap/ap_wpa.c:	ASSERT(pEntry->apidx < pAd->ApCfg.BssidNum);
+ap/ap_wpa.c:				if (RTMPCheckAKM(pStaTmp, &pAd->ApCfg.MBSSID[apidx].RSN_IE[0][0],0))
+ap/ap_wpa.c:			if ((pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1WPA2) || 
+ap/ap_wpa.c:				(pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK))
+ap/ap_wpa.c:				if (RTMPCheckAKM(pStaTmp, &pAd->ApCfg.MBSSID[apidx].RSN_IE[IE_Idx][0],1))
+ap/ap_wpa.c:	pMbss = &pAd->ApCfg.MBSSID[apidx];
+ap/ap_wpa.c:    pAd->ApCfg.MICFailureCounter++;
+ap/ap_wpa.c:    if (pAd->ApCfg.CMTimerRunning == TRUE)
+ap/ap_wpa.c:		GenRandom(pAd, pAd->ApCfg.MBSSID[pEntry->apidx].Bssid, pAd->ApCfg.MBSSID[pEntry->apidx].GNonce);
+ap/ap_wpa.c:		RTMPCancelTimer(&pAd->ApCfg.CounterMeasureTimer, &Cancelled);
+ap/ap_wpa.c:		pAd->ApCfg.CMTimerRunning = FALSE;
+ap/ap_wpa.c:            if (IS_ENTRY_CLIENT(&pAd->MacTab.Content[i]))
+ap/ap_wpa.c:                MlmeDeAuthAction(pAd, &pAd->MacTab.Content[i], REASON_MIC_FAILURE, FALSE);
+ap/ap_wpa.c:        pAd->ApCfg.BANClass3Data = TRUE;        
+ap/ap_wpa.c:        /*pAd->ApCfg.MBSSID[pEntry->apidx].GKeyDoneStations = pAd->MacTab.Size; */
+ap/ap_wpa.c:        /*DBGPRINT(RT_DEBUG_TRACE, ("GKeyDoneStations=%d \n", pAd->ApCfg.MBSSID[pEntry->apidx].GKeyDoneStations)); */
+ap/ap_wpa.c:	RTMPSetTimer(&pAd->ApCfg.CounterMeasureTimer, 60 * MLME_TASK_EXEC_INTV * MLME_TASK_EXEC_MULTIPLE);
+ap/ap_wpa.c:    pAd->ApCfg.CMTimerRunning = TRUE;
+ap/ap_wpa.c:    pAd->ApCfg.PrevaMICFailTime = pAd->ApCfg.aMICFailTime;
+ap/ap_wpa.c:	RTMP_GetCurrentSystemTime(&pAd->ApCfg.aMICFailTime);
+ap/ap_wpa.c:    pAd->ApCfg.BANClass3Data = FALSE;
+ap/ap_wpa.c:        if (IS_ENTRY_CLIENT(&pAd->MacTab.Content[i])
+ap/ap_wpa.c:			&& (pAd->MacTab.Content[i].CMTimerRunning == TRUE))
+ap/ap_wpa.c:            pAd->MacTab.Content[i].CMTimerRunning =FALSE;
+ap/ap_wpa.c:    pAd->ApCfg.CMTimerRunning = FALSE;
+ap/ap_wpa.c:	for (apidx=0; apidx<pAd->ApCfg.BssidNum; apidx++)
+ap/ap_wpa.c:		if (&pAd->ApCfg.MBSSID[apidx].REKEYTimer == pTimer)
+ap/ap_wpa.c:	if (apidx == pAd->ApCfg.BssidNum)
+ap/ap_wpa.c:		pMbss = &pAd->ApCfg.MBSSID[apidx];
+ap/ap_wpa.c:				pEntry = &pAd->MacTab.Content[i];
+ap/ap_wpa.c:		NdisGetSystemUpTime(&(pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[CacheIdx].RefreshTime));
+ap/ap_wpa.c:		NdisMoveMemory(&pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[CacheIdx].PMKID, PMKID, LEN_PMKID);
+ap/ap_wpa.c:		NdisMoveMemory(&pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[CacheIdx].PMK, PMK, PMK_LEN);
+ap/ap_wpa.c:		if (!pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[i].Valid)
+ap/ap_wpa.c:			pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[i].Valid = TRUE;
+ap/ap_wpa.c:			NdisGetSystemUpTime(&(pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[i].RefreshTime));
+ap/ap_wpa.c:			COPY_MAC_ADDR(&pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[i].MAC, pAddr);
+ap/ap_wpa.c:			NdisMoveMemory(&pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[i].PMKID, PMKID, LEN_PMKID);
+ap/ap_wpa.c:			NdisMoveMemory(&pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[i].PMK, PMK, PMK_LEN);
+ap/ap_wpa.c:			if (pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[i].Valid)
+ap/ap_wpa.c:				if (((timestamp == 0) && (idx == 0)) || ((timestamp != 0) && timestamp < pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[i].RefreshTime))
+ap/ap_wpa.c:					timestamp = pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[i].RefreshTime;
+ap/ap_wpa.c:		pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[idx].Valid = TRUE;
+ap/ap_wpa.c:		NdisGetSystemUpTime(&(pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[idx].RefreshTime));
+ap/ap_wpa.c:		COPY_MAC_ADDR(&pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[idx].MAC, pAddr);
+ap/ap_wpa.c:		NdisMoveMemory(&pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[idx].PMKID, PMKID, LEN_PMKID);
+ap/ap_wpa.c:		NdisMoveMemory(&pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[idx].PMK, PMK, PMK_LEN);
+ap/ap_wpa.c:		if ((pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[i].Valid)
+ap/ap_wpa.c:			&& MAC_ADDR_EQUAL(&pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[i].MAC, pAddr))
+ap/ap_wpa.c:	PAP_BSSID_INFO pInfo = &pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[idx];
+ap/ap_wpa.c:		PMULTISSID_STRUCT pMbss = &pAd->ApCfg.MBSSID[i];
+ap/ap_wpa.c:	if (pAd->ApCfg.MBSSID[apidx].RekeyCountDown > 0)
+ap/ap_wpa.c:	if (pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus == Ndis802_11Encryption3Enabled)
+ap/ap_wpa.c:	for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+ap/ap_wpa.c:		PMULTISSID_STRUCT	pMbss = &pAd->ApCfg.MBSSID[apidx];
+ap/ap_wpa.c:	NdisZeroMemory(pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK, sizeof(pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK));
+ap/ap_wpa.c:	WpaDerivePTK(pAd, temp, temp, pAd->ApCfg.MBSSID[pEntry->apidx].Bssid, temp,
+ap/ap_wpa.c:				pEntry->Addr, pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK, LEN_PTK);
+ap/ap_wpa.c:			pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK[0],
+ap/ap_wpa.c:			pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK[1],
+ap/ap_wpa.c:			pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK[2],
+ap/ap_wpa.c:			pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK[3],
+ap/ap_wpa.c:			pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK[4],
+ap/ap_wpa.c:			pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK[5],
+ap/ap_wpa.c:			pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK[6],
+ap/ap_wpa.c:			pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK[7]));
+ap/ap_wpa.c:        RT_HMAC_MD5(pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK, LEN_PTK_KCK, (PUCHAR)pSTAKey, MICMsgLen, mic, MD5_DIGEST_SIZE);
+ap/ap_wpa.c:        RT_HMAC_SHA1(pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK, LEN_PTK_KCK, (PUCHAR)pSTAKey,  MICMsgLen, digest, SHA1_DIGEST_SIZE);
+ap/ap_wpa.c:        MAKE_802_3_HEADER(Header802_3, pDaEntry->Addr, pAd->ApCfg.MBSSID[pDaEntry->apidx].Bssid, EAPOL);
+ap/ap_wpa.c:/*        NdisMoveMemory(pDaEntry->R_Counter, pAd->ApCfg.R_Counter, sizeof(pDaEntry->R_Counter)); */
+ap/ap_wpa.c:		WpaDerivePTK(pAd, temp, temp, pAd->ApCfg.MBSSID[pEntry->apidx].Bssid, temp, DA, pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK, LEN_PTK);
+ap/ap_wpa.c:				pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK[0],
+ap/ap_wpa.c:				pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK[1],
+ap/ap_wpa.c:				pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK[2],
+ap/ap_wpa.c:				pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK[3],
+ap/ap_wpa.c:				pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK[4],
+ap/ap_wpa.c:				pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK[5],
+ap/ap_wpa.c:				pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK[6],
+ap/ap_wpa.c:				pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK[7]));
+ap/ap_wpa.c:            RT_HMAC_SHA1(pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK, LEN_PTK_KCK, pOutBuffer, FrameLen, digest, SHA1_DIGEST_SIZE);
+ap/ap_wpa.c:            RT_HMAC_MD5(pAd->ApCfg.MBSSID[pEntry->apidx].DlsPTK, LEN_PTK_KCK, pOutBuffer, FrameLen, mic, MD5_DIGEST_SIZE);
+ap/ap_wpa.c:/*	struct net_device *dev = pAd->net_dev; */
+ap/ap_wpa.c:	RtmpOSWrielessEventSend(pAd->net_dev, RT_WLAN_EVENT_CUSTOM, -1, NULL, NULL, 0);
+ap/ap_ids.c:	if (pAd->ApCfg.IDSTimerRunning == FALSE)
+ap/ap_ids.c:		RTMPSetTimer(&pAd->ApCfg.IDSTimer, IDS_EXEC_INTV);
+ap/ap_ids.c:		pAd->ApCfg.IDSTimerRunning = TRUE;
+ap/ap_ids.c:	if (pAd->ApCfg.IDSTimerRunning == TRUE)
+ap/ap_ids.c:		RTMPCancelTimer(&pAd->ApCfg.IDSTimer, &Cancelled);
+ap/ap_ids.c:		pAd->ApCfg.IDSTimerRunning = FALSE;
+ap/ap_ids.c:	FloodFrameCount[0] = pAd->ApCfg.RcvdAuthCount;
+ap/ap_ids.c:	FloodFrameCount[1] = pAd->ApCfg.RcvdAssocReqCount;
+ap/ap_ids.c:	FloodFrameCount[2] = pAd->ApCfg.RcvdReassocReqCount;
+ap/ap_ids.c:	FloodFrameCount[3] = pAd->ApCfg.RcvdProbeReqCount;
+ap/ap_ids.c:	FloodFrameCount[4] = pAd->ApCfg.RcvdDisassocCount;
+ap/ap_ids.c:	FloodFrameCount[5] = pAd->ApCfg.RcvdDeauthCount;
+ap/ap_ids.c:	FloodFrameCount[6] = pAd->ApCfg.RcvdEapReqCount;
+ap/ap_ids.c:	FloodFrameThreshold[0] = pAd->ApCfg.AuthFloodThreshold;
+ap/ap_ids.c:	FloodFrameThreshold[1] = pAd->ApCfg.AssocReqFloodThreshold;
+ap/ap_ids.c:	FloodFrameThreshold[2] = pAd->ApCfg.ReassocReqFloodThreshold;
+ap/ap_ids.c:	FloodFrameThreshold[3] = pAd->ApCfg.ProbeReqFloodThreshold;
+ap/ap_ids.c:	FloodFrameThreshold[4] = pAd->ApCfg.DisassocFloodThreshold;
+ap/ap_ids.c:	FloodFrameThreshold[5] = pAd->ApCfg.DeauthFloodThreshold;
+ap/ap_ids.c:	FloodFrameThreshold[6] = pAd->ApCfg.EapReqFloodThreshold;
+ap/ap_ids.c:	for (i = 0; i < pAd->ApCfg.BssidNum; i++)
+ap/ap_ids.c:		SpoofedFrameCount[0] = pAd->ApCfg.MBSSID[i].RcvdConflictSsidCount;
+ap/ap_ids.c:		SpoofedFrameCount[1] = pAd->ApCfg.MBSSID[i].RcvdSpoofedAssocRespCount;
+ap/ap_ids.c:		SpoofedFrameCount[2] = pAd->ApCfg.MBSSID[i].RcvdSpoofedReassocRespCount;
+ap/ap_ids.c:		SpoofedFrameCount[3] = pAd->ApCfg.MBSSID[i].RcvdSpoofedProbeRespCount;
+ap/ap_ids.c:		SpoofedFrameCount[4] = pAd->ApCfg.MBSSID[i].RcvdSpoofedBeaconCount;
+ap/ap_ids.c:		SpoofedFrameCount[5] = pAd->ApCfg.MBSSID[i].RcvdSpoofedDisassocCount;
+ap/ap_ids.c:		SpoofedFrameCount[6] = pAd->ApCfg.MBSSID[i].RcvdSpoofedAuthCount;
+ap/ap_ids.c:		SpoofedFrameCount[7] = pAd->ApCfg.MBSSID[i].RcvdSpoofedDeauthCount;
+ap/ap_ids.c:		SpoofedFrameCount[8] = pAd->ApCfg.MBSSID[i].RcvdSpoofedUnknownMgmtCount;
+ap/ap_ids.c:		SpoofedFrameCount[9] = pAd->ApCfg.MBSSID[i].RcvdReplayAttackCount;
+ap/ap_ids.c:		RssiOfSpoofedFrame[0] = pAd->ApCfg.MBSSID[i].RssiOfRcvdConflictSsid;
+ap/ap_ids.c:		RssiOfSpoofedFrame[1] = pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedAssocResp;
+ap/ap_ids.c:		RssiOfSpoofedFrame[2] = pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedReassocResp;
+ap/ap_ids.c:		RssiOfSpoofedFrame[3] = pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedProbeResp;
+ap/ap_ids.c:		RssiOfSpoofedFrame[4] = pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedBeacon;
+ap/ap_ids.c:		RssiOfSpoofedFrame[5] = pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedDisassoc;
+ap/ap_ids.c:		RssiOfSpoofedFrame[6] = pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedAuth;
+ap/ap_ids.c:		RssiOfSpoofedFrame[7] = pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedDeauth;
+ap/ap_ids.c:		RssiOfSpoofedFrame[8] = pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedUnknownMgmt;
+ap/ap_ids.c:		RssiOfSpoofedFrame[9] = pAd->ApCfg.MBSSID[i].RssiOfRcvdReplayAttack;
+ap/ap_ids.c:	pAd->ApCfg.RcvdAuthCount = 0;
+ap/ap_ids.c:	pAd->ApCfg.RcvdAssocReqCount = 0;
+ap/ap_ids.c:	pAd->ApCfg.RcvdReassocReqCount = 0;
+ap/ap_ids.c:	pAd->ApCfg.RcvdProbeReqCount = 0;
+ap/ap_ids.c:	pAd->ApCfg.RcvdDisassocCount = 0;
+ap/ap_ids.c:	pAd->ApCfg.RcvdDeauthCount = 0;
+ap/ap_ids.c:	pAd->ApCfg.RcvdEapReqCount = 0;
+ap/ap_ids.c:	for (i = 0; i < pAd->ApCfg.BssidNum; i++)
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RcvdConflictSsidCount = 0;
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RcvdSpoofedAssocRespCount = 0;
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RcvdSpoofedReassocRespCount = 0;
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RcvdSpoofedProbeRespCount = 0;
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RcvdSpoofedBeaconCount = 0;
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RcvdSpoofedDisassocCount = 0;
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RcvdSpoofedAuthCount = 0;
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RcvdSpoofedDeauthCount = 0;
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RcvdSpoofedUnknownMgmtCount = 0;	
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RcvdReplayAttackCount = 0;		
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RssiOfRcvdConflictSsid = 0;
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedAssocResp = 0;
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedReassocResp = 0;
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedProbeResp = 0;
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedBeacon = 0;
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedDisassoc = 0;
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedAuth = 0;
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedDeauth = 0;
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedUnknownMgmt = 0;	
+ap/ap_ids.c:		pAd->ApCfg.MBSSID[i].RssiOfRcvdReplayAttack = 0;		
+ap/ap_ids.c:	pAd->ApCfg.IDSTimerRunning = FALSE;
+ap/ap_ids.c:	if (pAd->CommonCfg.bWirelessEvent)	
+ap/ap_ids.c:	if (pAd->ApCfg.IdsEnable)
+ap/ap_ids.c:		RTMPSetTimer(&pAd->ApCfg.IDSTimer, IDS_EXEC_INTV);
+ap/ap_ids.c:		pAd->ApCfg.IDSTimerRunning = TRUE;
+ap/ap_ids.c:	for (i = 0; i < pAd->ApCfg.BssidNum; i++)
+ap/ap_ids.c:		if (NdisEqualMemory(pHeader->Addr2, pAd->ApCfg.MBSSID[i].Bssid, MAC_ADDR_LEN))
+ap/ap_ids.c:          			pAd->ApCfg.MBSSID[i].RcvdSpoofedAssocRespCount ++;
+ap/ap_ids.c:					pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedAssocResp = RcvdRssi;
+ap/ap_ids.c:          			pAd->ApCfg.MBSSID[i].RcvdSpoofedReassocRespCount ++;
+ap/ap_ids.c:					pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedReassocResp = RcvdRssi;
+ap/ap_ids.c:          			pAd->ApCfg.MBSSID[i].RcvdSpoofedProbeRespCount ++;
+ap/ap_ids.c:					pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedProbeResp = RcvdRssi;
+ap/ap_ids.c:          			pAd->ApCfg.MBSSID[i].RcvdSpoofedBeaconCount ++;
+ap/ap_ids.c:					pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedBeacon = RcvdRssi;
+ap/ap_ids.c:          			pAd->ApCfg.MBSSID[i].RcvdSpoofedDisassocCount ++;
+ap/ap_ids.c:					pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedDisassoc = RcvdRssi;
+ap/ap_ids.c:          			pAd->ApCfg.MBSSID[i].RcvdSpoofedAuthCount ++;
+ap/ap_ids.c:					pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedAuth = RcvdRssi;
+ap/ap_ids.c:          			pAd->ApCfg.MBSSID[i].RcvdSpoofedDeauthCount ++;
+ap/ap_ids.c:					pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedDeauth = RcvdRssi;
+ap/ap_ids.c:            		pAd->ApCfg.MBSSID[i].RcvdSpoofedUnknownMgmtCount ++;
+ap/ap_ids.c:					pAd->ApCfg.MBSSID[i].RssiOfRcvdSpoofedUnknownMgmt = RcvdRssi;
+ap/ap_ids.c:	for (i = 0; i < pAd->ApCfg.BssidNum; i++)
+ap/ap_ids.c:		if (SSID_EQUAL(pSsid, SsidLen, pAd->ApCfg.MBSSID[i].Ssid, pAd->ApCfg.MBSSID[i].SsidLen))
+ap/ap_ids.c:			pAd->ApCfg.MBSSID[i].RcvdConflictSsidCount ++;
+ap/ap_ids.c:			pAd->ApCfg.MBSSID[i].RssiOfRcvdConflictSsid = RcvdRssi;
+ap/ap_ids.c:	for (i = 0; i < pAd->ApCfg.BssidNum; i++)
+ap/ap_ids.c:		if (NdisEqualMemory(pAddr2, pAd->ApCfg.MBSSID[i].Bssid, MAC_ADDR_LEN))
+ap/ap_ids.c:			pAd->ApCfg.MBSSID[i].RcvdReplayAttackCount ++;
+ap/ap_ids.c:			pAd->ApCfg.MBSSID[i].RssiOfRcvdReplayAttack = RcvdRssi;
+ap/ap_ids.c:          	pAd->ApCfg.RcvdAssocReqCount ++;
+ap/ap_ids.c:			/*DBGPRINT(RT_DEBUG_TRACE, ("RcvdAssocReqCount=%d\n", pAd->ApCfg.RcvdAssocReqCount)); */
+ap/ap_ids.c:          	pAd->ApCfg.RcvdReassocReqCount ++;
+ap/ap_ids.c:			/*DBGPRINT(RT_DEBUG_TRACE, ("RcvdReassocReqCount=%d\n", pAd->ApCfg.RcvdReassocReqCount)); */
+ap/ap_ids.c:          	pAd->ApCfg.RcvdProbeReqCount ++;
+ap/ap_ids.c:			/*DBGPRINT(RT_DEBUG_TRACE, ("RcvdProbeReqCount=%d\n", pAd->ApCfg.RcvdProbeReqCount)); */
+ap/ap_ids.c:          	pAd->ApCfg.RcvdDisassocCount ++;
+ap/ap_ids.c:			/*DBGPRINT(RT_DEBUG_TRACE, ("RcvdDisassocCount=%d\n", pAd->ApCfg.RcvdDisassocCount)); */
+ap/ap_ids.c:          	pAd->ApCfg.RcvdDeauthCount ++;
+ap/ap_ids.c:			/*DBGPRINT(RT_DEBUG_TRACE, ("RcvdDeauthCount=%d\n", pAd->ApCfg.RcvdDeauthCount)); */
+ap/ap_ids.c:          	pAd->ApCfg.RcvdAuthCount ++;
+ap/ap_ids.c:			/*DBGPRINT(RT_DEBUG_TRACE, ("RcvdAuthCount=%d\n", pAd->ApCfg.RcvdAuthCount)); */
+ap/ap_ids.c:			pAd->ApCfg.IdsEnable = TRUE;
+ap/ap_ids.c:			pAd->ApCfg.IdsEnable = FALSE;
+ap/ap_ids.c:		DBGPRINT(RT_DEBUG_TRACE, ("IDS is %s\n", pAd->ApCfg.IdsEnable ? "enabled" : "disabled"));
+ap/ap_ids.c:		pAd->ApCfg.AuthFloodThreshold = simple_strtol(tmpbuf, 0, 10);
+ap/ap_ids.c:		DBGPRINT(RT_DEBUG_TRACE, ("AuthFloodThreshold = %d\n", pAd->ApCfg.AuthFloodThreshold));
+ap/ap_ids.c:		pAd->ApCfg.AssocReqFloodThreshold = simple_strtol(tmpbuf, 0, 10);
+ap/ap_ids.c:		DBGPRINT(RT_DEBUG_TRACE, ("AssocReqFloodThreshold = %d\n", pAd->ApCfg.AssocReqFloodThreshold));
+ap/ap_ids.c:		pAd->ApCfg.ReassocReqFloodThreshold = simple_strtol(tmpbuf, 0, 10);
+ap/ap_ids.c:		DBGPRINT(RT_DEBUG_TRACE, ("ReassocReqFloodThreshold = %d\n", pAd->ApCfg.ReassocReqFloodThreshold));
+ap/ap_ids.c:		pAd->ApCfg.ProbeReqFloodThreshold = simple_strtol(tmpbuf, 0, 10);
+ap/ap_ids.c:		DBGPRINT(RT_DEBUG_TRACE, ("ProbeReqFloodThreshold = %d\n", pAd->ApCfg.ProbeReqFloodThreshold));
+ap/ap_ids.c:		pAd->ApCfg.DisassocFloodThreshold = simple_strtol(tmpbuf, 0, 10);
+ap/ap_ids.c:		DBGPRINT(RT_DEBUG_TRACE, ("DisassocFloodThreshold = %d\n", pAd->ApCfg.DisassocFloodThreshold));
+ap/ap_ids.c:		pAd->ApCfg.DeauthFloodThreshold = simple_strtol(tmpbuf, 0, 10);
+ap/ap_ids.c:		DBGPRINT(RT_DEBUG_TRACE, ("DeauthFloodThreshold = %d\n", pAd->ApCfg.DeauthFloodThreshold));
+ap/ap_ids.c:		pAd->ApCfg.EapReqFloodThreshold = simple_strtol(tmpbuf, 0, 10);
+ap/ap_ids.c:		DBGPRINT(RT_DEBUG_TRACE, ("EapReqFloodThreshold = %d\n", pAd->ApCfg.EapReqFloodThreshold));
+ap/ap_data.c:			 	 (IS_ENTRY_APCLI(pMacEntry) && (pAd->MlmeAux.APRalinkIe != 0x0) && (pMacEntry->PortSecured == WPA_802_1X_PORT_SECURED)) || 
+ap/ap_data.c:			pAd->RalinkCounters.PendingNdisPacketCount++;
+ap/ap_data.c:	pMacEntry = &pAd->MacTab.Content[Wcid];
+ap/ap_data.c:			/* if (pAd->MacTab.Size == 0) */
+ap/ap_data.c:			if (pAd->ApCfg.EntryClientCount == 0)
+ap/ap_data.c:			pMbss = &pAd->ApCfg.MBSSID[apidx];
+ap/ap_data.c:		pMbss = &pAd->ApCfg.MBSSID[apidx];
+ap/ap_data.c:	if (pAd->ApCfg.IgmpSnoopEnable)
+ap/ap_data.c:		AllowFragSize = (pAd->CommonCfg.FragmentThreshold) - LENGTH_802_11 - LENGTH_CRC;
+ap/ap_data.c:		RTSRequired = (pAd->CommonCfg.FragmentThreshold > pAd->CommonCfg.RtsThreshold) ? 1 : 0;
+ap/ap_data.c:		RTSRequired = (PacketInfo.TotalPacketLength > pAd->CommonCfg.RtsThreshold) ? 1 : 0;
+ap/ap_data.c:	pAd->BulkOutDataSizeCount[QueIdx]+=SrcBufLen;
+ap/ap_data.c:		if (pAd->TxSwQueue[QueIdx].Number >= pAd->TxSwQMaxLen)
+ap/ap_data.c:			RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+ap/ap_data.c:			InsertTailQueueAc(pAd, pMacEntry, &pAd->TxSwQueue[QueIdx], PACKET_TO_QUEUE_ENTRY(pPacket));
+ap/ap_data.c:			RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+ap/ap_data.c:	else if ((*pSrcBufVA & 0x01) && pAd->MacTab.fAnyStationInPsm
+ap/ap_data.c:		if (pAd->MacTab.McastPsQueue.Number >= MAX_PACKETS_IN_MCAST_PS_QUEUE)
+ap/ap_data.c:			DBGPRINT(RT_DEBUG_TRACE, ("M/BCAST PSQ(=%ld) full, drop it!\n", pAd->MacTab.McastPsQueue.Number));
+ap/ap_data.c:			RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+ap/ap_data.c:			InsertHeadQueue(&pAd->MacTab.McastPsQueue, PACKET_TO_QUEUE_ENTRY(pPacket));
+ap/ap_data.c:			RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+ap/ap_data.c:			if (pAd->TxSwQueue[QueIdx].Number >= pAd->TxSwQMaxLen)
+ap/ap_data.c:				RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+ap/ap_data.c:				InsertTailQueueAc(pAd, pMacEntry, &pAd->TxSwQueue[QueIdx], PACKET_TO_QUEUE_ENTRY(pPacket));
+ap/ap_data.c:				RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+ap/ap_data.c:/*	pAd->RalinkCounters.OneSecOsTxCount[QueIdx]++; */
+ap/ap_data.c:	pMbss = &pAd->ApCfg.MBSSID[apidx];
+ap/ap_data.c:			CipherAlg  = pAd->SharedKey[apidx][KeyIdx].CipherAlg;			
+ap/ap_data.c:				pKey = &pAd->SharedKey[apidx][KeyIdx];	
+ap/ap_data.c:			CipherAlg  = pAd->MacTab.Content[RAWcid].PairwiseKey.CipherAlg;
+ap/ap_data.c:				pKey = &pAd->MacTab.Content[RAWcid].PairwiseKey;
+ap/ap_data.c:				CipherAlg  = pAd->SharedKey[apidx+1][KeyIdx].CipherAlg;			
+ap/ap_data.c:			CipherAlg  = pAd->SharedKey[apidx][KeyIdx].CipherAlg;			
+ap/ap_data.c:				pKey = &pAd->SharedKey[apidx][KeyIdx];			
+ap/ap_data.c:			CipherAlg  = pAd->MacTab.Content[RAWcid].PairwiseKey.CipherAlg;
+ap/ap_data.c:				pKey = &pAd->MacTab.Content[RAWcid].PairwiseKey;
+ap/ap_data.c:		CipherAlg  = pAd->SharedKey[apidx][KeyIdx].CipherAlg;
+ap/ap_data.c:			pKey = &pAd->SharedKey[apidx][KeyIdx];
+ap/ap_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+ap/ap_data.c:		pWI->field.Seq_Num = pAd->Sequence;
+ap/ap_data.c:		pAd->Sequence = (pAd->Sequence+1) & MAXSEQ; /* next sequence */
+ap/ap_data.c:		(P2P_TEST_BIT(pAd->P2pCfg.CTWindows, P2P_OPPS_BIT ))
+ap/ap_data.c:		&& (pAd->P2pCfg.bP2pCliPmEnable))
+ap/ap_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+ap/ap_data.c:		wifi_hdr->Sequence = pAd->Sequence;
+ap/ap_data.c:		pAd->Sequence = (pAd->Sequence+1) & MAXSEQ; /* next sequence */
+ap/ap_data.c:		COPY_MAC_ADDR(wifi_hdr->Addr2, pAd->CurrentAddress);						/* from AP1 */
+ap/ap_data.c:		COPY_MAC_ADDR(wifi_hdr->Addr2, pAd->ApCfg.MBSSID[pTxBlk->apidx].Bssid);		/* BSSID */
+ap/ap_data.c:		(P2P_TEST_BIT(pAd->P2pCfg.CTWindows, P2P_OPPS_BIT ))
+ap/ap_data.c:		&& (pAd->P2pCfg.bP2pCliPmEnable))
+ap/ap_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+ap/ap_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+ap/ap_data.c:	if (pTxBlk->pMacEntry && pAd->chipCap.FlgHwTxBfCap)
+ap/ap_data.c:				if (pAd->CommonCfg.ETxBfNoncompress==0 &&
+ap/ap_data.c:				if (pAd->CommonCfg.ETxBfNoncompress==0 &&
+ap/ap_data.c:		if (pAd->CommonCfg.HtCapability.ExtHtCapInfo.MCSFeedback >=MCSFBK_MRQ && pMacEntry->toTxMfb == 1)
+ap/ap_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+ap/ap_data.c:		if ((pAd->CommonCfg.bRdg == TRUE) 
+ap/ap_data.c:		if (pAd->chipCap.FlgHwTxBfCap)
+ap/ap_data.c:					if (pAd->CommonCfg.ETxBfNoncompress==0 &&
+ap/ap_data.c:					if ((pAd->CommonCfg.ETxBfNoncompress==0) &&
+ap/ap_data.c:			if (pAd->CommonCfg.HtCapability.ExtHtCapInfo.MCSFeedback >=MCSFBK_MRQ && 
+ap/ap_data.c:		pAd->RalinkCounters.TransmittedMPDUsInAMPDUCount.u.LowPart ++;
+ap/ap_data.c:		pAd->RalinkCounters.TransmittedOctetsInAMPDUCount.QuadPart += pTxBlk->SrcBufLen;		
+ap/ap_data.c:			pAd->CommonCfg.wapi_usk_rekey_method == REKEY_METHOD_PKT)
+ap/ap_data.c:	if (pAd->CommonCfg.DebugFlags & DBF_DBQ_TXFRAME)
+ap/ap_data.c:	pAd->RalinkCounters.KickTxCount++;
+ap/ap_data.c:	pAd->RalinkCounters.OneSecTxDoneCount++;
+ap/ap_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+ap/ap_data.c:	if ( pAd->debug_on )
+ap/ap_data.c:		do_gettimeofday(&(pAd->debug_time_2[index]));
+ap/ap_data.c:		if ((pAd->CommonCfg.bRdg == TRUE) 
+ap/ap_data.c:	if ( pAd->debug_on )
+ap/ap_data.c:		do_gettimeofday(&(pAd->debug_time_3[index]));
+ap/ap_data.c:		pAd->RalinkCounters.TransmittedMPDUsInAMPDUCount.u.LowPart ++;
+ap/ap_data.c:		pAd->RalinkCounters.TransmittedOctetsInAMPDUCount.QuadPart += pTxBlk->SrcBufLen;		
+ap/ap_data.c:			pAd->CommonCfg.wapi_usk_rekey_method == REKEY_METHOD_PKT)
+ap/ap_data.c:	if ( pAd->debug_on )
+ap/ap_data.c:		do_gettimeofday(&(pAd->debug_time_4[index]));
+ap/ap_data.c:	pAd->RalinkCounters.KickTxCount++;
+ap/ap_data.c:	pAd->RalinkCounters.OneSecTxDoneCount++;
+ap/ap_data.c:	if ( pAd->debug_on )
+ap/ap_data.c:		do_gettimeofday(&(pAd->debug_time_5[index])); 
+ap/ap_data.c:		if ( pAd->debug_index < 201 )
+ap/ap_data.c:			pAd->debug_index ++;
+ap/ap_data.c:			pAd->debug_on = 0;
+ap/ap_data.c:			pApCliEntry = &pAd->ApCfg.ApCliTab[pTxBlk->pMacEntry->MatchAPCLITabIdx];
+ap/ap_data.c:		if (pAd->CommonCfg.DebugFlags & DBF_DBQ_TXFRAME)
+ap/ap_data.c:		pAd->RalinkCounters.KickTxCount++;
+ap/ap_data.c:		pAd->RalinkCounters.OneSecTxDoneCount++;		
+ap/ap_data.c:			pAd->RalinkCounters.TransmittedAMSDUCount.u.LowPart ++;
+ap/ap_data.c:			pAd->RalinkCounters.TransmittedOctetsInAMSDU.QuadPart += totalMPDUSize;			
+ap/ap_data.c:			if (pTxBlk->pMacEntry->WapiUskRekeyTimerRunning && pAd->CommonCfg.wapi_usk_rekey_method == REKEY_METHOD_PKT)
+ap/ap_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+ap/ap_data.c:		INC_COUNTER64(pAd->WlanCounters.MulticastTransmittedFrameCount);
+ap/ap_data.c:		for (idx = 0; idx < pAd->ApCfg.BssidNum; idx++)
+ap/ap_data.c:			if (pAd->ApCfg.MBSSID[idx].REKEYTimerRunning && 
+ap/ap_data.c:				pAd->ApCfg.MBSSID[idx].WPAREKEY.ReKeyMethod == PKT_REKEY)
+ap/ap_data.c:				pAd->ApCfg.MBSSID[idx].REKEYCOUNTER += (pTxBlk->SrcBufLen);
+ap/ap_data.c:		if (pAd->CommonCfg.WapiMskRekeyTimerRunning &&
+ap/ap_data.c:			pAd->CommonCfg.wapi_msk_rekey_method == REKEY_METHOD_PKT)
+ap/ap_data.c:			pAd->CommonCfg.wapi_msk_rekey_cnt += (pTxBlk->SrcBufLen);
+ap/ap_data.c:		*pHeaderBufPtr = ((pTxBlk->UserPriority & 0x0F) | (pAd->CommonCfg.AckPolicy[pTxBlk->QueIdx]<<5));
+ap/ap_data.c:		if (pAd->chipCap.FlgHwTxBfCap && 
+ap/ap_data.c:					if ((pAd->CommonCfg.ETxBfNoncompress==0) &&
+ap/ap_data.c:					if ((pAd->CommonCfg.ETxBfNoncompress == 0) &&
+ap/ap_data.c:			if (pAd->CommonCfg.HtCapability.ExtHtCapInfo.MCSFeedback >=MCSFBK_MRQ && pMacEntry->toTxMfb == 1)
+ap/ap_data.c:		if (pTxBlk->pMacEntry->WapiUskRekeyTimerRunning && pAd->CommonCfg.wapi_usk_rekey_method == REKEY_METHOD_PKT)
+ap/ap_data.c:	if (pAd->CommonCfg.DebugFlags & DBF_DBQ_TXFRAME)
+ap/ap_data.c:	pAd->RalinkCounters.KickTxCount++;
+ap/ap_data.c:	pAd->RalinkCounters.OneSecTxDoneCount++;
+ap/ap_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+ap/ap_data.c:		INC_COUNTER64(pAd->WlanCounters.MulticastTransmittedFrameCount);
+ap/ap_data.c:	if ( pAd->debug_on )
+ap/ap_data.c:		do_gettimeofday(&(pAd->debug_time_2[index]));
+ap/ap_data.c:		if (pTxBlk->pMacEntry->WapiUskRekeyTimerRunning && pAd->CommonCfg.wapi_usk_rekey_method == REKEY_METHOD_PKT)
+ap/ap_data.c:	if ( pAd->debug_on )
+ap/ap_data.c:		do_gettimeofday(&(pAd->debug_time_3[index]));
+ap/ap_data.c:	if (pAd->CommonCfg.DebugFlags & DBF_DBQ_TXFRAME)
+ap/ap_data.c:	pAd->RalinkCounters.KickTxCount++;
+ap/ap_data.c:	pAd->RalinkCounters.OneSecTxDoneCount++;
+ap/ap_data.c:	if ( pAd->debug_on )
+ap/ap_data.c:		do_gettimeofday(&(pAd->debug_time_4[index]));
+ap/ap_data.c:	if ( pAd->debug_on )
+ap/ap_data.c:		do_gettimeofday(&(pAd->debug_time_5[index])); 
+ap/ap_data.c:		if ( pAd->debug_index < 201 )
+ap/ap_data.c:			pAd->debug_index ++;
+ap/ap_data.c:			pAd->debug_on = 0;
+ap/ap_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+ap/ap_data.c:		NdisMoveMemory(pTxBlk->pSrcBufData + pTxBlk->SrcBufLen, &pAd->PrivateInfo.Tx.MIC[0], 8);
+ap/ap_data.c:		if (pTxBlk->pMacEntry->WapiUskRekeyTimerRunning && pAd->CommonCfg.wapi_usk_rekey_method == REKEY_METHOD_PKT)
+ap/ap_data.c:		AckDuration = RTMPCalcDuration(pAd, pAd->CommonCfg.ExpectedACKRate[pTxBlk->TxRate], 14);
+ap/ap_data.c:		FreeMpduSize = pAd->CommonCfg.FragmentThreshold - LENGTH_CRC;
+ap/ap_data.c:			pHeader_802_11->Duration = pAd->CommonCfg.Dsifs + AckDuration;
+ap/ap_data.c:			NextMpduSize = min(((UINT)SrcRemainingBytes - pTxBlk->SrcBufLen), ((UINT)pAd->CommonCfg.FragmentThreshold));
+ap/ap_data.c:			pHeader_802_11->Duration = (3 * pAd->CommonCfg.Dsifs) + (2 * AckDuration) + RTMPCalcDuration(pAd, pTxBlk->TxRate, NextMpduSize + EncryptionOverhead);
+ap/ap_data.c:		if (pAd->CommonCfg.DebugFlags & DBF_DBQ_TXFRAME)
+ap/ap_data.c:		pAd->RalinkCounters.KickTxCount++;
+ap/ap_data.c:		pAd->RalinkCounters.OneSecTxDoneCount++;
+ap/ap_data.c:		if (pAd->CommonCfg.DebugFlags & DBF_DBQ_TXFRAME)
+ap/ap_data.c:		pAd->RalinkCounters.OneSecTxAggregationCount++;
+ap/ap_data.c:		pAd->RalinkCounters.KickTxCount++;
+ap/ap_data.c:		pAd->RalinkCounters.OneSecTxDoneCount++;
+ap/ap_data.c:			if (pTxBlk->pMacEntry->WapiUskRekeyTimerRunning && pAd->CommonCfg.wapi_usk_rekey_method == REKEY_METHOD_PKT)
+ap/ap_data.c:	if ((pAd->Dot11_H.RDMode != RD_NORMAL_MODE)
+ap/ap_data.c:	if (apidx < pAd->ApCfg.BssidNum)
+ap/ap_data.c:		if (pAd->ApCfg.MBSSID[apidx].bVLAN_Tag == TRUE)
+ap/ap_data.c:	if (pAd->MacTab.Content[Wcid].Sst == SST_ASSOC)
+ap/ap_data.c:	else if (pAd->MacTab.Content[Wcid].Sst == SST_AUTH)
+ap/ap_data.c:	pMacEntry = &pAd->MacTab.Content[Aid];
+ap/ap_data.c:		/*NdisAcquireSpinLock(&pAd->MacTabLock); */
+ap/ap_data.c:		/*NdisAcquireSpinLock(&pAd->TxSwQueueLock); */
+ap/ap_data.c:        RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+ap/ap_data.c:				NumOfOldPsPkt = pAd->TxSwQueue[QID_AC_BE].Number;
+ap/ap_data.c:				InsertTailQueueAc(pAd, pMacEntry, &pAd->TxSwQueue[QID_AC_BE], pEntry);
+ap/ap_data.c:				if (NumOfOldPsPkt != pAd->TxSwQueue[QID_AC_BE].Number)
+ap/ap_data.c:					InsertTailQueueAc(pAd, pMacEntry, &pAd->TxSwQueue[QID_AC_BE], pEntry);
+ap/ap_data.c:		/*NdisReleaseSpinLock(&pAd->TxSwQueueLock); */
+ap/ap_data.c:		/*NdisReleaseSpinLock(&pAd->MacTabLock); */
+ap/ap_data.c:		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+ap/ap_data.c:	if ((pAd->CommonCfg.bEnableTxBurst == FALSE) 
+ap/ap_data.c:		&& (pAd->CommonCfg.bRdg == FALSE)
+ap/ap_data.c:		&& (pAd->CommonCfg.bRalinkBurstMode == FALSE)
+ap/ap_data.c:			if (pAd->flg_be_adjust == 0)
+ap/ap_data.c:				pAd->flg_be_adjust = 1;
+ap/ap_data.c:				NdisGetSystemUpTime(&pAd->be_adjust_last_time);
+ap/ap_data.c:			if (pAd->flg_be_adjust != 0)
+ap/ap_data.c:				pQueue = &pAd->TxSwQueue[QID_AC_BK];
+ap/ap_data.c:					if ((now - pAd->be_adjust_last_time) > TIME_ONE_SECOND)
+ap/ap_data.c:						pAd->flg_be_adjust = 0;
+ap/ap_data.c:					NdisGetSystemUpTime(&pAd->be_adjust_last_time);
+ap/ap_data.c:		pAd->OneSecondnonBEpackets++;
+ap/ap_data.c:		if (pAd->OneSecondnonBEpackets > 100 
+ap/ap_data.c:			&& pAd->MacTab.fAnyStationMIMOPSDynamic
+ap/ap_data.c:			if (!pAd->is_on)
+ap/ap_data.c:				pAd->is_on = 1;
+ap/ap_data.c:			if (pAd->is_on)
+ap/ap_data.c:				pAd->is_on = 0;
+ap/ap_data.c:	if (pAd->CommonCfg.bEnableTxBurst 
+ap/ap_data.c:		|| pAd->CommonCfg.bRdg
+ap/ap_data.c:		|| pAd->CommonCfg.bRalinkBurstMode
+ap/ap_data.c:			(pAd->WIFItestbed.bGreenField && pAd->MacTab.fAnyStationNonGF == TRUE) ||
+ap/ap_data.c:			((pAd->OneSecondnonBEpackets > nonBEpackets) || pAd->MacTab.fAnyStationMIMOPSDynamic) || 
+ap/ap_data.c:			(pAd->MacTab.fAnyTxOPForceDisable))
+ap/ap_data.c:					RegValue = pAd->CommonCfg.RestoreBurstMode;
+ap/ap_data.c:				if (pAd->CommonCfg.APEdcaParm.Txop[QID_AC_VO] != 102)
+ap/ap_data.c:				else if (pAd->CommonCfg.bEnableTxBurst)
+ap/ap_data.c:	pAd->OneSecondnonBEpackets = 0;
+ap/ap_data.c:		INC_COUNTER64(pAd->WlanCounters.WEPUndecryptableCount);
+ap/ap_data.c:			           		 if (pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].WpaSupplicantUP)
+ap/ap_data.c:								WpaSendMicFailureToWpaSupplicant(pAd->net_dev,
+ap/ap_data.c:			pEntry = &pAd->MacTab.Content[pRxWI->RxWIWirelessCliID];
+ap/ap_data.c:				if(pAd->ApCfg.MBSSID[pEntry->apidx].Hostapd == TRUE)
+ap/ap_data.c:	pAd->Counters8023.RxErrors++;
+ap/ap_data.c:		if(pAd->ApCfg.BANClass3Data == TRUE)
+ap/ap_data.c:		if (IS_ENTRY_APCLI(pEntry) && pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].WpaSupplicantUP)
+ap/ap_data.c:			WpaSendMicFailureToWpaSupplicant(pAd->net_dev,
+ap/ap_data.c:        MAP_CHANNEL_ID_TO_KHZ(pAd->LatchRfRegs.Channel, freq);
+ap/ap_data.c:        if ((pHeader->FC.SubType == SUBTYPE_PROBE_RSP) && (pAd->Cfg80211RegisterProbeReqFrame == TRUE))
+ap/ap_data.c:		if (pAd->Cfg80211VifDevSet.vifDevList.size > 0)        
+ap/ap_data.c:		if ( ((pHeader->FC.SubType == SUBTYPE_PROBE_REQ) && ( pAd->Cfg80211RegisterProbeReqFrame == TRUE)) ||
+ap/ap_data.c:			 ((pHeader->FC.SubType == SUBTYPE_ACTION)  && ( pAd->Cfg80211RegisterActionFrame == TRUE) ))
+ap/ap_data.c:			//pAd->net_dev
+ap/ap_data.c:			if (CFG80211OS_RxMgmt(pAd->dummy_p2p_net_dev, freq, (PUCHAR)pHeader, pRxWI->RXWI_O.MPDUtotalByteCnt))
+ap/ap_data.c:		if (pAd->ApCfg.BANClass3Data == TRUE)
+ap/ap_data.c:				pEntry = &pAd->MacTab.Content[pRxWI->RxWIWirelessCliID];
+ap/ap_data.c:								   &pAd->SharedKey[pEntry->apidx][pRxWI->RxWIKeyIndex], 
+ap/ap_data.c:		if (pAd->chipCap.FlgHwTxBfCap)
+ap/ap_data.c:	if ((pEntry) && pAd->ApCfg.MBSSID[pEntry->apidx].Hostapd == TRUE)
+ap/ap_data.c:	//if (pAd->VifNextMode == RT_CMD_80211_IFTYPE_AP)
+ap/ap_data.c:		if ( pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].WpaSupplicantUP && 
+ap/ap_data.c:			pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].IEEE8021X == TRUE &&
+ap/ap_data.c:				int BssIdx = pAd->ApCfg.BssidNum + MAX_MESH_NUM + pEntry->MatchAPCLITabIdx;
+ap/ap_data.c:				/* pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
+ap/ap_data.c:                if (pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].IEEE8021x_required_keys == FALSE)
+ap/ap_data.c:                    idx = pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].DesireSharedKeyId;
+ap/ap_data.c:                    CipherAlg = pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].DesireSharedKey[idx].CipherAlg;
+ap/ap_data.c:					Key = pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].DesireSharedKey[idx].Key;
+ap/ap_data.c:                    if (pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].DesireSharedKey[idx].KeyLen > 0)
+ap/ap_data.c:						RTMP_ASIC_SHARED_KEY_TABLE(pAd,BssIdx, idx, &pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].DesireSharedKey[idx]);
+ap/ap_data.c:                       	/* pAd->ExtraInfo = GENERAL_LINK_UP; */
+ap/ap_data.c:    					pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].SharedKey[idx].CipherAlg = CipherAlg;
+ap/ap_data.c:						pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].SharedKey[idx].KeyLen = pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].DesireSharedKey[idx].KeyLen;
+ap/ap_data.c:						NdisMoveMemory(pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].SharedKey[idx].Key, 
+ap/ap_data.c:									   pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].DesireSharedKey[idx].Key, 
+ap/ap_data.c:									   pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].DesireSharedKey[idx].KeyLen);
+ap/ap_data.c:		if(pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].WpaSupplicantUP && 
+ap/ap_data.c:			((pEntry->AuthMode == Ndis802_11AuthModeWPA) || (pEntry->AuthMode == Ndis802_11AuthModeWPA2) || pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].IEEE8021X == TRUE))
+ap/ap_data.c:		pAd->ApCfg.MBSSID[pEntry->apidx].IEEE8021X == TRUE))
+ap/ap_data.c:		if ((pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.WscConfMode != WSC_DISABLE) &&
+ap/ap_data.c:            (!MAC_ADDR_EQUAL(pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryAddr, ZERO_MAC_ADDR)))
+ap/ap_data.c:			&& (pAd->ApCfg.IgmpSnoopEnable) 
+ap/ap_data.c:		if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMPDU) && (pAd->CommonCfg.bDisableReordering == 0)) 
+ap/ap_data.c:			&& (pAd->ApCfg.IgmpSnoopEnable) 
+ap/ap_data.c:		if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMPDU) && (pAd->CommonCfg.bDisableReordering == 0)) 
+ap/ap_data.c:	COUNTER_RALINK *pCounter = &pAd->RalinkCounters;
+ap/ap_data.c:				if (FromWhichBSSID < pAd->ApCfg.BssidNum)
+ap/ap_data.c:				NdisGetSystemUpTime(&pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].ApCliRcvBeaconTime);
+ap/ap_data.c:			FromWhichBSSID < pAd->ApCfg.BssidNum)
+ap/ap_data.c:                        INC_COUNTER64(pAd->WlanCounters.MulticastReceivedFrameCount);
+ap/ap_data.c:		&& (pRxInfo->AMPDU == 1) && (pAd->CommonCfg.bHTProtect == TRUE)
+ap/ap_data.c:		if (pAd->CommonCfg.IOTestParm.bRTSLongProtOn == FALSE)
+ap/ap_data.c:	pAd->ApCfg.LastSNR0 = (UCHAR)(pRxWI->RxWISNR0);
+ap/ap_data.c:	pAd->ApCfg.LastSNR1 = (UCHAR)(pRxWI->RxWISNR1);
+ap/ap_data.c:	pAd->ApCfg.LastSNR2 = (UCHAR)(pRxWI->RxWISNR2);
+ap/ap_data.c:			pRxWI->RxWIBSSID < pAd->ApCfg.BssidNum)
+ap/ap_data.c:			pAd->ApCfg.MBSSID[pRxWI->RxWIBSSID].RxDropCount ++;			
+ap/ap_data.c:	if (pAd->chipCap.FlgHwTxBfCap && 
+ap/ap_data.c:		pRxWI->RxWIBSSID < pAd->ApCfg.BssidNum)
+ap/ap_data.c:		pAd->ApCfg.MBSSID[pRxWI->RxWIBSSID].RxDropCount ++;
+ap/ap_data.c:		pAd->ApCfg.MBSSID[pRxWI->RxWIBSSID].RxErrorCount ++;
+ap/ap_data.c:	COUNTER_RALINK *pCounter = &pAd->RalinkCounters;
+ap/ap_data.c:				if (FromWhichBSSID < pAd->ApCfg.BssidNum)
+ap/ap_data.c:			FromWhichBSSID < pAd->ApCfg.BssidNum)
+ap/ap_data.c:                        INC_COUNTER64(pAd->WlanCounters.MulticastReceivedFrameCount);
+ap/ap_data.c:		&& (pRxInfo->AMPDU == 1) && (pAd->CommonCfg.bHTProtect == TRUE)
+ap/ap_data.c:		if (pAd->CommonCfg.IOTestParm.bRTSLongProtOn == FALSE)
+ap/ap_data.c:	pAd->ApCfg.LastSNR0 = (UCHAR)(pRxWI->RxWISNR0);
+ap/ap_data.c:	pAd->ApCfg.LastSNR1 = (UCHAR)(pRxWI->RxWISNR1);
+ap/ap_data.c:	pAd->ApCfg.LastSNR2 = (UCHAR)(pRxWI->RxWISNR2);
+ap/ap_data.c:			pRxWI->RxWIBSSID < pAd->ApCfg.BssidNum)
+ap/ap_data.c:			pAd->ApCfg.MBSSID[pRxWI->RxWIBSSID].RxDropCount ++;			
+ap/ap_data.c:	if (pAd->chipCap.FlgHwTxBfCap && 
+ap/ap_data.c:		pRxWI->RxWIBSSID < pAd->ApCfg.BssidNum)
+ap/ap_data.c:		pAd->ApCfg.MBSSID[pRxWI->RxWIBSSID].RxDropCount ++;
+ap/ap_data.c:		pAd->ApCfg.MBSSID[pRxWI->RxWIBSSID].RxErrorCount ++;
+ap/ap_data.c:	UINT8 RXWISize = pAd->chipCap.RXWISize;
+ap/ap_data.c:		if (pAd->CommonCfg.DebugFlags & DBF_DBQ_RXWI)
+ap/ap_data.c:			dbQueueEnqueueRxFrame(pData, (UCHAR *)pHeader, pAd->CommonCfg.DebugFlags);
+ap/ap_data.c:		pAd->RalinkCounters.ReceivedByteCount += pRxWI->RxWIMPDUByteCnt;
+ap/ap_data.c:		pAd->RalinkCounters.OneSecReceivedByteCount += pRxWI->RxWIMPDUByteCnt;
+ap/ap_data.c:		pAd->RalinkCounters.RxCount++;
+ap/ap_data.c:		pAd->RalinkCounters.OneSecRxCount++;
+ap/ap_data.c:		INC_COUNTER64(pAd->WlanCounters.ReceivedFragmentCount);
+ap/ap_data.c:		INC_COUNTER64(pAd->WlanCounters.ReceivedFragmentCount);
+ap/ap_data.c:		INC_COUNTER64(pAd->WlanCounters.ReceivedFragmentCount);
+ap/ap_data.c:			pAd->ate.RxCntPerSec++;
+ap/ap_data.c:			if (pAd->ate.bQARxStart == TRUE)
+ap/ap_data.c:			if ((pAd->chipCap.FlgHwTxBfCap) && (pHeader->FC.Type == BTYPE_MGMT))
+ap/ap_data.c:					if (pAd->ate.sounding == 1) {
+ap/ap_data.c:						pAd->ate.soundingSNR[0] = (CHAR)((pRxBlk ->pData)[8]);
+ap/ap_data.c:						pAd->ate.soundingSNR[1] = (Nc<2)? 0: (CHAR)((pRxBlk ->pData)[9]);
+ap/ap_data.c:						pAd->ate.soundingSNR[2] = (Nc<3)? 0: (CHAR)((pRxBlk ->pData)[10]);
+ap/ap_data.c:						pAd->ate.sounding = 2;
+ap/ap_data.c:						pAd->ate.soundingRespSize = pRxBlk->DataSize;
+ap/ap_data.c:							pAd->ate.soundingResp[i] = pRxBlk->pData[i];
+ap/ap_data.c:				pRxWI->RxWIBSSID < pAd->ApCfg.BssidNum)
+ap/ap_data.c:				pMbss = &pAd->ApCfg.MBSSID[pRxWI->RxWIBSSID];
+ap/ap_data.c:						Update_Rssi_Sample(pAd, &pAd->ApCfg.RssiSample, pRxWI);
+ap/ap_data.c:						pAd->ApCfg.NumOfAvgRssiSample ++;
+ap/ap_data.c:							pAd->DiagStruct.RxDataCnt[pAd->DiagStruct.ArrayCurIdx]++;
+ap/ap_data.c:							pAd->DiagStruct.RxMcsCnt[pAd->DiagStruct.ArrayCurIdx][pRxWI->RxWIMCS]++;
+ap/ap_data.c:		pAd->ate.RxCntPerSec++;
+ap/ap_data.c:		if (pAd->ate.bQARxStart == TRUE)
+ap/ap_data.c:		if ((pAd->chipCap.FlgHwTxBfCap) && (pHeader->FC.Type == BTYPE_MGMT))
+ap/ap_data.c:				if (pAd->ate.sounding == 1)
+ap/ap_data.c:					pAd->ate.soundingSNR[0] = (CHAR)((pRxBlk ->pData)[8]);
+ap/ap_data.c:					pAd->ate.soundingSNR[1] = (Nc<2)? 0: (CHAR)((pRxBlk ->pData)[9]);
+ap/ap_data.c:					pAd->ate.soundingSNR[2] = (Nc<3)? 0: (CHAR)((pRxBlk ->pData)[10]);
+ap/ap_data.c:					pAd->ate.sounding = 2;
+ap/ap_data.c:					pAd->ate.soundingRespSize = pRxBlk->DataSize;
+ap/ap_data.c:						pAd->ate.soundingResp[i] = pRxBlk->pData[i];
+ap/ap_data.c:			(pRxWI->RxWIBSSID < pAd->ApCfg.BssidNum))
+ap/ap_data.c:			pMbss = &pAd->ApCfg.MBSSID[pRxWI->RxWIBSSID];
+ap/ap_data.c:				Update_Rssi_Sample(pAd, &pAd->ApCfg.RssiSample, pRxWI);
+ap/ap_data.c:				pAd->ApCfg.NumOfAvgRssiSample++;
+ap/ap_data.c:					pAd->DiagStruct.RxDataCnt[pAd->DiagStruct.ArrayCurIdx]++;
+ap/ap_data.c:					pAd->DiagStruct.RxMcsCnt[pAd->DiagStruct.ArrayCurIdx][pRxWI->RxWIMCS]++;
+ap/ap_data.c:			(pAd->P2pCfg.bSigmaEnabled == TRUE) ||
+ap/ap_data.c:			(pAd->ApCfg.MBSSID[FromWhichBSSID].StaCount > 1)))
+ap/ap_data.c:				if ((pAd->ApCfg.MBSSID[pEntry->apidx].IsolateInterStaTraffic == 1))
+ap/ap_data.c:				if (pAd->ApCfg.IsolateInterStaTrafficBTNBSSID == 1 ||
+ap/ap_data.c:					(pAd->ApCfg.MBSSID[pEntry->apidx].VLAN_VID != pAd->ApCfg.MBSSID[FromWhichBSSID].VLAN_VID)))
+ap/ap_data.c:			RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+ap/ap_data.c:			RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+ap/ap_data.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[pMacEntry->MatchAPCLITabIdx];
+ap/ap_data.c:	//COPY_MAC_ADDR(pHeader_802_11->Addr1, pAd->ApCliMlmeAux.Bssid);
+ap/ap_data.c:	//COPY_MAC_ADDR(pHeader_802_11->Addr3, pAd->ApCliMlmeAux.Bssid);
+ap/ap_data.c:	if (pAd->CommonCfg.bAPSDForcePowerSave)
+ap/ap_data.c:	pHeader_802_11->Duration = pAd->CommonCfg.Dsifs + RTMPCalcDuration(pAd, TxRate, 14);
+ap/ap_data.c:	pHeader_802_11->Sequence = pAd->Sequence;
+ap/ap_data.c:	pAd->Sequence = (pAd->Sequence+1) & MAXSEQ; /* next sequence  */
+ap/ap_connect.c:	PUCHAR pBeaconFrame = (PUCHAR)pAd->ApCfg.MBSSID[apidx].BeaconBuf;
+ap/ap_connect.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+ap/ap_connect.c:	if(!BeaconTransmitRequired(pAd, apidx, &pAd->ApCfg.MBSSID[apidx]))
+ap/ap_connect.c:	PhyMode = pAd->ApCfg.MBSSID[apidx].PhyMode;
+ap/ap_connect.c:	if (pAd->ApCfg.MBSSID[apidx].bHideSsid)
+ap/ap_connect.c:		SsidLen = pAd->ApCfg.MBSSID[apidx].SsidLen;
+ap/ap_connect.c:						pAd->ApCfg.MBSSID[apidx].Bssid,
+ap/ap_connect.c:						pAd->ApCfg.MBSSID[apidx].Bssid);
+ap/ap_connect.c:	SupRateLen = pAd->CommonCfg.SupRateLen;
+ap/ap_connect.c:						2,                               &pAd->CommonCfg.BeaconPeriod,
+ap/ap_connect.c:						2,                               &pAd->ApCfg.MBSSID[apidx].CapabilityInfo,
+ap/ap_connect.c:						SsidLen,                       pAd->ApCfg.MBSSID[apidx].Ssid,
+ap/ap_connect.c:						1,                               &pAd->CommonCfg.Channel,
+ap/ap_connect.c:					2,                               &pAd->CommonCfg.BeaconPeriod,
+ap/ap_connect.c:					2,                               &pAd->ApCfg.MBSSID[apidx].CapabilityInfo,
+ap/ap_connect.c:					SsidLen,                         pAd->ApCfg.MBSSID[apidx].Ssid,
+ap/ap_connect.c:					SupRateLen,                      pAd->CommonCfg.SupRate, 
+ap/ap_connect.c:					1,                               &pAd->CommonCfg.Channel,
+ap/ap_connect.c:	if ((pAd->CommonCfg.ExtRateLen) && (PhyMode != WMODE_B))
+ap/ap_connect.c:						1,                               &pAd->CommonCfg.ExtRateLen,
+ap/ap_connect.c:						pAd->CommonCfg.ExtRateLen,           pAd->CommonCfg.ExtRate, 
+ap/ap_connect.c:	if (pAd->CommonCfg.bCountryFlag)
+ap/ap_connect.c:				UCHAR MaxTxPower = GetCuntryMaxTxPwr(pAd, pAd->CommonCfg.Channel);
+ap/ap_connect.c:									1,                 	&pAd->ChannelList[0].Channel,
+ap/ap_connect.c:									1,                 	&pAd->ChannelListNum,
+ap/ap_connect.c:				                  3,                 	pAd->CommonCfg.CountryCode,
+ap/ap_connect.c:				                  3,                 	pAd->CommonCfg.CountryCode,
+ap/ap_connect.c:	RTMPWriteTxWI(pAd, &pAd->BeaconTxWI, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, 0, BSS0Mcast_WCID, 
+ap/ap_connect.c:	ptr = (PUCHAR)&pAd->BeaconTxWI;
+ap/ap_connect.c:	reg_base = pAd->BeaconOffset[pAd->ApCfg.MBSSID[apidx].BcnBufIdx];
+ap/ap_connect.c:	ptr = (PUCHAR)pAd->ApCfg.MBSSID[apidx].BeaconBuf;
+ap/ap_connect.c:	reg_base = pAd->BeaconOffset[pAd->ApCfg.MBSSID[apidx].BcnBufIdx] + TXWISize;
+ap/ap_connect.c:	pAd->ApCfg.MBSSID[apidx].TimIELocationInBeacon = (UCHAR)FrameLen; 
+ap/ap_connect.c:	pAd->ApCfg.MBSSID[apidx].CapabilityInfoLocationInBeacon = sizeof(HEADER_802_11) + TIMESTAMP_LEN + 2;
+ap/ap_connect.c:		pAd->ApCfg.MBSSID[apidx].CapabilityInfo
+ap/ap_connect.c:		pAd->ApCfg.ErpIeContent
+ap/ap_connect.c:	UCHAR *pBeaconFrame = (PUCHAR)pAd->ApCfg.MBSSID[apidx].BeaconBuf;
+ap/ap_connect.c:	ULONG FrameLen = pAd->ApCfg.MBSSID[apidx].TimIELocationInBeacon;
+ap/ap_connect.c:	ULONG UpdatePos = pAd->ApCfg.MBSSID[apidx].TimIELocationInBeacon;
+ap/ap_connect.c:	pMbss = &pAd->ApCfg.MBSSID[apidx];
+ap/ap_connect.c:	pComCfg = &pAd->CommonCfg;
+ap/ap_connect.c:	*(ptr + 2) = pAd->ApCfg.DtimCount;
+ap/ap_connect.c:	*(ptr + 3) = pAd->ApCfg.DtimPeriod;
+ap/ap_connect.c:    if (pAd->ApCfg.DtimCount == 0)
+ap/ap_connect.c:	if ( pAd->ApCfg.MBSSID[apidx].HostapdWPS && (pAd->ApCfg.MBSSID[apidx].WscIEBeacon.ValueLen))
+ap/ap_connect.c:    if (((pAd->ApCfg.MBSSID[apidx].WscControl.WscConfMode >= 1) && (pAd->ApCfg.MBSSID[apidx].WscIEBeacon.ValueLen)))
+ap/ap_connect.c:						  pAd->ApCfg.MBSSID[apidx].WscIEBeacon.ValueLen,    pAd->ApCfg.MBSSID[apidx].WscIEBeacon.Value,
+ap/ap_connect.c:    if ((pAd->ApCfg.MBSSID[apidx].WscControl.WscConfMode != WSC_DISABLE) &&
+ap/ap_connect.c:        (pAd->ApCfg.MBSSID[apidx].IEEE8021X == FALSE) && 
+ap/ap_connect.c:        (pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11WEPEnabled))
+ap/ap_connect.c:        *(ptr + 2) = pAd->ApCfg.ErpIeContent;
+ap/ap_connect.c:		&& (pAd->Dot11_H.RDMode == RD_SWITCHING_MODE))
+ap/ap_connect.c:		*(ptr + 4) = (pAd->Dot11_H.CSPeriod - pAd->Dot11_H.CSCount - 1);
+ap/ap_connect.c:		WmeParmIe[8] = pAd->ApCfg.BssEdcaParm.EdcaUpdateCount & 0x0f;
+ap/ap_connect.c:		NdisMoveMemory(AIFSN, pAd->ApCfg.BssEdcaParm.Aifsn, sizeof(AIFSN));
+ap/ap_connect.c:								   ((UCHAR)pAd->ApCfg.BssEdcaParm.bACM[i] << 4)     +     /* b4 is ACM */
+ap/ap_connect.c:			WmeParmIe[11+ (i*4)] = (pAd->ApCfg.BssEdcaParm.Cwmax[i] << 4)           +     /* b5-8 is CWMAX */
+ap/ap_connect.c:								   (pAd->ApCfg.BssEdcaParm.Cwmin[i] & 0x0f);              /* b0-3 is CWMIN */
+ap/ap_connect.c:			WmeParmIe[12+ (i*4)] = (UCHAR)(pAd->ApCfg.BssEdcaParm.Txop[i] & 0xff);        /* low byte of TXOP */
+ap/ap_connect.c:			WmeParmIe[13+ (i*4)] = (UCHAR)(pAd->ApCfg.BssEdcaParm.Txop[i] >> 8);          /* high byte of TXOP */
+ap/ap_connect.c:	if (pAd->FlgQloadEnable != 0)
+ap/ap_connect.c:		if (pAd->bBroadComHT == TRUE)
+ap/ap_connect.c:                                                  2,                                            &pAd->P2pCfg.P2pCapability,
+ap/ap_connect.c:                                                  6,                                            &pAd->P2pCfg.CurrentAddress,
+ap/ap_connect.c:	if (pAd->CommonCfg.Channel > 14) {
+ap/ap_connect.c:	RTMPWriteTxWI(pAd, &pAd->BeaconTxWI, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, 0, 0xff, 
+ap/ap_connect.c:	for (i=0; i<pAd->ApCfg.BssidNum; i++)
+ap/ap_connect.c:		if (pAd->ApCfg.MBSSID[i].bBcnSntReq)
+ap/ap_connect.c:			pAd->ApCfg.MBSSID[i].BcnBufIdx = NumBcn;
+ap/ap_connect.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+ap/ap_connect.c:	/* use pAd->ApCfg.BssidNum to avoid the case is best */
+ap/ap_connect.c:			RTMP_CHIP_UPDATE_BEACON(pAd, pAd->BeaconOffset[i] + j, 0, 4);
+ap/ap_connect.c:	for(i=0; i<pAd->ApCfg.BssidNum; i++)
+ap/ap_connect.c:	NumOfMacs = pAd->ApCfg.BssidNum + MAX_MESH_NUM + MAX_APCLI_NUM;
+ap/ap_connect.c:		pAd->ApCfg.MacMask = ~(1-1);
+ap/ap_connect.c:		if ((pAd->CurrentAddress[5] % 2 != 0)
+ap/ap_connect.c:		pAd->ApCfg.MacMask = ~(2-1);
+ap/ap_connect.c:		if (pAd->CurrentAddress[5] % 4 != 0)
+ap/ap_connect.c:		pAd->ApCfg.MacMask = ~(4-1);
+ap/ap_connect.c:		if (pAd->CurrentAddress[5] % 8 != 0)
+ap/ap_connect.c:		pAd->ApCfg.MacMask = ~(8-1);
+ap/ap_connect.c:	if (pAd->chipCap.MBSSIDMode == MBSSID_MODE1)
+ap/ap_connect.c:	if (pAd->ApCfg.DtimCount == 0)
+ap/ap_connect.c:		pAd->ApCfg.DtimCount = pAd->ApCfg.DtimPeriod - 1;
+ap/ap_connect.c:		pAd->ApCfg.DtimCount -= 1;
+ap/ap_connect.c:	if ((pAd->ApCfg.DtimCount == 0) && 
+ap/ap_connect.c:		(((pAd->CommonCfg.Bss2040CoexistFlag & BSS_2040_COEXIST_INFO_SYNC) && 
+ap/ap_connect.c:		  (pAd->CommonCfg.bForty_Mhz_Intolerant == FALSE)) ||
+ap/ap_connect.c:				pAd->CommonCfg.LastBSSCoexist2040.field.BSS20WidthReq, pAd->CommonCfg.LastBSSCoexist2040.field.Intolerant40));
+ap/ap_connect.c:		pAd->CommonCfg.Bss2040CoexistFlag &= (~BSS_2040_COEXIST_INFO_SYNC);
+ap/ap_connect.c:		prevBW = pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth; 
+ap/ap_connect.c:		prevExtChOffset = pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset;
+ap/ap_connect.c:		if (pAd->CommonCfg.LastBSSCoexist2040.field.BSS20WidthReq ||
+ap/ap_connect.c:			pAd->CommonCfg.LastBSSCoexist2040.field.Intolerant40 ||
+ap/ap_connect.c:			(pAd->MacTab.fAnyStaFortyIntolerant == TRUE) ||
+ap/ap_connect.c:			pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 0;
+ap/ap_connect.c:			pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = 0;
+ap/ap_connect.c:			pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = pAd->CommonCfg.RegTransmitSetting.field.BW;
+ap/ap_connect.c:			pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = pAd->CommonCfg.RegTransmitSetting.field.EXTCHA;
+ap/ap_connect.c:				pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth,
+ap/ap_connect.c:				pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset,
+ap/ap_connect.c:		pAd->CommonCfg.Bss2040CoexistFlag |= BSS_2040_COEXIST_INFO_NOTIFY;
+ap/ap_connect.c:	for(i=0; i<pAd->ApCfg.BssidNum; i++)
+ap/ap.c:		RTMPInitTimer(pAd, &pAd->ApCfg.MBSSID[i].REKEYTimer, GET_TIMER_FUNCTION(GREKEYPeriodicExec), pAd,  TRUE); 
+ap/ap.c:	RTMPInitTimer(pAd, &pAd->ApCfg.CounterMeasureTimer, GET_TIMER_FUNCTION(CMTimerExec), pAd, FALSE);
+ap/ap.c:	RTMPInitTimer(pAd, &pAd->CommonCfg.BeaconUpdateTimer, GET_TIMER_FUNCTION(BeaconUpdateExec), pAd, TRUE);
+ap/ap.c:	RTMPInitTimer(pAd, &pAd->ApCfg.IDSTimer, GET_TIMER_FUNCTION(RTMPIdsPeriodicExec), pAd, FALSE);
+ap/ap.c:	pAd->ApCfg.IDSTimerRunning = FALSE;
+ap/ap.c:	MulticastFilterTableInit(pAd, &pAd->pMulticastFilterTable);
+ap/ap.c:/*	if (pAd->OpMode == OPMODE_AP) */
+ap/ap.c:	MultiCastFilterTableReset(&pAd->pMulticastFilterTable);
+ap/ap.c:	NdisFreeSpinLock(&pAd->MacTabLock);
+ap/ap.c:	UCHAR		phy_mode = pAd->CommonCfg.cfg_wmode;
+ap/ap.c:		pAd->BulkOutDataSizeLimit[i]=24576;
+ap/ap.c:	TxPreamble = (pAd->CommonCfg.TxPreamble == Rt802_11PreambleLong ? 0 : 1);
+ap/ap.c:	if ((pAd->CommonCfg.Channel > 14) && pAd->CommonCfg.bIEEE80211H == TRUE)
+ap/ap.c:	for (apidx=0; apidx<pAd->ApCfg.BssidNum; apidx++)
+ap/ap.c:		MULTISSID_STRUCT *pMbss = &pAd->ApCfg.MBSSID[apidx];
+ap/ap.c:		COPY_MAC_ADDR(pMbss->Bssid, pAd->CurrentAddress);
+ap/ap.c:		if (pAd->chipCap.MBSSIDMode == MBSSID_MODE1)
+ap/ap.c:											TxPreamble, pAd->CommonCfg.bUseShortSlotTime,
+ap/ap.c:	if (phy_mode != pAd->CommonCfg.PhyMode)
+ap/ap.c:	COPY_MAC_ADDR(pAd->CommonCfg.Bssid, pAd->CurrentAddress);
+ap/ap.c:		if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) && (pAd->Antenna.field.TxPath == 2))
+ap/ap.c:	rtmp_bbp_set_rxpath(pAd, pAd->Antenna.field.RxPath);
+ap/ap.c:	if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) || bWmmCapable)
+ap/ap.c:		if (pAd->CommonCfg.APEdcaParm.bValid == FALSE)
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.bValid = TRUE;
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.Aifsn[0] = 3;
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.Aifsn[1] = 7;
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.Aifsn[2] = 1;
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.Aifsn[3] = 1;
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.Cwmin[0] = 4;
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.Cwmin[1] = 4;
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.Cwmin[2] = 3;
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.Cwmin[3] = 2;
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.Cwmax[0] = 6;
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.Cwmax[1] = 10;
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.Cwmax[2] = 4;
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.Cwmax[3] = 3;
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.Txop[0]  = 0;
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.Txop[1]  = 0;
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.Txop[2]  = 94;	/*96; */
+ap/ap.c:			pAd->CommonCfg.APEdcaParm.Txop[3]  = 47;	/*48; */
+ap/ap.c:		AsicSetEdcaParm(pAd, &pAd->CommonCfg.APEdcaParm);
+ap/ap.c:		if (pAd->ApCfg.BssEdcaParm.bValid == FALSE)
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.bValid = TRUE;
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.Aifsn[0] = 3;
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.Aifsn[1] = 7;
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.Aifsn[2] = 2;
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.Aifsn[3] = 2;
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.Cwmin[0] = 4;
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.Cwmin[1] = 4;
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.Cwmin[2] = 3;
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.Cwmin[3] = 2;
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.Cwmax[0] = 10;
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.Cwmax[1] = 10;
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.Cwmax[2] = 4;
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.Cwmax[3] = 3;
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.Txop[0]  = 0;
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.Txop[1]  = 0;
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.Txop[2]  = 94;	/*96; */
+ap/ap.c:			pAd->ApCfg.BssEdcaParm.Txop[3]  = 47;	/*48; */
+ap/ap.c:	if (!WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+ap/ap.c:		pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth = BW_20;
+ap/ap.c:	if (pAd->CommonCfg.bRdg)
+ap/ap.c:	if (pAd->CommonCfg.bRalinkBurstMode)
+ap/ap.c:	COPY_MAC_ADDR(pAd->ApCfg.MBSSID[BSS0].Bssid, pAd->CurrentAddress);
+ap/ap.c:	AsicSetBssid(pAd, pAd->CurrentAddress); 
+ap/ap.c:	pAd->MacTab.MsduLifeTime = 5; /* default 5 seconds */
+ap/ap.c:	pAd->MacTab.Content[0].Addr[0] = 0x01;
+ap/ap.c:	pAd->MacTab.Content[0].HTPhyMode.field.MODE = MODE_OFDM;
+ap/ap.c:	pAd->MacTab.Content[0].HTPhyMode.field.MCS = 3;
+ap/ap.c:	pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
+ap/ap.c:	if (pAd->CommonCfg.BBPCurrentBW == BW_80)
+ap/ap.c:		pAd->hw_cfg.cent_ch = pAd->CommonCfg.vht_cent_ch;
+ap/ap.c:		pAd->hw_cfg.cent_ch = pAd->CommonCfg.CentralChannel;
+ap/ap.c:	AsicSwitchChannel(pAd, pAd->hw_cfg.cent_ch, FALSE);
+ap/ap.c:	AsicLockChannel(pAd, pAd->hw_cfg.cent_ch);
+ap/ap.c:						__FUNCTION__, pAd->hw_cfg.cent_ch, pAd->CommonCfg.Channel, 
+ap/ap.c:						pAd->CommonCfg.CentralChannel, pAd->CommonCfg.vht_cent_ch,
+ap/ap.c:						pAd->CommonCfg.BBPCurrentBW));
+ap/ap.c:	if (pAd->ApCfg.bGreenAPEnable == TRUE)
+ap/ap.c:		pAd->ApCfg.GreenAPLevel=GREENAP_WITHOUT_ANY_STAS_CONNECT;
+ap/ap.c:	MlmeSetTxPreamble(pAd, (USHORT)pAd->CommonCfg.TxPreamble);	
+ap/ap.c:	for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+ap/ap.c:		if (WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+ap/ap.c:	pAd->Dot11_H.RDMode = RD_NORMAL_MODE;
+ap/ap.c:		pAd->MacTab.Content[i].PortSecured  = WPA_802_1X_PORT_NOT_SECURED;
+ap/ap.c:	for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+ap/ap.c:		PMULTISSID_STRUCT	pMbss = &pAd->ApCfg.MBSSID[apidx];
+ap/ap.c:				CipherAlg = pAd->SharedKey[apidx][idx].CipherAlg;
+ap/ap.c:				if (pAd->SharedKey[apidx][idx].KeyLen > 0)
+ap/ap.c:    				AsicAddSharedKeyEntry(pAd, apidx, idx, &pAd->SharedKey[apidx][idx]);	
+ap/ap.c:							pAd->SharedKey[apidx][idx].TxTsc[i] = RandomByte(pAd);   
+ap/ap.c:	RTMPSetPiggyBack(pAd, pAd->CommonCfg.bPiggyBackCapable);
+ap/ap.c:	ApLogEvent(pAd, pAd->CurrentAddress, EVENT_RESET_ACCESS_POINT);
+ap/ap.c:	pAd->Mlme.PeriodicRound = 0;
+ap/ap.c:	pAd->Mlme.OneSecPeriodicRound = 0;
+ap/ap.c:	if ( (pAd->CommonCfg.Channel > 14)
+ap/ap.c:		&& (pAd->CommonCfg.bIEEE80211H == 1)
+ap/ap.c:		&& RadarChannelCheck(pAd, pAd->CommonCfg.Channel))
+ap/ap.c:		pAd->Dot11_H.RDMode = RD_SILENCE_MODE;
+ap/ap.c:		pAd->Dot11_H.RDCount = 0;
+ap/ap.c:		pAd->Dot11_H.InServiceMonitorCount = 0;
+ap/ap.c:		pAd->Dot11_H.RDMode = RD_NORMAL_MODE;
+ap/ap.c:		if (pAd->CommonCfg.Channel > 14)
+ap/ap.c:			if ((pAd->CommonCfg.CarrierDetect.Enable == FALSE)
+ap/ap.c:				&& ((pAd->CommonCfg.RDDurRegion == JAP)
+ap/ap.c:					|| (pAd->CommonCfg.RDDurRegion == JAP_W53)
+ap/ap.c:					|| (pAd->CommonCfg.RDDurRegion == JAP_W56)))
+ap/ap.c:				pAd->CommonCfg.CarrierDetect.Enable = 1;
+ap/ap.c:			if (pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40)
+ap/ap.c:				if ((pAd->CommonCfg.CarrierDetect.Enable == FALSE)
+ap/ap.c:						&& ((pAd->CommonCfg.RDDurRegion == JAP)
+ap/ap.c:							|| (pAd->CommonCfg.RDDurRegion == JAP_W53)
+ap/ap.c:							|| (pAd->CommonCfg.RDDurRegion == JAP_W56)))
+ap/ap.c:					pAd->CommonCfg.CarrierDetect.Enable = TRUE;
+ap/ap.c:		if (pAd->CommonCfg.CarrierDetect.Enable == TRUE)
+ap/ap.c:	if (pAd->ApCfg.IdsEnable)
+ap/ap.c:		if (pAd->CommonCfg.bWirelessEvent == FALSE)
+ap/ap.c:	/* the value on pAd->CommonCfg.NumOfBulkInIRP may be large than 1. */
+ap/ap.c:	for(i=0; i<pAd->CommonCfg.NumOfBulkInIRP; i++)
+ap/ap.c:		AndesCalibrationOP(pAd, ANDES_CALIBRATION_DPD, pAd->chipCap.CurrentTemperature);
+ap/ap.c:		if (pAd->CommonCfg.CarrierDetect.Enable == TRUE)
+ap/ap.c:		if (pAd->ApCfg.MBSSID[apidx].REKEYTimerRunning == TRUE)
+ap/ap.c:			RTMPCancelTimer(&pAd->ApCfg.MBSSID[apidx].REKEYTimer, &Cancelled);
+ap/ap.c:			pAd->ApCfg.MBSSID[apidx].REKEYTimerRunning = FALSE;
+ap/ap.c:	if (pAd->ApCfg.CMTimerRunning == TRUE)
+ap/ap.c:		RTMPCancelTimer(&pAd->ApCfg.CounterMeasureTimer, &Cancelled);
+ap/ap.c:		pAd->ApCfg.CMTimerRunning = FALSE;
+ap/ap.c:	ULONG MinimumAMPDUSize = pAd->CommonCfg.DesiredHtPhy.MaxRAmpduFactor; /*Default set minimum AMPDU Size to 2, i.e. 32K */
+ap/ap.c:	pMacTable = &pAd->MacTab;
+ap/ap.c:			if ((pAd->Mlme.OneSecPeriodicRound % 10) == 8)
+ap/ap.c:			if (NdisEqualMemory(pEntry->Addr, pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryAddr, MAC_ADDR_LEN))
+ap/ap.c:				NdisZeroMemory(pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryAddr, MAC_ADDR_LEN);
+ap/ap.c:			if (pAd->CommonCfg.IOTestParm.bRTSLongProtOn == FALSE)
+ap/ap.c:		if ((pAd->ApCfg.MBSSID[pEntry->apidx].StationKeepAliveTime > 0) &&
+ap/ap.c:			(pEntry->NoDataIdleCount >= pAd->ApCfg.MBSSID[pEntry->apidx].StationKeepAliveTime))
+ap/ap.c:			MULTISSID_STRUCT *pMbss = &pAd->ApCfg.MBSSID[pEntry->apidx];
+ap/ap.c:		else if (pEntry->ContinueTxFailCnt >= pAd->ApCfg.EntryLifeCheck)
+ap/ap.c:					pEntry->ContinueTxFailCnt, pAd->ApCfg.EntryLifeCheck));
+ap/ap.c:					/*NdisReleaseSpinLock(&pAd->MacTabLock); */
+ap/ap.c:								pAd->ApCfg.MBSSID[pEntry->apidx].Bssid,
+ap/ap.c:								pAd->ApCfg.MBSSID[pEntry->apidx].Bssid);				
+ap/ap.c:				NdisAcquireSpinLock(&pAd->irq_lock);
+ap/ap.c:				NdisReleaseSpinLock(&pAd->irq_lock);
+ap/ap.c:			&& (pAd->CommonCfg.Bss2040CoexistFlag & BSS_2040_COEXIST_INFO_NOTIFY)
+ap/ap.c:			&& (pAd->CommonCfg.bBssCoexEnable == TRUE)
+ap/ap.c:			pAd->ApCfg.MBSSID[bss_index].PortSecured = WPA_802_1X_PORT_SECURED;
+ap/ap.c:			pAd->ApCfg.MBSSID[bss_index].PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+ap/ap.c:	if (pAd->CommonCfg.Bss2040CoexistFlag & BSS_2040_COEXIST_INFO_NOTIFY)
+ap/ap.c:		pAd->CommonCfg.Bss2040CoexistFlag &= (~BSS_2040_COEXIST_INFO_NOTIFY);
+ap/ap.c:	if (pAd->CommonCfg.bRdg && pMacTable->fAllStationAsRalink)
+ap/ap.c:	if (pAd->CommonCfg.bRalinkBurstMode && pMacTable->fAllStationGainGoodMCS)
+ap/ap.c:	if (WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+ap/ap.c:		if(pAd->MacTab.fAnyStationIsHT == FALSE
+ap/ap.c:			&& pAd->ApCfg.bGreenAPEnable == TRUE)
+ap/ap.c:			if (pAd->ApCfg.GreenAPLevel!=GREENAP_ONLY_11BG_STAS)
+ap/ap.c:				pAd->ApCfg.GreenAPLevel=GREENAP_ONLY_11BG_STAS;
+ap/ap.c:			if (pAd->ApCfg.GreenAPLevel!=GREENAP_11BGN_STAS)
+ap/ap.c:				pAd->ApCfg.GreenAPLevel=GREENAP_11BGN_STAS;
+ap/ap.c:	if ((pMacTable->fAnyStationBadAtheros == FALSE) && (pAd->CommonCfg.IOTestParm.bRTSLongProtOn == TRUE))
+ap/ap.c:		AsicUpdateProtect(pAd, pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode, ALLN_SETPROTECT, FALSE, pMacTable->fAnyStationNonGF);
+ap/ap.c:	/* 4. garbage collect pAd->MacTab.McastPsQueue if backlogged MCAST/BCAST frames */
+ap/ap.c:			/*NdisAcquireSpinLock(&pAd->MacTabLock); */
+ap/ap.c:			/*NdisReleaseSpinLock(&pAd->MacTabLock); */
+ap/ap.c:			if (pAd->ApCfg.BssidNum > MAX_MBSSID_NUM(pAd))
+ap/ap.c:				pAd->ApCfg.BssidNum = MAX_MBSSID_NUM(pAd);
+ap/ap.c:			for(bss_index=BSS0; bss_index<pAd->ApCfg.BssidNum; bss_index++)
+ap/ap.c:		MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[i];
+ap/ap.c:		*Rate       = pAd->CommonCfg.MlmeRate; 
+ap/ap.c:				*Rate   = pAd->CommonCfg.MlmeRate;
+ap/ap.c:			*Rate       = pAd->CommonCfg.MlmeRate; 
+ap/ap.c:	pEntry = &pAd->MacTab.Content[Wcid];
+ap/ap.c:	if (pAd->EventTab.Num < MAX_NUM_OF_EVENT)
+ap/ap.c:		RT_802_11_EVENT_LOG *pLog = &pAd->EventTab.Log[pAd->EventTab.Num];
+ap/ap.c:			pAd->EventTab.Num, pAddr[0], pAddr[1], pAddr[2], 
+ap/ap.c:		pAd->EventTab.Num += 1;
+ap/ap.c:	pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode = 0;
+ap/ap.c:	if ((pAd->ApCfg.LastNoneHTOLBCDetectTime + (5 * OS_HZ)) > pAd->Mlme.Now32) /* non HT BSS exist within 5 sec */
+ap/ap.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode = 1;
+ap/ap.c:    	AsicUpdateProtect(pAd, pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode, ALLN_SETPROTECT, FALSE, TRUE);
+ap/ap.c:	if ((pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode == 0) && (pAd->MacTab.fAnyStation20Only) && (pAd->CommonCfg.DesiredHtPhy.ChannelWidth == 1))
+ap/ap.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode = 2;
+ap/ap.c:		AsicUpdateProtect(pAd, pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode, (ALLN_SETPROTECT), TRUE, pAd->MacTab.fAnyStationNonGF);
+ap/ap.c:	if (pAd->MacTab.fAnyStationIsLegacy)
+ap/ap.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode = 3;
+ap/ap.c:		AsicUpdateProtect(pAd, pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode, (ALLN_SETPROTECT), TRUE, pAd->MacTab.fAnyStationNonGF);
+ap/ap.c:	pAd->CommonCfg.AddHTInfo.AddHtInfo2.NonGfPresent = pAd->MacTab.fAnyStationNonGF;
+ap/ap.c:	BOOLEAN ShortSlotCapable = pAd->CommonCfg.bUseShortSlotTime;
+ap/ap.c:	if (WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_B))
+ap/ap.c:		PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[i];
+ap/ap.c:	if ((pAd->ApCfg.LastOLBCDetectTime + (5 * OS_HZ)) > pAd->Mlme.Now32) 
+ap/ap.c:	/* decide ErpIR.UseProtection bit, depending on pAd->CommonCfg.UseBGProtection
+ap/ap.c:	if (pAd->CommonCfg.UseBGProtection == 0)
+ap/ap.c:		/*if ((pAd->ApCfg.LastOLBCDetectTime + (5 * OS_HZ)) > pAd->Mlme.Now32) // legacy BSS exist within 5 sec */
+ap/ap.c:	else if (pAd->CommonCfg.UseBGProtection == 1)   
+ap/ap.c:	bUseBGProtection = (pAd->CommonCfg.UseBGProtection == 1) ||    /* always use */
+ap/ap.c:						((pAd->CommonCfg.UseBGProtection == 0) && ERP_IS_USE_PROTECTION(ErpIeContent));
+ap/ap.c:	if (pAd->CommonCfg.Channel > 14) 
+ap/ap.c:		OperationMode = pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode;
+ap/ap.c:		bNonGFExist = pAd->MacTab.fAnyStationNonGF;
+ap/ap.c:	if ((pAd->CommonCfg.TxPreamble == Rt802_11PreambleLong) || (ApCheckLongPreambleSTA(pAd) == TRUE))
+ap/ap.c:		pAd->ApCfg.ErpIeContent = (ErpIeContent | 0x04);
+ap/ap.c:		pAd->ApCfg.ErpIeContent = ErpIeContent;
+ap/ap.c:	if (pAd->CommonCfg.Channel > 14)
+ap/ap.c:    for (apidx=0; apidx<pAd->ApCfg.BssidNum; apidx++)
+ap/ap.c:		USHORT *pCapInfo = &(pAd->ApCfg.MBSSID[apidx].CapabilityInfo);
+ap/ap.c:			&& (pAd->CommonCfg.Channel <= 14)
+ap/ap.c:   		if (pAd->CommonCfg.TxPreamble == Rt802_11PreambleLong)
+ap/ap.c:		PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[i];
+ap/ap.c:    if (pAd->ApCfg.MBSSID[Apidx].AccessControlList.Policy == 0)       /* ACL is disabled */
+ap/ap.c:        if (pAd->ApCfg.MBSSID[Apidx].AccessControlList.Policy == 1)   /* ACL is a positive list */
+ap/ap.c:        for (i=0; i<pAd->ApCfg.MBSSID[Apidx].AccessControlList.Num; i++)
+ap/ap.c:            if (MAC_ADDR_EQUAL(pAddr, pAd->ApCfg.MBSSID[Apidx].AccessControlList.Entry[i].Addr))
+ap/ap.c:    if (pAd->ApCfg.MBSSID[Apidx].AccessControlList.Policy == 0)
+ap/ap.c:		if (!IS_ENTRY_CLIENT(&pAd->MacTab.Content[MacIdx])) 
+ap/ap.c:		if (pAd->MacTab.Content[MacIdx].apidx != Apidx) 
+ap/ap.c:		 for (AclIdx = 0; AclIdx < pAd->ApCfg.MBSSID[Apidx].AccessControlList.Num; AclIdx++)
+ap/ap.c:			if (MAC_ADDR_EQUAL(&pAd->MacTab.Content[MacIdx].Addr, pAd->ApCfg.MBSSID[Apidx].AccessControlList.Entry[AclIdx].Addr))
+ap/ap.c:		if ((Matched == FALSE) && (pAd->ApCfg.MBSSID[Apidx].AccessControlList.Policy == 1))
+ap/ap.c:			DBGPRINT(RT_DEBUG_TRACE, ("pAd->ApCfg.MBSSID[%d].AccessControlList.Policy = %ld\n", Apidx,
+ap/ap.c:				pAd->ApCfg.MBSSID[Apidx].AccessControlList.Policy));
+ap/ap.c:			if (pAd->MacTab.Content[MacIdx].Sst == SST_ASSOC)
+ap/ap.c:				DBGPRINT(RT_DEBUG_ERROR, ("ASSOC - Send DISASSOC  Reason = %d frame  TO %x %x %x %x %x %x \n",Reason,pAd->MacTab.Content[MacIdx].Addr[0],
+ap/ap.c:					pAd->MacTab.Content[MacIdx].Addr[1],pAd->MacTab.Content[MacIdx].Addr[2],pAd->MacTab.Content[MacIdx].Addr[3],pAd->MacTab.Content[MacIdx].Addr[4],pAd->MacTab.Content[MacIdx].Addr[5]));
+ap/ap.c:				MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pAd->MacTab.Content[MacIdx].Addr, 
+ap/ap.c:									pAd->ApCfg.MBSSID[pAd->MacTab.Content[MacIdx].apidx].Bssid,
+ap/ap.c:									pAd->ApCfg.MBSSID[pAd->MacTab.Content[MacIdx].apidx].Bssid);
+ap/ap.c:			MacTableDeleteEntry(pAd, pAd->MacTab.Content[MacIdx].Aid, pAd->MacTab.Content[MacIdx].Addr);
+ap/ap.c:	       else if ((Matched == TRUE) && (pAd->ApCfg.MBSSID[Apidx].AccessControlList.Policy == 2))
+ap/ap.c:			DBGPRINT(RT_DEBUG_TRACE, ("pAd->ApCfg.MBSSID[%d].AccessControlList.Policy = %ld\n", Apidx,
+ap/ap.c:				pAd->ApCfg.MBSSID[Apidx].AccessControlList.Policy));
+ap/ap.c:			if (pAd->MacTab.Content[MacIdx].Sst == SST_ASSOC)
+ap/ap.c:				DBGPRINT(RT_DEBUG_ERROR, ("ASSOC - Send DISASSOC  Reason = %d frame  TO %x %x %x %x %x %x \n",Reason,pAd->MacTab.Content[MacIdx].Addr[0],
+ap/ap.c:					pAd->MacTab.Content[MacIdx].Addr[1],pAd->MacTab.Content[MacIdx].Addr[2],pAd->MacTab.Content[MacIdx].Addr[3],pAd->MacTab.Content[MacIdx].Addr[4],pAd->MacTab.Content[MacIdx].Addr[5]));
+ap/ap.c:				MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pAd->MacTab.Content[MacIdx].Addr, 
+ap/ap.c:									pAd->ApCfg.MBSSID[pAd->MacTab.Content[MacIdx].apidx].Bssid,
+ap/ap.c:									pAd->ApCfg.MBSSID[pAd->MacTab.Content[MacIdx].apidx].Bssid);
+ap/ap.c:			MacTableDeleteEntry(pAd, pAd->MacTab.Content[MacIdx].Aid, pAd->MacTab.Content[MacIdx].Addr);
+ap/ap.c:								pAd->ApCfg.MBSSID[apidx].Bssid,
+ap/ap.c:								pAd->ApCfg.MBSSID[apidx].Bssid);
+ap/ap.c:	if (pAd->CommonCfg.Channel > 14)
+ap/ap.c:		for (index = 0; index < pAd->ChannelListNum; index++)
+ap/ap.c:			if(pAd->ChannelList[index].Channel == pAd->CommonCfg.Channel)
+ap/ap.c:		if (index < pAd->ChannelListNum)
+ap/ap.c:			pCoexChRange->primaryCh = pAd->ChannelList[index].Channel;
+ap/ap.c:			if(pAd->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_ABOVE)
+ap/ap.c:										((pAd->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_ABOVE) ? "ABOVE" : "BELOW"), 
+ap/ap.c:										pCoexChRange->primaryCh, pAd->ChannelList[pCoexChRange->primaryCh].Channel, 
+ap/ap.c:										pCoexChRange->secondaryCh, pAd->ChannelList[pCoexChRange->secondaryCh].Channel,
+ap/ap.c:										pAd->ChannelList[pCoexChRange->effectChStart].Channel,
+ap/ap.c:										pAd->ChannelList[pCoexChRange->effectChEnd].Channel));
+ap/ap.c:						pAd->CommonCfg.Channel));
+ap/ap.c:		for (index = 0; index < pAd->ChannelListNum; index++)
+ap/ap.c:			if(pAd->ChannelList[index].Channel == pAd->CommonCfg.Channel)
+ap/ap.c:		if (index < pAd->ChannelListNum)
+ap/ap.c:			if(pAd->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_ABOVE)
+ap/ap.c:				if ((index + 4) < pAd->ChannelListNum)
+ap/ap.c:										((pAd->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_ABOVE) ? "ABOVE" : "BELOW"), 
+ap/ap.c:										pCoexChRange->primaryCh, pAd->ChannelList[pCoexChRange->primaryCh].Channel, 
+ap/ap.c:										pCoexChRange->secondaryCh, pAd->ChannelList[pCoexChRange->secondaryCh].Channel,
+ap/ap.c:										pAd->ChannelList[pCoexChRange->effectChStart].Channel,
+ap/ap.c:										pAd->ChannelList[pCoexChRange->effectChEnd].Channel));
+ap/ap.c:									index, pAd->ChannelListNum, pAd->CommonCfg.Channel));
+ap/ap.c:	UCHAR Channel = pAd->CommonCfg.Channel;
+ap/ap.c:	if ((!WMODE_CAP_N(pAd->CommonCfg.PhyMode)) || 
+ap/ap.c:		(pAd->CommonCfg.RegTransmitSetting.field.BW  == BW_20)
+ap/ap.c:		|| (pAd->CommonCfg.Channel > 14)
+ap/ap.c:		DBGPRINT(RT_DEBUG_TRACE, ("The pAd->PhyMode=%d, BW=%d, didn't need channel adjustment!\n", 
+ap/ap.c:				pAd->CommonCfg.PhyMode, pAd->CommonCfg.RegTransmitSetting.field.BW));
+ap/ap.c:	if (pAd->CommonCfg.Channel > 14)
+ap/ap.c:		for (index = 0; index < pAd->ChannelListNum; index++)
+ap/ap.c:			if(pAd->ChannelList[index].Channel == pAd->CommonCfg.Channel)
+ap/ap.c:		if (index < pAd->ChannelListNum)
+ap/ap.c:			if(pAd->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_ABOVE)
+ap/ap.c:						pAd->CommonCfg.Channel));
+ap/ap.c:		for (index = 0; index < pAd->ChannelListNum; index++)
+ap/ap.c:			if(pAd->ChannelList[index].Channel == pAd->CommonCfg.Channel)
+ap/ap.c:		if (index < pAd->ChannelListNum)
+ap/ap.c:			if(pAd->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_ABOVE)
+ap/ap.c:				curSecChIdx = ((index + 4) < pAd->ChannelListNum) ? (index + 4) : (pAd->ChannelListNum - 1);
+ap/ap.c:				chEndIdx = ((curSecChIdx + 3) < pAd->ChannelListNum) ? (curSecChIdx + 3) : (pAd->ChannelListNum - 1);
+ap/ap.c:				chEndIdx =  ((curPriChIdx + 3) < pAd->ChannelListNum) ? (curPriChIdx + 3) : (pAd->ChannelListNum - 1);;
+ap/ap.c:						pAd->CommonCfg.Channel));
+ap/ap.c:	for (index = 0; index < pAd->ChannelListNum; index++)
+ap/ap.c:		pAd->ChannelList[index].bEffectedChannel = 0;
+ap/ap.c:	pAd->CommonCfg.BssCoexApCnt = 0;	
+ap/ap.c:			the value on pAd->CommonCfg.NumOfBulkInIRP may be large than 1.
+ap/ap.c:		for(index=0; index<pAd->CommonCfg.NumOfBulkInIRP; index++)
+ap/ap.c:			pAd->ChannelList[chStartIdx].Channel, pAd->ChannelList[chEndIdx].Channel));
+ap/ap.c:	pAd->CommonCfg.bOverlapScanning = TRUE;
+ap/ap.c:		Channel = pAd->ChannelList[index].Channel;
+ap/ap.c:	pAd->CommonCfg.bOverlapScanning = FALSE;	
+ap/ap.c:					index, pAd->ChannelList[index].Channel, pAd->ChannelList[index].bEffectedChannel));
+ap/ap.c:		if ((pAd->ChannelList[index].bEffectedChannel & (EFFECTED_CH_PRIMARY | EFFECTED_CH_LEGACY))  && (index != curPriChIdx) )
+ap/ap.c:		if ((pAd->ChannelList[index].bEffectedChannel & EFFECTED_CH_SECONDARY)  && (index != curSecChIdx))
+ap/ap.c:		&& (pAd->CommonCfg.BssCoexApCnt > pAd->CommonCfg.BssCoexApCntThr)
+ap/ap.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 0;
+ap/ap.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = 0;
+ap/ap.c:		pAd->CommonCfg.LastBSSCoexist2040.field.BSS20WidthReq = 1;
+ap/ap.c:		pAd->CommonCfg.Bss2040CoexistFlag |= BSS_2040_COEXIST_INFO_SYNC;
+ap/ap.c:		NdisMoveMemory(s_addr, pAd->ApCfg.MBSSID[apidx].Bssid, MAC_ADDR_LENGTH);
+ap/ap.c:					  pAd->ApCfg.MBSSID[apidx].Bssid, 
+ap/ap.c:    if((pEntry->AuthMode == Ndis802_11AuthModeWPA) || (pEntry->AuthMode == Ndis802_11AuthModeWPA2) || (pAd->ApCfg.MBSSID[apidx].IEEE8021X == TRUE))
+ap/ap.c:		MAKE_802_3_HEADER(FrameBuf, pAd->ApCfg.MBSSID[apidx].Bssid, pEntry->Addr, EAPOL);
+ap/ap_assoc.c:	wdev = &pAd->ApCfg.MBSSID[pEntry->apidx];
+ap/ap_assoc.c:	if (ie_list->ht_cap_len && WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+ap/ap_assoc.c:					pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode, 
+ap/ap_assoc.c:					pAd->MacTab.fAnyStationIsLegacy,
+ap/ap_assoc.c:					pAd->MacTab.fAnyStation20Only, 
+ap/ap_assoc.c:					pAd->MacTab.fAnyStationNonGF));
+ap/ap_assoc.c:			WMODE_CAP_N(pAd->CommonCfg.PhyMode) &&
+ap/ap_assoc.c:			(pAd->CommonCfg.Channel > 14))
+ap/ap_assoc.c:	wdev = &pAd->ApCfg.MBSSID[pEntry->apidx];
+ap/ap_assoc.c:	pEntry->MaxSupportedRate = min(pAd->CommonCfg.MaxTxRate, MaxSupportedRate);
+ap/ap_assoc.c:	if ((pAd->CommonCfg.bAggregationCapable) && (ie_list->RalinkIe & 0x00000001))
+ap/ap_assoc.c:	if ((pAd->CommonCfg.bPiggyBackCapable) && (ie_list->RalinkIe & 0x00000002))
+ap/ap_assoc.c:	if (pAd->CommonCfg.HT_DisallowTKIP &&
+ap/ap_assoc.c:		WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+ap/ap_assoc.c:		ht_mode_adjust(pAd, pEntry, &ie_list->HTCapability, &pAd->CommonCfg.DesiredHtPhy);
+ap/ap_assoc.c:			pAd->MacTab.fAnyStaFortyIntolerant = TRUE;
+ap/ap_assoc.c:			if(((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth == BW_40) && 
+ap/ap_assoc.c:				(pAd->CommonCfg.Channel <=14)) &&
+ap/ap_assoc.c:			    ((pAd->CommonCfg.bBssCoexEnable == TRUE) &&
+ap/ap_assoc.c:				(pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth != 0) && 
+ap/ap_assoc.c:				(pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset != 0))
+ap/ap_assoc.c:				pAd->CommonCfg.LastBSSCoexist2040.field.BSS20WidthReq = 1;
+ap/ap_assoc.c:				pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 0;
+ap/ap_assoc.c:				pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = 0;
+ap/ap_assoc.c:				pAd->CommonCfg.Bss2040CoexistFlag |= BSS_2040_COEXIST_INFO_SYNC;
+ap/ap_assoc.c:		pEntry->MaxHTPhyMode.field.STBC = (ie_list->HTCapability.HtCapInfo.RxSTBC & (pAd->CommonCfg.DesiredHtPhy.TxSTBC));
+ap/ap_assoc.c:		if (pAd->CommonCfg.DesiredHtPhy.AmsduEnable && (pAd->CommonCfg.REGBACapability.field.AutoBA == FALSE))
+ap/ap_assoc.c:		if (pAd->CommonCfg.bRdg && ie_list->HTCapability.ExtHtCapInfo.RDGSupport)
+ap/ap_assoc.c:		if (WMODE_CAP_AC(pAd->CommonCfg.PhyMode) &&
+ap/ap_assoc.c:			(pAd->CommonCfg.Channel > 14) &&
+ap/ap_assoc.c:		pAd->MacTab.fAnyStationIsLegacy = TRUE;
+ap/ap_assoc.c:	if (pAd->chipCap.FlgHwTxBfCap)
+ap/ap_assoc.c:		RtmpOSWrielessEventSendExt(pAd->net_dev, RT_WLAN_EVENT_EXPIRED,
+ap/ap_assoc.c:    if ((WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_G) 
+ap/ap_assoc.c:		|| WMODE_EQUAL(pAd->CommonCfg.PhyMode, (WMODE_G | WMODE_GN))
+ap/ap_assoc.c:	if (WMODE_HT_ONLY(pAd->CommonCfg.PhyMode)&& (ie_list->ht_cap_len == 0))
+ap/ap_assoc.c:		wdev = &pAd->ApCfg.MBSSID[pEntry->apidx];
+ap/ap_assoc.c:				RtmpOSWrielessEventSendExt(pAd->net_dev, RT_WLAN_EVENT_EXPIRED,
+ap/ap_assoc.c:                                CFG80211OS_DelSta(pAd->net_dev, pEntry->Addr);
+ap/ap_assoc.c:	wdev = &pAd->ApCfg.MBSSID[pEntry->apidx];
+ap/ap_assoc.c:	    if (pEntry->apidx < pAd->ApCfg.BssidNum)
+ap/ap_assoc.c:		if (WMODE_CAP_AC(pAd->CommonCfg.PhyMode)) {
+ap/ap_assoc.c:	SupRateLen = pAd->CommonCfg.SupRateLen;
+ap/ap_assoc.c:	                      SupRateLen,               pAd->CommonCfg.SupRate,
+ap/ap_assoc.c:                      SupRateLen,               pAd->CommonCfg.SupRate,
+ap/ap_assoc.c:    if ((pAd->CommonCfg.ExtRateLen) && (PhyMode != WMODE_B) && (FlgIs11bSta == 0))
+ap/ap_assoc.c:                          1,                        &pAd->CommonCfg.ExtRateLen,
+ap/ap_assoc.c:                          pAd->CommonCfg.ExtRateLen,    pAd->CommonCfg.ExtRate,
+ap/ap_assoc.c:		WmeParmIe[8] = pAd->ApCfg.BssEdcaParm.EdcaUpdateCount & 0x0f;
+ap/ap_assoc.c:								((UCHAR)pAd->ApCfg.BssEdcaParm.bACM[i] << 4) + /* b4 is ACM */
+ap/ap_assoc.c:								(pAd->ApCfg.BssEdcaParm.Aifsn[i] & 0x0f);              /* b0-3 is AIFSN */
+ap/ap_assoc.c:			WmeParmIe[11+ (i*4)] = (pAd->ApCfg.BssEdcaParm.Cwmax[i] << 4) + /* b5-8 is CWMAX */
+ap/ap_assoc.c:								(pAd->ApCfg.BssEdcaParm.Cwmin[i] & 0x0f);              /* b0-3 is CWMIN */
+ap/ap_assoc.c:			WmeParmIe[12+ (i*4)] = (UCHAR)(pAd->ApCfg.BssEdcaParm.Txop[i] & 0xff);        /* low byte of TXOP */
+ap/ap_assoc.c:			WmeParmIe[13+ (i*4)] = (UCHAR)(pAd->ApCfg.BssEdcaParm.Txop[i] >> 8);          /* high byte of TXOP */
+ap/ap_assoc.c:	if ((ie_list->ht_cap_len > 0) && WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+ap/ap_assoc.c:		UCHAR HtLen1 = sizeof(pAd->CommonCfg.AddHTInfo);
+ap/ap_assoc.c:		NdisMoveMemory(&HtCapabilityRsp, &pAd->CommonCfg.HtCapability, ie_list->ht_cap_len);
+ap/ap_assoc.c:										HtLen1,			&pAd->CommonCfg.AddHTInfo,
+ap/ap_assoc.c:		NdisMoveMemory(&addHTInfoTmp, &pAd->CommonCfg.AddHTInfo, HtLen1);
+ap/ap_assoc.c:		if ((ie_list->RalinkIe) == 0 || (pAd->bBroadComHT == TRUE))
+ap/ap_assoc.c:						  HtLen1, 							&pAd->CommonCfg.AddHTInfo,
+ap/ap_assoc.c:	 	if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) &&
+ap/ap_assoc.c:			(pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth == 1))
+ap/ap_assoc.c:			OverlapScanParam.ScanPassiveDwell = cpu2le16(pAd->CommonCfg.Dot11OBssScanPassiveDwell);
+ap/ap_assoc.c:			OverlapScanParam.ScanActiveDwell = cpu2le16(pAd->CommonCfg.Dot11OBssScanActiveDwell);
+ap/ap_assoc.c:			OverlapScanParam.TriggerScanInt = cpu2le16(pAd->CommonCfg.Dot11BssWidthTriggerScanInt);
+ap/ap_assoc.c:			OverlapScanParam.PassiveTalPerChannel = cpu2le16(pAd->CommonCfg.Dot11OBssScanPassiveTotalPerChannel);
+ap/ap_assoc.c:			OverlapScanParam.ActiveTalPerChannel = cpu2le16(pAd->CommonCfg.Dot11OBssScanActiveTotalPerChannel);
+ap/ap_assoc.c:			OverlapScanParam.DelayFactor = cpu2le16(pAd->CommonCfg.Dot11BssWidthChanTranDelayFactor);
+ap/ap_assoc.c:			OverlapScanParam.ScanActThre = cpu2le16(pAd->CommonCfg.Dot11OBssScanActivityThre);
+ap/ap_assoc.c:		if (WMODE_CAP_AC(pAd->CommonCfg.PhyMode) &&
+ap/ap_assoc.c:			(pAd->CommonCfg.Channel > 14) &&
+ap/ap_assoc.c:		if (WMODE_CAP_N(pAd->CommonCfg.PhyMode)
+ap/ap_assoc.c:			&& (pAd->CommonCfg.Channel <= 14) 
+ap/ap_assoc.c:			&& (pAd->CommonCfg.bBssCoexEnable == TRUE)
+ap/ap_assoc.c:		RTMPMoveMemory(pAd->P2pTable.Client[P2pIdx].InterfaceAddr, pEntry->Addr, MAC_ADDR_LEN);
+ap/ap_assoc.c:/*		POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie; */
+ap/ap_assoc.c:			if ((pAd->CommonCfg.Channel <=14) &&
+ap/ap_assoc.c:				pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset &&
+ap/ap_assoc.c:		//if (pAd->VifNextMode == RT_CMD_80211_IFTYPE_AP)
+ap/ap_assoc.c:			if ((pAd->Cfg80211VifDevSet.vifDevList.size > 0) &&
+ap/ap_assoc.c:				CFG80211OS_NewSta(pAd->net_dev, ie_list->Addr2, (PUCHAR)Elem->Msg, Elem->MsgLen);
+ap/ap_assoc.c:				CipherAlg = pAd->SharedKey[pEntry->apidx][KeyIdx].CipherAlg;
+ap/ap_assoc.c:		wdev = &pAd->ApCfg.MBSSID[pEntry->apidx];
+ap/ap_assoc.c:		pEntry = &pAd->MacTab.Content[i];
+ap/ap_assoc.c:	if (ApIdx >= pAd->ApCfg.BssidNum)
+ap/ap_assoc.c:							pAd->ApCfg.MBSSID[ApIdx].Bssid,
+ap/ap_assoc.c:							pAd->ApCfg.MBSSID[ApIdx].Bssid);
+ap/ap_assoc.c:      pEntry = &(pAd->MacTab.Content[Wcid]);
+Binary file ap/ap_autoChSel.o matches
+ap/ap_sync.c:	RTMPInitTimer(pAd, &pAd->MlmeAux.APScanTimer, GET_TIMER_FUNCTION(APScanTimeout), pAd, FALSE);
+ap/ap_sync.c:	if ( pAd->P2pCfg.bSentProbeRSP != TRUE )
+ap/ap_sync.c:	for(apidx=0; apidx<pAd->ApCfg.BssidNum; apidx++)
+ap/ap_sync.c:		if ((pAd->ApCfg.MBSSID[apidx].MSSIDDev != NULL) &&
+ap/ap_sync.c:			!(RTMP_OS_NETDEV_STATE_RUNNING(pAd->ApCfg.MBSSID[apidx].MSSIDDev)))
+ap/ap_sync.c:		PhyMode = pAd->ApCfg.MBSSID[apidx].PhyMode;
+ap/ap_sync.c:		if (((SsidLen == 0) && (! pAd->ApCfg.MBSSID[apidx].bHideSsid)) ||
+ap/ap_sync.c:			((SsidLen == 32) && MAC_ADDR_EQUAL(Addr3, pAd->ApCfg.MBSSID[apidx].Bssid) && (pAd->ApCfg.MBSSID[apidx].bHideSsid == 0)) ||
+ap/ap_sync.c:		((SsidLen == pAd->ApCfg.MBSSID[apidx].SsidLen) && NdisEqualMemory(Ssid, pAd->ApCfg.MBSSID[apidx].Ssid, (ULONG) SsidLen)))
+ap/ap_sync.c:							pAd->ApCfg.MBSSID[apidx].Bssid,
+ap/ap_sync.c:							pAd->ApCfg.MBSSID[apidx].Bssid);
+ap/ap_sync.c:		 if ((pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA) ||
+ap/ap_sync.c:			(pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPAPSK))
+ap/ap_sync.c:		else if ((pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA2) ||
+ap/ap_sync.c:			(pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA2PSK))
+ap/ap_sync.c:		else if ((pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWAICERT) ||
+ap/ap_sync.c:			(pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWAIPSK))
+ap/ap_sync.c:			UCHAR	Channel = pAd->CommonCfg.Channel;
+ap/ap_sync.c:				Channel = pAd->P2pCfg.ListenChannel;
+ap/ap_sync.c:							  2,						  &pAd->CommonCfg.BeaconPeriod,
+ap/ap_sync.c:							  2,						  &pAd->ApCfg.MBSSID[apidx].CapabilityInfo,
+ap/ap_sync.c:							  1,						  &pAd->ApCfg.MBSSID[apidx].SsidLen,
+ap/ap_sync.c:							  pAd->ApCfg.MBSSID[apidx].SsidLen, 	pAd->ApCfg.MBSSID[apidx].Ssid,
+ap/ap_sync.c:		SupRateLen = pAd->CommonCfg.SupRateLen;
+ap/ap_sync.c:						  2,                          &pAd->CommonCfg.BeaconPeriod,
+ap/ap_sync.c:						  2,                          &pAd->ApCfg.MBSSID[apidx].CapabilityInfo,
+ap/ap_sync.c:						  1,                          &pAd->ApCfg.MBSSID[apidx].SsidLen,
+ap/ap_sync.c:						  pAd->ApCfg.MBSSID[apidx].SsidLen,     pAd->ApCfg.MBSSID[apidx].Ssid,
+ap/ap_sync.c:						  SupRateLen,                 pAd->CommonCfg.SupRate,
+ap/ap_sync.c:						  1,                          &pAd->CommonCfg.Channel,
+ap/ap_sync.c:		if ((pAd->CommonCfg.ExtRateLen) && (PhyMode != WMODE_B))
+ap/ap_sync.c:							  1,                        &pAd->ApCfg.ErpIeContent,
+ap/ap_sync.c:							  1,                        &pAd->CommonCfg.ExtRateLen,
+ap/ap_sync.c:							  pAd->CommonCfg.ExtRateLen,    pAd->CommonCfg.ExtRate,
+ap/ap_sync.c:		if ((pAd->CommonCfg.Channel > 14)
+ap/ap_sync.c:			&& (pAd->CommonCfg.bIEEE80211H == 1)
+ap/ap_sync.c:			&& (pAd->Dot11_H.RDMode == RD_SWITCHING_MODE))
+ap/ap_sync.c:							  1,                        &pAd->CommonCfg.Channel,
+ap/ap_sync.c:							  1,                        &pAd->Dot11_H.CSCount,
+ap/ap_sync.c:			(pAd->ApCfg.MBSSID[apidx].DesiredHtPhyInfo.bHtEnable))
+ap/ap_sync.c:   			if (pAd->CommonCfg.bExtChannelSwitchAnnouncement && (pAd->CommonCfg.Channel > 14))
+ap/ap_sync.c:			HtLen = sizeof(pAd->CommonCfg.HtCapability);
+ap/ap_sync.c:			AddHtLen = sizeof(pAd->CommonCfg.AddHTInfo);
+ap/ap_sync.c:							 sizeof(HT_CAPABILITY_IE),          &pAd->CommonCfg.HtCapability,
+ap/ap_sync.c:							 sizeof(ADD_HT_INFO_IE),          &pAd->CommonCfg.AddHTInfo,
+ap/ap_sync.c:			NdisMoveMemory(&HtCapabilityTmp, &pAd->CommonCfg.HtCapability, HtLen);
+ap/ap_sync.c:			NdisMoveMemory(&addHTInfoTmp, &pAd->CommonCfg.AddHTInfo, AddHtLen);
+ap/ap_sync.c:		if (pAd->ApCfg.MBSSID[apidx].AuthMode < Ndis802_11AuthModeWPA)
+ap/ap_sync.c:		else if ((pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1WPA2) ||
+ap/ap_sync.c:			(pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK))
+ap/ap_sync.c:							  1,                        &pAd->ApCfg.MBSSID[apidx].RSNIE_Len[0],
+ap/ap_sync.c:							  pAd->ApCfg.MBSSID[apidx].RSNIE_Len[0],  pAd->ApCfg.MBSSID[apidx].RSN_IE[0],
+ap/ap_sync.c:							  1,                        &pAd->ApCfg.MBSSID[apidx].RSNIE_Len[1],
+ap/ap_sync.c:							  pAd->ApCfg.MBSSID[apidx].RSNIE_Len[1],  pAd->ApCfg.MBSSID[apidx].RSN_IE[1],
+ap/ap_sync.c:							  1,                        &pAd->ApCfg.MBSSID[apidx].RSNIE_Len[0],
+ap/ap_sync.c:							  pAd->ApCfg.MBSSID[apidx].RSNIE_Len[0],  pAd->ApCfg.MBSSID[apidx].RSN_IE[0],
+ap/ap_sync.c:		if (pAd->ApCfg.MBSSID[apidx].bWmmCapable)
+ap/ap_sync.c:			WmeParmIe[8] = pAd->ApCfg.BssEdcaParm.EdcaUpdateCount & 0x0f;
+ap/ap_sync.c:			UAPSD_MR_IE_FILL(WmeParmIe[8], &pAd->ApCfg.MBSSID[apidx].UapsdInfo);
+ap/ap_sync.c:									   ((UCHAR)pAd->ApCfg.BssEdcaParm.bACM[i] << 4) +     /* b4 is ACM */
+ap/ap_sync.c:									   (pAd->ApCfg.BssEdcaParm.Aifsn[i] & 0x0f);		/* b0-3 is AIFSN */
+ap/ap_sync.c:				WmeParmIe[11+ (i*4)] = (pAd->ApCfg.BssEdcaParm.Cwmax[i] << 4) +	/* b5-8 is CWMAX */
+ap/ap_sync.c:									   (pAd->ApCfg.BssEdcaParm.Cwmin[i] & 0x0f);	/* b0-3 is CWMIN */
+ap/ap_sync.c:				WmeParmIe[12+ (i*4)] = (UCHAR)(pAd->ApCfg.BssEdcaParm.Txop[i] & 0xff);        /* low byte of TXOP */
+ap/ap_sync.c:				WmeParmIe[13+ (i*4)] = (UCHAR)(pAd->ApCfg.BssEdcaParm.Txop[i] >> 8);          /* high byte of TXOP */
+ap/ap_sync.c:		if (pAd->FlgQloadEnable != 0)
+ap/ap_sync.c:			(pAd->CommonCfg.Channel <= 14) &&
+ap/ap_sync.c:			(pAd->ApCfg.MBSSID[apidx].DesiredHtPhyInfo.bHtEnable) &&
+ap/ap_sync.c:			(pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth == 1))
+ap/ap_sync.c:			OverlapScanParam.ScanPassiveDwell = cpu2le16(pAd->CommonCfg.Dot11OBssScanPassiveDwell);
+ap/ap_sync.c:			OverlapScanParam.ScanActiveDwell = cpu2le16(pAd->CommonCfg.Dot11OBssScanActiveDwell);
+ap/ap_sync.c:			OverlapScanParam.TriggerScanInt = cpu2le16(pAd->CommonCfg.Dot11BssWidthTriggerScanInt);
+ap/ap_sync.c:			OverlapScanParam.PassiveTalPerChannel = cpu2le16(pAd->CommonCfg.Dot11OBssScanPassiveTotalPerChannel);
+ap/ap_sync.c:			OverlapScanParam.ActiveTalPerChannel = cpu2le16(pAd->CommonCfg.Dot11OBssScanActiveTotalPerChannel);
+ap/ap_sync.c:			OverlapScanParam.DelayFactor = cpu2le16(pAd->CommonCfg.Dot11BssWidthChanTranDelayFactor);
+ap/ap_sync.c:			OverlapScanParam.ScanActThre = cpu2le16(pAd->CommonCfg.Dot11OBssScanActivityThre);
+ap/ap_sync.c:			if (WMODE_CAP_N(PhyMode) && (pAd->CommonCfg.Channel <= 14) &&
+ap/ap_sync.c:				(pAd->ApCfg.MBSSID[apidx].DesiredHtPhyInfo.bHtEnable) && 
+ap/ap_sync.c:				(pAd->CommonCfg.bBssCoexEnable == TRUE))
+ap/ap_sync.c:		if ((pAd->CommonCfg.Channel > 14)
+ap/ap_sync.c:			&& (pAd->CommonCfg.bIEEE80211H == 1)
+ap/ap_sync.c:			&& (pAd->Dot11_H.RDMode == RD_SWITCHING_MODE))
+ap/ap_sync.c:							  1,                        &pAd->CommonCfg.Channel,
+ap/ap_sync.c:							  1,                        &pAd->Dot11_H.CSCount,
+ap/ap_sync.c:   			if (pAd->CommonCfg.bExtChannelSwitchAnnouncement)
+ap/ap_sync.c:		if (pAd->CommonCfg.bCountryFlag)
+ap/ap_sync.c:			if (pAd->CommonCfg.Channel > 14 && pAd->CommonCfg.bIEEE80211H == TRUE)
+ap/ap_sync.c:		                          1,                 	&pAd->ChannelList[0].Channel,
+ap/ap_sync.c:		                          1,                 	&pAd->ChannelListNum,
+ap/ap_sync.c:			                          3,                 	pAd->CommonCfg.CountryCode,
+ap/ap_sync.c:			                          3,                 	pAd->CommonCfg.CountryCode,
+ap/ap_sync.c:			(pAd->ApCfg.MBSSID[apidx].DesiredHtPhyInfo.bHtEnable))
+ap/ap_sync.c:			HtLen = sizeof(pAd->CommonCfg.HtCapability);
+ap/ap_sync.c:			AddHtLen = sizeof(pAd->CommonCfg.AddHTInfo);
+ap/ap_sync.c:		if (pAd->bBroadComHT == TRUE)
+ap/ap_sync.c:							  HtLen,          					&pAd->CommonCfg.HtCapability,
+ap/ap_sync.c:				NdisMoveMemory(&HtCapabilityTmp, &pAd->CommonCfg.HtCapability, HtLen);
+ap/ap_sync.c:								  AddHtLen, 					  &pAd->CommonCfg.AddHTInfo,
+ap/ap_sync.c:				NdisMoveMemory(&addHTInfoTmp, &pAd->CommonCfg.AddHTInfo, AddHtLen);
+ap/ap_sync.c:				(pAd->CommonCfg.Channel > 14)) {
+ap/ap_sync.c:		if ((pAd->ApCfg.MBSSID[apidx].WscControl.WscConfMode != WSC_DISABLE) &&
+ap/ap_sync.c:				(pAd->ApCfg.MBSSID[apidx].IEEE8021X == FALSE) && 
+ap/ap_sync.c:				(pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11WEPEnabled))
+ap/ap_sync.c:        if ((pAd->ApCfg.MBSSID[apidx].WscControl.WscConfMode > WSC_DISABLE) && (pAd->ApCfg.MBSSID[apidx].WscIEProbeResp.ValueLen))
+ap/ap_sync.c:    						  pAd->ApCfg.MBSSID[apidx].WscIEProbeResp.ValueLen,   pAd->ApCfg.MBSSID[apidx].WscIEProbeResp.Value,
+ap/ap_sync.c:		if (ie_list->Channel != pAd->CommonCfg.Channel
+ap/ap_sync.c:			&& (pAd->CommonCfg.bOverlapScanning == FALSE)
+ap/ap_sync.c:		if ((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth == BW_40)
+ap/ap_sync.c:			&& (pAd->CommonCfg.bOverlapScanning == FALSE)
+ap/ap_sync.c:			if (pAd->CommonCfg.Channel<=14)
+ap/ap_sync.c:					if (ie_list->Channel != pAd->CommonCfg.Channel)
+ap/ap_sync.c:						DBGPRINT(RT_DEBUG_INFO, ("Channel=%d is not equal as CommonCfg.Channel = %d.\n", ie_list->Channel, pAd->CommonCfg.Channel));
+ap/ap_sync.c:				if (((pAd->CommonCfg.CentralChannel+2) != ie_list->Channel) &&
+ap/ap_sync.c:					((pAd->CommonCfg.CentralChannel-2) != ie_list->Channel))
+ap/ap_sync.c:				if (ie_list->Channel != pAd->CommonCfg.Channel)
+ap/ap_sync.c:		if (LegacyBssExist && pAd->CommonCfg.DisableOLBCDetect == 0)
+ap/ap_sync.c:			pAd->ApCfg.LastOLBCDetectTime = pAd->Mlme.Now32;
+ap/ap_sync.c:		if ((pAd->CommonCfg.bHTProtect)
+ap/ap_sync.c:			pAd->ApCfg.LastNoneHTOLBCDetectTime = pAd->Mlme.Now32;
+ap/ap_sync.c:			pEntry = &pAd->MacTab.Content[Elem->Wcid];
+ap/ap_sync.c:				pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].ApCliRcvBeaconTime = pAd->Mlme.Now32;
+ap/ap_sync.c:			(NdisEqualMemory(pAd->ApCfg.ApCliTab[0].CfgApCliBssid, ie_list->Bssid, MAC_ADDR_LEN)))
+ap/ap_sync.c:				MiniportMMRequest(pAd, 0, (PUCHAR)&pAd->ApCfg.ApCliTab[0].PsPollFrame, sizeof(PSPOLL_FRAME));
+ap/ap_sync.c:			&& (NdisEqualMemory(pAd->ApCfg.ApCliTab[0].CfgApCliBssid, ie_list->Bssid, MAC_ADDR_LEN)))
+ap/ap_sync.c:			UINT8 RXWISize = pAd->chipCap.RXWISize;
+ap/ap_sync.c:			Update_Rssi_Sample(pAd, &pAd->ApCfg.RssiSample, &RxWI);
+ap/ap_sync.c:		if (pAd->CommonCfg.bOverlapScanning == TRUE)
+ap/ap_sync.c:			for (index = 0; index < pAd->ChannelListNum; index++)
+ap/ap_sync.c:				if(pAd->ChannelList[index].Channel == ie_list->Channel)
+ap/ap_sync.c:						pAd->ChannelList[index].bEffectedChannel |= EFFECTED_CH_PRIMARY; /* 2; 	// 2 for 11N 20/40MHz AP with primary channel set as this channel. */
+ap/ap_sync.c:								secChIdx = (((index+1) < pAd->ChannelListNum) ? (index + 1) : -1);
+ap/ap_sync.c:								secChIdx = (((index+4) < pAd->ChannelListNum) ? (index + 4) : -1);
+ap/ap_sync.c:							pAd->ChannelList[secChIdx].bEffectedChannel |= EFFECTED_CH_SECONDARY; /* 1; */
+ap/ap_sync.c:						if ((pAd->CommonCfg.Channel != ie_list->Channel) || 
+ap/ap_sync.c:							(pAdd_HtInfo->ExtChanOffset  != pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset)
+ap/ap_sync.c:							pAd->CommonCfg.BssCoexApCnt++;
+ap/ap_sync.c:						pAd->ChannelList[index].bEffectedChannel |=  EFFECTED_CH_LEGACY; /* 4; 1 for legacy AP. */
+ap/ap_sync.c:						pAd->CommonCfg.BssCoexApCnt++;
+ap/ap_sync.c:	if (ie_list->Channel == pAd->ApCfg.AutoChannel_Channel)
+ap/ap_sync.c:			pAd->pChannelInfo->ApCnt[pAd->ApCfg.current_channel_index]++;
+ap/ap_sync.c:	DBGPRINT(RT_DEBUG_TRACE, ("AYNC - InvalidStateWhenScan(state=%ld). Reset SYNC machine\n", pAd->Mlme.ApSyncMachine.CurrState));
+ap/ap_sync.c:	pAd->MlmeAux.Channel = NextChannel(pAd, pAd->MlmeAux.Channel);
+ap/ap_sync.c:		if (pAd->ApCfg.bAutoChannelAtBootup == TRUE)
+ap/ap_sync.c:			UpdateChannelInfo(pAd, pAd->ApCfg.current_channel_index, pAd->ApCfg.AutoChannelAlg);
+ap/ap_sync.c:			pAd->ApCfg.current_channel_index++;
+ap/ap_sync.c:			if (pAd->ApCfg.current_channel_index < pAd->ChannelListNum)
+ap/ap_sync.c:				pAd->ApCfg.AutoChannel_Channel = pAd->ChannelList[pAd->ApCfg.current_channel_index].Channel;
+ap/ap_sync.c:		NdisGetSystemUpTime(&pAd->ApCfg.LastScanTime);
+ap/ap_sync.c:		RTMPCancelTimer(&pAd->MlmeAux.APScanTimer, &Cancelled);
+ap/ap_sync.c:		pAd->MlmeAux.BssType = BssType;
+ap/ap_sync.c:		pAd->MlmeAux.ScanType = ScanType;
+ap/ap_sync.c:		pAd->MlmeAux.SsidLen = SsidLen;
+ap/ap_sync.c:		NdisMoveMemory(pAd->MlmeAux.Ssid, Ssid, SsidLen);
+ap/ap_sync.c:		pAd->MlmeAux.Channel = FirstChannel(pAd);
+ap/ap_sync.c:			if (pAd->ApCfg.bAutoChannelAtBootup == TRUE)/* iwpriv set auto channel selection */
+ap/ap_sync.c:				pAd->ApCfg.AutoChannel_Channel = pAd->ChannelList[0].Channel;
+ap/ap_sync.c:		pAd->Mlme.ApSyncMachine.CurrState = AP_SYNC_IDLE;
+ap/ap_sync.c:		if (ie_list->Channel != pAd->MlmeAux.Channel
+ap/ap_sync.c:			&& (pAd->CommonCfg.bOverlapScanning == FALSE)
+ap/ap_sync.c:		if (ie_list->Channel == pAd->CommonCfg.Channel)
+ap/ap_sync.c:        Idx = BssTableSearch(&pAd->ScanTab, ie_list->Bssid, ie_list->Channel);
+ap/ap_sync.c:            Rssi = pAd->ScanTab.BssEntry[Idx].Rssi;
+ap/ap_sync.c:        if ((RealRssi + pAd->BbpRssiToDbmDelta) > Rssi)
+ap/ap_sync.c:            Rssi = RealRssi + pAd->BbpRssiToDbmDelta;
+ap/ap_sync.c:		Idx = BssTableSetEntry(pAd, &pAd->ScanTab, ie_list, Rssi, LenVIE, pVIE);
+ap/ap_sync.c:			NdisMoveMemory(pAd->ScanTab.BssEntry[Idx].PTSF, &Elem->Msg[24], 4);
+ap/ap_sync.c:			NdisMoveMemory(&pAd->ScanTab.BssEntry[Idx].TTSF[0], &Elem->TimeStamp.u.LowPart, 4);
+ap/ap_sync.c:			NdisMoveMemory(&pAd->ScanTab.BssEntry[Idx].TTSF[4], &Elem->TimeStamp.u.LowPart, 4);
+ap/ap_sync.c:	if (ie_list->Channel == pAd->ApCfg.AutoChannel_Channel)
+ap/ap_sync.c:			pAd->pChannelInfo->ApCnt[pAd->ApCfg.current_channel_index]++;
+ap/ap_sync.c:	RTMPCancelTimer(&pAd->MlmeAux.APScanTimer, &Cancelled);
+ap/ap_sync.c:	pAd->MlmeAux.Channel = 0;
+ap/ap_sync.c:    BssTableInit(&pAd->ScanTab);
+ap/ap_sync.c:    pAd->Mlme.ApSyncMachine.CurrState = AP_SYNC_IDLE;
+ap/ap_sync.c:    pAd->ApCfg.bAutoChannelAtBootup = ChannelSel;
+ap/ap_sync.c:	return (pAd->Mlme.ApSyncMachine.CurrState == AP_SCAN_LISTEN) ? TRUE : FALSE;
+ap/ap_sync.c:		if (reg_class[i].spacing == pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth)
+ap/ap_sync.c:				if (reg_class[i].channelset[j] == pAd->CommonCfg.Channel)
+ap/ap_sync.c:	pIE->NewChannelNum = pAd->CommonCfg.Channel;
+ap/ap_sync.c:    pIE->ChannelSwitchCount = pAd->Dot11_H.CSCount;
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO   pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	const TX_POWER_TUNING_ENTRY_STRUCT *TxPowerTuningTable = pAd->chipCap.TxPowerTuningTable_2G;
+ate/common/rt_ate.c:				TxPwr[index] = pAd->Tx40MPwrCfgABand[index];	
+ate/common/rt_ate.c:				TxPwr[index] = pAd->Tx40MPwrCfgGBand[index];	
+ate/common/rt_ate.c:				TxPwr[index] = pAd->Tx20MPwrCfgABand[index];	
+ate/common/rt_ate.c:				TxPwr[index] = pAd->Tx20MPwrCfgGBand[index];	
+ate/common/rt_ate.c:	if (pAd->TxPowerCtrl.bInternalTxALC == TRUE)
+ate/common/rt_ate.c:			if (pAd->TxPowerCtrl.bExtendedTssiMode == TRUE) /* Per-channel TSSI */
+ate/common/rt_ate.c:						pAd->TxPowerCtrl.bExtendedTssiMode, 
+ate/common/rt_ate.c:						pAd->TxPowerCtrl.PerChTxPwrOffset[pATEInfo->Channel]));
+ate/common/rt_ate.c:					desiredTSSI += pAd->TxPowerCtrl.PerChTxPwrOffset[pATEInfo->Channel];
+ate/common/rt_ate.c:				pAd->TxPowerCtrl.idxTxPowerTable++;
+ate/common/rt_ate.c:				pAd->TxPowerCtrl.idxTxPowerTable--;
+ate/common/rt_ate.c:			if (pAd->TxPowerCtrl.idxTxPowerTable < LOWERBOUND_TX_POWER_TUNING_ENTRY)
+ate/common/rt_ate.c:				pAd->TxPowerCtrl.idxTxPowerTable = LOWERBOUND_TX_POWER_TUNING_ENTRY;
+ate/common/rt_ate.c:			if (pAd->TxPowerCtrl.idxTxPowerTable >= UPPERBOUND_TX_POWER_TUNING_ENTRY(pAd))
+ate/common/rt_ate.c:				pAd->TxPowerCtrl.idxTxPowerTable = UPPERBOUND_TX_POWER_TUNING_ENTRY(pAd);
+ate/common/rt_ate.c:			/* Valid pAd->TxPowerCtrl.idxTxPowerTable: -30 ~ 45 */
+ate/common/rt_ate.c:			pTxPowerTuningEntry = &TxPowerTuningTable[pAd->TxPowerCtrl.idxTxPowerTable + TX_POWER_TUNING_ENTRY_OFFSET]; /* zero-based array */
+ate/common/rt_ate.c:			pAd->TxPowerCtrl.RF_TX_ALC = pTxPowerTuningEntry->RF_TX_ALC;
+ate/common/rt_ate.c:			pAd->TxPowerCtrl.MAC_PowerDelta = pTxPowerTuningEntry->MAC_PowerDelta;
+ate/common/rt_ate.c:			DBGPRINT(RT_DEBUG_TRACE, ("pAd->TxPowerCtrl.idxTxPowerTable = %d, pAd->TxPowerCtrl.RF_TX_ALC = %d, pAd->TxPowerCtrl.MAC_PowerDelta = %d\n", 
+ate/common/rt_ate.c:			        pAd->TxPowerCtrl.idxTxPowerTable, pAd->TxPowerCtrl.RF_TX_ALC, pAd->TxPowerCtrl.MAC_PowerDelta  ));
+ate/common/rt_ate.c: 			TotalDeltaPower += pAd->TxPowerCtrl.MAC_PowerDelta;
+ate/common/rt_ate.c:			        pAd->TxPowerCtrl.idxTxPowerTable, 
+ate/common/rt_ate.c:			bAutoTxAgc         = pAd->bAutoTxAgcG;
+ate/common/rt_ate.c:			TssiRef            = pAd->TssiRefG;
+ate/common/rt_ate.c:			pTssiMinusBoundary = &pAd->TssiMinusBoundaryG[0];
+ate/common/rt_ate.c:			pTssiPlusBoundary  = &pAd->TssiPlusBoundaryG[0];
+ate/common/rt_ate.c:			TxAgcStep          = pAd->TxAgcStepG;
+ate/common/rt_ate.c:			pTxAgcCompensate   = &pAd->TxAgcCompensateG;
+ate/common/rt_ate.c:			bAutoTxAgc         = pAd->bAutoTxAgcA;
+ate/common/rt_ate.c:			TssiRef            = pAd->TssiRefA;
+ate/common/rt_ate.c:			pTssiMinusBoundary = &pAd->TssiMinusBoundaryA[0];
+ate/common/rt_ate.c:			pTssiPlusBoundary  = &pAd->TssiPlusBoundaryA[0];
+ate/common/rt_ate.c:			TxAgcStep          = pAd->TxAgcStepA;
+ate/common/rt_ate.c:			pTxAgcCompensate   = &pAd->TxAgcCompensateA;
+ate/common/rt_ate.c:			/* step value is defined in pAd->TxAgcStepG for tx power value */
+ate/common/rt_ate.c:			bAutoTxAgc         = pAd->bAutoTxAgcG;
+ate/common/rt_ate.c:			pTxAgcCompensate   = &pAd->TxAgcCompensateG;
+ate/common/rt_ate.c:			bAutoTxAgc         = pAd->bAutoTxAgcA;
+ate/common/rt_ate.c:			pTxAgcCompensate   = &pAd->TxAgcCompensateA;
+ate/common/rt_ate.c:				if (pAd->TxPowerCtrl.bInternalTxALC == TRUE)
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	if (pAd->LatchRfRegs.Channel > 14)
+ate/common/rt_ate.c:		RssiOffset = pAd->ARssiOffset[RssiNumber];
+ate/common/rt_ate.c:		RssiOffset = pAd->BGRssiOffset[RssiNumber];
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	if (pAd->infType == RTMP_DEV_INF_USB)
+ate/common/rt_ate.c:	if (pAd->infType == RTMP_DEV_INF_USB)
+ate/common/rt_ate.c:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R1);
+ate/common/rt_ate.c:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R2);
+ate/common/rt_ate.c:	RTMP_RF_IO_WRITE32(pAd, (pAd->LatchRfRegs.R3 & (~0x04)));
+ate/common/rt_ate.c:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R4);
+ate/common/rt_ate.c:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R1);
+ate/common/rt_ate.c:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R2);
+ate/common/rt_ate.c:	RTMP_RF_IO_WRITE32(pAd, (pAd->LatchRfRegs.R3 | 0x04));
+ate/common/rt_ate.c:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R4);
+ate/common/rt_ate.c:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R1);
+ate/common/rt_ate.c:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R2);
+ate/common/rt_ate.c:	RTMP_RF_IO_WRITE32(pAd, (pAd->LatchRfRegs.R3 & (~0x04)));
+ate/common/rt_ate.c:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R4);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:		if (pAd->NicConfig2.field.ExternalLNAForG)
+ate/common/rt_ate.c:		if (pAd->Antenna.field.TxPath == 1)
+ate/common/rt_ate.c:		if (pAd->Antenna.field.RxPath == 1)
+ate/common/rt_ate.c:		if (pAd->Antenna.field.TxPath == 2)
+ate/common/rt_ate.c:		if (pAd->NicConfig2.field.ExternalLNAForA)
+ate/common/rt_ate.c:		if (pAd->Antenna.field.TxPath == 1)
+ate/common/rt_ate.c:		if (pAd->Antenna.field.RxPath == 1)
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	ProtCfg.field.ProtectRate = pAd->CommonCfg.RtsRate;
+ate/common/rt_ate.c:	pAd->FlgCtsEnabled = 0; 
+ate/common/rt_ate.c:	pAd->CommonCfg.IOTestParm.bRTSLongProtOn = FALSE;
+ate/common/rt_ate.c:	if (pAd->CommonCfg.CarrierDetect.Enable == TRUE)
+ate/common/rt_ate.c:		if (pAd->ApCfg.MBSSID[apidx].REKEYTimerRunning == TRUE)
+ate/common/rt_ate.c:			RTMPCancelTimer(&pAd->ApCfg.MBSSID[apidx].REKEYTimer, &Cancelled);
+ate/common/rt_ate.c:			pAd->ApCfg.MBSSID[apidx].REKEYTimerRunning = FALSE;
+ate/common/rt_ate.c:	if (pAd->ApCfg.CMTimerRunning == TRUE)
+ate/common/rt_ate.c:		RTMPCancelTimer(&pAd->ApCfg.CounterMeasureTimer, &Cancelled);
+ate/common/rt_ate.c:		pAd->ApCfg.CMTimerRunning = FALSE;
+ate/common/rt_ate.c:	if (pAd->ApCfg.ApQuickResponeForRateUpTimerRunning == TRUE)
+ate/common/rt_ate.c:		RTMPCancelTimer(&pAd->ApCfg.ApQuickResponeForRateUpTimer, &Cancelled);
+ate/common/rt_ate.c:	if (pAd->ApCfg.bGreenAPEnable == TRUE)
+ate/common/rt_ate.c:		pAd->ApCfg.GreenAPLevel=GREENAP_WITHOUT_ANY_STAS_CONNECT;
+ate/common/rt_ate.c:		pAd->ApCfg.bGreenAPEnable = FALSE;
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	RTMP_OS_NETDEV_STOP_QUEUE(pAd->net_dev);
+ate/common/rt_ate.c:		AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+ate/common/rt_ate.c:		AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+ate/common/rt_ate.c:	while ((pAd->PendingRx > 0) && (LoopCount < 2))	
+ate/common/rt_ate.c:			UCHAR			RestoreRfICType=pAd->RfIcType;
+ate/common/rt_ate.c:			pAd->RfIcType=RestoreRfICType;
+ate/common/rt_ate.c:			UCHAR			RestoreRfICType=pAd->RfIcType;
+ate/common/rt_ate.c:			pAd->RfIcType=RestoreRfICType;			
+ate/common/rt_ate.c:				UCHAR			RestoreRfICType=pAd->RfIcType;
+ate/common/rt_ate.c:				pAd->RfIcType=RestoreRfICType;
+ate/common/rt_ate.c:/*	pAd->ContinBulkIn = FALSE; */
+ate/common/rt_ate.c:	RTMPCancelTimer(&pAd->MlmeAux.AssocTimer,      &Cancelled);
+ate/common/rt_ate.c:	RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer,    &Cancelled);
+ate/common/rt_ate.c:	RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer,   &Cancelled);
+ate/common/rt_ate.c:	RTMPCancelTimer(&pAd->MlmeAux.AuthTimer,       &Cancelled);
+ate/common/rt_ate.c:	RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer,     &Cancelled);
+ate/common/rt_ate.c:	RTMPCancelTimer(&pAd->MlmeAux.ScanTimer,       &Cancelled);
+ate/common/rt_ate.c:		pAd->BulkFlags != 0 : wait bulk out finish
+ate/common/rt_ate.c:	while ((pAd->PendingRx > 0))	
+ate/common/rt_ate.c:		pAd->PendingRx = 0;
+ate/common/rt_ate.c:	while (((pAd->BulkOutPending[0] == TRUE) ||
+ate/common/rt_ate.c:			(pAd->BulkOutPending[1] == TRUE) || 
+ate/common/rt_ate.c:			(pAd->BulkOutPending[2] == TRUE) ||
+ate/common/rt_ate.c:			(pAd->BulkOutPending[3] == TRUE)) && (pAd->BulkFlags != 0))
+ate/common/rt_ate.c:			/* pAd->BulkFlags != 0 : wait bulk out finish */	
+ate/common/rt_ate.c:				pAd->BulkOutPending[y] will be set to FALSE
+ate/common/rt_ate.c:	ASSERT(pAd->PendingRx == 0);
+ate/common/rt_ate.c:			For rx statistics, we cancel pAd->Mlme.PeriodicTimer
+ate/common/rt_ate.c:			and set pAd->ate.PeriodicTimer.
+ate/common/rt_ate.c:		RTMPCancelTimer(&pAd->Mlme.PeriodicTimer, &Cancelled);
+ate/common/rt_ate.c:		RTMPInitTimer(pAd, &pAd->ate.PeriodicTimer, GET_TIMER_FUNCTION(ATEPeriodicExec), pAd, TRUE);
+ate/common/rt_ate.c:		RTMPSetTimer(&pAd->ate.PeriodicTimer, ATE_TASK_EXEC_INTV);
+ate/common/rt_ate.c:	InterlockedExchange(&pAd->BulkOutRemained, 0);
+ate/common/rt_ate.c:	NdisAcquireSpinLock(&pAd->GenericLock);	
+ate/common/rt_ate.c:	pAd->ContinBulkOut = FALSE;		
+ate/common/rt_ate.c:	pAd->ContinBulkIn = FALSE;
+ate/common/rt_ate.c:	NdisReleaseSpinLock(&pAd->GenericLock);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:		UCHAR			RestoreRfICType=pAd->RfIcType;
+ate/common/rt_ate.c:		pAd->RfIcType=RestoreRfICType;
+ate/common/rt_ate.c:	InterlockedExchange(&pAd->BulkOutRemained, 0);				
+ate/common/rt_ate.c:	NdisAcquireSpinLock(&pAd->GenericLock);
+ate/common/rt_ate.c:	pAd->ContinBulkOut = FALSE;		
+ate/common/rt_ate.c:	//pAd->ContinBulkIn = FALSE;
+ate/common/rt_ate.c:	NdisReleaseSpinLock(&pAd->GenericLock);		
+ate/common/rt_ate.c:	pAd->ContinBulkIn = FALSE;
+ate/common/rt_ate.c:			For rx statistics, we cancel pAd->Mlme.PeriodicTimer
+ate/common/rt_ate.c:		RTMPInitTimer(pAd, &pAd->Mlme.PeriodicTimer, GET_TIMER_FUNCTION(MlmePeriodicExec), pAd, TRUE);
+ate/common/rt_ate.c:		RTMPSetTimer(&pAd->Mlme.PeriodicTimer, MLME_TASK_EXEC_INTV);
+ate/common/rt_ate.c:		pAd->BulkFlags != 0 : wait bulk out finish
+ate/common/rt_ate.c:/*	pAd->ContinBulkIn = FALSE; */
+ate/common/rt_ate.c:	if (pAd->PendingRx > 0)
+ate/common/rt_ate.c:	while (((pAd->BulkOutPending[0] == TRUE) ||
+ate/common/rt_ate.c:			(pAd->BulkOutPending[1] == TRUE) || 
+ate/common/rt_ate.c:			(pAd->BulkOutPending[2] == TRUE) ||
+ate/common/rt_ate.c:			(pAd->BulkOutPending[3] == TRUE)) && (pAd->BulkFlags != 0))
+ate/common/rt_ate.c:			/* pAd->BulkFlags != 0 : wait bulk out finish */
+ate/common/rt_ate.c:	ASSERT(pAd->PendingRx == 0);
+ate/common/rt_ate.c:	pAd->PendingRx = 0;
+ate/common/rt_ate.c:	pAd->NextRxBulkInReadIndex = 0;	
+ate/common/rt_ate.c:	pAd->NextRxBulkInIndex = RX_RING_SIZE - 1;	
+ate/common/rt_ate.c:	pAd->NextRxBulkInPosition = 0;
+ate/common/rt_ate.c:		PRX_CONTEXT  pRxContext = &(pAd->RxContext[ring_index]);
+ate/common/rt_ate.c:		pAd->Mlme.CntlMachine.CurrState    = CNTL_IDLE;
+ate/common/rt_ate.c:		pAd->Mlme.AssocMachine.CurrState   = ASSOC_IDLE;
+ate/common/rt_ate.c:		pAd->Mlme.AuthMachine.CurrState    = AUTH_REQ_IDLE;
+ate/common/rt_ate.c:		pAd->Mlme.AuthRspMachine.CurrState = AUTH_RSP_IDLE;
+ate/common/rt_ate.c:		pAd->Mlme.SyncMachine.CurrState    = SYNC_IDLE;
+ate/common/rt_ate.c:		pAd->Mlme.ActMachine.CurrState    = ACT_IDLE;
+ate/common/rt_ate.c:		ASSERT(pAd->CommonCfg.Channel != 0);			
+ate/common/rt_ate.c:		AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+ate/common/rt_ate.c:		AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+ate/common/rt_ate.c:	RTMP_OS_NETDEV_START_QUEUE(pAd->net_dev);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	InterlockedExchange(&pAd->BulkOutRemained, pATEInfo->TxCount);
+ate/common/rt_ate.c:	NdisAcquireSpinLock(&pAd->GenericLock);
+ate/common/rt_ate.c:	pAd->ContinBulkOut = FALSE;		
+ate/common/rt_ate.c:	NdisReleaseSpinLock(&pAd->GenericLock);
+ate/common/rt_ate.c:	while (atomic_read(&pAd->BulkOutRemained) > 0)
+ate/common/rt_ate.c:		InterlockedExchange(&pAd->BulkOutRemained, pATEInfo->TxCount);
+ate/common/rt_ate.c:		NdisAcquireSpinLock(&pAd->GenericLock);
+ate/common/rt_ate.c:		pAd->ContinBulkOut = FALSE;		
+ate/common/rt_ate.c:		NdisReleaseSpinLock(&pAd->GenericLock);
+ate/common/rt_ate.c:		/* Let pAd->BulkOutRemained be consumed to zero. */
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:		InterlockedExchange(&pAd->BulkOutRemained, 0);
+ate/common/rt_ate.c:		InterlockedExchange(&pAd->BulkOutRemained, pATEInfo->TxCount);
+ate/common/rt_ate.c:	DBGPRINT(RT_DEBUG_TRACE, ("bulk out count = %d\n", atomic_read(&pAd->BulkOutRemained)));
+ate/common/rt_ate.c:	ASSERT((atomic_read(&pAd->BulkOutRemained) >= 0));
+ate/common/rt_ate.c:	if (atomic_read(&pAd->BulkOutRemained) == 0)
+ate/common/rt_ate.c:		NdisAcquireSpinLock(&pAd->GenericLock);
+ate/common/rt_ate.c:		pAd->ContinBulkOut = TRUE;		
+ate/common/rt_ate.c:		NdisReleaseSpinLock(&pAd->GenericLock);
+ate/common/rt_ate.c:		BULK_OUT_LOCK(&pAd->BulkOutLock[0], IrqFlags);
+ate/common/rt_ate.c:		pAd->BulkOutPending[0] = FALSE;
+ate/common/rt_ate.c:		BULK_OUT_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
+ate/common/rt_ate.c:		NdisAcquireSpinLock(&pAd->GenericLock);
+ate/common/rt_ate.c:		pAd->ContinBulkOut = FALSE;		
+ate/common/rt_ate.c:		NdisReleaseSpinLock(&pAd->GenericLock);
+ate/common/rt_ate.c:		BULK_OUT_LOCK(&pAd->BulkOutLock[0], IrqFlags);
+ate/common/rt_ate.c:		pAd->BulkOutPending[0] = FALSE;
+ate/common/rt_ate.c:		BULK_OUT_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:		PRX_CONTEXT  pRxContext = &(pAd->RxContext[ring_index]);
+ate/common/rt_ate.c:		pAd->BulkInReq = 0;
+ate/common/rt_ate.c:		pAd->PendingRx = 0;
+ate/common/rt_ate.c:		pAd->NextRxBulkInReadIndex = 0;
+ate/common/rt_ate.c:		pAd->NextRxBulkInIndex		= RX_RING_SIZE - 1;	
+ate/common/rt_ate.c:		pAd->NextRxBulkInPosition = 0;			
+ate/common/rt_ate.c:	pAd->ContinBulkIn = TRUE;
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:		if (pATEInfo->Channel == pAd->TxPower[index].Channel)
+ate/common/rt_ate.c:			pATEInfo->TxPower0 = pAd->TxPower[index].Power;
+ate/common/rt_ate.c:			pATEInfo->TxPower1 = pAd->TxPower[index].Power2;
+ate/common/rt_ate.c:				pATEInfo->TxPower2 = pAd->TxPower[index].Power3;
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	maximun_index = pAd->Antenna.field.TxPath - 1;
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	INT maximun_index = pAd->Antenna.field.TxPath;
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	INT maximun_index = pAd->Antenna.field.RxPath;
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:				if (pAd->Tx20MPwrCfgGBand[powerIndex] == 0xffffffff)
+ate/common/rt_ate.c:				RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + powerIndex*4, pAd->Tx20MPwrCfgGBand[powerIndex]);	
+ate/common/rt_ate.c:				if (pAd->Tx20MPwrCfgABand[powerIndex] == 0xffffffff)
+ate/common/rt_ate.c:				RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + powerIndex*4, pAd->Tx20MPwrCfgABand[powerIndex]);	
+ate/common/rt_ate.c:			pAd->LatchRfRegs.R4 &= ~0x00200000;
+ate/common/rt_ate.c:				if (pAd->Tx40MPwrCfgGBand[powerIndex] == 0xffffffff)
+ate/common/rt_ate.c:				RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + powerIndex*4, pAd->Tx40MPwrCfgGBand[powerIndex]);	
+ate/common/rt_ate.c:				if (pAd->Tx40MPwrCfgABand[powerIndex] == 0xffffffff)
+ate/common/rt_ate.c:				RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + powerIndex*4, pAd->Tx40MPwrCfgABand[powerIndex]);	
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:		DBGPRINT(RT_DEBUG_OFF, ("R1 = %x\n", pAd->LatchRfRegs.R1));
+ate/common/rt_ate.c:		DBGPRINT(RT_DEBUG_OFF, ("R2 = %x\n", pAd->LatchRfRegs.R2));
+ate/common/rt_ate.c:		DBGPRINT(RT_DEBUG_OFF, ("R3 = %x\n", pAd->LatchRfRegs.R3));
+ate/common/rt_ate.c:		DBGPRINT(RT_DEBUG_OFF, ("R4 = %x\n", pAd->LatchRfRegs.R4));
+ate/common/rt_ate.c:	pAd->LatchRfRegs.R1 = value;
+ate/common/rt_ate.c:	pAd->LatchRfRegs.R2 = value;
+ate/common/rt_ate.c:	pAd->LatchRfRegs.R3 = value;
+ate/common/rt_ate.c:	pAd->LatchRfRegs.R4 = value;
+ate/common/rt_ate.c:        Load and Write E-Fuse from pAd->EEPROMImage.
+ate/common/rt_ate.c:		rt_ee_write_all(pAd, pAd->EEPROMImage);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	if (pAd->TxPowerCtrl.bInternalTxALC == FALSE)                  
+ate/common/rt_ate.c:	pAd->ate.bTSSICalbrEnableG = bTSSICalbrEnableG;
+ate/common/rt_ate.c:	if (pAd->ate.bTSSICalbrEnableG == FALSE)
+ate/common/rt_ate.c:		pAd->ate.bTSSICalbrEnableG = FALSE;
+ate/common/rt_ate.c:	NdisCopyMemory(TssiRefPerChannel, pAd->ate.TssiRefPerChannel, CFG80211_NUM_OF_CHAN_2GHZ);
+ate/common/rt_ate.c:	NdisCopyMemory(TssiDeltaPerChannel, pAd->ate.TssiDeltaPerChannel, CFG80211_NUM_OF_CHAN_2GHZ);
+ate/common/rt_ate.c:	if(pAd->bUseEfuse)
+ate/common/rt_ate.c:		if(pAd->bFroceEEPROMBuffer)
+ate/common/rt_ate.c:			NdisMoveMemory(&(pAd->EEPROMImage[EEPROM_TSSI_OVER_OFDM_54]), (PUCHAR) (&EEPData) ,2);
+ate/common/rt_ate.c:	if (pAd->bUseEfuse)
+ate/common/rt_ate.c:		if (pAd->bFroceEEPROMBuffer)
+ate/common/rt_ate.c:			NdisMoveMemory(&(pAd->EEPROMImage[EEPROM_TX_POWER_OFFSET_OVER_CH_1-1]), (PUCHAR)(&EEPData), 2);
+ate/common/rt_ate.c:		if (pAd->bUseEfuse)
+ate/common/rt_ate.c:			if (pAd->bFroceEEPROMBuffer)
+ate/common/rt_ate.c:				NdisMoveMemory(&(pAd->EEPROMImage[(EEPROM_TX_POWER_OFFSET_OVER_CH_3 +((CurrentChannel-3)/2))]), (PUCHAR)(&EEPData), 2);
+ate/common/rt_ate.c:	if (pAd->bUseEfuse)
+ate/common/rt_ate.c:		if (pAd->bFroceEEPROMBuffer)
+ate/common/rt_ate.c:			NdisMoveMemory(&(pAd->EEPROMImage[EEPROM_TSSI_ENABLE]), (PUCHAR)(&EEPData), 2);
+ate/common/rt_ate.c:	if (pAd->bUseEfuse)
+ate/common/rt_ate.c:		if (pAd->bFroceEEPROMBuffer)
+ate/common/rt_ate.c:			NdisMoveMemory(&(pAd->EEPROMImage[EEPROM_TSSI_MODE_EXTEND]), (PUCHAR)(&EEPData), 2);
+ate/common/rt_ate.c:	NdisCopyMemory(pAd->ate.TssiRefPerChannel, TssiRefPerChannel, CFG80211_NUM_OF_CHAN_2GHZ);
+ate/common/rt_ate.c:	NdisCopyMemory(pAd->ate.TssiDeltaPerChannel, TssiDeltaPerChannel, CFG80211_NUM_OF_CHAN_2GHZ);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:			DBGPRINT_ERR(("The interface type is %d\n", pAd->infType));
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:	if (((pAd->MACVersion & 0xffff0000) < 0x28830000) || 
+ate/common/rt_ate.c:		(pAd->Antenna.field.RxPath == 1))
+ate/common/rt_ate.c:		if (idx >= pAd->Antenna.field.RxPath)
+ate/common/rt_ate.c:	pAd->ate.Mode = ATE_START;
+ate/common/rt_ate.c:	pAd->ate.Mode = ATE_STOP;
+ate/common/rt_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_ate.c:		NdisZeroMemory(&pAd->RalinkCounters,
+ate/common/rt_ate.c:						(UINT32)&pAd->RalinkCounters.OneSecEnd -
+ate/common/rt_ate.c:						(UINT32)&pAd->RalinkCounters.OneSecStart);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	while (pAd->PendingRx > 0)
+ate/common/rt_qa.c:	while (((pAd->BulkOutPending[0] == TRUE) ||
+ate/common/rt_qa.c:			(pAd->BulkOutPending[1] == TRUE) || 
+ate/common/rt_qa.c:			(pAd->BulkOutPending[2] == TRUE) ||
+ate/common/rt_qa.c:			(pAd->BulkOutPending[3] == TRUE)) && (pAd->BulkFlags != 0))	
+ate/common/rt_qa.c:			/* pAd->BulkFlags != 0 : wait bulk out finish */
+ate/common/rt_qa.c:	ASSERT(pAd->PendingRx == 0);
+ate/common/rt_qa.c:	InterlockedExchange(&pAd->BulkOutRemained, 0);
+ate/common/rt_qa.c:	pAd->ContinBulkOut = FALSE;
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	while (pAd->PendingRx > 0)
+ate/common/rt_qa.c:	while (((pAd->BulkOutPending[0] == TRUE) ||
+ate/common/rt_qa.c:			(pAd->BulkOutPending[1] == TRUE) || 
+ate/common/rt_qa.c:			(pAd->BulkOutPending[2] == TRUE) ||
+ate/common/rt_qa.c:			(pAd->BulkOutPending[3] == TRUE)) && (pAd->BulkFlags != 0))	
+ate/common/rt_qa.c:			/* pAd->BulkFlags != 0 : wait bulk out finish */
+ate/common/rt_qa.c:	ASSERT(pAd->PendingRx == 0);
+ate/common/rt_qa.c:	pAd->ContinBulkIn = FALSE;
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:			if ( pAd->Antenna.field.RxPath >= 2 ) /* 2R */
+ate/common/rt_qa.c:			if ( pAd->Antenna.field.RxPath >= 3 ) /* 3R */
+ate/common/rt_qa.c:		if ( pAd->Antenna.field.RxPath >= 2 ) /* 2R */
+ate/common/rt_qa.c:		if ( pAd->Antenna.field.RxPath >= 3 ) /* 3R */
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:			DBGPRINT_ERR(("%s : unable to kill ate thread\n", RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev)));
+ate/common/rt_qa.c:	pAd->LatchRfRegs.R1 = OS_NTOHL(R1);
+ate/common/rt_qa.c:	pAd->LatchRfRegs.R2 = OS_NTOHL(R2);
+ate/common/rt_qa.c:	pAd->LatchRfRegs.R3 = OS_NTOHL(R3);
+ate/common/rt_qa.c:	pAd->LatchRfRegs.R4 = OS_NTOHL(R4);
+ate/common/rt_qa.c:	pAd->LatchRfRegs.Channel = OS_NTOHS(channel);
+ate/common/rt_qa.c:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R1);
+ate/common/rt_qa.c:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R2);
+ate/common/rt_qa.c:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R3);
+ate/common/rt_qa.c:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R4);
+ate/common/rt_qa.c:	for (bbp_reg_index = 0; bbp_reg_index < pAd->chipCap.MaxNumOfBbpId+1; bbp_reg_index++)
+ate/common/rt_qa.c:	ResponseToGUI(pRaCfg, wrq, sizeof(pRaCfg->status)+ pAd->chipCap.MaxNumOfBbpId+1, NDIS_STATUS_SUCCESS);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	memcpy_exl(pAd, &pRaCfg->data[4], (UCHAR *)&pAd->WlanCounters.RetryCount.u.LowPart, 4);
+ate/common/rt_qa.c:	memcpy_exl(pAd, &pRaCfg->data[8], (UCHAR *)&pAd->WlanCounters.FailedCount.u.LowPart, 4);
+ate/common/rt_qa.c:	memcpy_exl(pAd, &pRaCfg->data[12], (UCHAR *)&pAd->WlanCounters.RTSSuccessCount.u.LowPart, 4);
+ate/common/rt_qa.c:	memcpy_exl(pAd, &pRaCfg->data[16], (UCHAR *)&pAd->WlanCounters.RTSFailureCount.u.LowPart, 4);
+ate/common/rt_qa.c:	memcpy_exl(pAd, &pRaCfg->data[20], (UCHAR *)&pAd->WlanCounters.ReceivedFragmentCount.QuadPart, 4);
+ate/common/rt_qa.c:	memcpy_exl(pAd, &pRaCfg->data[24], (UCHAR *)&pAd->WlanCounters.FCSErrorCount.u.LowPart, 4);
+ate/common/rt_qa.c:	memcpy_exl(pAd, &pRaCfg->data[28], (UCHAR *)&pAd->Counters8023.RxNoBuffer, 4);
+ate/common/rt_qa.c:	memcpy_exl(pAd, &pRaCfg->data[32], (UCHAR *)&pAd->WlanCounters.FrameDuplicateCount.u.LowPart, 4);
+ate/common/rt_qa.c:	memcpy_exl(pAd, &pRaCfg->data[36], (UCHAR *)&pAd->RalinkCounters.OneSecFalseCCACnt, 4);
+ate/common/rt_qa.c:		RSSI0 = (INT32)(pATEInfo->LastRssi0 - pAd->BbpRssiToDbmDelta);
+ate/common/rt_qa.c:		RSSI1 = (INT32)(pATEInfo->LastRssi1 - pAd->BbpRssiToDbmDelta);
+ate/common/rt_qa.c:		RSSI2 = (INT32)(pATEInfo->LastRssi2 - pAd->BbpRssiToDbmDelta);
+ate/common/rt_qa.c:		RSSI0 = (INT32)(pATEInfo->LastRssi0 - pAd->BbpRssiToDbmDelta);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/rt_qa.c:	PATE_INFO pATEInfo = &(pAd->ate);
+Binary file ate/common/rt_qa.o matches
+ate/common/ate_usb.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/ate_usb.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+ate/common/ate_usb.c:	pNullContext = &(pAd->NullContext);
+ate/common/ate_usb.c:		NdisZeroMemory(&(pAd->NullFrame), sizeof(HEADER_802_11));
+ate/common/ate_usb.c:			pHeader80211 = NdisMoveMemory(&(pAd->NullFrame),
+ate/common/ate_usb.c:			NdisMoveMemory(&(pAd->NullFrame), TemplateFrame,
+ate/common/ate_usb.c:		RTMPFrameEndianChange(pAd, (PUCHAR)&(pAd->NullFrame), DIR_READ, FALSE);
+ate/common/ate_usb.c:			COPY_MAC_ADDR(pAd->NullFrame.Addr1, pATEInfo->Addr1);
+ate/common/ate_usb.c:			COPY_MAC_ADDR(pAd->NullFrame.Addr2, pATEInfo->Addr2);
+ate/common/ate_usb.c:			COPY_MAC_ADDR(pAd->NullFrame.Addr3, pATEInfo->Addr3);
+ate/common/ate_usb.c:		RTMPZeroMemory(&pAd->NullContext.TransferBuffer->field.WirelessPacket[0], TX_BUFFER_NORMSIZE);
+ate/common/ate_usb.c:		pTxInfo = (TXINFO_STRUC *)&pAd->NullContext.TransferBuffer->field.WirelessPacket[0];
+ate/common/ate_usb.c:		pTxWI = (TXWI_STRUC *)&pAd->NullContext.TransferBuffer->field.WirelessPacket[TXINFO_SIZE];
+ate/common/ate_usb.c:		hex_dump("ATE", pAd->NullContext.TransferBuffer->field.WirelessPacket, 24);
+ate/common/ate_usb.c:		RTMPMoveMemory(&pAd->NullContext.TransferBuffer->field.WirelessPacket[TXINFO_SIZE + TXWISize],
+ate/common/ate_usb.c:			&pAd->NullFrame, sizeof(HEADER_802_11));
+ate/common/ate_usb.c:		pDest = &(pAd->NullContext.TransferBuffer->field.WirelessPacket[TXINFO_SIZE + TXWISize + sizeof(HEADER_802_11)]);
+ate/common/ate_usb.c:		if ((TransferBufferLength % pAd->BulkOutMaxPacketSize) == 0)
+ate/common/ate_usb.c:		pAd->NullContext.BulkOutSize = TransferBufferLength;
+ate/common/ate_usb.c:	hex_dump("ATE TX", &pAd->NullContext.TransferBuffer->field.WirelessPacket[0], TXWISize + TXINFO_SIZE);
+ate/common/ate_usb.c:	PTX_CONTEXT		pNullContext = &(pAd->NullContext);
+ate/common/ate_usb.c:	BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+ate/common/ate_usb.c:	if (pAd->BulkOutPending[BulkOutPipeId] == TRUE)
+ate/common/ate_usb.c:		BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+ate/common/ate_usb.c:	pAd->BulkOutPending[BulkOutPipeId] = TRUE;
+ate/common/ate_usb.c:	BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+ate/common/ate_usb.c:	pAd->RalinkCounters.OneSecTransmittedByteCount +=  pNullContext->BulkOutSize; 
+ate/common/ate_usb.c:	pAd->RalinkCounters.TransmittedByteCount +=  pNullContext->BulkOutSize;
+ate/common/ate_usb.c:	pAd->BulkOutReq++;
+ate/common/ate_usb.c:		pRxContext = &(pAd->RxContext[rx_ring_index]);
+ate/common/ate_usb.c:	if ((pAd->PendingRx > 0) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+ate/common/ate_usb.c:		pAd->PendingRx = 0;
+ate/common/ate_usb.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/ate_usb.c:	PTX_CONTEXT	pNullContext = &(pAd->NullContext);
+ate/common/ate_usb.c:	DBGPRINT(RT_DEBUG_TRACE, ("pATEInfo->Mode == %d\npAd->ContinBulkOut == %d\npAd->BulkOutRemained == %d\n",
+ate/common/ate_usb.c:		pATEInfo->Mode, pAd->ContinBulkOut, atomic_read(&pAd->BulkOutRemained)));
+ate/common/ate_usb.c:	if ((pATEInfo->Mode == ATE_TXFRAME) && ((pAd->ContinBulkOut == TRUE) || (atomic_read(&pAd->BulkOutRemained) > 0)))
+ate/common/ate_usb.c:		RTUSBInitTxDesc(pAd, pNullContext, 0/* pAd->bulkResetPipeid */, (usb_complete_t)RTUSBBulkOutDataPacketComplete);
+ate/common/ate_usb.c:		pAd->BulkOutReq++;
+ate/common/ate_usb.c:		NdisAcquireSpinLock(&pAd->TxSwQueueLock[Index]);
+ate/common/ate_usb.c:		while (pAd->TxSwQueue[Index].Head != NULL)
+ate/common/ate_usb.c:			pQueue = (PQUEUE_HEADER) &(pAd->TxSwQueue[Index]);
+ate/common/ate_usb.c:		NdisReleaseSpinLock(&pAd->TxSwQueueLock[Index]);
+Binary file ate/common/ate_usb.o matches
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO   pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	const TX_POWER_TUNING_ENTRY_STRUCT *TxPowerTuningTable = pAd->chipCap.TxPowerTuningTable_2G;
+ate/common/mrgtmp0:				TxPwr[index] = pAd->Tx40MPwrCfgABand[index];	
+ate/common/mrgtmp0:				TxPwr[index] = pAd->Tx40MPwrCfgGBand[index];	
+ate/common/mrgtmp0:				TxPwr[index] = pAd->Tx20MPwrCfgABand[index];	
+ate/common/mrgtmp0:				TxPwr[index] = pAd->Tx20MPwrCfgGBand[index];	
+ate/common/mrgtmp0:	if (pAd->TxPowerCtrl.bInternalTxALC == TRUE)
+ate/common/mrgtmp0:			if (pAd->TxPowerCtrl.bExtendedTssiMode == TRUE) /* Per-channel TSSI */
+ate/common/mrgtmp0:						pAd->TxPowerCtrl.bExtendedTssiMode, 
+ate/common/mrgtmp0:						pAd->TxPowerCtrl.PerChTxPwrOffset[pATEInfo->Channel]));
+ate/common/mrgtmp0:					desiredTSSI += pAd->TxPowerCtrl.PerChTxPwrOffset[pATEInfo->Channel];
+ate/common/mrgtmp0:				pAd->TxPowerCtrl.idxTxPowerTable++;
+ate/common/mrgtmp0:				pAd->TxPowerCtrl.idxTxPowerTable--;
+ate/common/mrgtmp0:			if (pAd->TxPowerCtrl.idxTxPowerTable < LOWERBOUND_TX_POWER_TUNING_ENTRY)
+ate/common/mrgtmp0:				pAd->TxPowerCtrl.idxTxPowerTable = LOWERBOUND_TX_POWER_TUNING_ENTRY;
+ate/common/mrgtmp0:			if (pAd->TxPowerCtrl.idxTxPowerTable >= UPPERBOUND_TX_POWER_TUNING_ENTRY(pAd))
+ate/common/mrgtmp0:				pAd->TxPowerCtrl.idxTxPowerTable = UPPERBOUND_TX_POWER_TUNING_ENTRY(pAd);
+ate/common/mrgtmp0:			/* Valid pAd->TxPowerCtrl.idxTxPowerTable: -30 ~ 45 */
+ate/common/mrgtmp0:			pTxPowerTuningEntry = &TxPowerTuningTable[pAd->TxPowerCtrl.idxTxPowerTable + TX_POWER_TUNING_ENTRY_OFFSET]; /* zero-based array */
+ate/common/mrgtmp0:			pAd->TxPowerCtrl.RF_TX_ALC = pTxPowerTuningEntry->RF_TX_ALC;
+ate/common/mrgtmp0:			pAd->TxPowerCtrl.MAC_PowerDelta = pTxPowerTuningEntry->MAC_PowerDelta;
+ate/common/mrgtmp0:			DBGPRINT(RT_DEBUG_TRACE, ("pAd->TxPowerCtrl.idxTxPowerTable = %d, pAd->TxPowerCtrl.RF_TX_ALC = %d, pAd->TxPowerCtrl.MAC_PowerDelta = %d\n", 
+ate/common/mrgtmp0:			        pAd->TxPowerCtrl.idxTxPowerTable, pAd->TxPowerCtrl.RF_TX_ALC, pAd->TxPowerCtrl.MAC_PowerDelta  ));
+ate/common/mrgtmp0: 			TotalDeltaPower += pAd->TxPowerCtrl.MAC_PowerDelta;
+ate/common/mrgtmp0:			        pAd->TxPowerCtrl.idxTxPowerTable, 
+ate/common/mrgtmp0:			bAutoTxAgc         = pAd->bAutoTxAgcG;
+ate/common/mrgtmp0:			TssiRef            = pAd->TssiRefG;
+ate/common/mrgtmp0:			pTssiMinusBoundary = &pAd->TssiMinusBoundaryG[0];
+ate/common/mrgtmp0:			pTssiPlusBoundary  = &pAd->TssiPlusBoundaryG[0];
+ate/common/mrgtmp0:			TxAgcStep          = pAd->TxAgcStepG;
+ate/common/mrgtmp0:			pTxAgcCompensate   = &pAd->TxAgcCompensateG;
+ate/common/mrgtmp0:			bAutoTxAgc         = pAd->bAutoTxAgcA;
+ate/common/mrgtmp0:			TssiRef            = pAd->TssiRefA;
+ate/common/mrgtmp0:			pTssiMinusBoundary = &pAd->TssiMinusBoundaryA[0];
+ate/common/mrgtmp0:			pTssiPlusBoundary  = &pAd->TssiPlusBoundaryA[0];
+ate/common/mrgtmp0:			TxAgcStep          = pAd->TxAgcStepA;
+ate/common/mrgtmp0:			pTxAgcCompensate   = &pAd->TxAgcCompensateA;
+ate/common/mrgtmp0:			/* step value is defined in pAd->TxAgcStepG for tx power value */
+ate/common/mrgtmp0:			bAutoTxAgc         = pAd->bAutoTxAgcG;
+ate/common/mrgtmp0:			pTxAgcCompensate   = &pAd->TxAgcCompensateG;
+ate/common/mrgtmp0:			bAutoTxAgc         = pAd->bAutoTxAgcA;
+ate/common/mrgtmp0:			pTxAgcCompensate   = &pAd->TxAgcCompensateA;
+ate/common/mrgtmp0:				if (pAd->TxPowerCtrl.bInternalTxALC == TRUE)
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	if (pAd->LatchRfRegs.Channel > 14)
+ate/common/mrgtmp0:		RssiOffset = pAd->ARssiOffset[RssiNumber];
+ate/common/mrgtmp0:		RssiOffset = pAd->BGRssiOffset[RssiNumber];
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	if (pAd->infType == RTMP_DEV_INF_USB)
+ate/common/mrgtmp0:	if (pAd->infType == RTMP_DEV_INF_USB)
+ate/common/mrgtmp0:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R1);
+ate/common/mrgtmp0:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R2);
+ate/common/mrgtmp0:	RTMP_RF_IO_WRITE32(pAd, (pAd->LatchRfRegs.R3 & (~0x04)));
+ate/common/mrgtmp0:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R4);
+ate/common/mrgtmp0:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R1);
+ate/common/mrgtmp0:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R2);
+ate/common/mrgtmp0:	RTMP_RF_IO_WRITE32(pAd, (pAd->LatchRfRegs.R3 | 0x04));
+ate/common/mrgtmp0:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R4);
+ate/common/mrgtmp0:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R1);
+ate/common/mrgtmp0:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R2);
+ate/common/mrgtmp0:	RTMP_RF_IO_WRITE32(pAd, (pAd->LatchRfRegs.R3 & (~0x04)));
+ate/common/mrgtmp0:	RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R4);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:		if (pAd->NicConfig2.field.ExternalLNAForG)
+ate/common/mrgtmp0:		if (pAd->Antenna.field.TxPath == 1)
+ate/common/mrgtmp0:		if (pAd->Antenna.field.RxPath == 1)
+ate/common/mrgtmp0:		if (pAd->Antenna.field.TxPath == 2)
+ate/common/mrgtmp0:		if (pAd->NicConfig2.field.ExternalLNAForA)
+ate/common/mrgtmp0:		if (pAd->Antenna.field.TxPath == 1)
+ate/common/mrgtmp0:		if (pAd->Antenna.field.RxPath == 1)
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	ProtCfg.field.ProtectRate = pAd->CommonCfg.RtsRate;
+ate/common/mrgtmp0:	pAd->FlgCtsEnabled = 0; 
+ate/common/mrgtmp0:	pAd->CommonCfg.IOTestParm.bRTSLongProtOn = FALSE;
+ate/common/mrgtmp0:	if (pAd->CommonCfg.CarrierDetect.Enable == TRUE)
+ate/common/mrgtmp0:		if (pAd->ApCfg.MBSSID[apidx].REKEYTimerRunning == TRUE)
+ate/common/mrgtmp0:			RTMPCancelTimer(&pAd->ApCfg.MBSSID[apidx].REKEYTimer, &Cancelled);
+ate/common/mrgtmp0:			pAd->ApCfg.MBSSID[apidx].REKEYTimerRunning = FALSE;
+ate/common/mrgtmp0:	if (pAd->ApCfg.CMTimerRunning == TRUE)
+ate/common/mrgtmp0:		RTMPCancelTimer(&pAd->ApCfg.CounterMeasureTimer, &Cancelled);
+ate/common/mrgtmp0:		pAd->ApCfg.CMTimerRunning = FALSE;
+ate/common/mrgtmp0:	if (pAd->ApCfg.ApQuickResponeForRateUpTimerRunning == TRUE)
+ate/common/mrgtmp0:		RTMPCancelTimer(&pAd->ApCfg.ApQuickResponeForRateUpTimer, &Cancelled);
+ate/common/mrgtmp0:	if (pAd->ApCfg.bGreenAPEnable == TRUE)
+ate/common/mrgtmp0:		pAd->ApCfg.GreenAPLevel=GREENAP_WITHOUT_ANY_STAS_CONNECT;
+ate/common/mrgtmp0:		pAd->ApCfg.bGreenAPEnable = FALSE;
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	RTMP_OS_NETDEV_STOP_QUEUE(pAd->net_dev);
+ate/common/mrgtmp0:		AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+ate/common/mrgtmp0:		AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+ate/common/mrgtmp0:	while ((pAd->PendingRx > 0) && (LoopCount < 2))	
+ate/common/mrgtmp0:			UCHAR			RestoreRfICType=pAd->RfIcType;
+ate/common/mrgtmp0:			pAd->RfIcType=RestoreRfICType;
+ate/common/mrgtmp0:			UCHAR			RestoreRfICType=pAd->RfIcType;
+ate/common/mrgtmp0:			pAd->RfIcType=RestoreRfICType;			
+ate/common/mrgtmp0:				UCHAR			RestoreRfICType=pAd->RfIcType;
+ate/common/mrgtmp0:				pAd->RfIcType=RestoreRfICType;
+ate/common/mrgtmp0:/*	pAd->ContinBulkIn = FALSE; */
+ate/common/mrgtmp0:	RTMPCancelTimer(&pAd->MlmeAux.AssocTimer,      &Cancelled);
+ate/common/mrgtmp0:	RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer,    &Cancelled);
+ate/common/mrgtmp0:	RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer,   &Cancelled);
+ate/common/mrgtmp0:	RTMPCancelTimer(&pAd->MlmeAux.AuthTimer,       &Cancelled);
+ate/common/mrgtmp0:	RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer,     &Cancelled);
+ate/common/mrgtmp0:	RTMPCancelTimer(&pAd->MlmeAux.ScanTimer,       &Cancelled);
+ate/common/mrgtmp0:		pAd->BulkFlags != 0 : wait bulk out finish
+ate/common/mrgtmp0:	while ((pAd->PendingRx > 0))	
+ate/common/mrgtmp0:		pAd->PendingRx = 0;
+ate/common/mrgtmp0:	while (((pAd->BulkOutPending[0] == TRUE) ||
+ate/common/mrgtmp0:			(pAd->BulkOutPending[1] == TRUE) || 
+ate/common/mrgtmp0:			(pAd->BulkOutPending[2] == TRUE) ||
+ate/common/mrgtmp0:			(pAd->BulkOutPending[3] == TRUE)) && (pAd->BulkFlags != 0))
+ate/common/mrgtmp0:			/* pAd->BulkFlags != 0 : wait bulk out finish */	
+ate/common/mrgtmp0:				pAd->BulkOutPending[y] will be set to FALSE
+ate/common/mrgtmp0:	ASSERT(pAd->PendingRx == 0);
+ate/common/mrgtmp0:			For rx statistics, we cancel pAd->Mlme.PeriodicTimer
+ate/common/mrgtmp0:			and set pAd->ate.PeriodicTimer.
+ate/common/mrgtmp0:		RTMPCancelTimer(&pAd->Mlme.PeriodicTimer, &Cancelled);
+ate/common/mrgtmp0:		RTMPInitTimer(pAd, &pAd->ate.PeriodicTimer, GET_TIMER_FUNCTION(ATEPeriodicExec), pAd, TRUE);
+ate/common/mrgtmp0:		RTMPSetTimer(&pAd->ate.PeriodicTimer, ATE_TASK_EXEC_INTV);
+ate/common/mrgtmp0:	InterlockedExchange(&pAd->BulkOutRemained, 0);
+ate/common/mrgtmp0:	NdisAcquireSpinLock(&pAd->GenericLock);	
+ate/common/mrgtmp0:	pAd->ContinBulkOut = FALSE;		
+ate/common/mrgtmp0:	pAd->ContinBulkIn = FALSE;
+ate/common/mrgtmp0:	NdisReleaseSpinLock(&pAd->GenericLock);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:		UCHAR			RestoreRfICType=pAd->RfIcType;
+ate/common/mrgtmp0:		pAd->RfIcType=RestoreRfICType;
+ate/common/mrgtmp0:			For rx statistics, we cancel pAd->Mlme.PeriodicTimer
+ate/common/mrgtmp0:		RTMPInitTimer(pAd, &pAd->Mlme.PeriodicTimer, GET_TIMER_FUNCTION(MlmePeriodicExec), pAd, TRUE);
+ate/common/mrgtmp0:		RTMPSetTimer(&pAd->Mlme.PeriodicTimer, MLME_TASK_EXEC_INTV);
+ate/common/mrgtmp0:		pAd->BulkFlags != 0 : wait bulk out finish
+ate/common/mrgtmp0:/*	pAd->ContinBulkIn = FALSE; */
+ate/common/mrgtmp0:	while (pAd->PendingRx > 0)
+ate/common/mrgtmp0:	while (((pAd->BulkOutPending[0] == TRUE) ||
+ate/common/mrgtmp0:			(pAd->BulkOutPending[1] == TRUE) || 
+ate/common/mrgtmp0:			(pAd->BulkOutPending[2] == TRUE) ||
+ate/common/mrgtmp0:			(pAd->BulkOutPending[3] == TRUE)) && (pAd->BulkFlags != 0))
+ate/common/mrgtmp0:			/* pAd->BulkFlags != 0 : wait bulk out finish */
+ate/common/mrgtmp0:	ASSERT(pAd->PendingRx == 0);
+ate/common/mrgtmp0:	pAd->PendingRx = 0;
+ate/common/mrgtmp0:	pAd->NextRxBulkInReadIndex = 0;	
+ate/common/mrgtmp0:	pAd->NextRxBulkInIndex = RX_RING_SIZE - 1;	
+ate/common/mrgtmp0:	pAd->NextRxBulkInPosition = 0;
+ate/common/mrgtmp0:		PRX_CONTEXT  pRxContext = &(pAd->RxContext[ring_index]);
+ate/common/mrgtmp0:		pAd->Mlme.CntlMachine.CurrState    = CNTL_IDLE;
+ate/common/mrgtmp0:		pAd->Mlme.AssocMachine.CurrState   = ASSOC_IDLE;
+ate/common/mrgtmp0:		pAd->Mlme.AuthMachine.CurrState    = AUTH_REQ_IDLE;
+ate/common/mrgtmp0:		pAd->Mlme.AuthRspMachine.CurrState = AUTH_RSP_IDLE;
+ate/common/mrgtmp0:		pAd->Mlme.SyncMachine.CurrState    = SYNC_IDLE;
+ate/common/mrgtmp0:		pAd->Mlme.ActMachine.CurrState    = ACT_IDLE;
+ate/common/mrgtmp0:		ASSERT(pAd->CommonCfg.Channel != 0);			
+ate/common/mrgtmp0:		AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+ate/common/mrgtmp0:		AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+ate/common/mrgtmp0:	InterlockedExchange(&pAd->BulkOutRemained, 0);				
+ate/common/mrgtmp0:	NdisAcquireSpinLock(&pAd->GenericLock);
+ate/common/mrgtmp0:	pAd->ContinBulkOut = FALSE;		
+ate/common/mrgtmp0:	pAd->ContinBulkIn = FALSE;
+ate/common/mrgtmp0:	NdisReleaseSpinLock(&pAd->GenericLock);		
+ate/common/mrgtmp0:	RTMP_OS_NETDEV_START_QUEUE(pAd->net_dev);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	InterlockedExchange(&pAd->BulkOutRemained, pATEInfo->TxCount);
+ate/common/mrgtmp0:	NdisAcquireSpinLock(&pAd->GenericLock);
+ate/common/mrgtmp0:	pAd->ContinBulkOut = FALSE;		
+ate/common/mrgtmp0:	NdisReleaseSpinLock(&pAd->GenericLock);
+ate/common/mrgtmp0:	while (atomic_read(&pAd->BulkOutRemained) > 0)
+ate/common/mrgtmp0:		InterlockedExchange(&pAd->BulkOutRemained, pATEInfo->TxCount);
+ate/common/mrgtmp0:		NdisAcquireSpinLock(&pAd->GenericLock);
+ate/common/mrgtmp0:		pAd->ContinBulkOut = FALSE;		
+ate/common/mrgtmp0:		NdisReleaseSpinLock(&pAd->GenericLock);
+ate/common/mrgtmp0:		/* Let pAd->BulkOutRemained be consumed to zero. */
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:		InterlockedExchange(&pAd->BulkOutRemained, 0);
+ate/common/mrgtmp0:		InterlockedExchange(&pAd->BulkOutRemained, pATEInfo->TxCount);
+ate/common/mrgtmp0:	DBGPRINT(RT_DEBUG_TRACE, ("bulk out count = %d\n", atomic_read(&pAd->BulkOutRemained)));
+ate/common/mrgtmp0:	ASSERT((atomic_read(&pAd->BulkOutRemained) >= 0));
+ate/common/mrgtmp0:	if (atomic_read(&pAd->BulkOutRemained) == 0)
+ate/common/mrgtmp0:		NdisAcquireSpinLock(&pAd->GenericLock);
+ate/common/mrgtmp0:		pAd->ContinBulkOut = TRUE;		
+ate/common/mrgtmp0:		NdisReleaseSpinLock(&pAd->GenericLock);
+ate/common/mrgtmp0:		BULK_OUT_LOCK(&pAd->BulkOutLock[0], IrqFlags);
+ate/common/mrgtmp0:		pAd->BulkOutPending[0] = FALSE;
+ate/common/mrgtmp0:		BULK_OUT_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
+ate/common/mrgtmp0:		NdisAcquireSpinLock(&pAd->GenericLock);
+ate/common/mrgtmp0:		pAd->ContinBulkOut = FALSE;		
+ate/common/mrgtmp0:		NdisReleaseSpinLock(&pAd->GenericLock);
+ate/common/mrgtmp0:		BULK_OUT_LOCK(&pAd->BulkOutLock[0], IrqFlags);
+ate/common/mrgtmp0:		pAd->BulkOutPending[0] = FALSE;
+ate/common/mrgtmp0:		BULK_OUT_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:		PRX_CONTEXT  pRxContext = &(pAd->RxContext[ring_index]);
+ate/common/mrgtmp0:		pAd->BulkInReq = 0;
+ate/common/mrgtmp0:		pAd->PendingRx = 0;
+ate/common/mrgtmp0:		pAd->NextRxBulkInReadIndex = 0;
+ate/common/mrgtmp0:		pAd->NextRxBulkInIndex		= RX_RING_SIZE - 1;	
+ate/common/mrgtmp0:		pAd->NextRxBulkInPosition = 0;			
+ate/common/mrgtmp0:	pAd->ContinBulkIn = TRUE;
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:		if (pATEInfo->Channel == pAd->TxPower[index].Channel)
+ate/common/mrgtmp0:			pATEInfo->TxPower0 = pAd->TxPower[index].Power;
+ate/common/mrgtmp0:			pATEInfo->TxPower1 = pAd->TxPower[index].Power2;
+ate/common/mrgtmp0:				pATEInfo->TxPower2 = pAd->TxPower[index].Power3;
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	maximun_index = pAd->Antenna.field.TxPath - 1;
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	INT maximun_index = pAd->Antenna.field.TxPath;
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	INT maximun_index = pAd->Antenna.field.RxPath;
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:				if (pAd->Tx20MPwrCfgGBand[powerIndex] == 0xffffffff)
+ate/common/mrgtmp0:				RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + powerIndex*4, pAd->Tx20MPwrCfgGBand[powerIndex]);	
+ate/common/mrgtmp0:				if (pAd->Tx20MPwrCfgABand[powerIndex] == 0xffffffff)
+ate/common/mrgtmp0:				RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + powerIndex*4, pAd->Tx20MPwrCfgABand[powerIndex]);	
+ate/common/mrgtmp0:			pAd->LatchRfRegs.R4 &= ~0x00200000;
+ate/common/mrgtmp0:				if (pAd->Tx40MPwrCfgGBand[powerIndex] == 0xffffffff)
+ate/common/mrgtmp0:				RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + powerIndex*4, pAd->Tx40MPwrCfgGBand[powerIndex]);	
+ate/common/mrgtmp0:				if (pAd->Tx40MPwrCfgABand[powerIndex] == 0xffffffff)
+ate/common/mrgtmp0:				RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + powerIndex*4, pAd->Tx40MPwrCfgABand[powerIndex]);	
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:		DBGPRINT(RT_DEBUG_OFF, ("R1 = %x\n", pAd->LatchRfRegs.R1));
+ate/common/mrgtmp0:		DBGPRINT(RT_DEBUG_OFF, ("R2 = %x\n", pAd->LatchRfRegs.R2));
+ate/common/mrgtmp0:		DBGPRINT(RT_DEBUG_OFF, ("R3 = %x\n", pAd->LatchRfRegs.R3));
+ate/common/mrgtmp0:		DBGPRINT(RT_DEBUG_OFF, ("R4 = %x\n", pAd->LatchRfRegs.R4));
+ate/common/mrgtmp0:	pAd->LatchRfRegs.R1 = value;
+ate/common/mrgtmp0:	pAd->LatchRfRegs.R2 = value;
+ate/common/mrgtmp0:	pAd->LatchRfRegs.R3 = value;
+ate/common/mrgtmp0:	pAd->LatchRfRegs.R4 = value;
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	if (pAd->TxPowerCtrl.bInternalTxALC == FALSE)                  
+ate/common/mrgtmp0:	pAd->ate.bTSSICalbrEnableG = bTSSICalbrEnableG;
+ate/common/mrgtmp0:	if (pAd->ate.bTSSICalbrEnableG == FALSE)
+ate/common/mrgtmp0:		pAd->ate.bTSSICalbrEnableG = FALSE;
+ate/common/mrgtmp0:	NdisCopyMemory(TssiRefPerChannel, pAd->ate.TssiRefPerChannel, CFG80211_NUM_OF_CHAN_2GHZ);
+ate/common/mrgtmp0:	NdisCopyMemory(TssiDeltaPerChannel, pAd->ate.TssiDeltaPerChannel, CFG80211_NUM_OF_CHAN_2GHZ);
+ate/common/mrgtmp0:	if(pAd->bUseEfuse)
+ate/common/mrgtmp0:		if(pAd->bFroceEEPROMBuffer)
+ate/common/mrgtmp0:			NdisMoveMemory(&(pAd->EEPROMImage[EEPROM_TSSI_OVER_OFDM_54]), (PUCHAR) (&EEPData) ,2);
+ate/common/mrgtmp0:	if (pAd->bUseEfuse)
+ate/common/mrgtmp0:		if (pAd->bFroceEEPROMBuffer)
+ate/common/mrgtmp0:			NdisMoveMemory(&(pAd->EEPROMImage[EEPROM_TX_POWER_OFFSET_OVER_CH_1-1]), (PUCHAR)(&EEPData), 2);
+ate/common/mrgtmp0:		if (pAd->bUseEfuse)
+ate/common/mrgtmp0:			if (pAd->bFroceEEPROMBuffer)
+ate/common/mrgtmp0:				NdisMoveMemory(&(pAd->EEPROMImage[(EEPROM_TX_POWER_OFFSET_OVER_CH_3 +((CurrentChannel-3)/2))]), (PUCHAR)(&EEPData), 2);
+ate/common/mrgtmp0:	if (pAd->bUseEfuse)
+ate/common/mrgtmp0:		if (pAd->bFroceEEPROMBuffer)
+ate/common/mrgtmp0:			NdisMoveMemory(&(pAd->EEPROMImage[EEPROM_TSSI_ENABLE]), (PUCHAR)(&EEPData), 2);
+ate/common/mrgtmp0:	if (pAd->bUseEfuse)
+ate/common/mrgtmp0:		if (pAd->bFroceEEPROMBuffer)
+ate/common/mrgtmp0:			NdisMoveMemory(&(pAd->EEPROMImage[EEPROM_TSSI_MODE_EXTEND]), (PUCHAR)(&EEPData), 2);
+ate/common/mrgtmp0:	NdisCopyMemory(pAd->ate.TssiRefPerChannel, TssiRefPerChannel, CFG80211_NUM_OF_CHAN_2GHZ);
+ate/common/mrgtmp0:	NdisCopyMemory(pAd->ate.TssiDeltaPerChannel, TssiDeltaPerChannel, CFG80211_NUM_OF_CHAN_2GHZ);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:			DBGPRINT_ERR(("The interface type is %d\n", pAd->infType));
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:	if (((pAd->MACVersion & 0xffff0000) < 0x28830000) || 
+ate/common/mrgtmp0:		(pAd->Antenna.field.RxPath == 1))
+ate/common/mrgtmp0:		if (idx >= pAd->Antenna.field.RxPath)
+ate/common/mrgtmp0:	pAd->ate.Mode = ATE_START;
+ate/common/mrgtmp0:	pAd->ate.Mode = ATE_STOP;
+ate/common/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/common/mrgtmp0:		NdisZeroMemory(&pAd->RalinkCounters,
+ate/common/mrgtmp0:						(UINT32)&pAd->RalinkCounters.OneSecEnd -
+ate/common/mrgtmp0:						(UINT32)&pAd->RalinkCounters.OneSecStart);
+Binary file ate/common/rt_ate.o matches
+ate/include/rt_ate.h:	if (__pAd->ate.pChipStruct->RxVGAInit != NULL)	\
+ate/include/rt_ate.h:		__pAd->ate.pChipStruct->RxVGAInit(__pAd)
+ate/include/rt_ate.h:	if (__pAd->ate.pChipStruct->AsicSetTxRxPath != NULL)	\
+ate/include/rt_ate.h:		__pAd->ate.pChipStruct->AsicSetTxRxPath(__pAd)
+ate/chips/rt28xx_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/chips/rt28xx_ate.c:	switch (pAd->RfIcType)
+ate/chips/rt28xx_ate.c:					if (pAd->Antenna.field.TxPath == 1)
+ate/chips/rt28xx_ate.c:					if (pAd->Antenna.field.TxPath == 2)
+ate/chips/rt28xx_ate.c:					if (pAd->Antenna.field.RxPath == 2)
+ate/chips/rt28xx_ate.c:					else if (pAd->Antenna.field.RxPath == 1)
+ate/chips/rt28xx_ate.c:					if (pAd->Antenna.field.RxPath == 3)
+ate/chips/rt28xx_ate.c:					pAd->LatchRfRegs.Channel = Channel;
+ate/chips/rt28xx_ate.c:					pAd->LatchRfRegs.R1 = RFRegTable[index].R1;
+ate/chips/rt28xx_ate.c:					pAd->LatchRfRegs.R2 = R2;
+ate/chips/rt28xx_ate.c:					pAd->LatchRfRegs.R3 = R3;
+ate/chips/rt28xx_ate.c:					pAd->LatchRfRegs.R4 = R4;
+ate/chips/rt28xx_ate.c:		if (pAd->NicConfig2.field.ExternalLNAForG)
+ate/chips/rt28xx_ate.c:		if (pAd->Antenna.field.TxPath == 1)
+ate/chips/rt28xx_ate.c:		if (pAd->Antenna.field.RxPath == 1)
+ate/chips/rt28xx_ate.c:		if (pAd->Antenna.field.TxPath == 2)
+ate/chips/rt28xx_ate.c:		if (pAd->NicConfig2.field.ExternalLNAForA)
+ate/chips/rt28xx_ate.c:		if (pAd->Antenna.field.TxPath == 1)
+ate/chips/rt28xx_ate.c:		if (pAd->Antenna.field.RxPath == 1)
+ate/chips/rt28xx_ate.c:								  pAd->RfIcType, 
+ate/chips/rt28xx_ate.c:								  pAd->Antenna.field.TxPath,
+ate/chips/rt28xx_ate.c:								  pAd->LatchRfRegs.R1, 
+ate/chips/rt28xx_ate.c:								  pAd->LatchRfRegs.R2, 
+ate/chips/rt28xx_ate.c:								  pAd->LatchRfRegs.R3, 
+ate/chips/rt28xx_ate.c:								  pAd->LatchRfRegs.R4));
+ate/chips/rt28xx_ate.c:								  pAd->RfIcType, 
+ate/chips/rt28xx_ate.c:								  pAd->Antenna.field.TxPath,
+ate/chips/rt28xx_ate.c:								  pAd->LatchRfRegs.R1, 
+ate/chips/rt28xx_ate.c:								  pAd->LatchRfRegs.R2, 
+ate/chips/rt28xx_ate.c:								  pAd->LatchRfRegs.R3, 
+ate/chips/rt28xx_ate.c:								  pAd->LatchRfRegs.R4));
+ate/chips/rt28xx_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/chips/rt28xx_ate.c:			R |= (pAd->LatchRfRegs.R3 & 0xffffc1ff);
+ate/chips/rt28xx_ate.c:			pAd->LatchRfRegs.R3 = R;
+ate/chips/rt28xx_ate.c:			R |= (pAd->LatchRfRegs.R4 & 0xfffff83f);
+ate/chips/rt28xx_ate.c:			pAd->LatchRfRegs.R4 = R;
+ate/chips/rt28xx_ate.c:				R |= (pAd->LatchRfRegs.R3 & 0xffffc1ff);
+ate/chips/rt28xx_ate.c:				pAd->LatchRfRegs.R3 = R;
+ate/chips/rt28xx_ate.c:				R |= (pAd->LatchRfRegs.R4 & 0xfffff83f);
+ate/chips/rt28xx_ate.c:				pAd->LatchRfRegs.R4 = R;
+ate/chips/rt28xx_ate.c:				R |= (pAd->LatchRfRegs.R3 & 0xffffc1ff);
+ate/chips/rt28xx_ate.c:				pAd->LatchRfRegs.R3 = (R & (~(1 << 9)));
+ate/chips/rt28xx_ate.c:				R |= (pAd->LatchRfRegs.R4 & 0xfffff83f);
+ate/chips/rt28xx_ate.c:				pAd->LatchRfRegs.R4 = (R & (~(1 << 6)));
+ate/chips/rt28xx_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/chips/rt28xx_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/chips/rt28xx_ate.c:				if (pAd->Tx20MPwrCfgGBand[powerIndex] == 0xffffffff)
+ate/chips/rt28xx_ate.c:				RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + powerIndex*4, pAd->Tx20MPwrCfgGBand[powerIndex]);	
+ate/chips/rt28xx_ate.c:				if (pAd->Tx20MPwrCfgABand[powerIndex] == 0xffffffff)
+ate/chips/rt28xx_ate.c:				RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + powerIndex*4, pAd->Tx20MPwrCfgABand[powerIndex]);	
+ate/chips/rt28xx_ate.c:		pAd->LatchRfRegs.R4 &= ~0x00200000;
+ate/chips/rt28xx_ate.c:				if (pAd->Tx40MPwrCfgGBand[powerIndex] == 0xffffffff)
+ate/chips/rt28xx_ate.c:				RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + powerIndex*4, pAd->Tx40MPwrCfgGBand[powerIndex]);	
+ate/chips/rt28xx_ate.c:				if (pAd->Tx40MPwrCfgABand[powerIndex] == 0xffffffff)
+ate/chips/rt28xx_ate.c:				RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + powerIndex*4, pAd->Tx40MPwrCfgABand[powerIndex]);	
+ate/chips/rt28xx_ate.c:		pAd->LatchRfRegs.R4 |= 0x00200000;
+ate/chips/rt28xx_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/chips/rt28xx_ate.c:	R4 |= (pAd->LatchRfRegs.R4 & ((~0x001f8000)));
+ate/chips/rt28xx_ate.c:	pAd->LatchRfRegs.R4 = R4;
+ate/chips/mt7601_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/chips/mt7601_ate.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+ate/chips/mt7601_ate.c:	rtmp_bbp_set_bw(pAd, pAd->ate.TxWI.TxWIBW);
+ate/chips/mt7601_ate.c:	switch (pAd->ate.TxWI.TxWIBW)
+ate/chips/mt7601_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/chips/mt7601_ate.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+ate/chips/mt7601_ate.c:		pAd->ate.TxWI.TxWIBW = BW_20;
+ate/chips/mt7601_ate.c:		pAd->ate.TxWI.TxWIBW = BW_40;
+ate/chips/mt7601_ate.c:	if ((pAd->ate.TxWI.TxWIPHYMODE == MODE_CCK) && (pAd->ate.TxWI.TxWIBW == BW_40))
+ate/chips/mt7601_ate.c:		pAd->ate.TxWI.TxWIBW = BW_20;
+ate/chips/mt7601_ate.c:	if (pAd->ate.TxWI.TxWIBW == BW_20)
+ate/chips/mt7601_ate.c:		if (pAd->ate.Channel <= 14)
+ate/chips/mt7601_ate.c:				if (pAd->Tx20MPwrCfgGBand[powerIndex] == 0xffffffff)
+ate/chips/mt7601_ate.c:				RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + powerIndex*4, pAd->Tx20MPwrCfgGBand[powerIndex]);	
+ate/chips/mt7601_ate.c:		if (pAd->ate.Channel == 14)
+ate/chips/mt7601_ate.c:			INT TxMode = pAd->ate.TxWI.TxWIPHYMODE;
+ate/chips/mt7601_ate.c:	else if (pAd->ate.TxWI.TxWIBW == BW_40)
+ate/chips/mt7601_ate.c:		if (pAd->ate.Channel <= 14)
+ate/chips/mt7601_ate.c:				if (pAd->Tx40MPwrCfgGBand[powerIndex] == 0xffffffff)
+ate/chips/mt7601_ate.c:				RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + powerIndex*4, pAd->Tx40MPwrCfgGBand[powerIndex]);	
+ate/chips/mt7601_ate.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_ATE_TX_BW_Proc (BBPCurrentBW = %d)\n", pAd->ate.TxWI.TxWIBW));
+ate/chips/mt7601_ate.c:	MT7601_TX_ALC_DATA *pTxALCData = &pAd->chipCap.TxALCData;
+ate/chips/mt7601_ate.c:	if ((pAd->ate.Channel >= 1) && (pAd->ate.Channel <= 14))
+ate/chips/mt7601_ate.c:		ch = pAd->ate.Channel;
+ate/chips/mt7601_ate.c:		DBGPRINT(RT_DEBUG_ERROR, ("%s::Incorrect channel #%d\n", __FUNCTION__, pAd->ate.Channel));
+ate/chips/mt7601_ate.c:	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R49, &(pAd->chipCap.CurrentTemperBbpR49));
+ate/chips/mt7601_ate.c:	DBGPRINT(RT_DEBUG_TRACE, ("temperature = 0x%X\n", pAd->chipCap.CurrentTemperBbpR49));
+ate/chips/mt7601_ate.c:	Power = pAd->ate.TxPower0;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_CCK_1M : BW20_MCS_POWER_CCK_1M;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_CCK_2M : BW20_MCS_POWER_CCK_2M;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_CCK_5M : BW20_MCS_POWER_CCK_5M;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_CCK_11M : BW20_MCS_POWER_CCK_11M;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_OFDM_6M : BW20_MCS_POWER_OFDM_6M;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_OFDM_9M : BW20_MCS_POWER_OFDM_9M;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_OFDM_12M : BW20_MCS_POWER_OFDM_12M;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_OFDM_18M : BW20_MCS_POWER_OFDM_18M;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_OFDM_24M : BW20_MCS_POWER_OFDM_24M;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_OFDM_36M : BW20_MCS_POWER_OFDM_36M;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_OFDM_48M : BW20_MCS_POWER_OFDM_48M;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_OFDM_54M : BW20_MCS_POWER_OFDM_54M;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_HT_MCS0: BW20_MCS_POWER_HT_MCS0;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_HT_MCS1: BW20_MCS_POWER_HT_MCS1;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_HT_MCS2: BW20_MCS_POWER_HT_MCS2;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_HT_MCS3: BW20_MCS_POWER_HT_MCS3;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_HT_MCS4: BW20_MCS_POWER_HT_MCS4;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_HT_MCS5: BW20_MCS_POWER_HT_MCS5;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_HT_MCS6: BW20_MCS_POWER_HT_MCS6;
+ate/chips/mt7601_ate.c:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_HT_MCS7: BW20_MCS_POWER_HT_MCS7;
+ate/chips/mt7601_ate.c:	MT7601_TX_ALC_DATA *pTxALCData = &pAd->chipCap.TxALCData;
+ate/chips/mt7601_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/chips/mt7601_ate.c:		if ((pAd->ate.Channel >= 1) && (pAd->ate.Channel <= 14))
+ate/chips/mt7601_ate.c:			ch = pAd->ate.Channel;
+ate/chips/mt7601_ate.c:			DBGPRINT(RT_DEBUG_ERROR, ("%s::Incorrect channel #%d\n", __FUNCTION__, pAd->ate.Channel));
+ate/chips/mt7601_ate.c:		if(pAd->TxPower[ch - 1].Power <= 20)
+ate/chips/mt7601_ate.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+ate/chips/mt7601_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/chips/mt7601_ate.c:		if ( pAd->TxPowerCtrl.bInternalTxALC == FALSE )
+ate/chips/mt7601_ate.c:		0. if current radio is a noisy environment (pAd->DrsCounters.fNoisyEnvironment)
+ate/chips/mt7601_ate.c:	NOTE: Since this routine requires the value of (pAd->DrsCounters.fNoisyEnvironment),
+ate/chips/mt7601_ate.c:	pAd->ate.RFFreqOffset = RFFreqOffset;
+ate/chips/mt7601_ate.c:		rlt_rf_write(pAd, RF_BANK0, RF_R12, pAd->ate.RFFreqOffset);
+ate/chips/mt7601_ate.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_ATE_TX_FREQOFFSET_Proc (RFFreqOffset = %d)\n", pAd->ate.RFFreqOffset));
+ate/chips/mt7601_ate.c:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/chips/mt7601_ate.c:	if ( pAd->ate.RxAntennaSel == 1 )
+ate/chips/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/chips/mrgtmp0:	MT7601_TX_ALC_DATA *pTxALCData = &pAd->chipCap.TxALCData;
+ate/chips/mrgtmp0:	rtmp_bbp_set_bw(pAd, pAd->ate.TxWI.TxWIBW);
+ate/chips/mrgtmp0:	switch (pAd->ate.TxWI.TxWIBW)
+ate/chips/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+ate/chips/mrgtmp0:	MT7601_TX_ALC_DATA *pTxALCData = &pAd->chipCap.TxALCData;
+ate/chips/mrgtmp0:		pAd->ate.TxWI.TxWIBW = BW_20;
+ate/chips/mrgtmp0:		pAd->ate.TxWI.TxWIBW = BW_40;
+ate/chips/mrgtmp0:	if ((pAd->ate.TxWI.TxWIPHYMODE == MODE_CCK) && (pAd->ate.TxWI.TxWIBW == BW_40))
+ate/chips/mrgtmp0:		pAd->ate.TxWI.TxWIBW = BW_20;
+ate/chips/mrgtmp0:	if (pAd->ate.TxWI.TxWIBW == BW_20)
+ate/chips/mrgtmp0:		if (pAd->ate.Channel <= 14)
+ate/chips/mrgtmp0:				if (pAd->Tx20MPwrCfgGBand[powerIndex] == 0xffffffff)
+ate/chips/mrgtmp0:				RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + powerIndex*4, pAd->Tx20MPwrCfgGBand[powerIndex]);	
+ate/chips/mrgtmp0:		if (pAd->ate.Channel == 14)
+ate/chips/mrgtmp0:			INT TxMode = pAd->ate.TxWI.TxWIPHYMODE;
+ate/chips/mrgtmp0:	else if (pAd->ate.TxWI.TxWIBW == BW_40)
+ate/chips/mrgtmp0:		if (pAd->ate.Channel <= 14)
+ate/chips/mrgtmp0:				if (pAd->Tx40MPwrCfgGBand[powerIndex] == 0xffffffff)
+ate/chips/mrgtmp0:				RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0 + powerIndex*4, pAd->Tx40MPwrCfgGBand[powerIndex]);	
+ate/chips/mrgtmp0:	DBGPRINT(RT_DEBUG_TRACE, ("Set_ATE_TX_BW_Proc (BBPCurrentBW = %d)\n", pAd->ate.TxWI.TxWIBW));
+ate/chips/mrgtmp0:	MT7601_TX_ALC_DATA *pTxALCData = &pAd->chipCap.TxALCData;
+ate/chips/mrgtmp0:	if ((pAd->ate.Channel >= 1) && (pAd->ate.Channel <= 14))
+ate/chips/mrgtmp0:		ch = pAd->ate.Channel;
+ate/chips/mrgtmp0:		DBGPRINT(RT_DEBUG_ERROR, ("%s::Incorrect channel #%d\n", __FUNCTION__, pAd->ate.Channel));
+ate/chips/mrgtmp0:	Power = pAd->TxPower[ch-1].Power;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_CCK_1M : BW20_MCS_POWER_CCK_1M;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_CCK_2M : BW20_MCS_POWER_CCK_2M;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_CCK_5M : BW20_MCS_POWER_CCK_5M;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_CCK_11M : BW20_MCS_POWER_CCK_11M;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_OFDM_6M : BW20_MCS_POWER_OFDM_6M;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_OFDM_9M : BW20_MCS_POWER_OFDM_9M;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_OFDM_12M : BW20_MCS_POWER_OFDM_12M;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_OFDM_18M : BW20_MCS_POWER_OFDM_18M;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_OFDM_24M : BW20_MCS_POWER_OFDM_24M;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_OFDM_36M : BW20_MCS_POWER_OFDM_36M;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_OFDM_48M : BW20_MCS_POWER_OFDM_48M;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_OFDM_54M : BW20_MCS_POWER_OFDM_54M;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_HT_MCS0: BW20_MCS_POWER_HT_MCS0;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_HT_MCS1: BW20_MCS_POWER_HT_MCS1;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_HT_MCS2: BW20_MCS_POWER_HT_MCS2;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_HT_MCS3: BW20_MCS_POWER_HT_MCS3;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_HT_MCS4: BW20_MCS_POWER_HT_MCS4;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_HT_MCS5: BW20_MCS_POWER_HT_MCS5;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_HT_MCS6: BW20_MCS_POWER_HT_MCS6;
+ate/chips/mrgtmp0:					Power += (pAd->ate.TxWI.TxWIBW == BW_40)? BW40_MCS_POWER_HT_MCS7: BW20_MCS_POWER_HT_MCS7;
+ate/chips/mrgtmp0:	MT7601_TX_ALC_DATA *pTxALCData = &pAd->chipCap.TxALCData;
+ate/chips/mrgtmp0:	if (pAd->Mlme.OneSecPeriodicRound % 4 == 0)
+ate/chips/mrgtmp0:		if ((pAd->ate.Channel >= 1) && (pAd->ate.Channel <= 14))
+ate/chips/mrgtmp0:			ch = pAd->ate.Channel;
+ate/chips/mrgtmp0:			DBGPRINT(RT_DEBUG_ERROR, ("%s::Incorrect channel #%d\n", __FUNCTION__, pAd->ate.Channel));
+ate/chips/mrgtmp0:		if(pAd->TxPower[ch - 1].Power <= 20)
+ate/chips/mrgtmp0:		0. if current radio is a noisy environment (pAd->DrsCounters.fNoisyEnvironment)
+ate/chips/mrgtmp0:	NOTE: Since this routine requires the value of (pAd->DrsCounters.fNoisyEnvironment),
+ate/chips/mrgtmp0:	pAd->ate.RFFreqOffset = RFFreqOffset;
+ate/chips/mrgtmp0:		rlt_rf_write(pAd, RF_BANK0, RF_R12, pAd->ate.RFFreqOffset);
+ate/chips/mrgtmp0:	DBGPRINT(RT_DEBUG_TRACE, ("Set_ATE_TX_FREQOFFSET_Proc (RFFreqOffset = %d)\n", pAd->ate.RFFreqOffset));
+ate/chips/mrgtmp0:	PATE_INFO pATEInfo = &(pAd->ate);
+chips/rt6590.c:		if (pAd->CommonCfg.BBPCurrentBW == RT6590_RF_BW_Switch[IdReg].BW)
+chips/rt6590.c:			pAd->LatchRfRegs.Channel = Channel; /* Channel latch */
+chips/rt6590.c:				pAd->RfIcType,
+chips/rt6590.c:				pAd->Antenna.field.TxPath,
+chips/rt6590.c:		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
+chips/rt6590.c:	if (WMODE_CAP(pAd->CommonCfg.PhyMode, WMODE_AC) &&
+chips/rt6590.c:		(pAd->CommonCfg.Channel > 14) &&
+chips/rt6590.c:		(pAd->CommonCfg.vht_bw == VHT_BW_80) &&
+chips/rt6590.c:		(pAd->CommonCfg.vht_cent_ch != pAd->CommonCfg.CentralChannel))
+chips/rt6590.c:		pAd->CommonCfg.vht_cent_ch = vht_cent_ch_freq(pAd, pAd->CommonCfg.Channel);
+chips/rt6590.c:				__FUNCTION__, rf_bw, ext_ch, pAd->CommonCfg.Channel,
+chips/rt6590.c:				pAd->CommonCfg.CentralChannel, pAd->CommonCfg.vht_cent_ch));
+chips/rt6590.c:					pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth,
+chips/rt6590.c:					pAd->CommonCfg.Channel,
+chips/rt6590.c:					pAd->CommonCfg.RegTransmitSetting.field.EXTCHA,
+chips/rt6590.c:					pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset));
+chips/rt6590.c:	rtmp_bbp_set_bw(pAd, pAd->CommonCfg.BBPCurrentBW);
+chips/rt6590.c:		if (Channel == pAd->TxPower[Index].Channel)
+chips/rt6590.c:			TxPwer = pAd->TxPower[Index].Power;
+chips/rt6590.c:	snprintf((PSTRING) pAd->nickname, sizeof(pAd->nickname), "RT6590STA");
+chips/rt6590.c:		pAd->TxPower[i].Channel = rt6590_txpwr_chlist[i];
+chips/rt6590.c:		pAd->TxPower[i].Power = DEFAULT_RF_TX_POWER;	
+chips/rt6590.c:		pAd->TxPower[idx].Power = tx_pwr1;
+chips/rt6590.c:		pAd->TxPower[idx + 1].Power = tx_pwr2;
+chips/rt6590.c:		ASSERT((pAd->TxPower[choffset].Channel == 36));
+chips/rt6590.c:		ASSERT((pAd->TxPower[choffset].Channel == 36));
+chips/rt6590.c:				pAd->TxPower[idx + choffset + 0].Power = Power.field.Byte0;
+chips/rt6590.c:				pAd->TxPower[idx + choffset + 1].Power = Power.field.Byte1;
+chips/rt6590.c:		ASSERT((pAd->TxPower[choffset].Channel == 100));
+chips/rt6590.c:				pAd->TxPower[idx + choffset + 0].Power = Power.field.Byte0;
+chips/rt6590.c:				pAd->TxPower[idx + choffset + 1].Power = Power.field.Byte1;
+chips/rt6590.c:		ASSERT((pAd->TxPower[choffset].Channel == 149));
+chips/rt6590.c:				pAd->TxPower[idx + choffset + 0].Power = Power.field.Byte0;
+chips/rt6590.c:				pAd->TxPower[idx + choffset + 1].Power = Power.field.Byte1;
+chips/rt6590.c:		ASSERT((pAd->TxPower[choffset].Channel == 42));
+chips/rt6590.c:		NdisMoveMemory(&pAd->TxPower[53], &pAd->TxPower[16], sizeof(CHANNEL_TX_POWER)); // channel 42 = channel 40
+chips/rt6590.c:		NdisMoveMemory(&pAd->TxPower[54], &pAd->TxPower[22], sizeof(CHANNEL_TX_POWER)); // channel 58 = channel 56
+chips/rt6590.c:		NdisMoveMemory(&pAd->TxPower[55], &pAd->TxPower[28], sizeof(CHANNEL_TX_POWER)); // channel 106 = channel 104
+chips/rt6590.c:		NdisMoveMemory(&pAd->TxPower[56], &pAd->TxPower[34], sizeof(CHANNEL_TX_POWER)); // channel 122 = channel 120
+chips/rt6590.c:		NdisMoveMemory(&pAd->TxPower[57], &pAd->TxPower[44], sizeof(CHANNEL_TX_POWER)); // channel 155 = channel 153
+chips/rt6590.c:		pAd->TxPower[choffset].Channel = 42;
+chips/rt6590.c:		pAd->TxPower[choffset+1].Channel = 58;
+chips/rt6590.c:		pAd->TxPower[choffset+2].Channel = 106;
+chips/rt6590.c:		pAd->TxPower[choffset+3].Channel = 122;
+chips/rt6590.c:		pAd->TxPower[choffset+4].Channel = 155;
+chips/rt6590.c:						i, pAd->TxPower[i].Channel, pAd->TxPower[i].Power));
+chips/rt6590.c:		pAd->Tx20MPwrCfgABand[i] = data;
+chips/rt6590.c:		pAd->Tx20MPwrCfgGBand[i] = data;
+chips/rt6590.c:		pAd->Tx40MPwrCfgABand[i] = DataBw40ABand;
+chips/rt6590.c:		pAd->Tx80MPwrCfgABand[i] = DataBw80ABand;
+chips/rt6590.c:		pAd->Tx40MPwrCfgGBand[i] = DataBw40GBand;
+chips/rt6590.c:	RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
+chips/rt6590.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+chips/rt6590.c:	pAd->RfIcType = RFIC_UNKNOWN;
+chips/rt6590.c:	pAd->chipCap.carrier_func = TONE_RADAR_V2;
+chips/rt65xx.c:	RTMP_SEM_EVENT_WAIT(&(pAd->WlanEnLock), RET);
+chips/rt65xx.c:	DBGPRINT(RT_DEBUG_OFF, ("==>%s(): OnOff:%d, pAd->WlanFunCtrl:0x%x, Reg-WlanFunCtrl=0x%x\n",
+chips/rt65xx.c:				__FUNCTION__, bOn, pAd->WlanFunCtrl.word, WlanFunCtrl.word));
+chips/rt65xx.c:		if (pAd->WlanFunCtrl.field.WLAN_EN)
+chips/rt65xx.c:	RTMP_IO_FORCE_READ32(pAd, MAC_CSR0, &pAd->MACVersion);
+chips/rt65xx.c:	DBGPRINT(RT_DEBUG_TRACE, ("MACVersion = 0x%08x\n", pAd->MACVersion));
+chips/rt65xx.c:	pAd->WlanFunCtrl.word = WlanFunCtrl.word;
+chips/rt65xx.c:		("<== %s():  pAd->WlanFunCtrl.word = 0x%x, Reg->WlanFunCtrl=0x%x!\n",
+chips/rt65xx.c:		__FUNCTION__, pAd->WlanFunCtrl.word, WlanFunCtrl.word));
+chips/rt65xx.c:	RTMP_SEM_EVENT_UP(&(pAd->WlanEnLock));
+chips/rt28xx.c:	if (pAd->MACVersion != 0x28600100)
+chips/rt28xx.c:		if (Channel == pAd->TxPower[index].Channel)
+chips/rt28xx.c:			TxPwer = pAd->TxPower[index].Power;
+chips/rt28xx.c:			TxPwer2 = pAd->TxPower[index].Power2;
+chips/rt28xx.c:	switch (pAd->RfIcType)
+chips/rt28xx.c:					if (pAd->Antenna.field.TxPath == 1)
+chips/rt28xx.c:					if ((pAd->Antenna.field.RxPath == 2)
+chips/rt28xx.c:						&& (pAd->ApCfg.bGreenAPActive == FALSE)
+chips/rt28xx.c:					else if ((pAd->Antenna.field.RxPath == 1)
+chips/rt28xx.c:							|| (pAd->ApCfg.bGreenAPActive == TRUE)
+chips/rt28xx.c:						R4 = (RFRegTable[index].R4 & (~0x001f87c0)) | (pAd->RfFreqOffset << 15);
+chips/rt28xx.c:						R4 = (RFRegTable[index].R4 & (~0x001f87c0)) | (pAd->RfFreqOffset << 15) | (TxPwer2 <<6);/* Set freq Offset & TxPwr1*/
+chips/rt28xx.c:					if (!bScan && (pAd->CommonCfg.BBPCurrentBW == BW_40)
+chips/rt28xx.c:						&& (pAd->ApCfg.bGreenAPActive == 0)
+chips/rt28xx.c:					pAd->LatchRfRegs.Channel = Channel;
+chips/rt28xx.c:					pAd->LatchRfRegs.R1 = RFRegTable[index].R1;
+chips/rt28xx.c:					pAd->LatchRfRegs.R2 = R2;
+chips/rt28xx.c:					pAd->LatchRfRegs.R3 = R3;
+chips/rt28xx.c:					pAd->LatchRfRegs.R4 = R4;
+chips/rt28xx.c:					RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R1);
+chips/rt28xx.c:					RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R2);
+chips/rt28xx.c:					RTMP_RF_IO_WRITE32(pAd, (pAd->LatchRfRegs.R3 & (~0x04)));
+chips/rt28xx.c:					RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R4);
+chips/rt28xx.c:					RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R1);
+chips/rt28xx.c:					RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R2);
+chips/rt28xx.c:					RTMP_RF_IO_WRITE32(pAd, (pAd->LatchRfRegs.R3 | 0x04));
+chips/rt28xx.c:					RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R4);
+chips/rt28xx.c:					RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R1);
+chips/rt28xx.c:					RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R2);
+chips/rt28xx.c:					RTMP_RF_IO_WRITE32(pAd, (pAd->LatchRfRegs.R3 & (~0x04)));
+chips/rt28xx.c:					RTMP_RF_IO_WRITE32(pAd, pAd->LatchRfRegs.R4);
+chips/rt28xx.c:										pAd->RfIcType, 
+chips/rt28xx.c:										pAd->Antenna.field.TxPath,
+chips/rt28xx.c:										pAd->LatchRfRegs.R1, 
+chips/rt28xx.c:										pAd->LatchRfRegs.R2, 
+chips/rt28xx.c:										pAd->LatchRfRegs.R3, 
+chips/rt28xx.c:										pAd->LatchRfRegs.R4));
+chips/rt28xx.c:			DBGPRINT(RT_DEBUG_TRACE, ("SwitchChannel#%d : unknown RFIC=%d\n", Channel, pAd->RfIcType));
+chips/rt28xx.c:			if (pAd->NicConfig2.field.ExternalLNAForG)
+chips/rt28xx.c:		if (pAd->Antenna.field.TxPath == 1)
+chips/rt28xx.c:		if (pAd->Antenna.field.RxPath == 1)
+chips/rt28xx.c:		bbpValue = (pAd->NicConfig2.field.ExternalLNAForA) ? 0x46 : 0x50;
+chips/rt28xx.c:		if (pAd->Antenna.field.TxPath == 1)
+chips/rt28xx.c:		if (pAd->Antenna.field.RxPath == 1)
+chips/mt7601.c:		RTMP_SEM_EVENT_WAIT(&pAd->hw_atomic, RET);
+chips/mt7601.c:	DBGPRINT(RT_DEBUG_INFO, ("==>%s(): OnOff:%d, pAd->WlanFunCtrl:0x%x, Reg-WlanFunCtrl=0x%x\n",
+chips/mt7601.c:				__FUNCTION__, bOn, pAd->WlanFunCtrl.word, WlanFunCtrl.word));
+chips/mt7601.c:		if (pAd->WlanFunCtrl.field.WLAN_EN)
+chips/mt7601.c:	RTMP_IO_READ32(pAd, MAC_CSR0, &pAd->MACVersion);
+chips/mt7601.c:	DBGPRINT(RT_DEBUG_TRACE, ("MACVersion = 0x%08x\n", pAd->MACVersion));
+chips/mt7601.c:	pAd->WlanFunCtrl.word = WlanFunCtrl.word;
+chips/mt7601.c:		("<== %s():  pAd->WlanFunCtrl.word = 0x%x, Reg->WlanFunCtrl=0x%x!\n",
+chips/mt7601.c:		__FUNCTION__, pAd->WlanFunCtrl.word, WlanFunCtrl.word));
+chips/mt7601.c:		RTMP_SEM_EVENT_UP(&pAd->hw_atomic);
+chips/mt7601.c:	MT7601_Bootup_Read_Temperature(pAd, &pAd->chipCap.CurrentTemperBbpR49);
+chips/mt7601.c:	pAd->chipCap.CurrentTemperature = (pAd->chipCap.CurrentTemperBbpR49 - pAd->chipCap.TemperatureRef25C) * MT7601_E2_TEMPERATURE_SLOPE;
+chips/mt7601.c:	pAd->chipCap.TemperatureDPD = pAd->chipCap.CurrentTemperature;
+chips/mt7601.c:	AndesCalibrationOP(pAd, ANDES_CALIBRATION_DPD, pAd->chipCap.CurrentTemperature);
+chips/mt7601.c:	rlt_rf_write(pAd, RF_BANK0, RF_R12, pAd->RfFreqOffset);
+chips/mt7601.c:		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
+chips/mt7601.c:					pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth,
+chips/mt7601.c:					pAd->CommonCfg.Channel,
+chips/mt7601.c:					pAd->CommonCfg.RegTransmitSetting.field.EXTCHA,
+chips/mt7601.c:					pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset));
+chips/mt7601.c:	if (pAd->LatchRfRegs.Channel <= 14) /* BG band */
+chips/mt7601.c:	if (pAd->LatchRfRegs.Channel <= 14) /* BG band */
+chips/mt7601.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+chips/mt7601.c:				__FUNCTION__, Channel, pAd->RfIcType, pAd->Antenna.field.TxPath));
+chips/mt7601.c:	if (pAd->TxPowerCtrl.bInternalTxALC != TRUE)
+chips/mt7601.c:		if ( pAd->DefaultTargetPwr > SkuBasePwr )
+chips/mt7601.c:			ChannelPwrAdj = SkuBasePwr - pAd->DefaultTargetPwr;
+chips/mt7601.c:		DBGPRINT(RT_DEBUG_TRACE, ("SkuBasePwr = 0x%x,  DefaultTargetPwr = 0x%x, ChannelPwrAdj 0x13b4: 0x%x\n", SkuBasePwr, pAd->DefaultTargetPwr, value));
+chips/mt7601.c:	if (pAd->TxPowerCtrl.bInternalTxALC)
+chips/mt7601.c:	TxPwer = pAd->TxPower[Channel - 1].Power;
+chips/mt7601.c:		RTMP_SEM_EVENT_WAIT(&pAd->hw_atomic, ret);
+chips/mt7601.c:	pAd->LatchRfRegs.Channel = Channel; /* Channel latch */
+chips/mt7601.c:	rtmp_bbp_set_bw(pAd, pAd->CommonCfg.BBPCurrentBW);
+chips/mt7601.c:	switch (pAd->CommonCfg.BBPCurrentBW)
+chips/mt7601.c:	if ( (pAd->CommonCfg.BBPCurrentBW == BW_20) && ( Channel == 14 ) )
+chips/mt7601.c:		value = pAd->TxCCKPwrCfg;
+chips/mt7601.c:		pAd->Tx20MPwrCfgGBand[0] = value;
+chips/mt7601.c:		pAd->Tx20MPwrCfgGBand[0] = pAd->TxCCKPwrCfg;
+chips/mt7601.c:	RTMP_IO_WRITE32(pAd, TX_PWR_CFG_0, pAd->Tx20MPwrCfgGBand[0]);
+chips/mt7601.c:		RTMP_SEM_EVENT_UP(&pAd->hw_atomic);
+chips/mt7601.c:	if (pAd->TxPowerCtrl.bInternalTxALC)
+chips/mt7601.c:		UpdateSkuRatePwr(pAd, Channel, pAd->CommonCfg.BBPCurrentBW, TxPwer);
+chips/mt7601.c:		UpdateSkuRatePwr(pAd, Channel, pAd->CommonCfg.BBPCurrentBW, SkuBasePwr);
+chips/mt7601.c:		__FUNCTION__, (ULONG)pAd->WlanCounters.TransmittedFragmentCount.u.LowPart));
+chips/mt7601.c:		__FUNCTION__, (ULONG)pAd->WlanCounters.ReceivedFragmentCount.QuadPart));
+chips/mt7601.c:		if (!pAd->chipCap.IsComboChip)
+chips/mt7601.c:		if ((pAd->chipCap.IsComboChip) || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_SUSPEND)
+chips/mt7601.c:		RTMP_SEM_EVENT_WAIT(&pAd->hw_atomic, ret);
+chips/mt7601.c:	if((pAd->PendingRx > 0) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+chips/mt7601.c:		//pAd->PendingRx = 0;
+chips/mt7601.c:		RTMP_SEM_EVENT_UP(&pAd->hw_atomic);
+chips/mt7601.c:	RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
+chips/mt7601.c:	POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+chips/mt7601.c:	if (pAd->WlanFunCtrl.field.WLAN_EN == 0)
+chips/mt7601.c:	if (pAd->StaCfg.PSPXlink)
+chips/mt7601.c:	if ( pAd->Mlme.bSendNullFrameAfterWareUp == TRUE)
+chips/mt7601.c:						  pAd->CommonCfg.TxRate, 
+chips/mt7601.c:						  (pAd->CommonCfg.bWmmCapable & pAd->CommonCfg.APEdcaParm.bValid),
+chips/mt7601.c:						  pAd->CommonCfg.bAPSDForcePowerSave ? PWR_SAVE : pAd->StaCfg.Psm);
+chips/mt7601.c:			pAd->CommonCfg.TxRate, 
+chips/mt7601.c:			(pAd->CommonCfg.bWmmCapable & pAd->CommonCfg.APEdcaParm.bValid),
+chips/mt7601.c:			pAd->CommonCfg.bAPSDForcePowerSave ? PWR_SAVE : pAd->StaCfg.Psm, 0);
+chips/mt7601.c:		pAd->Mlme.bSendNullFrameAfterWareUp = FALSE;
+chips/mt7601.c:	snprintf((PSTRING) pAd->nickname, sizeof(pAd->nickname), "MT7601STA");
+chips/mt7601.c:	pAd->DefaultTargetPwr = tx_pwr1;
+chips/mt7601.c:	NicConfig2.word = pAd->EEPROMDefaultValue[EEPROM_NIC_CFG2_OFFSET];
+chips/mt7601.c:			pAd->TxPower[idx].Power = tx_pwr1;
+chips/mt7601.c:			pAd->TxPower[idx + 1].Power = tx_pwr1;
+chips/mt7601.c:			pAd->TxPower[idx].Channel = i * 2 +1;
+chips/mt7601.c:			pAd->TxPower[idx + 1].Channel = i * 2 + 2;
+chips/mt7601.c:				pAd->TxPower[i * 2].Power, 
+chips/mt7601.c:				pAd->TxPower[i * 2 + 1].Power));
+chips/mt7601.c:		pAd->TxPower[idx].Power = tx_pwr1;
+chips/mt7601.c:		pAd->TxPower[idx + 1].Power = tx_pwr2;
+chips/mt7601.c:		pAd->TxPower[idx].Channel = i * 2 +1;
+chips/mt7601.c:		pAd->TxPower[idx + 1].Channel = i * 2 + 2;
+chips/mt7601.c:			pAd->TxPower[i * 2].Power, 
+chips/mt7601.c:			pAd->TxPower[i * 2 + 1].Power));
+chips/mt7601.c:	pAd->chipCap.Apwrdelta = Apwrdelta;
+chips/mt7601.c:	pAd->chipCap.Gpwrdelta = Gpwrdelta;
+chips/mt7601.c:		pAd->Tx20MPwrCfgABand[i] = data;
+chips/mt7601.c:		pAd->Tx20MPwrCfgGBand[i] = data;
+chips/mt7601.c:		pAd->Tx40MPwrCfgABand[i] = Adata;
+chips/mt7601.c:		pAd->Tx40MPwrCfgGBand[i] = Gdata;
+chips/mt7601.c:	pAd->TxCCKPwrCfg = pAd->Tx20MPwrCfgGBand[0];
+chips/mt7601.c:			pAd->chipCap.PAModeCCK[index] = RF_PA_MODE3_DECODE;
+chips/mt7601.c:			pAd->chipCap.PAModeCCK[index] = RF_PA_MODE1_DECODE;
+chips/mt7601.c:			pAd->chipCap.PAModeCCK[index] = RF_PA_MODE0_DECODE;
+chips/mt7601.c:			pAd->chipCap.PAModeCCK[index] = RF_PA_MODE2_DECODE;
+chips/mt7601.c:		DBGPRINT(RT_DEBUG_TRACE, ("PAModeCCK[%d] = %d\n", index, pAd->chipCap.PAModeCCK[index]));
+chips/mt7601.c:			pAd->chipCap.PAModeOFDM[index] = RF_PA_MODE3_DECODE;
+chips/mt7601.c:			pAd->chipCap.PAModeOFDM[index] = RF_PA_MODE1_DECODE;
+chips/mt7601.c:			pAd->chipCap.PAModeOFDM[index] = RF_PA_MODE0_DECODE;
+chips/mt7601.c:			pAd->chipCap.PAModeOFDM[index] = RF_PA_MODE2_DECODE;
+chips/mt7601.c:		DBGPRINT(RT_DEBUG_TRACE, ("PAModeOFDM[%d] = %d\n", index, pAd->chipCap.PAModeOFDM[index]));
+chips/mt7601.c:			pAd->chipCap.PAModeHT[index] = RF_PA_MODE3_DECODE;
+chips/mt7601.c:			pAd->chipCap.PAModeHT[index] = RF_PA_MODE1_DECODE;
+chips/mt7601.c:			pAd->chipCap.PAModeHT[index] = RF_PA_MODE0_DECODE;
+chips/mt7601.c:			pAd->chipCap.PAModeHT[index] = RF_PA_MODE2_DECODE;
+chips/mt7601.c:		DBGPRINT(RT_DEBUG_TRACE, ("PAModeHT[%d] = %d\n", index, pAd->chipCap.PAModeHT[index]));
+chips/mt7601.c:	pAd->chipCap.TemperatureMode = TEMPERATURE_MODE_NORMAL;
+chips/mt7601.c:	pAd->chipCap.CurrentTemperature = 0;
+chips/mt7601.c:	pAd->chipCap.bPllLockProtect = FALSE;
+chips/mt7601.c:	pAd->chipCap.TemperatureRef25C = (Value >> 8) & 0xFF;
+chips/mt7601.c:	DBGPRINT(RT_DEBUG_TRACE, ("pAd->TemperatureRef25C = 0x%x\n", pAd->chipCap.TemperatureRef25C));
+chips/mt7601.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+chips/mt7601.c:	if (pAd->Mlme.OneSecPeriodicRound % 4 == 0)
+chips/mt7601.c:		if ( pAd->TxPowerCtrl.bInternalTxALC == FALSE )
+chips/mt7601.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+chips/mt7601.c:		if ( pAd->chipCap.bPllLockProtect == FALSE )
+chips/mt7601.c:			pAd->chipCap.bPllLockProtect = TRUE;
+chips/mt7601.c:		if ( pAd->chipCap.bPllLockProtect == TRUE )
+chips/mt7601.c:			pAd->chipCap.bPllLockProtect = FALSE;
+chips/mt7601.c:			if (pAd->CommonCfg.BBPCurrentBW == BW_20 )
+chips/mt7601.c:			else if (pAd->CommonCfg.BBPCurrentBW == BW_40 )
+chips/mt7601.c:				DBGPRINT(RT_DEBUG_ERROR, ("%s::Unsupported BW(%x)\n", __FUNCTION__, pAd->CommonCfg.BBPCurrentBW));
+chips/mt7601.c:			if (pAd->CommonCfg.BBPCurrentBW == BW_20 )
+chips/mt7601.c:			else if (pAd->CommonCfg.BBPCurrentBW == BW_40 )
+chips/mt7601.c:				DBGPRINT(RT_DEBUG_ERROR, ("%s::Unsupported BW(%x)\n", __FUNCTION__, pAd->CommonCfg.BBPCurrentBW));
+chips/mt7601.c:			if (pAd->CommonCfg.BBPCurrentBW == BW_20 )
+chips/mt7601.c:			else if (pAd->CommonCfg.BBPCurrentBW == BW_40 )
+chips/mt7601.c:				DBGPRINT(RT_DEBUG_ERROR, ("%s::Unsupported BW(%x)\n", __FUNCTION__, pAd->CommonCfg.BBPCurrentBW));
+chips/mt7601.c:	MT7601_TX_ALC_DATA *pTxALCData = &pAd->chipCap.TxALCData;
+chips/mt7601.c:		RTMP_SEM_EVENT_WAIT(&pAd->hw_atomic, ret);
+chips/mt7601.c:			RTMP_SEM_EVENT_UP(&pAd->hw_atomic);
+chips/mt7601.c:	MT7601_TX_ALC_DATA *pTxALCData = &pAd->chipCap.TxALCData;
+chips/mt7601.c:	MT7601_TX_ALC_DATA *pTxALCData = &pAd->chipCap.TxALCData;
+chips/mt7601.c:	if (pAd->TxPowerCtrl.bInternalTxALC == FALSE)
+chips/mt7601.c:		if(pAd->TxPower[pAd->CommonCfg.CentralChannel-1].Power <= 20)
+chips/mt7601.c:		if(pAd->TxPower[pAd->CommonCfg.Channel-1].Power <= 20)
+chips/mt7601.c:	MT7601_TX_ALC_DATA *pTxALCData = &pAd->chipCap.TxALCData;
+chips/mt7601.c:	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R49, &(pAd->chipCap.CurrentTemperBbpR49));
+chips/mt7601.c:	DBGPRINT(RT_DEBUG_INFO, ("temperature = 0x%X\n", pAd->chipCap.CurrentTemperBbpR49));
+chips/mt7601.c:	Power = pAd->TxPower[pAd->CommonCfg.CentralChannel-1].Power;
+chips/mt7601.c:	Power = pAd->TxPower[pAd->CommonCfg.Channel-1].Power ;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_CCK_1M : BW20_MCS_POWER_CCK_1M;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_CCK_2M : BW20_MCS_POWER_CCK_2M;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_CCK_5M : BW20_MCS_POWER_CCK_5M;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_CCK_11M : BW20_MCS_POWER_CCK_11M;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_OFDM_6M : BW20_MCS_POWER_OFDM_6M;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_OFDM_9M : BW20_MCS_POWER_OFDM_9M;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_OFDM_12M : BW20_MCS_POWER_OFDM_12M;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_OFDM_18M : BW20_MCS_POWER_OFDM_18M;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_OFDM_24M : BW20_MCS_POWER_OFDM_24M;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_OFDM_36M : BW20_MCS_POWER_OFDM_36M;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_OFDM_48M : BW20_MCS_POWER_OFDM_48M;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_OFDM_54M : BW20_MCS_POWER_OFDM_54M;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_HT_MCS0: BW20_MCS_POWER_HT_MCS0;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_HT_MCS1: BW20_MCS_POWER_HT_MCS1;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_HT_MCS2: BW20_MCS_POWER_HT_MCS2;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_HT_MCS3: BW20_MCS_POWER_HT_MCS3;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_HT_MCS4: BW20_MCS_POWER_HT_MCS4;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_HT_MCS5: BW20_MCS_POWER_HT_MCS5;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_HT_MCS6: BW20_MCS_POWER_HT_MCS6;
+chips/mt7601.c:					Power += (pAd->CommonCfg.BBPCurrentBW == BW_40)? BW40_MCS_POWER_HT_MCS7: BW20_MCS_POWER_HT_MCS7;
+chips/mt7601.c:	MT7601_TX_ALC_DATA *pTxALCData = &pAd->chipCap.TxALCData;
+chips/mt7601.c:	if ( pAd->TxPowerCtrl.bInternalTxALC == FALSE )
+chips/mt7601.c:	if (pAd->Mlme.OneSecPeriodicRound % 4 == 0)
+chips/mt7601.c:		if(pAd->TxPower[pAd->CommonCfg.CentralChannel-1].Power <= 20)
+chips/mt7601.c:		if(pAd->TxPower[pAd->CommonCfg.Channel-1].Power <= 20)
+chips/mt7601.c:		if ( pAd->CommonCfg.CentralChannel <= 4 )
+chips/mt7601.c:		else if ( pAd->CommonCfg.CentralChannel >= 9 )
+chips/mt7601.c:		if ( pAd->CommonCfg.Channel <= 4 )
+chips/mt7601.c:		else if ( pAd->CommonCfg.Channel >= 9 )
+chips/mt7601.c:	if ( (pAd->chipCap.TxALCData.TssiTriggered == 1)  && ( pAd->TxPowerCtrl.bInternalTxALC == TRUE ) )
+chips/mt7601.c:		*Temperature = pAd->chipCap.CurrentTemperBbpR49;
+chips/mt7601.c:	RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
+chips/mt7601.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+chips/mt7601.c:	pAd->RfIcType = RFIC_UNKNOWN;
+chips/mt7601.c:	pAd->chipCap.carrier_func = TONE_RADAR_V2;
+chips/rt85592.c:		pAd->Tx20MPwrCfgABand[i] = data;
+chips/rt85592.c:		pAd->Tx20MPwrCfgGBand[i] = data;
+chips/rt85592.c:		pAd->Tx40MPwrCfgABand[i] = DataBw40ABand;
+chips/rt85592.c:		pAd->Tx80MPwrCfgABand[i] = DataBw80ABand;
+chips/rt85592.c:		pAd->Tx40MPwrCfgGBand[i] = DataBw40GBand;
+chips/rt85592.c:		pAd->TxPower[i].Channel = txpwr_chlist[i];
+chips/rt85592.c:		pAd->TxPower[i].Power = DEFAULT_RF_TX_POWER;
+chips/rt85592.c:		pAd->TxPower[i].Power2 = DEFAULT_RF_TX_POWER;
+chips/rt85592.c:				pAd->TxPower[idx].Power = tx_pwr1;
+chips/rt85592.c:				pAd->TxPower[idx + 1].Power = tx_pwr2;
+chips/rt85592.c:				pAd->TxPower[idx].Power2 = tx_pwr1;
+chips/rt85592.c:				pAd->TxPower[idx + 1].Power2 = tx_pwr2;
+chips/rt85592.c:		ASSERT((pAd->TxPower[choffset].Channel == 36));
+chips/rt85592.c:		ASSERT((pAd->TxPower[choffset].Channel == 36));
+chips/rt85592.c:				pAd->TxPower[idx + choffset + 0].Power = Power.field.Byte0;
+chips/rt85592.c:				pAd->TxPower[idx + choffset + 1].Power = Power.field.Byte1;			
+chips/rt85592.c:				pAd->TxPower[idx + choffset + 0].Power2 = Power2.field.Byte0;
+chips/rt85592.c:				pAd->TxPower[idx + choffset + 1].Power2 = Power2.field.Byte1;
+chips/rt85592.c:		ASSERT((pAd->TxPower[choffset].Channel == 100));
+chips/rt85592.c:				pAd->TxPower[idx + choffset + 0].Power = Power.field.Byte0;
+chips/rt85592.c:				pAd->TxPower[idx + choffset + 1].Power = Power.field.Byte1;
+chips/rt85592.c:				pAd->TxPower[idx + choffset + 0].Power2 = Power2.field.Byte0;
+chips/rt85592.c:				pAd->TxPower[idx + choffset + 1].Power2 = Power2.field.Byte1;
+chips/rt85592.c:		ASSERT((pAd->TxPower[choffset].Channel == 149));
+chips/rt85592.c:				pAd->TxPower[idx + choffset + 0].Power = Power.field.Byte0;
+chips/rt85592.c:				pAd->TxPower[idx + choffset + 1].Power = Power.field.Byte1;
+chips/rt85592.c:				pAd->TxPower[idx + choffset + 0].Power2 = Power2.field.Byte0;
+chips/rt85592.c:				pAd->TxPower[idx + choffset + 1].Power2 = Power2.field.Byte1;
+chips/rt85592.c:		ASSERT((pAd->TxPower[choffset].Channel == 42));
+chips/rt85592.c:		NdisMoveMemory(&pAd->TxPower[53], &pAd->TxPower[16], sizeof(CHANNEL_TX_POWER)); // channel 42 = channel 40
+chips/rt85592.c:		NdisMoveMemory(&pAd->TxPower[54], &pAd->TxPower[22], sizeof(CHANNEL_TX_POWER)); // channel 58 = channel 56
+chips/rt85592.c:		NdisMoveMemory(&pAd->TxPower[55], &pAd->TxPower[28], sizeof(CHANNEL_TX_POWER)); // channel 106 = channel 104
+chips/rt85592.c:		NdisMoveMemory(&pAd->TxPower[56], &pAd->TxPower[34], sizeof(CHANNEL_TX_POWER)); // channel 122 = channel 120
+chips/rt85592.c:		NdisMoveMemory(&pAd->TxPower[57], &pAd->TxPower[44], sizeof(CHANNEL_TX_POWER)); // channel 155 = channel 153
+chips/rt85592.c:		pAd->TxPower[choffset].Channel = 42;
+chips/rt85592.c:		pAd->TxPower[choffset+1].Channel = 58;
+chips/rt85592.c:		pAd->TxPower[choffset+2].Channel = 106;
+chips/rt85592.c:		pAd->TxPower[choffset+3].Channel = 122;
+chips/rt85592.c:		pAd->TxPower[choffset+4].Channel = 155;
+chips/rt85592.c:						i, pAd->TxPower[i].Channel, pAd->TxPower[i].Power, pAd->TxPower[i].Power2 ));
+chips/rt85592.c:	if ((pAd->Antenna.field.TxPath == 2) && (pAd->Antenna.field.RxPath == 2))
+chips/rt85592.c:	for(IdReg=0; IdReg < pAd->chipCap.bbpRegTbSize; IdReg++)
+chips/rt85592.c:		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
+chips/rt85592.c:	if (WMODE_CAP(pAd->CommonCfg.PhyMode, WMODE_AC) &&
+chips/rt85592.c:		(pAd->CommonCfg.Channel > 14) &&
+chips/rt85592.c:		(pAd->CommonCfg.vht_bw == VHT_BW_80) &&
+chips/rt85592.c:		(pAd->CommonCfg.vht_cent_ch != pAd->CommonCfg.CentralChannel))
+chips/rt85592.c:		pAd->CommonCfg.vht_cent_ch = vht_cent_ch_freq(pAd, pAd->CommonCfg.Channel);
+chips/rt85592.c:				__FUNCTION__, rf_bw, ext_ch, pAd->CommonCfg.Channel,
+chips/rt85592.c:				pAd->CommonCfg.CentralChannel, pAd->CommonCfg.vht_cent_ch));
+chips/rt85592.c:									pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth,
+chips/rt85592.c:									pAd->CommonCfg.Channel,
+chips/rt85592.c:									pAd->CommonCfg.RegTransmitSetting.field.EXTCHA,
+chips/rt85592.c:									pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset));
+chips/rt85592.c:	if (WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_B))
+chips/rt85592.c:	if (pAd->CommonCfg.BBPCurrentBW == BW_80)
+chips/rt85592.c:	else if (pAd->CommonCfg.BBPCurrentBW == BW_40)
+chips/rt85592.c:		if (Channel == pAd->TxPower[idx].Channel)
+chips/rt85592.c:			TxPwer = pAd->TxPower[idx].Power;
+chips/rt85592.c:			TxPwer2 = pAd->TxPower[idx].Power2;
+chips/rt85592.c:				Channel, pAd->RfIcType,
+chips/rt85592.c:				pAd->Antenna.field.TxPath,
+chips/rt85592.c:				pAd->CommonCfg.BBPCurrentBW));
+chips/rt85592.c:	if (pAd->Antenna.field.TxPath == 2)
+chips/rt85592.c:	else if (pAd->Antenna.field.TxPath == 1)
+chips/rt85592.c:	if (pAd->Antenna.field.RxPath == 2)
+chips/rt85592.c:	else if (pAd->Antenna.field.RxPath == 1)
+chips/rt85592.c:	if( (pAd->FreqCalibrationCtrl.bEnableFrequencyCalibration == TRUE) && INFRA_ON(pAd))
+chips/rt85592.c:		RFValue = ((RFValue & ~0x7F) | (pAd->FreqCalibrationCtrl.AdaptiveFreqOffset & 0x7F));
+chips/rt85592.c:		RFValue = ((RFValue & ~0x7F) | (pAd->RfFreqOffset & 0x7F)); 
+chips/rt85592.c:	pAd->LatchRfRegs.Channel = Channel; /* Channel latch */
+chips/rt85592.c:		if (pAd->Antenna.field.TxPath == 1)
+chips/rt85592.c:		if (pAd->Antenna.field.RxPath == 1)
+chips/rt85592.c:		if (pAd->Antenna.field.TxPath == 1)
+chips/rt85592.c:		if (pAd->Antenna.field.RxPath == 1)
+chips/rt85592.c:	snprintf((PSTRING) pAd->nickname, sizeof(pAd->nickname), "RT85592STA");
+chips/rt85592.c:	RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
+chips/rt85592.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+chips/rt85592.c:	pAd->RfIcType = RFIC_UNKNOWN;
+chips/rt85592.c:	pAd->chipCap.carrier_func = TONE_RADAR_V2;
+Binary file chips/mt7601.o matches
+chips/rt3290.c:	index = GET_TSSI_RATE_TABLE_INDEX(tb_idx + pAd->TxPowerCtrl.PerChTxPwrOffset[ch]);
+chips/rt3290.c:	if (pAd->TxPowerCtrl.bInternalTxALC == FALSE)
+chips/rt3290.c:		pAd->TxPowerCtrl.bExtendedTssiMode = TRUE;
+chips/rt3290.c:		pAd->TxPowerCtrl.PerChTxPwrOffset[1] = (TxPwrOffset.field.Byte1 & 0x0F); /* Tx power offset over channel 1 */
+chips/rt3290.c:		pAd->TxPowerCtrl.PerChTxPwrOffset[2] = (((TxPwrOffset.field.Byte1 & 0xF0) >> 4) & 0x0F); /* Tx power offset over channel 2 */
+chips/rt3290.c:		pAd->TxPowerCtrl.PerChTxPwrOffset[3] = (TxPwrOffset.field.Byte0 & 0x0F); /* Tx power offset over channel 3 */
+chips/rt3290.c:		pAd->TxPowerCtrl.PerChTxPwrOffset[4] = (((TxPwrOffset.field.Byte0 & 0xF0) >> 4) & 0x0F); /* Tx power offset over channel 4 */
+chips/rt3290.c:		pAd->TxPowerCtrl.PerChTxPwrOffset[5] = (TxPwrOffset.field.Byte1 & 0x0F); /* Tx power offset over channel 5 */
+chips/rt3290.c:		pAd->TxPowerCtrl.PerChTxPwrOffset[6] = (((TxPwrOffset.field.Byte1 & 0xF0) >> 4) & 0x0F); /* Tx power offset over channel 6 */
+chips/rt3290.c:		pAd->TxPowerCtrl.PerChTxPwrOffset[7] = (TxPwrOffset.field.Byte0 & 0x0F); /* Tx power offset over channel 7 */
+chips/rt3290.c:		pAd->TxPowerCtrl.PerChTxPwrOffset[8] = (((TxPwrOffset.field.Byte0 & 0xF0) >> 4) & 0x0F); /* Tx power offset over channel 8 */
+chips/rt3290.c:		pAd->TxPowerCtrl.PerChTxPwrOffset[9] = (TxPwrOffset.field.Byte1 & 0x0F); /* Tx power offset over channel 9 */
+chips/rt3290.c:		pAd->TxPowerCtrl.PerChTxPwrOffset[10] = (((TxPwrOffset.field.Byte1 & 0xF0) >> 4) & 0x0F); /* Tx power offset over channel 10 */
+chips/rt3290.c:		pAd->TxPowerCtrl.PerChTxPwrOffset[11] = (TxPwrOffset.field.Byte0 & 0x0F); /* Tx power offset over channel 11 */
+chips/rt3290.c:		pAd->TxPowerCtrl.PerChTxPwrOffset[12] = (((TxPwrOffset.field.Byte0 & 0xF0) >> 4) & 0x0F); /* Tx power offset over channel 12 */
+chips/rt3290.c:		pAd->TxPowerCtrl.PerChTxPwrOffset[13] = (TxPwrOffset.field.Byte1 & 0x0F); /* Tx power offset over channel 13 */
+chips/rt3290.c:		pAd->TxPowerCtrl.PerChTxPwrOffset[14] = (((TxPwrOffset.field.Byte1 & 0xF0) >> 4) & 0x0F); /* Tx power offset over channel 14 */
+chips/rt3290.c:			if ((pAd->TxPowerCtrl.PerChTxPwrOffset[i] & 0x08) == 0x00) /* Positive number */
+chips/rt3290.c:				pAd->TxPowerCtrl.PerChTxPwrOffset[i] = (pAd->TxPowerCtrl.PerChTxPwrOffset[i] & ~0xF8);
+chips/rt3290.c:				pAd->TxPowerCtrl.PerChTxPwrOffset[i] = (pAd->TxPowerCtrl.PerChTxPwrOffset[i] | 0xF0);
+chips/rt3290.c:			DBGPRINT(RT_DEBUG_TRACE, ("\t[%d] = %d\n", i, pAd->TxPowerCtrl.PerChTxPwrOffset[i]));
+chips/rt3290.c:		pAd->TxPowerCtrl.bExtendedTssiMode = FALSE;
+chips/rt3290.c:		RTMPZeroMemory(pAd->TxPowerCtrl.PerChTxPwrOffset, sizeof(pAd->TxPowerCtrl.PerChTxPwrOffset));
+chips/rt3290.c:	if ((pAd->CommonCfg.CentralChannel >= 1) && (pAd->CommonCfg.CentralChannel <= 14))
+chips/rt3290.c:		ch = pAd->CommonCfg.CentralChannel;
+chips/rt3290.c:					__FUNCTION__, pAd->CommonCfg.CentralChannel, ch));
+chips/rt3290.c:	const TX_POWER_TUNING_ENTRY_STRUCT *TxPowerTuningTable = pAd->chipCap.TxPowerTuningTable_2G;
+chips/rt3290.c:	if (pAd->TxPowerCtrl.bInternalTxALC == TRUE)
+chips/rt3290.c:		if ((pAd->Mlme.OneSecPeriodicRound % 4 == 0) && (*pDeltaPowerByBbpR1 == 0))
+chips/rt3290.c:				RFValue = ((RFValue & ~0x3F) | pAd->TxPowerCtrl.RF_TX_ALC);
+chips/rt3290.c:				TotalDeltaPower += pAd->TxPowerCtrl.MAC_PowerDelta;
+chips/rt3290.c:					pAd->TxPowerCtrl.idxTxPowerTable++;
+chips/rt3290.c:					pAd->TxPowerCtrl.idxTxPowerTable--;
+chips/rt3290.c:				TuningTableIndex = pAd->TxPowerCtrl.idxTxPowerTable
+chips/rt3290.c:									+ pAd->TxPower[pAd->CommonCfg.CentralChannel-1].Power;
+chips/rt3290.c:									+ pAd->TxPower[pAd->CommonCfg.Channel-1].Power;
+chips/rt3290.c:				/* Valide pAd->TxPowerCtrl.idxTxPowerTable: -30 ~ 69 */
+chips/rt3290.c:				pAd->TxPowerCtrl.RF_TX_ALC = pTxPowerTuningEntry->RF_TX_ALC;
+chips/rt3290.c:				pAd->TxPowerCtrl.MAC_PowerDelta = pTxPowerTuningEntry->MAC_PowerDelta;
+chips/rt3290.c:				RFValue = ((RFValue & ~0x3F) | pAd->TxPowerCtrl.RF_TX_ALC);
+chips/rt3290.c:				TotalDeltaPower += pAd->TxPowerCtrl.MAC_PowerDelta;
+chips/rt3290.c:					pAd->TxPowerCtrl.idxTxPowerTable, 
+chips/rt3290.c:			RFValue = ((RFValue & ~0x3F) | pAd->TxPowerCtrl.RF_TX_ALC);
+chips/rt3290.c:			TotalDeltaPower += pAd->TxPowerCtrl.MAC_PowerDelta;
+chips/rt3290.c:	if (!(pAd->TxPowerCtrl.bInternalTxALC))
+chips/rt3290.c:	RFValue = ((RFValue & 0xF0) | pAd->TssiGain); /* [3:0] = (tssi_gain and tssi_atten) */
+chips/rt3290.c:	NdisZeroMemory(&pAd->ate, sizeof(struct _ATE_INFO));
+chips/rt3290.c:	pAd->ate.TxCount = 100;
+chips/rt3290.c:	pAd->ate.TxLength = 1024;
+chips/rt3290.c:	 pAd->ate.Channel = 1;
+chips/rt3290.c:	COPY_MAC_ADDR(pAd->ate.Addr1, BROADCAST_ADDR);
+chips/rt3290.c:	COPY_MAC_ADDR(pAd->ate.Addr2, pAd->PermanentAddress);                                                     
+chips/rt3290.c:	COPY_MAC_ADDR(pAd->ate.Addr3, BSSID_ADDR);    
+chips/rt3290.c:	pAd->ate.TxPower0 = inputDAC;
+chips/rt3290.c:     	DBGPRINT(RT_DEBUG_TRACE, ("(Calibrated) Tx.Power0= 0x%x\n", pAd->ate.TxPower0));
+chips/rt3290.c:	pAd->ate.RFFreqOffset = (UCHAR) (EEPData & 0xff);
+chips/rt3290.c:	if (pAd->bUseEfuse)
+chips/rt3290.c:		if (pAd->bFroceEEPROMBuffer)
+chips/rt3290.c:			NdisMoveMemory(&(pAd->EEPROMImage[EEPROM_TSSI_OVER_OFDM_54]), (PUCHAR)(&EEPData) ,2);
+chips/rt3290.c:	NdisZeroMemory(&pAd->ate, sizeof(ATE_INFO));
+chips/rt3290.c:	pAd->ate.TxCount = 100;
+chips/rt3290.c:	pAd->ate.TxLength = 1024;
+chips/rt3290.c:	pAd->ate.Channel = Channel;
+chips/rt3290.c:	COPY_MAC_ADDR(pAd->ate.Addr1, BROADCAST_ADDR);
+chips/rt3290.c:	COPY_MAC_ADDR(pAd->ate.Addr2, pAd->PermanentAddress);                                                     
+chips/rt3290.c:	COPY_MAC_ADDR(pAd->ate.Addr3, BSSID_ADDR);    		
+chips/rt3290.c:	pAd->ate.TxPower0 = (UCHAR)(ChannelPower & 0xff);
+chips/rt3290.c:	DBGPRINT(RT_DEBUG_TRACE, ("Channel %d, Calibrated Tx.Power0= 0x%x\n", Channel, pAd->ate.TxPower0));
+chips/rt3290.c:	pAd->ate.RFFreqOffset = (UCHAR)(EEPData & 0xff);
+chips/rt3290.c:	if ((pAd->TxPowerCtrl.bInternalTxALC) && (pAd->TxPowerCtrl.bExtendedTssiMode)))
+chips/rt3290.c:		RFValue = ((RFValue & 0xF0) | pAd->TssiGain); /* [3:0] = (tssi_gain and tssi_atten) */
+chips/rt3290.c:	pAd->bPCIclkOff = TRUE;
+chips/rt3290.c:	pAd->Mlme.CaliBW20RfR24 = 0x1F;
+chips/rt3290.c:	pAd->Mlme.CaliBW40RfR24 = 0x2F; /* Bit[5] must be 1 for BW 40 */
+chips/rt3290.c:	if ((pAd->bPCIclkOff == FALSE) && 
+chips/rt3290.c:		(((pAd->CmbCtrl.field.AUX_OPT_Bit15_Two_AntennaMode == TRUE) && 
+chips/rt3290.c:		   (pAd->NicConfig2.field.AntDiversity == TRUE))
+chips/rt3290.c:		   || (pAd->NicConfig2.field.AntOpt == 1)))
+chips/rt3290.c:		RTMP_SEM_LOCK(&pAd->WlanEnLock);
+chips/rt3290.c:			pAd->WlanFunCtrl.word = WlanFunCtrl.word;	
+chips/rt3290.c:		RTMP_SEM_UNLOCK(&pAd->WlanEnLock);
+chips/rt3290.c:	snprintf((PSTRING) pAd->nickname, sizeof(pAd->nickname), "RT3290STA");
+chips/rt3290.c:		if (pAd->WlanBTCoexInfo.coexSettingRunning == FALSE)
+chips/rt3290.c:		(pAd->CommonCfg.BBPCurrentBW == BW_20) &&
+chips/rt3290.c:		((pAd->CommonCfg.Channel == 13) || (pAd->CommonCfg.Channel == 14)) &&
+chips/rt3290.c:		if (Channel == pAd->TxPower[index].Channel)
+chips/rt3290.c:			TxPwer = pAd->TxPower[index].Power;
+chips/rt3290.c:			TxPwer2 = pAd->TxPower[index].Power2;
+chips/rt3290.c:				Tx0FinePowerCtrl = pAd->TxPower[index].Tx0FinePowerCtrl;
+chips/rt3290.c:				Tx1FinePowerCtrl = pAd->TxPower[index].Tx1FinePowerCtrl;
+chips/rt3290.c:			if (pAd->FreqCalibrationCtrl.bEnableFrequencyCalibration == TRUE && INFRA_ON(pAd))
+chips/rt3290.c:				Value = ((Value & ~0x7F) | (pAd->FreqCalibrationCtrl.AdaptiveFreqOffset & 0x7F)); // xo_code (C1 value control) - Crystal calibration
+chips/rt3290.c:				Value = ((Value & ~0x7F) | (pAd->RfFreqOffset & 0x7F)); // xo_code (C1 value control) - Crystal calibration
+chips/rt3290.c:			if ((!bScan) && (pAd->CommonCfg.BBPCurrentBW == BW_40))
+chips/rt3290.c:				TxRxh20M = ((pAd->Mlme.CaliBW40RfR24 & 0x20) >> 5);
+chips/rt3290.c:				TxRxh20M = ((pAd->Mlme.CaliBW20RfR24 & 0x20) >> 5);
+chips/rt3290.c:			pAd->LatchRfRegs.Channel = Channel;
+chips/rt3290.c:				__FUNCTION__, Channel, pAd->RfIcType, 
+chips/rt3290.c:				TxPwer, TxPwer2, pAd->Antenna.field.TxPath, 
+chips/rt3290.c:		if (pAd->Antenna.field.TxPath == 1)
+chips/rt3290.c:		if (pAd->Antenna.field.RxPath == 1)
+chips/rt3290.c:				EnterIdle, pAd->bPCIclkOff));
+chips/rt3290.c:	if (pAd->BbpWriteLatch[BBP_R65] != 0x2c)
+chips/rt3290.c:	if (pAd->BbpWriteLatch[BBP_R67] != 0x20)
+chips/rt3290.c:	pAd->WlanBTCoexInfo.ampduOff = FALSE;
+chips/rt3290.c:	if (pAd->BbpWriteLatch[BBP_R65] != 0x2c)
+chips/rt3290.c:	//pAd->CommonCfg.BaLimit = 14;
+chips/rt3290.c:	pAd->WlanBTCoexInfo.ampduOff = FALSE;
+chips/rt3290.c:	pAd->WlanBTCoexInfo.alc = Value;
+chips/rt3290.c:	RTMP_SEM_LOCK(&pAd->WlanEnLock);
+chips/rt3290.c:				bOn, pAd->bPCIclkOff, pAd->WlanFunCtrl.word));
+chips/rt3290.c:	RTMP_IO_FORCE_READ32(pAd, WLAN_FUN_CTRL, &pAd->WlanFunCtrl.word);
+chips/rt3290.c:		pAd->WlanFunCtrl.field.GPIO0_OUT_OE_N = 0xFF;
+chips/rt3290.c:		pAd->WlanFunCtrl.field.FRC_WL_ANT_SET = TRUE;
+chips/rt3290.c:				("==> RTMPWlan %d, bPCIclkOff = %d, pAd->WlanFunCtrl.word = 0x%x\n",
+chips/rt3290.c:				bOn, pAd->bPCIclkOff, pAd->WlanFunCtrl.word));
+chips/rt3290.c:	WlanFunCtrl.word = pAd->WlanFunCtrl.word;
+chips/rt3290.c:			RTMP_SEM_UNLOCK(&pAd->WlanEnLock);
+chips/rt3290.c:				pAd->bPCIclkOff));			
+chips/rt3290.c:			RTMP_SEM_UNLOCK(&pAd->WlanEnLock);
+chips/rt3290.c:		bOn, pAd->bPCIclkOff, WlanFunCtrl.word));
+chips/rt3290.c:	pAd->WlanFunCtrl.word = WlanFunCtrl.word;
+chips/rt3290.c:			pAd->WlanFunCtrl.field.PCIE_APP0_CLK_REQ = 0;
+chips/rt3290.c:			pAd->WlanFunCtrl.field.WLAN_CLK_EN = 1;
+chips/rt3290.c:				RTMP_IO_FORCE_WRITE32(pAd, WLAN_FUN_CTRL, pAd->WlanFunCtrl.word | 0x8);	
+chips/rt3290.c:				pAd->WlanFunCtrl.word &= (~0x8);
+chips/rt3290.c:				RTMP_IO_FORCE_WRITE32(pAd, WLAN_FUN_CTRL, pAd->WlanFunCtrl.word);		
+chips/rt3290.c:				RTMP_IO_FORCE_WRITE32(pAd, WLAN_FUN_CTRL, pAd->WlanFunCtrl.word);
+chips/rt3290.c:	RTMP_SEM_UNLOCK(&pAd->WlanEnLock);
+chips/rt3290.c:		("<== RTMPWlan %d  bPCIclkOff = %d pAd->WlanFunCtrl.word = 0x%x\n",
+chips/rt3290.c:		bOn, pAd->bPCIclkOff, pAd->WlanFunCtrl.word));
+chips/rt3290.c:	RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
+chips/rt3290.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+chips/rt3290.c:	pAd->chipCap.carrier_func = TONE_RADAR_V2;
+chips/rtmp_chip.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+chips/rtmp_chip.c:	pAd->chipOps.BeaconUpdate = RtmpChipWriteMemory;
+chips/rtmp_chip.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+chips/rtmp_chip.c:	//pAd->NullBufOffset[0] = 0xd000;
+chips/rtmp_chip.c:	pAd->NullBufOffset[0] = 0xd000;
+chips/rtmp_chip.c:	pAd->NullBufOffset[1] = 0xd200;
+chips/rtmp_chip.c:	pAd->chipOps.BeaconUpdate = RtmpChipWriteMemory;
+chips/rtmp_chip.c:	if(pAd->CommonCfg.Channel>14)
+chips/rtmp_chip.c:	pAd->ApCfg.bGreenAPActive=TRUE;
+chips/rtmp_chip.c:	CentralChannel = pAd->CommonCfg.CentralChannel;
+chips/rtmp_chip.c:	pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
+chips/rtmp_chip.c:	CentralChannel = pAd->CommonCfg.Channel;
+chips/rtmp_chip.c:	if (pAd->Antenna.field.RxPath>1||pAd->Antenna.field.TxPath>1)
+chips/rtmp_chip.c:	if(pAd->CommonCfg.Channel>14)
+chips/rtmp_chip.c:	if (pAd->Antenna.field.TxPath == 1)
+chips/rtmp_chip.c:	if (pAd->Antenna.field.RxPath == 1)
+chips/rtmp_chip.c:	pAd->ApCfg.bGreenAPActive=FALSE;
+chips/rtmp_chip.c:	if ((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth == BW_40) && (pAd->CommonCfg.Channel != 14))
+chips/rtmp_chip.c:		if (pAd->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_ABOVE)
+chips/rtmp_chip.c:			pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel + 2;
+chips/rtmp_chip.c:		else if ((pAd->CommonCfg.Channel > 2) && (pAd->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_BELOW))
+chips/rtmp_chip.c:			pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel - 2;
+chips/rtmp_chip.c:		CentralChannel = pAd->CommonCfg.CentralChannel;
+chips/rtmp_chip.c:	if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) && (pAd->Antenna.field.TxPath == 2))
+chips/rtmp_chip.c:	rtmp_bbp_set_rxpath(pAd, pAd->Antenna.field.RxPath);
+chips/rtmp_chip.c:	if (pAd->LatchRfRegs.Channel <= 14)
+chips/rtmp_chip.c:		if (pAd->CommonCfg.BBPCurrentBW == BW_20)
+chips/rtmp_chip.c:		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
+chips/rtmp_chip.c:		bbp_val = (pAd->CommonCfg.Channel > 14) ? 0x48 : 0x38;
+chips/rtmp_chip.c:		bbp_val = (pAd->CommonCfg.Channel > 14) ? 0x40 : 0x38;
+chips/rtmp_chip.c:	if (pAd->MACVersion == 0x28600100)
+chips/rtmp_chip.c:					pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth, 
+chips/rtmp_chip.c:					pAd->CommonCfg.Channel, 
+chips/rtmp_chip.c:					pAd->CommonCfg.RegTransmitSetting.field.EXTCHA,
+chips/rtmp_chip.c:					pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset));
+chips/rtmp_chip.c:	if (pAd->CommonCfg.Channel > 14)
+chips/rtmp_chip.c:	if (pAd->LatchRfRegs.Channel <= 14)
+chips/rtmp_chip.c:		snprintf((PSTRING) pAd->nickname, sizeof(pAd->nickname), "RT2870STA");
+chips/rtmp_chip.c:		if (pAd->FixDefaultAntenna == 0)
+chips/rtmp_chip.c:		RTMP_IO_READ32(pAd, reg, &pAd->MACVersion);
+chips/rtmp_chip.c:					pAd->MACVersion));
+chips/rtmp_chip.c:	RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
+chips/rtmp_chip.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+chips/rtmp_chip.c:	pAd->MACVersion = MacValue;	
+common/rtusb_io.c:	pAd->VendorResetFlag = TRUE;
+common/rtusb_io.c:	pAd->VendorResetFlag = FALSE;
+common/rtusb_io.c:	RTMP_SEM_EVENT_WAIT(&pAd->reg_atomic, ret);
+common/rtusb_io.c:	RTMP_SEM_EVENT_UP(&pAd->reg_atomic);
+common/rtusb_io.c:		*pValue = pAd->BbpWriteLatch[Id];
+common/rtusb_io.c:	RTMP_SEM_EVENT_WAIT(&pAd->reg_atomic, ret);
+common/rtusb_io.c:		pAd->BbpWriteLatch[Id] = Value;
+common/rtusb_io.c:	RTMP_SEM_EVENT_UP(&pAd->reg_atomic);
+common/rtusb_io.c:	RTMP_SEM_EVENT_WAIT(&pAd->reg_atomic, status);
+common/rtusb_io.c:	RTMP_SEM_EVENT_UP(&pAd->reg_atomic);
+common/rtusb_io.c:	RTMP_OS_TASK	*pTask = &pAd->cmdQTask;
+common/rtusb_io.c:	NdisAcquireSpinLock(&pAd->CmdQLock);
+common/rtusb_io.c:	if (pAd->CmdQ.CmdQState & RTMP_TASK_CAN_DO_INSERT)
+common/rtusb_io.c:		EnqueueCmd((&pAd->CmdQ), cmdqelmt);
+common/rtusb_io.c:	NdisReleaseSpinLock(&pAd->CmdQLock);
+common/rtusb_io.c:	RTCMDUp(&pAd->cmdQTask);
+common/rtusb_io.c:	POS_COOKIE		pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/rtusb_io.c:		RTMP_SEM_EVENT_WAIT(&(pAd->UsbVendorReq_semaphore), RET);
+common/rtusb_io.c:			NdisMoveMemory(pAd->UsbVendorReqBuf, TransferBuffer, TransferBufferLength);
+common/rtusb_io.c:				RTUSB_CONTROL_MSG(pObj->pUsb_Dev, 0, Request, RequestType, Value, Index, pAd->UsbVendorReqBuf, TransferBufferLength, CONTROL_TIMEOUT_JIFFIES, RET);
+common/rtusb_io.c:			if (RET < 0 && !pAd->VendorResetFlag) {
+common/rtusb_io.c:		} while((RET < 0 && !pAd->VendorResetFlag) && (RetryCount < MAX_VENDOR_REQ_RETRY_COUNT));
+common/rtusb_io.c:			NdisMoveMemory(TransferBuffer, pAd->UsbVendorReqBuf, TransferBufferLength);
+common/rtusb_io.c:	  	RTMP_SEM_EVENT_UP(&(pAd->UsbVendorReq_semaphore));
+common/rtusb_io.c:			DBGPRINT(RT_DEBUG_ERROR, ("RTUSB_VendorRequest failed(%d),TxFlags=0x%x, ReqType=%s, Req=0x%x, Idx=0x%x,pAd->Flags=0x%lx\n",
+common/rtusb_io.c:						RET, TransferFlags, (RequestType == DEVICE_VENDOR_REQUEST_OUT ? "OUT" : "IN"), Request, Index, pAd->Flags));
+common/rtusb_io.c:				pAd->StaCfg.bHwRadio = TRUE;
+common/rtusb_io.c:				pAd->StaCfg.bHwRadio = FALSE;
+common/rtusb_io.c:			if (pAd->StaCfg.bRadio != (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio))
+common/rtusb_io.c:				pAd->StaCfg.bRadio = (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio);
+common/rtusb_io.c:				if (pAd->StaCfg.bRadio == TRUE)
+common/rtusb_io.c:					pAd->ExtraInfo = EXTRA_INFO_CLEAR;
+common/rtusb_io.c:					pAd->ExtraInfo = HW_RADIO_OFF;
+common/rtusb_io.c:	DBGPRINT(RT_DEBUG_TRACE, ("CMDTHREAD_RESET_BULK_OUT(ResetPipeid=0x%0x)===>\n", pAd->bulkResetPipeid));
+common/rtusb_io.c:	if ((pAd->bulkResetPipeid & BULKOUT_MGMT_RESET_FLAG) == BULKOUT_MGMT_RESET_FLAG)
+common/rtusb_io.c:		if (pAd->MgmtRing.TxSwFreeIdx < MGMT_RING_SIZE /* pMLMEContext->bWaitingBulkOut == TRUE */)
+common/rtusb_io.c:		pHTTXContext = &(pAd->TxContext[pAd->bulkResetPipeid]);
+common/rtusb_io.c:		/*NdisAcquireSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]);*/
+common/rtusb_io.c:		RTMP_INT_LOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
+common/rtusb_io.c:		if ( pAd->BulkOutPending[pAd->bulkResetPipeid] == FALSE)
+common/rtusb_io.c:			pAd->BulkOutPending[pAd->bulkResetPipeid] = TRUE;
+common/rtusb_io.c:			pAd->watchDogTxPendingCnt[pAd->bulkResetPipeid] = 1;
+common/rtusb_io.c:			/*NdisReleaseSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]);*/
+common/rtusb_io.c:			RTMP_INT_UNLOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
+common/rtusb_io.c:				RTUSBInitHTTxDesc(pAd, pHTTXContext, pAd->bulkResetPipeid,
+common/rtusb_io.c:						RTMP_INT_LOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
+common/rtusb_io.c:						pAd->BulkOutPending[pAd->bulkResetPipeid] = FALSE;
+common/rtusb_io.c:						pAd->watchDogTxPendingCnt[pAd->bulkResetPipeid] = 0;
+common/rtusb_io.c:						RTMP_INT_UNLOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
+common/rtusb_io.c:						RTMP_INT_LOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
+common/rtusb_io.c:											pAd->bulkResetPipeid, pHTTXContext->CurWritePosition, pHTTXContext->NextBulkOutPosition,
+common/rtusb_io.c:											pAd->BulkOutPending[pAd->bulkResetPipeid]));
+common/rtusb_io.c:											pAd->BulkOutReq, pAd->BulkOutComplete, pAd->BulkOutCompleteOther));
+common/rtusb_io.c:						RTMP_INT_UNLOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
+common/rtusb_io.c:											pAd->bulkResetReq[pAd->bulkResetPipeid],
+common/rtusb_io.c:			/*NdisReleaseSpinLock(&pAd->BulkOutLock[pAd->bulkResetPipeid]);*/
+common/rtusb_io.c:			/*RTMP_INT_UNLOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);*/
+common/rtusb_io.c:								pAd->bulkResetReq[pAd->bulkResetPipeid], pAd->bulkResetPipeid));
+common/rtusb_io.c:			if (pAd->bulkResetPipeid == 0)
+common/rtusb_io.c:				PHT_TX_CONTEXT pHTTXContext = (PHT_TX_CONTEXT)(&pAd->TxContext[pAd->bulkResetPipeid ]);
+common/rtusb_io.c:				PTX_CONTEXT pMLMEContext = (PTX_CONTEXT)(pAd->MgmtRing.Cell[pAd->MgmtRing.TxDmaIdx].AllocVa);
+common/rtusb_io.c:				PTX_CONTEXT pNULLContext = (PTX_CONTEXT)(&pAd->PsPollContext);
+common/rtusb_io.c:				PTX_CONTEXT pPsPollContext = (PTX_CONTEXT)(&pAd->NullContext);
+common/rtusb_io.c:			RTMP_INT_UNLOCK(&pAd->BulkOutLock[pAd->bulkResetPipeid], IrqFlags);
+common/rtusb_io.c:			RTUSB_SET_BULK_FLAG(pAd, (fRTUSB_BULK_OUT_DATA_NORMAL << pAd->bulkResetPipeid));
+common/rtusb_io.c:		/*while ((atomic_read(&pAd->PendingRx) > 0) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))) */
+common/rtusb_io.c:		if((pAd->PendingRx > 0) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+common/rtusb_io.c:			pAd->PendingRx = 0;
+common/rtusb_io.c:		pAd->NextRxBulkInPosition = pAd->RxContext[pAd->NextRxBulkInIndex].BulkInOffset;
+common/rtusb_io.c:					pAd->NextRxBulkInIndex,  pAd->NextRxBulkInReadIndex, pAd->NextRxBulkInPosition, pAd->BulkInReq, pAd->BulkInComplete, pAd->BulkInCompleteFail));
+common/rtusb_io.c:							, i, pAd->RxContext[i].IRPPending, pAd->RxContext[i].InUse, pAd->RxContext[i].Readable));
+common/rtusb_io.c:		for (i = 0; i < pAd->CommonCfg.NumOfBulkInIRP; i++)
+common/rtusb_io.c:			RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
+common/rtusb_io.c:			pRxContext = &(pAd->RxContext[pAd->NextRxBulkInIndex]);
+common/rtusb_io.c:			if ((pAd->PendingRx > 0) || (pRxContext->Readable == TRUE) || (pRxContext->InUse == TRUE))
+common/rtusb_io.c:				RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
+common/rtusb_io.c:			pAd->PendingRx++;
+common/rtusb_io.c:			pAd->BulkInReq++;
+common/rtusb_io.c:			RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
+common/rtusb_io.c:				RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
+common/rtusb_io.c:				pAd->PendingRx--;
+common/rtusb_io.c:				pAd->BulkInReq--;
+common/rtusb_io.c:				RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
+common/rtusb_io.c:				/*							pAd->PendingRx, pAd->NextRxBulkInIndex, pAd->NextRxBulkInReadIndex));*/
+common/rtusb_io.c:			DBGPRINT_RAW(RT_DEBUG_ERROR, ("CMDTHREAD_RESET_BULK_IN: Cannot do bulk in because flags(0x%lx) on !\n", pAd->Flags));
+common/rtusb_io.c:	MACValue = (pAd->MacTab.Content[SetAsicWcid.WCID].Addr[3]<<24)+(pAd->MacTab.Content[SetAsicWcid.WCID].Addr[2]<<16)+(pAd->MacTab.Content[SetAsicWcid.WCID].Addr[1]<<8)+(pAd->MacTab.Content[SetAsicWcid.WCID].Addr[0]);
+common/rtusb_io.c:	MACValue = (pAd->MacTab.Content[SetAsicWcid.WCID].Addr[5]<<8)+pAd->MacTab.Content[SetAsicWcid.WCID].Addr[4];
+common/rtusb_io.c:	USHORT  NextDtim = pAd->StaCfg.DtimPeriod;
+common/rtusb_io.c:	NextDtim -= (USHORT)(Now - pAd->StaCfg.LastBeaconRxTime)/pAd->CommonCfg.BeaconPeriod;
+common/rtusb_io.c:	TbttNumToNextWakeUp = pAd->StaCfg.DefaultListenCount;
+common/rtusb_io.c:	pAd->CommonCfg.Channel = AP_AUTO_CH_SEL(pAd, TRUE);
+common/rtusb_io.c:	DBGPRINT(RT_DEBUG_TRACE, ("cmd> Switch to %d! \n", pAd->CommonCfg.Channel));
+common/rtusb_io.c:								pAd->MlmeAux.Bssid,
+common/rtusb_io.c:								/*pAd->MacTab.Content[BSSID_WCID].RSN_IE, pAd->MacTab.Content[BSSID_WCID].RSNIE_Len,*/
+common/rtusb_io.c:								pAd->StaCfg.ReqVarIEs, pAd->StaCfg.ReqVarIELen,
+common/rtusb_io.c:	while (pAd && pAd->CmdQ.size > 0)
+common/rtusb_io.c:		NdisAcquireSpinLock(&pAd->CmdQLock);
+common/rtusb_io.c:		RTThreadDequeueCmd(&pAd->CmdQ, &cmdqelmt);
+common/rtusb_io.c:		NdisReleaseSpinLock(&pAd->CmdQLock);
+common/rtusb_io.c:	if (pAd->watchDogRxOverFlowCnt >= 2)
+common/rtusb_io.c:		pAd->watchDogRxOverFlowCnt = 0;
+common/rtusb_io.c:		RTMP_IRQ_LOCK(&pAd->BulkOutLock[idx], irqFlags);
+common/rtusb_io.c:/*		if ((pAd->BulkOutPending[idx] == TRUE) && pAd->watchDogTxPendingCnt)*/
+common/rtusb_io.c:		if (pAd->BulkOutPending[idx] == TRUE)
+common/rtusb_io.c:			pAd->watchDogTxPendingCnt[idx]++;
+common/rtusb_io.c:			if ((pAd->watchDogTxPendingCnt[idx] > 2) &&
+common/rtusb_io.c:				pHTTXContext = (PHT_TX_CONTEXT)(&pAd->TxContext[idx]);
+common/rtusb_io.c:					pMLMEContext = (PTX_CONTEXT)(pAd->MgmtRing.Cell[pAd->MgmtRing.TxDmaIdx].AllocVa);
+common/rtusb_io.c:					pPsPollContext = (PTX_CONTEXT)(&pAd->PsPollContext);
+common/rtusb_io.c:					pNULLContext = (PTX_CONTEXT)(&pAd->NullContext);
+common/rtusb_io.c:				RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[idx], irqFlags);
+common/rtusb_io.c:				RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[idx], irqFlags);
+common/rtusb_io.c:			RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[idx], irqFlags);
+common/rtusb_io.c:	if((needDumpSeq == TRUE) && (pAd->CommonCfg.bDisableReordering == 0))
+common/rtusb_io.c:		Idx = pAd->MacTab.Content[BSSID_WCID].BARecWcidArray[0];
+common/rtusb_io.c:		pBAEntry = &pAd->BATable.BARecEntry[Idx];
+common/rtmp_init.c:			initList(&pAd->RscTimerMemList);
+common/rtmp_init.c:			initList(&pAd->RscTaskMemList);
+common/rtmp_init.c:			initList(&pAd->RscLockMemList);
+common/rtmp_init.c:			initList(&pAd->RscTaskletMemList);
+common/rtmp_init.c:			initList(&pAd->RscSemMemList);
+common/rtmp_init.c:			initList(&pAd->RscAtomicMemList);
+common/rtmp_init.c:			initList(&pAd->RscTimerCreateList);
+common/rtmp_init.c:			pAd->OS_Cookie = handle;
+common/rtmp_init.c:		pAd->BeaconBuf = pBeaconBuf;
+common/rtmp_init.c:		if (RtmpOsStatsAlloc(&pAd->stats, &pAd->iw_stats) == FALSE)
+common/rtmp_init.c:		NdisAllocateSpinLock(pAd, &pAd->MgmtRingLock);
+common/rtmp_init.c:			NdisAllocateSpinLock(pAd, &pAd->TxSwQueueLock[index]);
+common/rtmp_init.c:			NdisAllocateSpinLock(pAd, &pAd->DeQueueLock[index]);
+common/rtmp_init.c:			pAd->DeQueueRunning[index] = FALSE;
+common/rtmp_init.c:		NdisAllocateSpinLock(pAd, &pAd->irq_lock);
+common/rtmp_init.c:		RTMP_OS_ATMOIC_INIT(&pAd->BulkOutRemained, &pAd->RscAtomicMemList);
+common/rtmp_init.c:		RTMP_OS_ATMOIC_INIT(&pAd->BulkInRemained, &pAd->RscAtomicMemList);
+common/rtmp_init.c:		if (pAd->stats != NULL)
+common/rtmp_init.c:			os_free_mem(NULL, pAd->stats);
+common/rtmp_init.c:		if (pAd->iw_stats != NULL)
+common/rtmp_init.c:			os_free_mem(NULL, pAd->iw_stats);
+common/rtmp_init.c:		if (os_alloc_mem(pAd,&pAd->ProbeRespIE[index].pIe, MAX_VIE_LEN) == NDIS_STATUS_SUCCESS)
+common/rtmp_init.c:			RTMPZeroMemory(pAd->ProbeRespIE[index].pIe, MAX_VIE_LEN);
+common/rtmp_init.c:			pAd->ProbeRespIE[index].pIe = NULL;
+common/rtmp_init.c:	if (pAd->chipOps.eeinit)
+common/rtmp_init.c:		pAd->chipOps.eeinit(pAd);
+common/rtmp_init.c:		if(!pAd->bFroceEEPROMBuffer && pAd->bEEPROMFile)
+common/rtmp_init.c:	pAd->PermanentAddress[0] = (UCHAR)(Addr01 & 0xff);
+common/rtmp_init.c:	pAd->PermanentAddress[1] = (UCHAR)(Addr01 >> 8);
+common/rtmp_init.c:	pAd->PermanentAddress[2] = (UCHAR)(Addr23 & 0xff);
+common/rtmp_init.c:	pAd->PermanentAddress[3] = (UCHAR)(Addr23 >> 8);
+common/rtmp_init.c:	pAd->PermanentAddress[4] = (UCHAR)(Addr45 & 0xff);
+common/rtmp_init.c:	pAd->PermanentAddress[5] = (UCHAR)(Addr45 >> 8);
+common/rtmp_init.c:	if (pAd->PermanentAddress[0] == 0xff)
+common/rtmp_init.c:		pAd->PermanentAddress[0] = RandomByte(pAd)&0xf8;
+common/rtmp_init.c:								PRINT_MAC(pAd->PermanentAddress)));
+common/rtmp_init.c:	if (pAd->bLocalAdminMAC)
+common/rtmp_init.c:			AtoH(macptr, &pAd->CurrentAddress[j], 1);
+common/rtmp_init.c:		COPY_MAC_ADDR(pAd->CurrentAddress, pAd->PermanentAddress);
+common/rtmp_init.c:	csr2.field.Byte0 = pAd->CurrentAddress[0];
+common/rtmp_init.c:	csr2.field.Byte1 = pAd->CurrentAddress[1];
+common/rtmp_init.c:	csr2.field.Byte2 = pAd->CurrentAddress[2];
+common/rtmp_init.c:	csr2.field.Byte3 = pAd->CurrentAddress[3];
+common/rtmp_init.c:	csr3.field.Byte4 = pAd->CurrentAddress[4];
+common/rtmp_init.c:	if ((pAd->CurrentAddress[5] & 0x01) == 0x01)
+common/rtmp_init.c:		csr3.field.Byte5 = pAd->CurrentAddress[5] - 1;
+common/rtmp_init.c:		csr3.field.Byte5 = pAd->CurrentAddress[5];
+common/rtmp_init.c:					PRINT_MAC(pAd->CurrentAddress)));
+common/rtmp_init.c:	pAd->EepromVersion = Version.field.Version + Version.field.FaeReleaseNumber * 256;
+common/rtmp_init.c:	pAd->EEPROMDefaultValue[EEPROM_NIC_CFG1_OFFSET] = value;
+common/rtmp_init.c:	pAd->EEPROMDefaultValue[EEPROM_NIC_CFG2_OFFSET] = value;
+common/rtmp_init.c:		pAd->EEPROMDefaultValue[EEPROM_COUNTRY_REG_OFFSET] = value;
+common/rtmp_init.c:	pAd->EEPROMDefaultValue[EEPROM_NIC_CFG3_OFFSET] = value;
+common/rtmp_init.c:	pAd->NicConfig3.word = pAd->EEPROMDefaultValue[EEPROM_NIC_CFG3_OFFSET];
+common/rtmp_init.c:		pAd->EEPROMDefaultValue[i+EEPROM_BBP_ARRAY_OFFSET] = value;
+common/rtmp_init.c:	Antenna.word = pAd->EEPROMDefaultValue[EEPROM_NIC_CFG1_OFFSET];
+common/rtmp_init.c:		pAd->chipCap.bTxRxSwAntDiv = TRUE;		/* for GPIO switch */
+common/rtmp_init.c:					Antenna.word, Antenna.field.BoardType, pAd->NicConfig2.field.AntDiversity));
+common/rtmp_init.c:	if ((pAd->CommonCfg.TxStream == 0) || (pAd->CommonCfg.TxStream > Antenna.field.TxPath))
+common/rtmp_init.c:		pAd->CommonCfg.TxStream = Antenna.field.TxPath;
+common/rtmp_init.c:	if ((pAd->CommonCfg.RxStream == 0) || (pAd->CommonCfg.RxStream > Antenna.field.RxPath))
+common/rtmp_init.c:		pAd->CommonCfg.RxStream = Antenna.field.RxPath;
+common/rtmp_init.c:		if ((pAd->MACVersion != RALINK_3883_VERSION) &&
+common/rtmp_init.c:			(pAd->MACVersion != RALINK_2883_VERSION) &&
+common/rtmp_init.c:			(pAd->CommonCfg.RxStream > 2))
+common/rtmp_init.c:			pAd->CommonCfg.RxStream = 2;
+common/rtmp_init.c:	NicConfig2.word = pAd->EEPROMDefaultValue[EEPROM_NIC_CFG2_OFFSET];
+common/rtmp_init.c:	if ((pAd->MACVersion == 0x28600100) || (pAd->MACVersion == 0x28700100))
+common/rtmp_init.c:		pAd->bAutoTxAgcA = pAd->bAutoTxAgcG = TRUE;
+common/rtmp_init.c:		pAd->bAutoTxAgcA = pAd->bAutoTxAgcG = FALSE;
+common/rtmp_init.c:	pAd->NicConfig2.word = NicConfig2.word;
+common/rtmp_init.c:	pAd->Antenna.word = Antenna.word;
+common/rtmp_init.c:	pAd->Mlme.RealRxPath = (UCHAR) Antenna.field.RxPath;
+common/rtmp_init.c:	pAd->RfIcType = (UCHAR) Antenna.field.RfIcType;
+common/rtmp_init.c:		pAd->Mlme.RealRxPath = 2;
+common/rtmp_init.c:		pAd->RfIcType = RFIC_UNKNOWN;
+common/rtmp_init.c:		pAd->Mlme.RealRxPath = 1;
+common/rtmp_init.c:		pAd->RfIcType = RFIC_UNKNOWN;
+common/rtmp_init.c:	if (WMODE_CAP_5G(pAd->CommonCfg.PhyMode))
+common/rtmp_init.c:						__FUNCTION__, pAd->RfIcType));
+common/rtmp_init.c:			pAd->RFICType = RFIC_24GHZ;
+common/rtmp_init.c:		pAd->RFICType = RFIC_24GHZ | RFIC_5GHZ;
+common/rtmp_init.c:		pAd->RFICType = RFIC_24GHZ;
+common/rtmp_init.c:			pAd->TssiMinusBoundaryG[4] = Power.field.Byte0;
+common/rtmp_init.c:			pAd->TssiMinusBoundaryG[3] = Power.field.Byte1;
+common/rtmp_init.c:			pAd->TssiMinusBoundaryG[2] = Power.field.Byte0;
+common/rtmp_init.c:			pAd->TssiMinusBoundaryG[1] = Power.field.Byte1;
+common/rtmp_init.c:			pAd->TssiRefG   = Power.field.Byte0; /* reference value [0] */
+common/rtmp_init.c:			pAd->TssiPlusBoundaryG[1] = Power.field.Byte1;
+common/rtmp_init.c:			pAd->TssiPlusBoundaryG[2] = Power.field.Byte0;
+common/rtmp_init.c:			pAd->TssiPlusBoundaryG[3] = Power.field.Byte1;
+common/rtmp_init.c:			pAd->TssiPlusBoundaryG[4] = Power.field.Byte0;
+common/rtmp_init.c:			pAd->TxAgcStepG = Power.field.Byte1;    
+common/rtmp_init.c:			pAd->TxAgcCompensateG = 0;
+common/rtmp_init.c:			pAd->TssiMinusBoundaryG[0] = pAd->TssiRefG;
+common/rtmp_init.c:			pAd->TssiPlusBoundaryG[0]  = pAd->TssiRefG;
+common/rtmp_init.c:			if (pAd->TssiRefG == 0xff)
+common/rtmp_init.c:				pAd->bAutoTxAgcG = FALSE;
+common/rtmp_init.c:			pAd->TssiMinusBoundaryG[4], pAd->TssiMinusBoundaryG[3], pAd->TssiMinusBoundaryG[2], pAd->TssiMinusBoundaryG[1],
+common/rtmp_init.c:			pAd->TssiRefG,
+common/rtmp_init.c:			pAd->TssiPlusBoundaryG[1], pAd->TssiPlusBoundaryG[2], pAd->TssiPlusBoundaryG[3], pAd->TssiPlusBoundaryG[4],
+common/rtmp_init.c:			pAd->TxAgcStepG, pAd->bAutoTxAgcG));
+common/rtmp_init.c:			pAd->TssiMinusBoundaryA[4] = Power.field.Byte0;
+common/rtmp_init.c:			pAd->TssiMinusBoundaryA[3] = Power.field.Byte1;
+common/rtmp_init.c:			pAd->TssiMinusBoundaryA[2] = Power.field.Byte0;
+common/rtmp_init.c:			pAd->TssiMinusBoundaryA[1] = Power.field.Byte1;
+common/rtmp_init.c:			pAd->TssiRefA = Power.field.Byte0;
+common/rtmp_init.c:			pAd->TssiPlusBoundaryA[1] = Power.field.Byte1;
+common/rtmp_init.c:			pAd->TssiPlusBoundaryA[2] = Power.field.Byte0;
+common/rtmp_init.c:			pAd->TssiPlusBoundaryA[3] = Power.field.Byte1;
+common/rtmp_init.c:			pAd->TssiPlusBoundaryA[4] = Power.field.Byte0;
+common/rtmp_init.c:			pAd->TxAgcStepA = Power.field.Byte1;    
+common/rtmp_init.c:			pAd->TxAgcCompensateA = 0;
+common/rtmp_init.c:			pAd->TssiMinusBoundaryA[0] = pAd->TssiRefA;
+common/rtmp_init.c:			pAd->TssiPlusBoundaryA[0]  = pAd->TssiRefA;
+common/rtmp_init.c:			if (pAd->TssiRefA == 0xff)
+common/rtmp_init.c:				pAd->bAutoTxAgcA = FALSE;
+common/rtmp_init.c:			pAd->TssiMinusBoundaryA[4], pAd->TssiMinusBoundaryA[3], pAd->TssiMinusBoundaryA[2], pAd->TssiMinusBoundaryA[1],
+common/rtmp_init.c:			pAd->TssiRefA,
+common/rtmp_init.c:			pAd->TssiPlusBoundaryA[1], pAd->TssiPlusBoundaryA[2], pAd->TssiPlusBoundaryA[3], pAd->TssiPlusBoundaryA[4],
+common/rtmp_init.c:			pAd->TxAgcStepA, pAd->bAutoTxAgcA));
+common/rtmp_init.c:	pAd->BbpRssiToDbmDelta = 0x0;
+common/rtmp_init.c:		pAd->RfFreqOffset = (ULONG) (value & 0x00FF);
+common/rtmp_init.c:		pAd->RfFreqOffset = 0;
+common/rtmp_init.c:	DBGPRINT(RT_DEBUG_TRACE, ("E2PROM: RF FreqOffset=0x%lx \n", pAd->RfFreqOffset));
+common/rtmp_init.c:		value = pAd->EEPROMDefaultValue[EEPROM_COUNTRY_REG_OFFSET] >> 8;		/* 2.4G band*/
+common/rtmp_init.c:		value2 = pAd->EEPROMDefaultValue[EEPROM_COUNTRY_REG_OFFSET] & 0x00FF;	/* 5G band*/
+common/rtmp_init.c:		pAd->CommonCfg.CountryRegion = ((UCHAR) value) | 0x80;
+common/rtmp_init.c:		pAd->CommonCfg.CountryRegionForABand = ((UCHAR) value2) | 0x80;
+common/rtmp_init.c:		pAd->BGRssiOffset[0] = value & 0x00ff;
+common/rtmp_init.c:		pAd->BGRssiOffset[1] = (value >> 8);
+common/rtmp_init.c:			pAd->BGRssiOffset[2] = value & 0x00ff;
+common/rtmp_init.c:		pAd->ALNAGain1 = (value >> 8);
+common/rtmp_init.c:		pAd->BLNAGain = value & 0x00ff;
+common/rtmp_init.c:		pAd->ALNAGain0 = (value >> 8);
+common/rtmp_init.c:		pAd->ARssiOffset[0] = value & 0x00ff;
+common/rtmp_init.c:		pAd->ARssiOffset[1] = (value >> 8);
+common/rtmp_init.c:		pAd->ARssiOffset[2] = value & 0x00ff;
+common/rtmp_init.c:		pAd->ALNAGain2 = (value >> 8);
+common/rtmp_init.c:	if (((UCHAR)pAd->ALNAGain1 == 0xFF) || (pAd->ALNAGain1 == 0x00))
+common/rtmp_init.c:		pAd->ALNAGain1 = pAd->ALNAGain0;
+common/rtmp_init.c:	if (((UCHAR)pAd->ALNAGain2 == 0xFF) || (pAd->ALNAGain2 == 0x00))
+common/rtmp_init.c:		pAd->ALNAGain2 = pAd->ALNAGain0;
+common/rtmp_init.c:		if ((pAd->BGRssiOffset[i] < -10) || (pAd->BGRssiOffset[i] > 10))
+common/rtmp_init.c:			pAd->BGRssiOffset[i] = 0;
+common/rtmp_init.c:		if ((pAd->ARssiOffset[i] < -10) || (pAd->ARssiOffset[i] > 10))
+common/rtmp_init.c:			pAd->ARssiOffset[i] = 0;
+common/rtmp_init.c:		RT28xx_EEPROM_READ16(pAd, EEPROM_DEFINE_MAX_TXPWR, pAd->CommonCfg.DefineMaxTxPwr);
+common/rtmp_init.c:	if (pAd->CommonCfg.ModuleTxpower > 0) 
+common/rtmp_init.c:		pAd->CommonCfg.DefineMaxTxPwr = pAd->CommonCfg.ModuleTxpower;
+common/rtmp_init.c:	DBGPRINT(RT_DEBUG_TRACE, ("TX Power set for SINGLE SKU MODE is : 0x%04x \n", pAd->CommonCfg.DefineMaxTxPwr));
+common/rtmp_init.c:	pAd->CommonCfg.bSKUMode = FALSE;
+common/rtmp_init.c:	if ((pAd->CommonCfg.DefineMaxTxPwr & 0xFF) <= 0x50)
+common/rtmp_init.c:			pAd->CommonCfg.bSKUMode = TRUE;
+common/rtmp_init.c:		else if ((pAd->CommonCfg.AntGain > 0) && (pAd->CommonCfg.BandedgeDelta >= 0))
+common/rtmp_init.c:			pAd->CommonCfg.bSKUMode = TRUE;
+common/rtmp_init.c:				pAd->CommonCfg.bSKUMode ? "Enable" : "Disable"));
+common/rtmp_init.c:		   	pAd->TxPowerCtrl.bInternalTxALC = FALSE;
+common/rtmp_init.c:		   	pAd->TxPowerCtrl.bInternalTxALC = TRUE;
+common/rtmp_init.c:		   	pAd->TxPowerCtrl.bInternalTxALC = FALSE;
+common/rtmp_init.c:	DBGPRINT(RT_DEBUG_TRACE, ("TXALC> bInternalTxALC = %d\n", pAd->TxPowerCtrl.bInternalTxALC));
+common/rtmp_init.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s: pAd->Antenna.field.BoardType = %d, IS_MINI_CARD(pAd) = %d, IS_RT5390U(pAd) = %d\n", 
+common/rtmp_init.c:		pAd->Antenna.field.BoardType,
+common/rtmp_init.c:		if ((pAd->EEPROMDefaultValue[i] != 0xFFFF) && (pAd->EEPROMDefaultValue[i] != 0))
+common/rtmp_init.c:			BbpRegIdx = (UCHAR)(pAd->EEPROMDefaultValue[i] >> 8);
+common/rtmp_init.c:			BbpValue  = (UCHAR)(pAd->EEPROMDefaultValue[i] & 0xff);
+common/rtmp_init.c:	NicConfig2.word = pAd->NicConfig2.word;
+common/rtmp_init.c:	if (pAd->chipOps.AsicRfInit)
+common/rtmp_init.c:		pAd->chipOps.AsicRfInit(pAd);
+common/rtmp_init.c:			pAd->StaCfg.bHardwareRadio = TRUE;
+common/rtmp_init.c:				pAd->StaCfg.bHwRadio = FALSE;
+common/rtmp_init.c:				pAd->StaCfg.bRadio = FALSE;
+common/rtmp_init.c:			pAd->StaCfg.bHardwareRadio = FALSE;
+common/rtmp_init.c:		if (pAd->StaCfg.bRadio == FALSE)
+common/rtmp_init.c:			RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
+common/rtmp_init.c:			&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3) 
+common/rtmp_init.c:			&& (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))
+common/rtmp_init.c:			RTMP_SEM_LOCK(&pAd->McuCmdLock);
+common/rtmp_init.c:			pAd->brt30xxBanMcuCmd = FALSE;
+common/rtmp_init.c:			RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
+common/rtmp_init.c:			RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
+common/rtmp_init.c:/*		pAd->bTest1 = TRUE;*/
+common/rtmp_init.c:		pAd->bAutoTxAgcA = pAd->bAutoTxAgcG = TRUE;
+common/rtmp_init.c:		pAd->bAutoTxAgcA = pAd->bAutoTxAgcG = FALSE;
+common/rtmp_init.c:			pAd->TxPowerCtrl.bInternalTxALC = FALSE;
+common/rtmp_init.c:			pAd->TxPowerCtrl.bInternalTxALC = TRUE;
+common/rtmp_init.c:			pAd->TxPowerCtrl.bInternalTxALC = FALSE;
+common/rtmp_init.c:	if (pAd->MACVersion == 0x53900501)
+common/rtmp_init.c:		pAd->TxPowerCtrl.bInternalTxALC = FALSE;
+common/rtmp_init.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s: pAd->TxPowerCtrl.bInternalTxALC = %d\n", 
+common/rtmp_init.c:		pAd->TxPowerCtrl.bInternalTxALC));
+common/rtmp_init.c:		pAd->TssiGain = 0x02;	 /* RT5390 uses 2 as TSSI gain/attenuation default value */
+common/rtmp_init.c:		pAd->TssiGain = 0x03; /* RT5392 uses 3 as TSSI gain/attenuation default value */
+common/rtmp_init.c:		pAd->TssiGain =  (UCHAR) (value & 0x000F);
+common/rtmp_init.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s: EEPROM_TSSI_GAIN_AND_ATTENUATION = 0x%X, pAd->TssiGain=0x%x\n", 
+common/rtmp_init.c:				pAd->TssiGain));
+common/rtmp_init.c:	rtmp_bbp_set_rxpath(pAd, pAd->Antenna.field.RxPath);
+common/rtmp_init.c:			if(pAd->Antenna.field.TxPath == 1)
+common/rtmp_init.c:					pAd->StaCfg.bHardwareRadio, pAd->StaCfg.bHardwareRadio));
+common/rtmp_init.c:		if (pAd->StaCfg.AdaptiveFreq == TRUE) /*Todo: iwpriv and profile support.*/
+common/rtmp_init.c:		pAd->FreqCalibrationCtrl.bEnableFrequencyCalibration = TRUE;
+common/rtmp_init.c:		DBGPRINT(RT_DEBUG_TRACE, ("%s: pAd->FreqCalibrationCtrl.bEnableFrequencyCalibration = %d\n", 
+common/rtmp_init.c:			pAd->FreqCalibrationCtrl.bEnableFrequencyCalibration));
+common/rtmp_init.c:				pAd->Antenna.field.TxPath, pAd->Antenna.field.RxPath, pAd->RfIcType));
+common/rtmp_init.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+common/rtmp_init.c:		pAd->BeaconOffset[idx] = pChipCap->BcnBase[idx];
+common/rtmp_init.c:		DBGPRINT(RT_DEBUG_TRACE, ("\t\tBcnBase[%d] = 0x%x, pAd->BeaconOffset[%d]=0x%x\n",
+common/rtmp_init.c:					idx, pChipCap->BcnBase[idx], idx, pAd->BeaconOffset[idx]));
+common/rtmp_init.c:		if (pAd->chipOps.loadFirmware)
+common/rtmp_init.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+common/rtmp_init.c:	/*we use a local variable "MacCsr0" instead of using "pAd->MACVersion" directly.*/
+common/rtmp_init.c:	// TODO: shiang, how about the value setting of pAd->MACVersion?? Original it assigned here
+common/rtmp_init.c:			__FUNCTION__, pAd->MACVersion));
+common/rtmp_init.c:	if (pAd->BulkInMaxPacketSize == 512)
+common/rtmp_init.c:	if (pAd->chipOps.AsicMacInit != NULL)
+common/rtmp_init.c:		pAd->chipOps.AsicMacInit(pAd);
+common/rtmp_init.c:	pAd->LastMCUCmd = 0x72;
+common/rtmp_init.c:		((pAd->MACVersion >= RALINK_2880E_VERSION) &&
+common/rtmp_init.c:		(pAd->MACVersion < RALINK_3070_VERSION))) /* 3*3*/
+common/rtmp_init.c:		if (pAd->StaCfg.bRadio == FALSE)
+common/rtmp_init.c:			if (pAd->BeaconOffset[apidx] > 0) {
+common/rtmp_init.c:				// TODO: shiang-6590, if we didn't define MBSS_SUPPORT, the pAd->BeaconOffset[x] may set as 0 when chipCap.BcnMaxHwNum != HW_BEACON_MAX_COUNT
+common/rtmp_init.c:					RTMP_CHIP_UPDATE_BEACON(pAd, pAd->BeaconOffset[apidx] + i, 0x00, 4); 
+common/rtmp_init.c:				if (pAd->CommonCfg.pBeaconSync)
+common/rtmp_init.c:					pAd->CommonCfg.pBeaconSync->BeaconBitMap &= (~(BEACON_BITMAP_MASK & (1 << apidx)));
+common/rtmp_init.c:		if ((pAd->MACVersion&0xffff) != 0x0101)
+common/rtmp_init.c:		if (pAd->CommonCfg.DebugFlags & DBF_DBQ_TXFIFO) {
+common/rtmp_init.c:			pEntry = &pAd->MacTab.Content[wcid];
+common/rtmp_init.c:			if (pAd->chipCap.FlgHwTxBfCap)
+common/rtmp_init.c:	if (pAd->chipCap.FlgHwFifoExtCap)
+common/rtmp_init.c:	if (pAd->chipCap.FlgHwFifoExtCap)
+common/rtmp_init.c:	pAd->bUpdateBcnCntDone = TRUE;	/* not appear in Rory's code */
+common/rtmp_init.c:	pAd->RalinkCounters.OneSecBeaconSentCnt += pStaTxCnt0->field.TxBeaconCount;
+common/rtmp_init.c:	pAd->RalinkCounters.OneSecTxRetryOkCount += pStaTxCnt1->field.TxRetransmit;
+common/rtmp_init.c:	pAd->RalinkCounters.OneSecTxNoRetryOkCount += pStaTxCnt1->field.TxSuccess;
+common/rtmp_init.c:	pAd->RalinkCounters.OneSecTxFailCount += pStaTxCnt0->field.TxFailCount;
+common/rtmp_init.c:	pAd->WlanCounters.TransmittedFragmentCount.u.LowPart += pStaTxCnt1->field.TxSuccess;
+common/rtmp_init.c:	pAd->WlanCounters.RetryCount.u.LowPart += pStaTxCnt1->field.TxRetransmit;
+common/rtmp_init.c:	pAd->WlanCounters.FailedCount.u.LowPart += pStaTxCnt0->field.TxFailCount;
+common/rtmp_init.c:	pRalinkCounters = &pAd->RalinkCounters;
+common/rtmp_init.c:	if ((pAd->CommonCfg.CarrierDetect.Enable == FALSE) || (pAd->OpMode == OPMODE_STA))
+common/rtmp_init.c:	    pAd->PrivateInfo.PhyRxErrCnt += RxStaCnt1.field.PlcpErr;
+common/rtmp_init.c:		pAd->RalinkCounters.OneSecFalseCCACnt += RxStaCnt1.field.FalseCca;
+common/rtmp_init.c:		pAd->RalinkCounters.FalseCCACnt += RxStaCnt1.field.FalseCca;
+common/rtmp_init.c:	OldValue= pAd->WlanCounters.FCSErrorCount.u.LowPart;
+common/rtmp_init.c:	pAd->WlanCounters.FCSErrorCount.u.LowPart += (RxStaCnt0.field.CrcErr); /* >> 7);*/
+common/rtmp_init.c:	if (pAd->WlanCounters.FCSErrorCount.u.LowPart < OldValue)
+common/rtmp_init.c:		pAd->WlanCounters.FCSErrorCount.u.HighPart++;
+common/rtmp_init.c:	pAd->WlanCounters.FrameDuplicateCount.u.LowPart += RxStaCnt2.field.RxDupliCount;
+common/rtmp_init.c:	pAd->Counters8023.RxNoBuffer += (RxStaCnt2.field.RxFifoOverflowCount);
+common/rtmp_init.c:	/*pAd->RalinkCounters.RxCount = 0;*/
+common/rtmp_init.c:	if (pRalinkCounters->RxCount != pAd->watchDogRxCnt)
+common/rtmp_init.c:		pAd->watchDogRxCnt = pRalinkCounters->RxCount;
+common/rtmp_init.c:		pAd->watchDogRxOverFlowCnt = 0;
+common/rtmp_init.c:			pAd->watchDogRxOverFlowCnt++;
+common/rtmp_init.c:			pAd->watchDogRxOverFlowCnt = 0;
+common/rtmp_init.c:	/*	(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) && (pAd->MacTab.Size != 1)))*/
+common/rtmp_init.c:	if (!pAd->bUpdateBcnCntDone)
+common/rtmp_init.c:	/*if (pAd->bStaFifoTest == TRUE)*/
+common/rtmp_init.c:		pDiag = &pAd->DiagStruct;
+common/rtmp_init.c:	if (pAd->chipOps.loadFirmware)
+common/rtmp_init.c:		status = pAd->chipOps.loadFirmware(pAd);
+common/rtmp_init.c:	if (pAd->chipOps.eraseFirmware)
+common/rtmp_init.c:		pAd->chipOps.eraseFirmware(pAd);
+common/rtmp_init.c:	NdisFreeSpinLock(&pAd->MacTabLock);
+common/rtmp_init.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/rtmp_init.c:	pAd->IndicateMediaState = NdisMediaStateDisconnected; 
+common/rtmp_init.c:	pAd->CommonCfg.BasicRateBitmap = 0xF;
+common/rtmp_init.c:	pAd->CommonCfg.BasicRateBitmapOld = 0xF;
+common/rtmp_init.c:	pAd->BulkOutReq = 0;
+common/rtmp_init.c:	pAd->BulkOutComplete = 0;
+common/rtmp_init.c:	pAd->BulkOutCompleteOther = 0;
+common/rtmp_init.c:	pAd->BulkOutCompleteCancel = 0;
+common/rtmp_init.c:	pAd->BulkInReq = 0;
+common/rtmp_init.c:	pAd->BulkInComplete = 0;
+common/rtmp_init.c:	pAd->BulkInCompleteFail = 0;
+common/rtmp_init.c:	/*pAd->QuickTimerP = 100;*/
+common/rtmp_init.c:	/*pAd->TurnAggrBulkInCount = 0;*/
+common/rtmp_init.c:	pAd->bUsbTxBulkAggre = 0;
+common/rtmp_init.c:	pAd->LedCntl.LedIndicatorStrength = 0xFF;
+common/rtmp_init.c:	pAd->CommonCfg.MaxPktOneTxBulk = 2;
+common/rtmp_init.c:	pAd->CommonCfg.TxBulkFactor = 1;
+common/rtmp_init.c:	pAd->CommonCfg.RxBulkFactor =1;
+common/rtmp_init.c:	pAd->CommonCfg.TxPower = 100; /*mW*/
+common/rtmp_init.c:	NdisZeroMemory(&pAd->CommonCfg.IOTestParm, sizeof(pAd->CommonCfg.IOTestParm));
+common/rtmp_init.c:	pAd->CountDowntoPsm = 0;
+common/rtmp_init.c:	pAd->StaCfg.Connectinfoflag = FALSE;
+common/rtmp_init.c:			pAd->SharedKey[bss_index][key_index].KeyLen = 0;
+common/rtmp_init.c:			pAd->SharedKey[bss_index][key_index].CipherAlg = CIPHER_NONE;
+common/rtmp_init.c:	pAd->bLocalAdminMAC = FALSE;
+common/rtmp_init.c:	pAd->EepromAccess = FALSE;
+common/rtmp_init.c:	pAd->Antenna.word = 0; 
+common/rtmp_init.c:	pAd->CommonCfg.BBPCurrentBW = BW_20;
+common/rtmp_init.c:	pAd->bAutoTxAgcA = FALSE;			/* Default is OFF*/
+common/rtmp_init.c:	pAd->bAutoTxAgcG = FALSE;			/* Default is OFF*/
+common/rtmp_init.c:	pAd->TxPowerCtrl.bInternalTxALC = FALSE; /* Off by default */
+common/rtmp_init.c:	pAd->TxPowerCtrl.idxTxPowerTable = 0;
+common/rtmp_init.c:	pAd->TxPowerCtrl.idxTxPowerTable2 = 0;
+common/rtmp_init.c:	pAd->TxPowerCtrl.LookupTableIndex = 0;
+common/rtmp_init.c:	pAd->RfIcType = RFIC_2820;
+common/rtmp_init.c:	pAd->CommonCfg.CentralChannel = 1;
+common/rtmp_init.c:	pAd->bForcePrintTX = FALSE;
+common/rtmp_init.c:	pAd->bForcePrintRX = FALSE;
+common/rtmp_init.c:	pAd->bStaFifoTest = FALSE;
+common/rtmp_init.c:	pAd->bProtectionTest = FALSE;
+common/rtmp_init.c:	pAd->bHCCATest = FALSE;
+common/rtmp_init.c:	pAd->bGenOneHCCA = FALSE;
+common/rtmp_init.c:	pAd->CommonCfg.Dsifs = 10;      /* in units of usec */
+common/rtmp_init.c:	pAd->CommonCfg.TxPower = 100; /* mW*/
+common/rtmp_init.c:	pAd->CommonCfg.TxPowerPercentage = 0xffffffff; /* AUTO*/
+common/rtmp_init.c:	pAd->CommonCfg.TxPowerDefault = 0xffffffff; /* AUTO*/
+common/rtmp_init.c:	pAd->CommonCfg.TxPreamble = Rt802_11PreambleAuto; /* use Long preamble on TX by defaut*/
+common/rtmp_init.c:	pAd->CommonCfg.bUseZeroToDisableFragment = FALSE;
+common/rtmp_init.c:	pAd->CommonCfg.RtsThreshold = 2347;
+common/rtmp_init.c:	pAd->CommonCfg.FragmentThreshold = 2346;
+common/rtmp_init.c:	pAd->CommonCfg.UseBGProtection = 0;    /* 0: AUTO*/
+common/rtmp_init.c:	pAd->CommonCfg.bEnableTxBurst = TRUE; /* 0;    	*/
+common/rtmp_init.c:	pAd->CommonCfg.PhyMode = 0xff;     /* unknown*/
+common/rtmp_init.c:	pAd->CommonCfg.SavedPhyMode = pAd->CommonCfg.PhyMode;
+common/rtmp_init.c:	pAd->CommonCfg.CarrierDetect.delta = CARRIER_DETECT_DELTA;
+common/rtmp_init.c:	pAd->CommonCfg.CarrierDetect.div_flag = CARRIER_DETECT_DIV_FLAG;
+common/rtmp_init.c:	pAd->CommonCfg.CarrierDetect.criteria = CARRIER_DETECT_CRITIRIA;
+common/rtmp_init.c:	pAd->CommonCfg.CarrierDetect.threshold = CARRIER_DETECT_THRESHOLD;
+common/rtmp_init.c:	pAd->CommonCfg.CarrierDetect.recheck1 = CARRIER_DETECT_RECHECK_TIME;
+common/rtmp_init.c:	pAd->CommonCfg.CarrierDetect.CarrierGoneThreshold = CARRIER_GONE_TRESHOLD;
+common/rtmp_init.c:	pAd->CommonCfg.CarrierDetect.VGA_Mask = CARRIER_DETECT_DEFAULT_MASK;
+common/rtmp_init.c:	pAd->CommonCfg.CarrierDetect.Packet_End_Mask = CARRIER_DETECT_DEFAULT_MASK;
+common/rtmp_init.c:	pAd->CommonCfg.CarrierDetect.Rx_PE_Mask = CARRIER_DETECT_DEFAULT_MASK;
+common/rtmp_init.c:	pAd->CommonCfg.RadarDetect.bDfsInit = FALSE;
+common/rtmp_init.c:	pAd->Dot11_H.ChMovingTime = 65;
+common/rtmp_init.c:		UAPSD_INFO_INIT(&pAd->ApCfg.MBSSID[IdMbss].UapsdInfo);
+common/rtmp_init.c:	pAd->StaCfg.UapsdInfo.bAPSDCapable = FALSE;
+common/rtmp_init.c:	pAd->CommonCfg.bNeedSendTriggerFrame = FALSE;
+common/rtmp_init.c:	pAd->CommonCfg.TriggerTimerCount = 0;
+common/rtmp_init.c:	pAd->CommonCfg.bAPSDForcePowerSave = FALSE;
+common/rtmp_init.c:	/*pAd->CommonCfg.bCountryFlag = FALSE;*/
+common/rtmp_init.c:	pAd->CommonCfg.TxStream = 0;
+common/rtmp_init.c:	pAd->CommonCfg.RxStream = 0;
+common/rtmp_init.c:	NdisZeroMemory(&pAd->BeaconTxWI, TXWISize);
+common/rtmp_init.c:	NdisZeroMemory(&pAd->CommonCfg.HtCapability, sizeof(pAd->CommonCfg.HtCapability));
+common/rtmp_init.c:	pAd->HTCEnable = FALSE;
+common/rtmp_init.c:	pAd->bBroadComHT = FALSE;
+common/rtmp_init.c:	pAd->CommonCfg.bRdg = FALSE;
+common/rtmp_init.c:	pAd->CommonCfg.Dot11OBssScanPassiveDwell = dot11OBSSScanPassiveDwell;	/* Unit : TU. 5~1000*/
+common/rtmp_init.c:	pAd->CommonCfg.Dot11OBssScanActiveDwell = dot11OBSSScanActiveDwell;	/* Unit : TU. 10~1000*/
+common/rtmp_init.c:	pAd->CommonCfg.Dot11BssWidthTriggerScanInt = dot11BSSWidthTriggerScanInterval;	/* Unit : Second	*/
+common/rtmp_init.c:	pAd->CommonCfg.Dot11OBssScanPassiveTotalPerChannel = dot11OBSSScanPassiveTotalPerChannel;	/* Unit : TU. 200~10000*/
+common/rtmp_init.c:	pAd->CommonCfg.Dot11OBssScanActiveTotalPerChannel = dot11OBSSScanActiveTotalPerChannel;	/* Unit : TU. 20~10000*/
+common/rtmp_init.c:	pAd->CommonCfg.Dot11BssWidthChanTranDelayFactor = dot11BSSWidthChannelTransactionDelayFactor;
+common/rtmp_init.c:	pAd->CommonCfg.Dot11OBssScanActivityThre = dot11BSSScanActivityThreshold;	/* Unit : percentage*/
+common/rtmp_init.c:	pAd->CommonCfg.Dot11BssWidthChanTranDelay = (pAd->CommonCfg.Dot11BssWidthTriggerScanInt * pAd->CommonCfg.Dot11BssWidthChanTranDelayFactor);
+common/rtmp_init.c:	pAd->CommonCfg.bBssCoexEnable = TRUE; /* by default, we enable this feature, you can disable it via the profile or ioctl command*/
+common/rtmp_init.c:	pAd->CommonCfg.BssCoexApCntThr = 0;
+common/rtmp_init.c:	pAd->CommonCfg.Bss2040NeedFallBack = 0;
+common/rtmp_init.c:	NdisZeroMemory(&pAd->CommonCfg.AddHTInfo, sizeof(pAd->CommonCfg.AddHTInfo));
+common/rtmp_init.c:	pAd->CommonCfg.BACapability.field.MMPSmode = MMPS_ENABLE;
+common/rtmp_init.c:	pAd->CommonCfg.BACapability.field.MpduDensity = 0;
+common/rtmp_init.c:	pAd->CommonCfg.BACapability.field.Policy = IMMED_BA;
+common/rtmp_init.c:	pAd->CommonCfg.BACapability.field.RxBAWinLimit = 64; /*32;*/
+common/rtmp_init.c:	pAd->CommonCfg.BACapability.field.TxBAWinLimit = 64; /*32;*/
+common/rtmp_init.c:	DBGPRINT(RT_DEBUG_TRACE, ("--> UserCfgInit. BACapability = 0x%x\n", pAd->CommonCfg.BACapability.word));    
+common/rtmp_init.c:	pAd->CommonCfg.BACapability.field.AutoBA = FALSE;	
+common/rtmp_init.c:	BATableInit(pAd, &pAd->BATable);
+common/rtmp_init.c:	pAd->CommonCfg.bExtChannelSwitchAnnouncement = 1;
+common/rtmp_init.c:	pAd->CommonCfg.bHTProtect = 1;
+common/rtmp_init.c:	pAd->CommonCfg.bMIMOPSEnable = TRUE;
+common/rtmp_init.c:	pAd->ApCfg.bGreenAPEnable=FALSE;
+common/rtmp_init.c:	pAd->ApCfg.bGreenAPActive = FALSE;
+common/rtmp_init.c:	pAd->ApCfg.GreenAPLevel= GREENAP_WITHOUT_ANY_STAS_CONNECT;
+common/rtmp_init.c:	pAd->CommonCfg.bBADecline = FALSE;
+common/rtmp_init.c:	pAd->CommonCfg.bDisableReordering = FALSE;
+common/rtmp_init.c:	if (pAd->MACVersion == 0x28720200)
+common/rtmp_init.c:		pAd->CommonCfg.TxBASize = 13; /*by Jerry recommend*/
+common/rtmp_init.c:		pAd->CommonCfg.TxBASize = 7;
+common/rtmp_init.c:	pAd->CommonCfg.REGBACapability.word = pAd->CommonCfg.BACapability.word;
+common/rtmp_init.c:	/*pAd->CommonCfg.HTPhyMode.field.BW = BW_20;*/
+common/rtmp_init.c:	/*pAd->CommonCfg.HTPhyMode.field.MCS = MCS_AUTO;*/
+common/rtmp_init.c:	/*pAd->CommonCfg.HTPhyMode.field.ShortGI = GI_800;*/
+common/rtmp_init.c:	/*pAd->CommonCfg.HTPhyMode.field.STBC = STBC_NONE;*/
+common/rtmp_init.c:	pAd->CommonCfg.TxRate = RATE_6;
+common/rtmp_init.c:	pAd->CommonCfg.MlmeTransmit.field.MCS = MCS_RATE_6;
+common/rtmp_init.c:	pAd->CommonCfg.MlmeTransmit.field.BW = BW_20;
+common/rtmp_init.c:	pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
+common/rtmp_init.c:	pAd->CommonCfg.BeaconPeriod = 100;     /* in mSec*/
+common/rtmp_init.c:	if (pAd->chipCap.FlgHwStreamMode)
+common/rtmp_init.c:		pAd->CommonCfg.StreamMode = 3;
+common/rtmp_init.c:		pAd->CommonCfg.StreamModeMCS = 0x0B0B;
+common/rtmp_init.c:	pAd->CommonCfg.ETxBfNoncompress = 0;
+common/rtmp_init.c:	pAd->CommonCfg.ETxBfIncapable = 0;
+common/rtmp_init.c:	pAd->CommonCfg.lowTrafficThrd = 2;
+common/rtmp_init.c:	pAd->CommonCfg.TrainUpRule = 2; // 1;
+common/rtmp_init.c:	pAd->CommonCfg.TrainUpRuleRSSI = -70; // 0;
+common/rtmp_init.c:	pAd->CommonCfg.TrainUpLowThrd = 90;
+common/rtmp_init.c:	pAd->CommonCfg.TrainUpHighThrd = 110;
+common/rtmp_init.c:	pAd->CommonCfg.DebugFlags = 0;
+common/rtmp_init.c:	pAd->CommonCfg.wapi_usk_rekey_method = REKEY_METHOD_DISABLE;
+common/rtmp_init.c:	pAd->CommonCfg.wapi_msk_rekey_method = REKEY_METHOD_DISABLE;
+common/rtmp_init.c:	pAd->CommonCfg.wapi_msk_rekey_cnt = 0;
+common/rtmp_init.c:	pAd->CommonCfg.MCastPhyMode.word
+common/rtmp_init.c:	= pAd->MacTab.Content[MCAST_WCID].HTPhyMode.word;
+common/rtmp_init.c:	pAd->CommonCfg.HT_DisallowTKIP = TRUE;
+common/rtmp_init.c:	pAd->ra_interval = DEF_RA_TIME_INTRVAL;
+common/rtmp_init.c:	pAd->ra_fast_interval = DEF_QUICK_RA_TIME_INTERVAL;
+common/rtmp_init.c:	if (pAd->rateAlg == RATE_ALG_AGS)
+common/rtmp_init.c:		pAd->ra_fast_interval = AGS_QUICK_RA_TIME_INTERVAL;
+common/rtmp_init.c:	pAd->TxSwQMaxLen = MAX_PACKETS_IN_QUEUE;
+common/rtmp_init.c:	pAd->CommonCfg.bRalinkBurstMode = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.Psm = PWR_ACTIVE;
+common/rtmp_init.c:		pAd->StaCfg.PairCipher = Ndis802_11EncryptionDisabled;
+common/rtmp_init.c:		pAd->StaCfg.GroupCipher = Ndis802_11EncryptionDisabled;
+common/rtmp_init.c:		pAd->StaCfg.bMixCipher = FALSE;	
+common/rtmp_init.c:		pAd->StaCfg.DefaultKeyId = 0;
+common/rtmp_init.c:		pAd->StaCfg.PrivacyFilter = Ndis802_11PrivFilter8021xWEP;
+common/rtmp_init.c:		pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+common/rtmp_init.c:		pAd->StaCfg.LastMicErrorTime = 0;
+common/rtmp_init.c:		pAd->StaCfg.MicErrCnt        = 0;
+common/rtmp_init.c:		pAd->StaCfg.bBlockAssoc      = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.WpaState         = SS_NOTUSE;
+common/rtmp_init.c:		pAd->CommonCfg.NdisRadioStateOff = FALSE;		/* New to support microsoft disable radio with OID command*/
+common/rtmp_init.c:		pAd->StaCfg.RssiTrigger = 0;
+common/rtmp_init.c:		NdisZeroMemory(&pAd->StaCfg.RssiSample, sizeof(RSSI_SAMPLE));
+common/rtmp_init.c:		pAd->StaCfg.RssiTriggerMode = RSSI_TRIGGERED_UPON_BELOW_THRESHOLD;
+common/rtmp_init.c:		pAd->StaCfg.AtimWin = 0;
+common/rtmp_init.c:		pAd->StaCfg.DefaultListenCount = 3;/*default listen count;*/
+common/rtmp_init.c:		pAd->StaCfg.DefaultListenCount = 1;
+common/rtmp_init.c:		pAd->StaCfg.BssType = BSS_INFRA;  /* BSS_INFRA or BSS_ADHOC or BSS_MONITOR*/
+common/rtmp_init.c:		pAd->StaCfg.bSkipAutoScanConn = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.bAutoTxRateSwitch = TRUE;
+common/rtmp_init.c:		pAd->StaCfg.DesiredTransmitSetting.field.MCS = MCS_AUTO;
+common/rtmp_init.c:		pAd->StaCfg.bAutoConnectIfNoSSID = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.AdaptiveFreq = TRUE; /* Todo: iwpriv and profile support. */
+common/rtmp_init.c:	pAd->StaCfg.IEEE80211dClientMode = Rt802_11_D_None;
+common/rtmp_init.c:	pAd->CommonCfg.PhyMode = (WMODE_B | WMODE_G);		/* default PHY mode*/
+common/rtmp_init.c:		pAd->StaCfg.WindowsPowerMode = Ndis802_11PowerModeCAM;
+common/rtmp_init.c:		pAd->StaCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeCAM;
+common/rtmp_init.c:		pAd->StaCfg.bWindowsACCAMEnable = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.bHwRadio  = TRUE; /* Default Hardware Radio status is On*/
+common/rtmp_init.c:		pAd->StaCfg.bSwRadio  = TRUE; /* Default Software Radio status is On*/
+common/rtmp_init.c:		pAd->StaCfg.bRadio    = TRUE; /* bHwRadio && bSwRadio*/
+common/rtmp_init.c:		pAd->StaCfg.bHardwareRadio = FALSE;		/* Default is OFF*/
+common/rtmp_init.c:		pAd->StaCfg.bShowHiddenSSID = FALSE;		/* Default no show*/
+common/rtmp_init.c:		pAd->StaCfg.bAutoReconnect = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.bAutoReconnect = TRUE;
+common/rtmp_init.c:		pAd->StaCfg.LastScanTime = 0;
+common/rtmp_init.c:		NdisZeroMemory(pAd->nickname, IW_ESSID_MAX_SIZE+1);
+common/rtmp_init.c:		pAd->bWriteDat = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.IEEE8021X = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.IEEE8021x_required_keys = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.WpaSupplicantUP = WPA_SUPPLICANT_DISABLE;
+common/rtmp_init.c:		pAd->StaCfg.bRSN_IE_FromWpaSupplicant = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.WpaSupplicantUP = WPA_SUPPLICANT_ENABLE;
+common/rtmp_init.c:		pAd->bWriteDat = TRUE;
+common/rtmp_init.c:		pAd->StaCfg.bLostAp = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.pWpsProbeReqIe = NULL;
+common/rtmp_init.c:		pAd->StaCfg.WpsProbeReqIeLen = 0;
+common/rtmp_init.c:		pAd->StaCfg.pWpaAssocIe = NULL;
+common/rtmp_init.c:		pAd->StaCfg.WpaAssocIeLen = 0;
+common/rtmp_init.c:		pAd->StaCfg.WpaSupplicantScanCount = 0;
+common/rtmp_init.c:			pWscControl = &pAd->StaCfg.WscControl;
+common/rtmp_init.c:			NdisZeroMemory(&pAd->StaCfg.WscControl.RegData, sizeof(WSC_REG_DATA));
+common/rtmp_init.c:			pAd->WriteWscCfgToDatFile = 0xFF;
+common/rtmp_init.c:		NdisZeroMemory(pAd->StaCfg.ReplayCounter, 8);
+common/rtmp_init.c:		pAd->StaCfg.bAutoConnectByBssid = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.BeaconLostTime = BEACON_LOST_TIME;
+common/rtmp_init.c:		NdisZeroMemory(pAd->StaCfg.WpaPassPhrase, 64);    
+common/rtmp_init.c:		pAd->StaCfg.WpaPassPhraseLen = 0;
+common/rtmp_init.c:		pAd->StaCfg.bAutoRoaming = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.bForceTxBurst = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.bNotFirstScan = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.bImprovedScan = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.bAdhocN = TRUE;
+common/rtmp_init.c:		pAd->StaCfg.bFastConnect = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.bAdhocCreator = FALSE;
+common/rtmp_init.c:	pAd->ExtraInfo = EXTRA_INFO_CLEAR;
+common/rtmp_init.c:	pAd->bConfigChanged = FALSE;
+common/rtmp_init.c:		pAd->ApCfg.BssidNum = MAX_MBSSID_NUM(pAd);
+common/rtmp_init.c:		for(j = BSS0; j < pAd->ApCfg.BssidNum; j++)
+common/rtmp_init.c:			pAd->ApCfg.MBSSID[j].AuthMode = Ndis802_11AuthModeOpen;
+common/rtmp_init.c:			pAd->ApCfg.MBSSID[j].WepStatus = Ndis802_11EncryptionDisabled;
+common/rtmp_init.c:			pAd->ApCfg.MBSSID[j].GroupKeyWepStatus = Ndis802_11EncryptionDisabled;
+common/rtmp_init.c:			pAd->ApCfg.MBSSID[j].DefaultKeyId = 0;
+common/rtmp_init.c:			pAd->ApCfg.MBSSID[j].WpaMixPairCipher = MIX_CIPHER_NOTUSE;
+common/rtmp_init.c:			pAd->ApCfg.MBSSID[j].RekeyCountDown = 0;	/* it's used for WPA rekey */
+common/rtmp_init.c:			pAd->ApCfg.MBSSID[j].IEEE8021X = FALSE;
+common/rtmp_init.c:			pAd->ApCfg.MBSSID[j].PreAuth = FALSE;
+common/rtmp_init.c:			pAd->ApCfg.MBSSID[j].PMKCachePeriod = (10 * 60 * OS_HZ); /* unit : tick(default: 10 minute)*/
+common/rtmp_init.c:			NdisZeroMemory(&pAd->ApCfg.MBSSID[j].PMKIDCache, sizeof(NDIS_AP_802_11_PMKID));
+common/rtmp_init.c:			pAd->ApCfg.MBSSID[j].radius_srv_num = 0;
+common/rtmp_init.c:			pAd->ApCfg.MBSSID[j].NasIdLen = 0;
+common/rtmp_init.c:        		pAd->ApCfg.MBSSID[j].VLAN_VID = 0;
+common/rtmp_init.c:			pAd->ApCfg.MBSSID[j].bAutoTxRateSwitch = TRUE;
+common/rtmp_init.c:			pAd->ApCfg.MBSSID[j].DesiredTransmitSetting.field.MCS = MCS_AUTO;
+common/rtmp_init.c:			pAd->ApCfg.MBSSID[j].MaxStaNum = 0;
+common/rtmp_init.c:			pAd->ApCfg.MBSSID[j].StaCount = 0;
+common/rtmp_init.c:			pAd->ApCfg.MBSSID[j].WscSecurityMode = 0xff;
+common/rtmp_init.c:				pWscControl = &pAd->ApCfg.MBSSID[j].WscControl;
+common/rtmp_init.c:				NdisZeroMemory(&pAd->CommonCfg.WscStaPbcProbeInfo, sizeof(WSC_STA_PBC_PROBE_INFO));
+common/rtmp_init.c:				pAd->CommonCfg.WscPBCOverlap = FALSE;
+common/rtmp_init.c:	        		pAd->ApCfg.MBSSID[j].TimBitmaps[i] = 0;
+common/rtmp_init.c:		pAd->ApCfg.DtimCount  = 0;
+common/rtmp_init.c:		pAd->ApCfg.DtimPeriod = DEFAULT_DTIM_PERIOD;
+common/rtmp_init.c:		pAd->ApCfg.ErpIeContent = 0;
+common/rtmp_init.c:		pAd->ApCfg.StaIdleTimeout = MAC_TABLE_AGEOUT_TIME;
+common/rtmp_init.c:		pAd->ApCfg.IdsEnable = FALSE;
+common/rtmp_init.c:		pAd->ApCfg.AuthFloodThreshold = 0;
+common/rtmp_init.c:		pAd->ApCfg.AssocReqFloodThreshold = 0;
+common/rtmp_init.c:		pAd->ApCfg.ReassocReqFloodThreshold = 0;
+common/rtmp_init.c:		pAd->ApCfg.ProbeReqFloodThreshold = 0;
+common/rtmp_init.c:		pAd->ApCfg.DisassocFloodThreshold = 0;
+common/rtmp_init.c:		pAd->ApCfg.DeauthFloodThreshold = 0;
+common/rtmp_init.c:		pAd->ApCfg.EapReqFloodThreshold = 0;
+common/rtmp_init.c:		pAd->WriteWscCfgToDatFile = 0xFF;
+common/rtmp_init.c:		pAd->WriteWscCfgToAr9DatFile = FALSE;
+common/rtmp_init.c:		pAd->bWscDriverAutoUpdateCfg = TRUE;
+common/rtmp_init.c:		pAd->ApCfg.FlgApCliIsUapsdInfoUpdated = FALSE;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].AuthMode = Ndis802_11AuthModeOpen;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].WepStatus = Ndis802_11WEPDisabled;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].bAutoTxRateSwitch = TRUE;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].DesiredTransmitSetting.field.MCS = MCS_AUTO;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].UapsdInfo.bAPSDCapable = FALSE;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].IEEE8021X=FALSE;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].IEEE8021x_required_keys=FALSE;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].bRSN_IE_FromWpaSupplicant=FALSE;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].bLostAp=FALSE;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].bScanReqIsFromWebUI=FALSE;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].bConfigChanged=FALSE;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].DesireSharedKeyId=0;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].WpaSupplicantUP=WPA_SUPPLICANT_DISABLE;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].WpaSupplicantScanCount=0;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].pWpsProbeReqIe=NULL;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].WpsProbeReqIeLen=0;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].pWpaAssocIe=NULL;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].WpaAssocIeLen=0;
+common/rtmp_init.c:			pAd->ApCfg.ApCliTab[j].SavedPMKNum=0;
+common/rtmp_init.c:			RTMPZeroMemory(pAd->ApCfg.ApCliTab[j].SavedPMK, (PMKID_NO * sizeof(BSSID_INFO)));
+common/rtmp_init.c:		pAd->ApCfg.EntryClientCount = 0;
+common/rtmp_init.c:	pAd->BbpTuning.bEnable                = TRUE;  
+common/rtmp_init.c:	pAd->BbpTuning.FalseCcaLowerThreshold = 100;
+common/rtmp_init.c:	pAd->BbpTuning.FalseCcaUpperThreshold = 512;
+common/rtmp_init.c:	pAd->BbpTuning.R66Delta               = 4;
+common/rtmp_init.c:	pAd->Mlme.bEnableAutoAntennaCheck = TRUE;
+common/rtmp_init.c:	pAd->BbpTuning.R66CurrentValue = 0x38;
+common/rtmp_init.c:	pAd->Bbp94 = BBPR94_DEFAULT;
+common/rtmp_init.c:	pAd->BbpForCCK = FALSE;
+common/rtmp_init.c:	/*pAd->bTest1 = FALSE;*/
+common/rtmp_init.c:	NdisZeroMemory(&pAd->MacTab, sizeof(MAC_TABLE));
+common/rtmp_init.c:	InitializeQueueHeader(&pAd->MacTab.McastPsQueue);
+common/rtmp_init.c:	NdisAllocateSpinLock(pAd, &pAd->MacTabLock);
+common/rtmp_init.c:	/*RTMPInitTimer(pAd, &pAd->RECBATimer, RECBATimerTimeout, pAd, TRUE);*/
+common/rtmp_init.c:	/*RTMPSetTimer(&pAd->RECBATimer, REORDER_EXEC_INTV);*/
+common/rtmp_init.c:	pAd->CommonCfg.bWiFiTest = FALSE;
+common/rtmp_init.c:	pAd->ApCfg.EntryLifeCheck = MAC_ENTRY_LIFE_CHECK_CNT;
+common/rtmp_init.c:		pAd->StaCfg.TdlsInfo.bTDLSCapable = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.TdlsInfo.TdlsChSwitchSupp = TRUE;
+common/rtmp_init.c:		pAd->StaCfg.TdlsInfo.TdlsPsmSupp = FALSE;
+common/rtmp_init.c:		pAd->StaCfg.TdlsInfo.TdlsKeyLifeTime = TDLS_LEY_LIFETIME;
+common/rtmp_init.c:		initList(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerList);
+common/rtmp_init.c:		NdisAllocateSpinLock(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+common/rtmp_init.c:		initList(&pAd->StaCfg.TdlsInfo.TdlsBlackList);
+common/rtmp_init.c:		NdisAllocateSpinLock(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+common/rtmp_init.c:		pAd->StaCfg.TdlsInfo.TdlsAutoSetupRssiThreshold = TDLS_AUTO_SETUP_RSSI_THRESHOLD;
+common/rtmp_init.c:		pAd->StaCfg.TdlsInfo.TdlsAutoTeardownRssiThreshold = TDLS_AUTO_TEARDOWN_RSSI_THRESHOLD;
+common/rtmp_init.c:		pAd->StaCfg.TdlsInfo.TdlsRssiMeasurementPeriod = TDLS_RSSI_MEASUREMENT_PERIOD;
+common/rtmp_init.c:		pAd->StaCfg.TdlsInfo.TdlsDisabledPeriodByTeardown = TDLS_DISABLE_PERIOD_BY_TEARDOWN;
+common/rtmp_init.c:		pAd->StaCfg.TdlsInfo.TdlsAutoDiscoveryPeriod = TDLS_AUTO_DISCOVERY_PERIOD;
+common/rtmp_init.c:	pAd->RxAnt.Pair1PrimaryRxAnt = 0;
+common/rtmp_init.c:	pAd->RxAnt.Pair1SecondaryRxAnt = 1;
+common/rtmp_init.c:		pAd->RxAnt.EvaluatePeriod = 0;
+common/rtmp_init.c:		pAd->RxAnt.RcvPktNumWhenEvaluate = 0;
+common/rtmp_init.c:		pAd->RxAnt.Pair1AvgRssi[0] = pAd->RxAnt.Pair1AvgRssi[1] = 0;
+common/rtmp_init.c:		pAd->RxAnt.Pair1AvgRssiGroup1[0] = pAd->RxAnt.Pair1AvgRssiGroup1[1] = 0;
+common/rtmp_init.c:		pAd->RxAnt.Pair1AvgRssiGroup2[0] = pAd->RxAnt.Pair1AvgRssiGroup2[1] = 0;
+common/rtmp_init.c:		pAd->chipCap.bTxRxSwAntDiv = FALSE;
+common/rtmp_init.c:		PBSS_ENTRY	pBssEntry = &pAd->ScanTab.BssEntry[i];
+common/rtmp_init.c:		if (pAd->ProbeRespIE[i].pIe)
+common/rtmp_init.c:			pBssEntry->pVarIeFromProbRsp = pAd->ProbeRespIE[i].pIe;
+common/rtmp_init.c:	NdisZeroMemory(&pAd->CommonCfg.WscStaPbcProbeInfo, sizeof(WSC_STA_PBC_PROBE_INFO));
+common/rtmp_init.c:	pAd->CommonCfg.WscPBCOverlap = FALSE;
+common/rtmp_init.c:	pAd->Dot11_H.CSCount = 0;
+common/rtmp_init.c:	pAd->Dot11_H.CSPeriod = 10;
+common/rtmp_init.c:	pAd->Dot11_H.RDMode = RD_NORMAL_MODE;
+common/rtmp_init.c:	pAd->Dot11_H.bDFSIndoor = 1;
+common/rtmp_init.c:	pAd->Cfg80211RocTimerInit = FALSE;
+common/rtmp_init.c:	pAd->Cfg80211RocTimerRunning = FALSE;
+common/rtmp_init.c:	pAd->FlgCfg80211Scanning = FALSE;
+common/rtmp_init.c:	pAd->isCfgDeviceInP2p = TRUE;
+common/rtmp_init.c:	pAd->fpga_on = 0x0;
+common/rtmp_init.c:	pAd->tx_kick_cnt = 0;
+common/rtmp_init.c:	pAd->data_phy = 0;
+common/rtmp_init.c:	pAd->data_mcs = 0;
+common/rtmp_init.c:	pAd->data_bw = 0;
+common/rtmp_init.c:	pAd->data_gi = 0;
+common/rtmp_init.c:	LIST_HEADER *pRscList = &pAd->RscTimerCreateList;
+common/rtmp_init.c:	LIST_HEADER *pRscList = &pAd->RscTimerCreateList;
+common/rtmp_init.c:	initList(&pAd->RscTimerCreateList);
+common/rtmp_init.c:        LIST_HEADER *pRscList = &pAd->RscTimerCreateList;
+common/rtmp_init.c:        initList(&pAd->RscTimerCreateList);
+common/rtmp_init.c:	RTMP_OS_Init_Timer(pAd, &pTimer->TimerObj,	pTimerFunc, (PVOID) pTimer, &pAd->RscTimerMemList);	
+common/rtmp_init.c:	if (pAd->OpMode == OPMODE_AP)
+common/rtmp_init.c:			if (pAd->ApCfg.IdsEnable)
+common/rtmp_init.c:		if (pAd->StaCfg.PSPXlink)
+common/rtmp_init.c:	/*pAd->bBroadComHT = TRUE;*/
+common/rtmp_init.c:	RTMP_CHIP_OP	*pChipOps = &pAd->chipOps;
+common/rtmp_init.c:	ChipOpsMCUHook(pAd, pAd->chipCap.MCUType);
+common/rtmp_init.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+common/rtmp_init.c:	pAd->infType = infType;
+common/rtmp_init.c:	pAd->OpMode = OPMODE_STA;
+common/rtmp_init.c:	pAd->OpMode = OPMODE_AP;
+common/rtmp_init.c:	pAd->OpMode = OPMODE_STA;
+common/rtmp_init.c:	RTMP_SEM_EVENT_INIT(&(pAd->UsbVendorReq_semaphore), &pAd->RscSemMemList);
+common/rtmp_init.c:	RTMP_SEM_EVENT_INIT(&(pAd->reg_atomic), &pAd->RscSemMemList);
+common/rtmp_init.c:	RTMP_SEM_EVENT_INIT(&(pAd->hw_atomic), &pAd->RscSemMemList);
+common/rtmp_init.c:	os_alloc_mem(pAd, (PUCHAR *)&pAd->UsbVendorReqBuf, MAX_PARAM_BUFFER_SIZE - 1);
+common/rtmp_init.c:	if (pAd->UsbVendorReqBuf == NULL)
+common/rtmp_init.c:		if (!PairEP(pAd, pAd->BulkOutEpAddr[i], i, 0))
+common/rtmp_init.c:			DBGPRINT(RT_DEBUG_ERROR, ("Invalid bulk out ep(%x)\n", pAd->BulkOutEpAddr[i]));
+common/rtmp_init.c:		if (!PairEP(pAd, pAd->BulkInEpAddr[i], i, 1))
+common/rtmp_init.c:			DBGPRINT(RT_DEBUG_ERROR, ("Invalid bulk in ep(%x)\n", pAd->BulkInEpAddr[i]));
+common/rtmp_init.c:	pAd->MC_RowID = -1; /* use default profile path*/
+common/rtmp_init.c:	if (pAd->MC_RowID == -1)
+common/rtmp_init.c:		strcpy(pAd->MC_FileName, AP_PROFILE_PATH);
+common/rtmp_init.c:		strcpy(pAd->MC_FileName, STA_PROFILE_PATH);
+common/rtmp_init.c:	DBGPRINT(RT_DEBUG_TRACE, ("MC> ROW = %d, PATH = %s\n", pAd->MC_RowID, pAd->MC_FileName));
+common/rtmp_init.c:	if (pAd->chipCap.asic_caps | fASIC_CAP_CSO)
+common/rtmp_init.c:	if ((pAd->MC_RowID >= 0) && (pAd->MC_RowID <= MAX_NUM_OF_MULTIPLE_CARD))
+common/rtmp_init.c:		MC_CardUsed[pAd->MC_RowID] = 0; /* not clear MAC address*/
+common/rtmp_init.c:		NdisFreeSpinLock(&pAd->StaCtIf.Lock);
+common/rtmp_init.c:	RTMP_SEM_EVENT_DESTORY(&(pAd->UsbVendorReq_semaphore));
+common/rtmp_init.c:	RTMP_SEM_EVENT_DESTORY(&(pAd->reg_atomic));
+common/rtmp_init.c:	RTMP_SEM_EVENT_DESTORY(&(pAd->hw_atomic));
+common/rtmp_init.c:	if (pAd->UsbVendorReqBuf)
+common/rtmp_init.c:		os_free_mem(pAd, pAd->UsbVendorReqBuf);
+common/rtmp_init.c:		if (pAd->ProbeRespIE[index].pIe)
+common/rtmp_init.c:			os_free_mem(pAd, pAd->ProbeRespIE[index].pIe);
+common/rtmp_init.c:	if (IS_RT6590(pAd) && (pAd->WlanFunCtrl.field.WLAN_EN == 1))
+common/rtmp_init.c:	if (IS_MT7601(pAd) && (pAd->WlanFunCtrl.field.WLAN_EN == 1) )
+common/rtmp_init.c:	RTMPInitTimer(pAd, &pAd->CommonCfg.Bss2040CoexistTimer, GET_TIMER_FUNCTION(Bss2040CoexistTimeOut), pAd, FALSE);
+common/rtmp_init.c:	DBGPRINT(RT_DEBUG_OFF, ("%s: bTxRxSwAntDiv %d\n", __FUNCTION__, pAd->chipCap.bTxRxSwAntDiv));
+common/rtmp_init.c:	if (pAd->chipCap.bTxRxSwAntDiv)  
+common/rtmp_init.c:					pAd->Antenna.word, pAd->Antenna.field.BoardType, pAd->NicConfig2.field.AntDiversity));
+common/rtmp_init.c:		if (pAd->NicConfig2.field.AntOpt== 1) /* ant selected by efuse */
+common/rtmp_init.c:			if (pAd->NicConfig2.field.AntDiversity == 0) /* main */
+common/rtmp_init.c:				pAd->RxAnt.Pair1PrimaryRxAnt = 0;
+common/rtmp_init.c:				pAd->RxAnt.Pair1SecondaryRxAnt = 1;
+common/rtmp_init.c:				pAd->RxAnt.Pair1PrimaryRxAnt = 1;
+common/rtmp_init.c:				pAd->RxAnt.Pair1SecondaryRxAnt = 0;
+common/rtmp_init.c:		else if (pAd->NicConfig2.field.AntDiversity == 0) /* Ant div off: default ant is main */
+common/rtmp_init.c:			pAd->RxAnt.Pair1PrimaryRxAnt = 0;
+common/rtmp_init.c:			pAd->RxAnt.Pair1SecondaryRxAnt = 1;
+common/rtmp_init.c:		else if (pAd->NicConfig2.field.AntDiversity == 1)/* Ant div on */
+common/rtmp_init.c:			pAd->RxAnt.Pair1PrimaryRxAnt = 0;
+common/rtmp_init.c:			pAd->RxAnt.Pair1SecondaryRxAnt = 1;
+common/rtmp_init.c:					pAd->RxAnt.Pair1PrimaryRxAnt,
+common/rtmp_init.c:					pAd->RxAnt.Pair1SecondaryRxAnt));
+common/cmm_data_usb.c:	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
+common/cmm_data_usb.c:	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
+common/cmm_data_usb.c:	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
+common/cmm_data_usb.c:	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
+common/cmm_data_usb.c:	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
+common/cmm_data_usb.c:	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
+common/cmm_data_usb.c:	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
+common/cmm_data_usb.c:	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
+common/cmm_data_usb.c:	if ((pHTTXContext->IRPPending == TRUE)  /*&& (pAd->TxSwQueue[BulkOutPipeId].Number == 0) */)
+common/cmm_data_usb.c:	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags);
+common/cmm_data_usb.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/cmm_data_usb.c:	NdisZeroMemory(&pAd->PsPollFrame, sizeof (PSPOLL_FRAME));
+common/cmm_data_usb.c:	pAd->PsPollFrame.FC.PwrMgmt = 0;
+common/cmm_data_usb.c:	pAd->PsPollFrame.FC.Type = BTYPE_CNTL;
+common/cmm_data_usb.c:	pAd->PsPollFrame.FC.SubType = SUBTYPE_PS_POLL;
+common/cmm_data_usb.c:	pAd->PsPollFrame.Aid = pAd->StaActive.Aid | 0xC000;
+common/cmm_data_usb.c:	COPY_MAC_ADDR(pAd->PsPollFrame.Bssid, pAd->CommonCfg.Bssid);
+common/cmm_data_usb.c:	COPY_MAC_ADDR(pAd->PsPollFrame.Ta, pAd->CurrentAddress);
+common/cmm_data_usb.c:	buf = &pAd->PsPollContext.TransferBuffer->field.WirelessPacket[0];
+common/cmm_data_usb.c:		      (UCHAR) pAd->CommonCfg.MlmeTransmit.field.MCS,
+common/cmm_data_usb.c:		      IFS_BACKOFF, FALSE, &pAd->CommonCfg.MlmeTransmit);
+common/cmm_data_usb.c:	RTMPMoveMemory((VOID *)&buf[TXWISize + TXINFO_SIZE + TSO_SIZE], (VOID *)&pAd->PsPollFrame, data_len);
+common/cmm_data_usb.c:	pAd->PsPollContext.BulkOutSize = TXINFO_SIZE + TXWISize + TSO_SIZE + data_len + 4;
+common/cmm_data_usb.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/cmm_data_usb.c:	USHORT data_len = sizeof(pAd->NullFrame);;
+common/cmm_data_usb.c:	NdisZeroMemory(&pAd->NullFrame, data_len);
+common/cmm_data_usb.c:	pAd->NullFrame.FC.Type = BTYPE_DATA;
+common/cmm_data_usb.c:	pAd->NullFrame.FC.SubType = SUBTYPE_NULL_FUNC;
+common/cmm_data_usb.c:	pAd->NullFrame.FC.ToDs = 1;
+common/cmm_data_usb.c:	COPY_MAC_ADDR(pAd->NullFrame.Addr1, pAd->CommonCfg.Bssid);
+common/cmm_data_usb.c:	COPY_MAC_ADDR(pAd->NullFrame.Addr2, pAd->CurrentAddress);
+common/cmm_data_usb.c:	COPY_MAC_ADDR(pAd->NullFrame.Addr3, pAd->CommonCfg.Bssid);
+common/cmm_data_usb.c:	buf = &pAd->NullContext.TransferBuffer->field.WirelessPacket[0];
+common/cmm_data_usb.c:		      (UCHAR)pAd->CommonCfg.MlmeTransmit.field.MCS,
+common/cmm_data_usb.c:		      IFS_BACKOFF, FALSE, &pAd->CommonCfg.MlmeTransmit);
+common/cmm_data_usb.c:	RTMPMoveMemory((VOID *)&buf[TXWISize + TXINFO_SIZE], (VOID *)&pAd->NullFrame, data_len);
+common/cmm_data_usb.c:	pAd->NullContext.BulkOutSize = TXINFO_SIZE + TXWISize + TSO_SIZE + data_len + 4;
+common/cmm_data_usb.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/cmm_data_usb.c:	pHTTXContext  = &pAd->TxContext[QueIdx];
+common/cmm_data_usb.c:	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
+common/cmm_data_usb.c:	pHTTXContext  = &pAd->TxContext[QueIdx];
+common/cmm_data_usb.c:			RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
+common/cmm_data_usb.c:			RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
+common/cmm_data_usb.c:	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
+common/cmm_data_usb.c:		RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
+common/cmm_data_usb.c:		RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
+common/cmm_data_usb.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/cmm_data_usb.c:	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
+common/cmm_data_usb.c:	pHTTXContext  = &pAd->TxContext[QueIdx];
+common/cmm_data_usb.c:		RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
+common/cmm_data_usb.c:		RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
+common/cmm_data_usb.c:	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
+common/cmm_data_usb.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/cmm_data_usb.c:	pHTTXContext  = &pAd->TxContext[QueIdx];
+common/cmm_data_usb.c:	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
+common/cmm_data_usb.c:	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
+common/cmm_data_usb.c:	pHTTXContext  = &pAd->TxContext[QueIdx];
+common/cmm_data_usb.c:	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
+common/cmm_data_usb.c:	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
+common/cmm_data_usb.c:	ULONG SwIdx = pAd->MgmtRing.TxCpuIdx;
+common/cmm_data_usb.c:	TX_CONTEXT *pMLMEContext = (PTX_CONTEXT)pAd->MgmtRing.Cell[SwIdx].AllocVa;
+common/cmm_data_usb.c:/*	if ((BulkOutSize % pAd->BulkOutMaxPacketSize) == 0)*/
+common/cmm_data_usb.c:	RTMP_IRQ_LOCK(&pAd->MLMEBulkOutLock, IrqFlags);
+common/cmm_data_usb.c:	pAd->MgmtRing.Cell[pAd->MgmtRing.TxCpuIdx].pNdisPacket = pPacket;
+common/cmm_data_usb.c:	pAd->RalinkCounters.KickTxCount++;
+common/cmm_data_usb.c:	pAd->RalinkCounters.OneSecTxDoneCount++;
+common/cmm_data_usb.c:	if (pAd->MgmtRing.TxSwFreeIdx == MGMT_RING_SIZE)
+common/cmm_data_usb.c:	pAd->MgmtRing.TxSwFreeIdx--;
+common/cmm_data_usb.c:	INC_RING_INDEX(pAd->MgmtRing.TxCpuIdx, MGMT_RING_SIZE);
+common/cmm_data_usb.c:	RTMP_IRQ_UNLOCK(&pAd->MLMEBulkOutLock, IrqFlags);	
+common/cmm_data_usb.c:	if (pAd->NullContext.InUse == FALSE)
+common/cmm_data_usb.c:		UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/cmm_data_usb.c:		pNullContext = &(pAd->NullContext);
+common/cmm_data_usb.c:			0, 0, (UCHAR)pAd->CommonCfg.MlmeTransmit.field.MCS, IFS_HTTXOP, FALSE, &pAd->CommonCfg.MlmeTransmit);
+common/cmm_data_usb.c:		pAd->NullContext.BulkOutSize =  TXINFO_SIZE + TXWISize + TSO_SIZE + frameLen + 4;
+common/cmm_data_usb.c:		DBGPRINT(RT_DEBUG_TRACE, ("%s - Send NULL Frame @%d Mbps...\n", __FUNCTION__, RateIdToMbps[pAd->CommonCfg.TxRate]));
+common/cmm_data_usb.c:		pAd->Sequence = (pAd->Sequence+1) & MAXSEQ;
+common/cmm_data_usb.c:	UINT8 RXWISize = pAd->chipCap.RXWISize;
+common/cmm_data_usb.c:	pRxContext = &pAd->RxContext[pAd->NextRxBulkInReadIndex];
+common/cmm_data_usb.c:	RxBufferLength = pRxContext->BulkInOffset - pAd->ReadPosition;
+common/cmm_data_usb.c:	pData = &pRxContext->TransferBuffer[pAd->ReadPosition];
+common/cmm_data_usb.c:								pAd->NextRxBulkInReadIndex, ThisFrameLen, pRxContext->BulkInOffset));     
+common/cmm_data_usb.c:								pAd->NextRxBulkInReadIndex, ThisFrameLen, pRxContext->BulkInOffset));
+common/cmm_data_usb.c:						pAd->NextRxBulkInReadIndex, ThisFrameLen, pRxContext->BulkInOffset, RxBufferLength, pAd->ReadPosition));
+common/cmm_data_usb.c:	pAd->ReadPosition += (ThisFrameLen + RXDMA_FIELD_SIZE + RXINFO_SIZE);	/* 8 for (RXDMA_FIELD_SIZE + sizeof(RXINFO_STRUC))*/
+common/cmm_data_usb.c:		dBm = (INT) (pRxWI->RxWIRSSI0) - pAd->BbpRssiToDbmDelta;
+common/cmm_data_usb.c:			pAd->StaCfg.RPIDensity[0] += 1;
+common/cmm_data_usb.c:			pAd->StaCfg.RPIDensity[1] += 1;
+common/cmm_data_usb.c:			pAd->StaCfg.RPIDensity[2] += 1;
+common/cmm_data_usb.c:			pAd->StaCfg.RPIDensity[3] += 1;
+common/cmm_data_usb.c:			pAd->StaCfg.RPIDensity[4] += 1;
+common/cmm_data_usb.c:			pAd->StaCfg.RPIDensity[5] += 1;
+common/cmm_data_usb.c:			pAd->StaCfg.RPIDensity[6] += 1;
+common/cmm_data_usb.c:			pAd->StaCfg.RPIDensity[7] += 1;
+common/cmm_data_usb.c:	pAd->StaCfg.CLBusyBytes += (pRxWI->RxWIMPDUByteCnt + 14);
+common/cmm_data_usb.c:            RTMPSendWirelessEvent(pAd, IW_ICV_ERROR_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);			
+common/cmm_data_usb.c:                RTMPSendWirelessEvent(pAd, IW_MIC_ERROR_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
+common/cmm_data_usb.c:			pWpaKey = &pAd->SharedKey[BSS0][pRxWI->RxWIKeyIndex];
+common/cmm_data_usb.c:            if (pAd->StaCfg.WpaSupplicantUP)
+common/cmm_data_usb.c:                WpaSendMicFailureToWpaSupplicant(pAd->net_dev, 
+common/cmm_data_usb.c:			(pAd->SharedKey[BSS0][pRxWI->RxWIKeyIndex].CipherAlg == CIPHER_AES) &&
+common/cmm_data_usb.c:			(pHeader->Sequence == pAd->FragFrame.Sequence))
+common/cmm_data_usb.c:	if (pAd && pAd->Mlme.AutoWakeupTimerRunning)
+common/cmm_data_usb.c:				RTMPSetTimer(&pAd->Mlme.AutoWakeupTimer, AUTO_WAKEUP_TIMEOUT);
+common/cmm_data_usb.c:		pAd->Mlme.AutoWakeupTimerRunning = FALSE;
+common/cmm_data_usb.c:	if (pAd->Mlme.AutoWakeupTimerRunning)
+common/cmm_data_usb.c:		RTMPCancelTimer(&pAd->Mlme.AutoWakeupTimer, &Canceled);
+common/cmm_data_usb.c:		pAd->Mlme.AutoWakeupTimerRunning = FALSE;
+common/cmm_data_usb.c:	if (pAd->CountDowntoPsm > 0)
+common/cmm_data_usb.c:	if (pAd->Mlme.AutoWakeupTimerRunning == TRUE)
+common/cmm_data_usb.c:	RTMPSetTimer(&pAd->Mlme.AutoWakeupTimer, AUTO_WAKEUP_TIMEOUT);
+common/cmm_data_usb.c:	pAd->Mlme.AutoWakeupTimerRunning = TRUE;
+common/cmm_data_usb.c:		if((pAd->PendingRx > 0) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+common/cmm_data_usb.c:			/* resend bulk-in IRPs to receive beacons after a period of (pAd->CommonCfg.BeaconPeriod - 40) ms*/
+common/cmm_data_usb.c:			pAd->PendingRx = 0;
+common/client_wds.c:	NdisAllocateSpinLock(pAd, &pAd->ApCfg.CliWdsTabLock);
+common/client_wds.c:/*	pAd->ApCfg.pCliWdsEntryPool = kmalloc(sizeof(CLIWDS_PROXY_ENTRY) * CLIWDS_POOL_SIZE, GFP_ATOMIC);*/
+common/client_wds.c:	os_alloc_mem(pAd, (UCHAR **)&(pAd->ApCfg.pCliWdsEntryPool), sizeof(CLIWDS_PROXY_ENTRY) * CLIWDS_POOL_SIZE);
+common/client_wds.c:	if (pAd->ApCfg.pCliWdsEntryPool)
+common/client_wds.c:		NdisZeroMemory(pAd->ApCfg.pCliWdsEntryPool, sizeof(CLIWDS_PROXY_ENTRY) * CLIWDS_POOL_SIZE);
+common/client_wds.c:		initList(&pAd->ApCfg.CliWdsEntryFreeList);
+common/client_wds.c:			insertTailList(&pAd->ApCfg.CliWdsEntryFreeList, (PLIST_ENTRY)(pAd->ApCfg.pCliWdsEntryPool + (ULONG)i));
+common/client_wds.c:		DBGPRINT(RT_DEBUG_ERROR, ("%s Fail to alloc memory for pAd->CommonCfg.pCliWdsEntryPool", __FUNCTION__));
+common/client_wds.c:		initList(&pAd->ApCfg.CliWdsProxyTab[idx]);
+common/client_wds.c:	NdisFreeSpinLock(&pAd->ApCfg.CliWdsTabLock);
+common/client_wds.c:			(PCLIWDS_PROXY_ENTRY)pAd->ApCfg.CliWdsProxyTab[idx].pHead;
+common/client_wds.c:	if (pAd->ApCfg.pCliWdsEntryPool)
+common/client_wds.c:/*		kfree(pAd->ApCfg.pCliWdsEntryPool);*/
+common/client_wds.c:		os_free_mem(NULL, pAd->ApCfg.pCliWdsEntryPool);
+common/client_wds.c:	pAd->ApCfg.pCliWdsEntryPool = NULL;	
+common/client_wds.c:	RTMP_SEM_LOCK(&pAd->ApCfg.CliWdsTabLock);
+common/client_wds.c:	pCliWdsEntry = (PCLIWDS_PROXY_ENTRY)removeHeadList(&pAd->ApCfg.CliWdsEntryFreeList);
+common/client_wds.c:	RTMP_SEM_UNLOCK(&pAd->ApCfg.CliWdsTabLock);
+common/client_wds.c:	RTMP_SEM_LOCK(&pAd->ApCfg.CliWdsTabLock);
+common/client_wds.c:	insertTailList(&pAd->ApCfg.CliWdsEntryFreeList, (PLIST_ENTRY)pCliWdsEntry);
+common/client_wds.c:	RTMP_SEM_UNLOCK(&pAd->ApCfg.CliWdsTabLock);
+common/client_wds.c:		(PCLIWDS_PROXY_ENTRY)pAd->ApCfg.CliWdsProxyTab[HashId].pHead;
+common/client_wds.c:				return pAd->MacTab.Content[pCliWdsEntry->Aid].Addr;
+common/client_wds.c:		insertTailList(&pAd->ApCfg.CliWdsProxyTab[HashId], (PLIST_ENTRY)pCliWdsEntry);
+common/client_wds.c:		pCliWdsEntry = (PCLIWDS_PROXY_ENTRY)(pAd->ApCfg.CliWdsProxyTab[idx].pHead);
+common/client_wds.c:				delEntryList(&pAd->ApCfg.CliWdsProxyTab[idx], (PLIST_ENTRY)pCliWdsEntry);
+common/ba_action.c:	if (pAd->MACVersion >= RALINK_2883_VERSION)
+common/ba_action.c:		if (pAd->MACVersion >= RALINK_3070_VERSION)
+common/ba_action.c:	else if (pAd->MACVersion >= RALINK_2880E_VERSION) /* 2880e */
+common/ba_action.c:	Tab = &pAd->BATable;
+common/ba_action.c:	NdisAcquireSpinLock(&pAd->BATabLock);
+common/ba_action.c:	NdisReleaseSpinLock(&pAd->BATabLock);
+common/ba_action.c:	NdisAcquireSpinLock(&pAd->mpdu_blk_pool.lock);
+common/ba_action.c:	os_free_mem(pAd, pAd->mpdu_blk_pool.mem);
+common/ba_action.c:	NdisReleaseSpinLock(&pAd->mpdu_blk_pool.lock);
+common/ba_action.c:	NdisAllocateSpinLock(pAd, &pAd->mpdu_blk_pool.lock);
+common/ba_action.c:	freelist = &pAd->mpdu_blk_pool.freelist;
+common/ba_action.c:	pAd->mpdu_blk_pool.mem = mem;
+common/ba_action.c:	NdisAcquireSpinLock(&pAd->mpdu_blk_pool.lock);
+common/ba_action.c:	mpdu_blk = ba_dequeue(&pAd->mpdu_blk_pool.freelist);
+common/ba_action.c:	NdisReleaseSpinLock(&pAd->mpdu_blk_pool.lock);
+common/ba_action.c:	NdisAcquireSpinLock(&pAd->mpdu_blk_pool.lock);
+common/ba_action.c:	ba_enqueue(&pAd->mpdu_blk_pool.freelist, mpdu_blk);
+common/ba_action.c:	NdisReleaseSpinLock(&pAd->mpdu_blk_pool.lock);
+common/ba_action.c:	if ((pAd->CommonCfg.BACapability.field.AutoBA != TRUE)  &&  (isForced == FALSE))
+common/ba_action.c:		pBAEntry =&pAd->BATable.BAOriEntry[Idx];
+common/ba_action.c:	pBAEntry->BAWinSize = pAd->CommonCfg.BACapability.field.RxBAWinLimit;   
+common/ba_action.c:	pBAEntry =&pAd->BATable.BAOriEntry[Idx];
+common/ba_action.c:		pAd->BATable.numDoneOriginator ++;
+common/ba_action.c:		BarHeaderInit(pAd, &FrameBar, pAd->MacTab.Content[pBAEntry->Wcid].Addr, pAd->MacTab.Content[pBAEntry->Wcid].HdrAddr2);
+common/ba_action.c:			if (IS_ENTRY_APCLI(&pAd->MacTab.Content[pBAEntry->Wcid]))
+common/ba_action.c:				apidx = pAd->MacTab.Content[pBAEntry->Wcid].MatchAPCLITabIdx;
+common/ba_action.c:				BarHeaderInit(pAd, &FrameBar, pAd->MacTab.Content[pBAEntry->Wcid].Addr, pAd->ApCfg.ApCliTab[apidx].CurrentAddress);
+common/ba_action.c:				apidx = pAd->MacTab.Content[pBAEntry->Wcid].apidx;
+common/ba_action.c:				BarHeaderInit(pAd, &FrameBar, pAd->MacTab.Content[pBAEntry->Wcid].Addr, pAd->ApCfg.MBSSID[apidx].Bssid);
+common/ba_action.c:			BarHeaderInit(pAd, &FrameBar, pAd->MacTab.Content[pBAEntry->Wcid].Addr, pAd->CurrentAddress);
+common/ba_action.c:	BAWinSize = min(((UCHAR)pFrame->BaParm.BufSize), (UCHAR)pAd->CommonCfg.BACapability.field.RxBAWinLimit);
+common/ba_action.c:		pBAEntry = &pAd->BATable.BARecEntry[Idx];
+common/ba_action.c:	DBGPRINT(RT_DEBUG_TRACE,("%s(%ld): Idx = %d, BAWinSize(req %d) = %d\n", __FUNCTION__, pAd->BATable.numAsRecipient, Idx, 
+common/ba_action.c:	NdisAcquireSpinLock(&pAd->BATabLock);
+common/ba_action.c:	if (pAd->BATable.numAsRecipient >= (MAX_LEN_OF_BA_REC_TABLE - 1))
+common/ba_action.c:							pAd->BATable.numAsRecipient, (MAX_LEN_OF_BA_REC_TABLE - 1)));
+common/ba_action.c:		pBAEntry =&pAd->BATable.BARecEntry[i];
+common/ba_action.c:			pAd->BATable.numAsRecipient++;
+common/ba_action.c:	NdisReleaseSpinLock(&pAd->BATabLock);
+common/ba_action.c:	NdisAcquireSpinLock(&pAd->BATabLock);
+common/ba_action.c:	if (pAd->BATable.numAsOriginator >= (MAX_LEN_OF_BA_ORI_TABLE - 1))
+common/ba_action.c:		pBAEntry =&pAd->BATable.BAOriEntry[i];
+common/ba_action.c:			pAd->BATable.numAsOriginator++;
+common/ba_action.c:	NdisReleaseSpinLock(&pAd->BATabLock);
+common/ba_action.c:	pBAEntry =&pAd->BATable.BAOriEntry[Idx];
+common/ba_action.c:		pEntry = &pAd->MacTab.Content[pBAEntry->Wcid];
+common/ba_action.c:		NdisAcquireSpinLock(&pAd->BATabLock);
+common/ba_action.c:			pAd->BATable.numDoneOriginator -= 1;
+common/ba_action.c:			DBGPRINT(RT_DEBUG_TRACE, ("BATableFreeOriEntry numAsOriginator= %ld\n", pAd->BATable.numAsRecipient));
+common/ba_action.c:		ASSERT(pAd->BATable.numAsOriginator != 0);
+common/ba_action.c:		pAd->BATable.numAsOriginator -= 1;
+common/ba_action.c:		NdisReleaseSpinLock(&pAd->BATabLock);
+common/ba_action.c:	pBAEntry =&pAd->BATable.BARecEntry[Idx];
+common/ba_action.c:		pEntry = &pAd->MacTab.Content[pBAEntry->Wcid];
+common/ba_action.c:		NdisAcquireSpinLock(&pAd->BATabLock);
+common/ba_action.c:		ASSERT(pAd->BATable.numAsRecipient != 0);
+common/ba_action.c:		pAd->BATable.numAsRecipient -= 1;
+common/ba_action.c:		NdisReleaseSpinLock(&pAd->BATabLock);
+common/ba_action.c:	Idx = pAd->MacTab.Content[Wcid].BAOriWcidArray[TID];
+common/ba_action.c:				COPY_MAC_ADDR(DelbaReq.Addr, pAd->MacTab.Content[Wcid].Addr);
+common/ba_action.c:	pBAEntry = &pAd->BATable.BAOriEntry[Idx];
+common/ba_action.c:			COPY_MAC_ADDR(DelbaReq.Addr, pAd->MacTab.Content[Wcid].Addr);
+common/ba_action.c:		/*BAOriSessionSetUp(pAd, &pAd->MacTab.Content[Wcid], TID, 0, 10000, TRUE);*/
+common/ba_action.c:	Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
+common/ba_action.c:	pBAEntry = &pAd->BATable.BARecEntry[Idx];
+common/ba_action.c:				COPY_MAC_ADDR(DelbaReq.Addr, pAd->MacTab.Content[Wcid].Addr);
+common/ba_action.c:		NdisAcquireSpinLock(&pAd->BATabLock);
+common/ba_action.c:		pAd->MacTab.Content[Wcid].RXBAbitmap &= (~(1<<(pBAEntry->TID)));
+common/ba_action.c:		pAd->MacTab.Content[Wcid].BARecWcidArray[TID] = 0;
+common/ba_action.c:		NdisReleaseSpinLock(&pAd->BATabLock);
+common/ba_action.c:	pEntry = &pAd->MacTab.Content[pBAEntry->Wcid];
+common/ba_action.c:	if ((pAd->OpMode == OPMODE_STA) && IS_ENTRY_CLIENT(pEntry) && IS_P2P_ENTRY_NONE(pEntry))
+common/ba_action.c:		AddbaReq.BaBufSize = pAd->CommonCfg.BACapability.field.RxBAWinLimit;
+common/ba_action.c:	pMacEntry = &pAd->MacTab.Content[Elem->Wcid];
+common/ba_action.c:		if ((pAd->CommonCfg.bBADecline == FALSE) && IS_HT_STA(pMacEntry))
+common/ba_action.c:			if (BARecSessionAdd(pAd, &pAd->MacTab.Content[Elem->Wcid], pAddreqFrame))
+common/ba_action.c:	if (IS_ENTRY_CLIENT(&pAd->MacTab.Content[Elem->Wcid]))
+common/ba_action.c:		ASSERT(pAd->MacTab.Content[Elem->Wcid].Sst == SST_ASSOC);
+common/ba_action.c:				|| (IS_ENTRY_DLS(&pAd->MacTab.Content[Elem->Wcid]))
+common/ba_action.c:				|| (IS_ENTRY_TDLS(&pAd->MacTab.Content[Elem->Wcid]))
+common/ba_action.c:				ActHeaderInit(pAd, &ADDframe.Hdr, pAddr, pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+common/ba_action.c:		if (IS_ENTRY_APCLI(&pAd->MacTab.Content[Elem->Wcid]))
+common/ba_action.c:			apidx = pAd->MacTab.Content[Elem->Wcid].MatchAPCLITabIdx;
+common/ba_action.c:			ActHeaderInit(pAd, &ADDframe.Hdr, pAddr, pAd->ApCfg.ApCliTab[apidx].CurrentAddress, pAddr);		
+common/ba_action.c:			apidx = pAd->MacTab.Content[Elem->Wcid].apidx;
+common/ba_action.c:			ActHeaderInit(pAd, &ADDframe.Hdr, pAddr, pAd->ApCfg.MBSSID[apidx].Bssid, pAd->ApCfg.MBSSID[apidx].Bssid);
+common/ba_action.c:			|| (IS_ENTRY_DLS(&pAd->MacTab.Content[Elem->Wcid]))
+common/ba_action.c:			|| (IS_ENTRY_TDLS(&pAd->MacTab.Content[Elem->Wcid]))
+common/ba_action.c:			ActHeaderInit(pAd, &ADDframe.Hdr, pAddr, pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+common/ba_action.c:			ActHeaderInit(pAd, &ADDframe.Hdr, pAd->CommonCfg.Bssid, pAd->CurrentAddress, pAddr);
+common/ba_action.c:	ADDframe.BaParm.BufSize = min(((UCHAR)pAddreqFrame->BaParm.BufSize), (UCHAR)pAd->CommonCfg.BACapability.field.RxBAWinLimit);
+common/ba_action.c:				BAOriSessionAdd(pAd, &pAd->MacTab.Content[Elem->Wcid], pFrame);
+common/ba_action.c:            || ((pAd->OpMode == OPMODE_STA) && STA_TGN_WIFI_ON(pAd) && (pFrame->StatusCode != 0))
+common/ba_action.c:			pAd->MacTab.Content[Elem->Wcid].BADeclineBitmap |= 1<<pFrame->BaParm.TID;
+common/ba_action.c:		Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
+common/ba_action.c:		pBAEntry = &pAd->BATable.BARecEntry[Idx];
+common/ba_action.c:		pEntry = &pAd->MacTab.Content[Wcid];
+common/ba_action.c:			ActHeaderInit(pAd, &Frame.Hdr, pAd->MacTab.Content[Wcid].Addr, pEntry->HdrAddr2, pEntry->HdrAddr3);
+common/ba_action.c:		if (IS_ENTRY_APCLI(&pAd->MacTab.Content[Wcid]))
+common/ba_action.c:			apidx = pAd->MacTab.Content[Wcid].MatchAPCLITabIdx;
+common/ba_action.c:			ActHeaderInit(pAd, &Frame.Hdr, pAd->MacTab.Content[Wcid].Addr, pAd->ApCfg.ApCliTab[apidx].CurrentAddress, pAd->MacTab.Content[Wcid].Addr);		
+common/ba_action.c:			apidx = pAd->MacTab.Content[Wcid].apidx;
+common/ba_action.c:			ActHeaderInit(pAd, &Frame.Hdr, pAd->MacTab.Content[Wcid].Addr, pAd->ApCfg.MBSSID[apidx].Bssid, pAd->ApCfg.MBSSID[apidx].Bssid);
+common/ba_action.c:		ActHeaderInit(pAd, &Frame.Hdr, pAd->CommonCfg.Bssid, pAd->CurrentAddress, pAd->MacTab.Content[Wcid].Addr);
+common/ba_action.c:	if (IS_ENTRY_APCLI(&pAd->MacTab.Content[Wcid]))
+common/ba_action.c:	apidx = pAd->MacTab.Content[Wcid].apidx;
+common/ba_action.c:	ActHeaderInit(pAd, &Frame.Hdr, pAd->MacTab.Content[Wcid].Addr, pAd->ApCfg.MBSSID[apidx].Bssid, pAd->ApCfg.MBSSID[apidx].Bssid);
+common/ba_action.c:		Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
+common/ba_action.c:		pBAEntry = &pAd->BATable.BARecEntry[Idx];
+common/ba_action.c:		Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
+common/ba_action.c:		pBAEntry = &pAd->BATable.BARecEntry[Idx];
+common/ba_action.c:        pEntry = &pAd->MacTab.Content[Wcid];
+common/ba_action.c:            Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
+common/ba_action.c:            pBAEntry = &pAd->BATable.BARecEntry[Idx];
+common/wsc_ufd.c:	PWSC_CREDENTIAL     pCredential = &pAd->ApCfg.MBSSID[ApIdx].WscControl.WscProfile.Profile[0];
+common/wsc_ufd.c:							  &pAd->ApCfg.MBSSID[ApIdx].WscControl, 
+common/wsc_ufd.c:							  &pAd->ApCfg.MBSSID[ApIdx].WscControl.WscProfile.Profile[0], TRUE);
+common/wsc_ufd.c:		pAd->WriteWscCfgToDatFile = ApIdx;
+common/wsc_ufd.c:		RtmpOsTaskWakeUp(&(pAd->wscTask));
+common/wsc_ufd.c:	PWSC_CTRL           pWscControl = &pAd->ApCfg.MBSSID[ApIdx].WscControl;
+common/cmm_profile.c:		pAd->StaCfg.DefaultKeyId = (UCHAR) (KeyIdx - 1);
+common/cmm_profile.c:		pAd->StaCfg.DefaultKeyId = 0;
+common/cmm_profile.c:	pSharedKey = &pAd->SharedKey[BSSIdx][KeyIdx];
+common/cmm_profile.c:				if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:					pAd->ApCfg.MBSSID[i].DefaultKeyId = (UCHAR) (KeyIdx - 1 );
+common/cmm_profile.c:					pAd->ApCfg.MBSSID[i].DefaultKeyId = 0;
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("I/F(ra%d) DefaultKeyID(0~3)=%d\n", i, pAd->ApCfg.MBSSID[i].DefaultKeyId));
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("DefaultKeyID(0~3)=%d\n", pAd->StaCfg.DefaultKeyId));
+common/cmm_profile.c:					//GPRINT(RT_DEBUG_TRACE, ("pAd->ApCfg.BssidNum=%d\n", pAd->ApCfg.BssidNum));
+common/cmm_profile.c:					for (i = 0; i < pAd->ApCfg.BssidNum; i++)
+common/cmm_profile.c:							if (pAd->ApCfg.BssidNum == 1)
+common/cmm_profile.c:			pApCliEntry = &pAd->ApCfg.ApCliTab[i];
+common/cmm_profile.c:			pApCliEntry = &pAd->ApCfg.ApCliTab[i];
+common/cmm_profile.c:			pApCliEntry = &pAd->ApCfg.ApCliTab[i];
+common/cmm_profile.c:			pApCliEntry = &pAd->ApCfg.ApCliTab[i];
+common/cmm_profile.c:			pApCliEntry = &pAd->ApCfg.ApCliTab[i];
+common/cmm_profile.c:			pApCliEntry = &pAd->ApCfg.ApCliTab[i];
+common/cmm_profile.c:			pApCliEntry = &pAd->ApCfg.ApCliTab[i];
+common/cmm_profile.c:					pApCliEntry = &pAd->ApCfg.ApCliTab[i];
+common/cmm_profile.c:			pApCliEntry = &pAd->ApCfg.ApCliTab[i];
+common/cmm_profile.c:			pApCliEntry = &pAd->ApCfg.ApCliTab[i];
+common/cmm_profile.c:				pAd->ApCfg.ApCliTab[0].WscControl.WscEnrollee4digitPinCode = TRUE;
+common/cmm_profile.c:				pAd->ApCfg.ApCliTab[0].WscControl.WscEnrollee4digitPinCode = FALSE;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("I/F(apcli%d) ApCli_Wsc4digitPinCode=%d\n", i, pAd->ApCfg.ApCliTab[0].WscControl.WscEnrollee4digitPinCode));
+common/cmm_profile.c:		pAd->ApCfg.FlgApCliIsUapsdInfoUpdated = TRUE;
+common/cmm_profile.c:			pApCliEntry = &pAd->ApCfg.ApCliTab[i];
+common/cmm_profile.c:		memset(&pAd->ApCfg.MBSSID[idx].AccessControlList, 0, sizeof(RT_802_11_ACL));
+common/cmm_profile.c:					pAd->ApCfg.MBSSID[idx].AccessControlList.Policy = 1;
+common/cmm_profile.c:					pAd->ApCfg.MBSSID[idx].AccessControlList.Policy = 2;
+common/cmm_profile.c:					pAd->ApCfg.MBSSID[idx].AccessControlList.Policy = 0;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("%s=%ld\n", tok_str, pAd->ApCfg.MBSSID[idx].AccessControlList.Policy));
+common/cmm_profile.c:				ASSERT(pAd->ApCfg.MBSSID[idx].AccessControlList.Num <= MAX_NUM_OF_ACL_LIST);
+common/cmm_profile.c:				if (pAd->ApCfg.MBSSID[idx].AccessControlList.Num == MAX_NUM_OF_ACL_LIST)
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[idx].AccessControlList.Num++;
+common/cmm_profile.c:				NdisMoveMemory(pAd->ApCfg.MBSSID[idx].AccessControlList.Entry[(pAd->ApCfg.MBSSID[idx].AccessControlList.Num - 1)].Addr, macAddress, ETH_LENGTH_OF_ADDRESS);				
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("%s=Get %ld Mac Address\n", tok_str, pAd->ApCfg.MBSSID[idx].AccessControlList.Num));
+common/cmm_profile.c:			if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[i].bWmmCapable = TRUE;
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[i].bWmmCapable = FALSE;
+common/cmm_profile.c:				pAd->CommonCfg.APEdcaParm.bValid = TRUE;
+common/cmm_profile.c:				pAd->ApCfg.BssEdcaParm.bValid = TRUE;
+common/cmm_profile.c:				pAd->CommonCfg.APEdcaParm.bValid = FALSE;
+common/cmm_profile.c:				pAd->ApCfg.BssEdcaParm.bValid = FALSE;
+common/cmm_profile.c:			pAd->ApCfg.MBSSID[i].bWmmCapableOrg = \
+common/cmm_profile.c:											pAd->ApCfg.MBSSID[i].bWmmCapable;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("I/F(ra%d) WmmCapable=%d\n", i, pAd->ApCfg.MBSSID[i].bWmmCapable));
+common/cmm_profile.c:			if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[i].bDLSCapable = TRUE;
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[i].bDLSCapable = FALSE;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("I/F(ra%d) DLSCapable=%d\n", i, pAd->ApCfg.MBSSID[i].bDLSCapable));
+common/cmm_profile.c:			pAd->CommonCfg.APEdcaParm.Aifsn[i] = (UCHAR) simple_strtol(macptr, 0, 10);;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("APAifsn[%d]=%d\n", i, pAd->CommonCfg.APEdcaParm.Aifsn[i]));
+common/cmm_profile.c:			pAd->CommonCfg.APEdcaParm.Cwmin[i] = (UCHAR) simple_strtol(macptr, 0, 10);;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("APCwmin[%d]=%d\n", i, pAd->CommonCfg.APEdcaParm.Cwmin[i]));
+common/cmm_profile.c:			pAd->CommonCfg.APEdcaParm.Cwmax[i] = (UCHAR) simple_strtol(macptr, 0, 10);;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("APCwmax[%d]=%d\n", i, pAd->CommonCfg.APEdcaParm.Cwmax[i]));
+common/cmm_profile.c:			pAd->CommonCfg.APEdcaParm.Txop[i] = (USHORT) simple_strtol(macptr, 0, 10);;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("APTxop[%d]=%d\n", i, pAd->CommonCfg.APEdcaParm.Txop[i]));
+common/cmm_profile.c:			pAd->CommonCfg.APEdcaParm.bACM[i] = (BOOLEAN) simple_strtol(macptr, 0, 10);;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("APACM[%d]=%d\n", i, pAd->CommonCfg.APEdcaParm.bACM[i]));
+common/cmm_profile.c:			pAd->ApCfg.BssEdcaParm.Aifsn[i] = (UCHAR) simple_strtol(macptr, 0, 10);;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("BSSAifsn[%d]=%d\n", i, pAd->ApCfg.BssEdcaParm.Aifsn[i]));
+common/cmm_profile.c:			pAd->ApCfg.BssEdcaParm.Cwmin[i] = (UCHAR) simple_strtol(macptr, 0, 10);;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("BSSCwmin[%d]=%d\n", i, pAd->ApCfg.BssEdcaParm.Cwmin[i]));
+common/cmm_profile.c:			pAd->ApCfg.BssEdcaParm.Cwmax[i] = (UCHAR) simple_strtol(macptr, 0, 10);;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("BSSCwmax[%d]=%d\n", i, pAd->ApCfg.BssEdcaParm.Cwmax[i]));
+common/cmm_profile.c:			pAd->ApCfg.BssEdcaParm.Txop[i] = (USHORT) simple_strtol(macptr, 0, 10);;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("BSSTxop[%d]=%d\n", i, pAd->ApCfg.BssEdcaParm.Txop[i]));
+common/cmm_profile.c:			pAd->ApCfg.BssEdcaParm.bACM[i] = (BOOLEAN) simple_strtol(macptr, 0, 10);;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("BSSACM[%d]=%d\n", i, pAd->ApCfg.BssEdcaParm.bACM[i]));
+common/cmm_profile.c:			pAd->CommonCfg.AckPolicy[i] = (UCHAR) simple_strtol(macptr, 0, 10);;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("AckPolicy[%d]=%d\n", i, pAd->CommonCfg.AckPolicy[i]));
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[i].UapsdInfo.bAPSDCapable = \
+common/cmm_profile.c:						pAd->ApCfg.MBSSID[i].UapsdInfo.bAPSDCapable));
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[i].UapsdInfo.bAPSDCapable =
+common/cmm_profile.c:							pAd->ApCfg.MBSSID[0].UapsdInfo.bAPSDCapable;
+common/cmm_profile.c:						pAd->ApCfg.MBSSID[i].UapsdInfo.bAPSDCapable));
+common/cmm_profile.c:		if (pAd->ApCfg.FlgApCliIsUapsdInfoUpdated == FALSE)
+common/cmm_profile.c:				pAd->ApCfg.ApCliTab[i].UapsdInfo.bAPSDCapable = \
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[0].UapsdInfo.bAPSDCapable;
+common/cmm_profile.c:						i, pAd->ApCfg.ApCliTab[i].UapsdInfo.bAPSDCapable));
+common/cmm_profile.c:		pAd->ApCfg.session_timeout_interval = simple_strtol(tmpbuf, 0, 10); 
+common/cmm_profile.c:		DBGPRINT(RT_DEBUG_TRACE, ("session_timeout_interval=%d\n", pAd->ApCfg.session_timeout_interval));
+common/cmm_profile.c:		pAd->ApCfg.quiet_interval = simple_strtol(tmpbuf, 0, 10); 
+common/cmm_profile.c:		DBGPRINT(RT_DEBUG_TRACE, ("quiet_interval=%d\n", pAd->ApCfg.quiet_interval));
+common/cmm_profile.c:			if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[i].PreAuth = TRUE;
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[i].PreAuth = FALSE;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("I/F(ra%d) PreAuth=%d\n", i, pAd->ApCfg.MBSSID[i].PreAuth));
+common/cmm_profile.c:			if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[i].IEEE8021X = TRUE;
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[i].IEEE8021X = FALSE;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d), IEEE8021X=%d\n", i, pAd->ApCfg.MBSSID[i].IEEE8021X));
+common/cmm_profile.c:			if (rtinet_aton(macptr, &ip_addr) && pAd->ApCfg.MBSSID[i].radius_srv_num < MAX_RADIUS_SRV_NUM)
+common/cmm_profile.c:				INT	srv_idx = pAd->ApCfg.MBSSID[i].radius_srv_num;
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[i].radius_srv_info[srv_idx].radius_ip = ip_addr;
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[i].radius_srv_num++;
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d), radius_ip(seq-%d)=%s(%x)\n", i, pAd->ApCfg.MBSSID[i].radius_srv_num, macptr, pAd->ApCfg.MBSSID[i].radius_srv_info[srv_idx].radius_ip));
+common/cmm_profile.c:			if (count[i] < pAd->ApCfg.MBSSID[i].radius_srv_num)
+common/cmm_profile.c:            	pAd->ApCfg.MBSSID[i].radius_srv_info[srv_idx].radius_port = (UINT32) simple_strtol(macptr, 0, 10); 
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d), radius_port(seq-%d)=%d\n", i, count[i], pAd->ApCfg.MBSSID[i].radius_srv_info[srv_idx].radius_port));
+common/cmm_profile.c:			if (strlen(macptr) > 0 && (count[i] < pAd->ApCfg.MBSSID[i].radius_srv_num))
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[i].radius_srv_info[srv_idx].radius_key_len = strlen(macptr); 
+common/cmm_profile.c:				NdisMoveMemory(pAd->ApCfg.MBSSID[i].radius_srv_info[srv_idx].radius_key, macptr, strlen(macptr));
+common/cmm_profile.c:															pAd->ApCfg.MBSSID[i].radius_srv_info[srv_idx].radius_key, 
+common/cmm_profile.c:															pAd->ApCfg.MBSSID[i].radius_srv_info[srv_idx].radius_key_len));
+common/cmm_profile.c:	for (i = 0; i < pAd->ApCfg.BssidNum; i++)
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[i].NasIdLen = strlen(tmpbuf); 
+common/cmm_profile.c:				NdisMoveMemory(pAd->ApCfg.MBSSID[i].NasId, tmpbuf, strlen(tmpbuf));
+common/cmm_profile.c:												pAd->ApCfg.MBSSID[i].NasId, 
+common/cmm_profile.c:												pAd->ApCfg.MBSSID[i].NasIdLen));
+common/cmm_profile.c:				if (strlen(tmpbuf) > 0 && (srv_idx < pAd->ApCfg.MBSSID[i].radius_srv_num))
+common/cmm_profile.c:					pAd->ApCfg.MBSSID[i].radius_srv_info[srv_idx].radius_key_len = strlen(tmpbuf); 
+common/cmm_profile.c:					NdisMoveMemory(pAd->ApCfg.MBSSID[i].radius_srv_info[srv_idx].radius_key, tmpbuf, strlen(tmpbuf));					
+common/cmm_profile.c:																pAd->ApCfg.MBSSID[i].radius_srv_info[srv_idx].radius_key, 
+common/cmm_profile.c:																pAd->ApCfg.MBSSID[i].radius_srv_info[srv_idx].radius_key_len));
+common/cmm_profile.c:	ret = RT_CfgSetWPAPSKKey(pAd, tmpbuf, len, (PUCHAR)pAd->ApCfg.MBSSID[i].Ssid, pAd->ApCfg.MBSSID[i].SsidLen, pAd->ApCfg.MBSSID[i].PMK);
+common/cmm_profile.c:	NdisZeroMemory(pAd->ApCfg.MBSSID[i].WscControl.WpaPsk, 64);
+common/cmm_profile.c:	pAd->ApCfg.MBSSID[i].WscControl.WpaPskLen = 0;
+common/cmm_profile.c:		NdisMoveMemory(pAd->ApCfg.MBSSID[i].WscControl.WpaPsk, tmpbuf, len);
+common/cmm_profile.c:		pAd->ApCfg.MBSSID[i].WscControl.WpaPskLen = len;
+common/cmm_profile.c:			pAd->CommonCfg.bWmmCapable = TRUE;
+common/cmm_profile.c:			pAd->CommonCfg.bWmmCapable = FALSE;
+common/cmm_profile.c:		DBGPRINT(RT_DEBUG_TRACE, ("WmmCapable=%d\n", pAd->CommonCfg.bWmmCapable));
+common/cmm_profile.c:			pAd->CommonCfg.bDLSCapable = TRUE;
+common/cmm_profile.c:			pAd->CommonCfg.bDLSCapable = FALSE;
+common/cmm_profile.c:		DBGPRINT(RT_DEBUG_TRACE, ("bDLSCapable=%d\n", pAd->CommonCfg.bDLSCapable));
+common/cmm_profile.c:			pAd->CommonCfg.AckPolicy[i] = (UCHAR)simple_strtol(macptr, 0, 10);
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("AckPolicy[%d]=%d\n", i, pAd->CommonCfg.AckPolicy[i]));
+common/cmm_profile.c:				pAd->StaCfg.UapsdInfo.bAPSDCapable = TRUE;
+common/cmm_profile.c:				pAd->StaCfg.UapsdInfo.bAPSDCapable = FALSE;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("APSDCapable=%d\n", pAd->StaCfg.UapsdInfo.bAPSDCapable));
+common/cmm_profile.c:			pAd->CommonCfg.MaxSPLength = simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("MaxSPLength=%d\n", pAd->CommonCfg.MaxSPLength));
+common/cmm_profile.c:			pAd->CommonCfg.bAPSDAC_BE = apsd_ac[0];
+common/cmm_profile.c:			pAd->CommonCfg.bAPSDAC_BK = apsd_ac[1];
+common/cmm_profile.c:			pAd->CommonCfg.bAPSDAC_VI = apsd_ac[2];
+common/cmm_profile.c:			pAd->CommonCfg.bAPSDAC_VO = apsd_ac[3];
+common/cmm_profile.c:			pAd->CommonCfg.bACMAPSDTr[0] = apsd_ac[0];
+common/cmm_profile.c:			pAd->CommonCfg.bACMAPSDTr[1] = apsd_ac[1];
+common/cmm_profile.c:			pAd->CommonCfg.bACMAPSDTr[2] = apsd_ac[2];
+common/cmm_profile.c:			pAd->CommonCfg.bACMAPSDTr[3] = apsd_ac[3];
+common/cmm_profile.c:			pAd->StaCfg.PSPXlink = TRUE;
+common/cmm_profile.c:			pAd->StaCfg.PSPXlink = FALSE;
+common/cmm_profile.c:		if (pAd->StaCfg.PSPXlink)
+common/cmm_profile.c:		DBGPRINT(RT_DEBUG_TRACE, ("PSP_XLINK_MODE=%d\n", pAd->StaCfg.PSPXlink));
+common/cmm_profile.c:			pAd->CommonCfg.vht_bw = VHT_BW_80;
+common/cmm_profile.c:			pAd->CommonCfg.vht_bw = VHT_BW_2040;
+common/cmm_profile.c:	pAd->CommonCfg.Channel = 40;
+common/cmm_profile.c:	for (i = 0; i < pAd->ApCfg.BssidNum; i++)
+common/cmm_profile.c:                pAd->ApCfg.MBSSID[i].PhyMode = cfgmode_2_wmode(cfg_mode);
+common/cmm_profile.c:                DBGPRINT(RT_DEBUG_TRACE, ("BSS%d PhyMode=%d\n", i, pAd->ApCfg.MBSSID[i].PhyMode));
+common/cmm_profile.c:                	for(IdBss=1; IdBss<pAd->ApCfg.BssidNum; IdBss++)
+common/cmm_profile.c:                        	pAd->ApCfg.MBSSID[IdBss].PhyMode = pAd->ApCfg.MBSSID[0].PhyMode;
+common/cmm_profile.c:        DBGPRINT(RT_DEBUG_TRACE, ("PhyMode=%d\n", pAd->CommonCfg.PhyMode));
+common/cmm_profile.c:	pAd->CommonCfg.RegTransmitSetting.field.BW = BW_40;
+common/cmm_profile.c:	pAd->CommonCfg.RegTransmitSetting.field.EXTCHA  = EXTCHA_BELOW;
+common/cmm_profile.c:	pAd->CommonCfg.vht_bw = VHT_BW_80;
+common/cmm_profile.c:            pAd->CommonCfg.bHTProtect = FALSE;
+common/cmm_profile.c:            pAd->CommonCfg.bHTProtect = TRUE;
+common/cmm_profile.c:			pAd->CommonCfg.BACapability.field.MMPSmode = MMPS_ENABLE;
+common/cmm_profile.c:            pAd->CommonCfg.BACapability.field.MMPSmode = MMPS_ENABLE;
+common/cmm_profile.c:			/*pAd->CommonCfg.BACapability.field.MMPSmode = Value;*/
+common/cmm_profile.c:            pAd->CommonCfg.bBADecline = FALSE;
+common/cmm_profile.c:            pAd->CommonCfg.bBADecline = TRUE;
+common/cmm_profile.c:            pAd->CommonCfg.BACapability.field.AutoBA = FALSE;
+common/cmm_profile.c:			pAd->CommonCfg.BACapability.field.Policy = BA_NOTUSE;
+common/cmm_profile.c:            pAd->CommonCfg.BACapability.field.AutoBA = TRUE;
+common/cmm_profile.c:			pAd->CommonCfg.BACapability.field.Policy = IMMED_BA;
+common/cmm_profile.c:        pAd->CommonCfg.REGBACapability.field.AutoBA = pAd->CommonCfg.BACapability.field.AutoBA;
+common/cmm_profile.c:		pAd->CommonCfg.REGBACapability.field.Policy = pAd->CommonCfg.BACapability.field.Policy;
+common/cmm_profile.c:			pAd->HTCEnable = FALSE;
+common/cmm_profile.c:            pAd->HTCEnable = TRUE;
+common/cmm_profile.c:			pAd->CommonCfg.bRdg = FALSE;
+common/cmm_profile.c:			pAd->HTCEnable = TRUE;
+common/cmm_profile.c:            pAd->CommonCfg.bRdg = TRUE;
+common/cmm_profile.c:			pAd->CommonCfg.BACapability.field.AmsduEnable = FALSE;
+common/cmm_profile.c:            pAd->CommonCfg.BACapability.field.AmsduEnable = TRUE;
+common/cmm_profile.c:			pAd->CommonCfg.BACapability.field.MpduDensity = Value;
+common/cmm_profile.c:			pAd->CommonCfg.BACapability.field.MpduDensity = 4;
+common/cmm_profile.c:			pAd->CommonCfg.REGBACapability.field.RxBAWinLimit = Value;
+common/cmm_profile.c:			pAd->CommonCfg.BACapability.field.RxBAWinLimit = Value;
+common/cmm_profile.c:            pAd->CommonCfg.REGBACapability.field.RxBAWinLimit = 64;
+common/cmm_profile.c:			pAd->CommonCfg.BACapability.field.RxBAWinLimit = 64;
+common/cmm_profile.c:			pAd->CommonCfg.RegTransmitSetting.field.ShortGI = GI_400;
+common/cmm_profile.c:			pAd->CommonCfg.RegTransmitSetting.field.ShortGI = GI_800;
+common/cmm_profile.c:			pAd->CommonCfg.RegTransmitSetting.field.HTMODE  = HTMODE_GF;
+common/cmm_profile.c:			pAd->CommonCfg.RegTransmitSetting.field.HTMODE  = HTMODE_MM;
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[i].DesiredTransmitSetting.field.FixedTxMode = 
+common/cmm_profile.c:											pAd->ApCfg.MBSSID[i].DesiredTransmitSetting.field.FixedTxMode));							
+common/cmm_profile.c:			pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode = 
+common/cmm_profile.c:											pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode));			
+common/cmm_profile.c:			pAd->CommonCfg.RegTransmitSetting.field.BW = BW_40;
+common/cmm_profile.c:			pAd->CommonCfg.RegTransmitSetting.field.BW = BW_20;
+common/cmm_profile.c:		pAd->CommonCfg.MCastPhyMode.field.BW = pAd->CommonCfg.RegTransmitSetting.field.BW;
+common/cmm_profile.c:			pAd->CommonCfg.RegTransmitSetting.field.EXTCHA  = EXTCHA_BELOW;
+common/cmm_profile.c:			pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_ABOVE;
+common/cmm_profile.c:					pAd->ApCfg.MBSSID[i].DesiredTransmitSetting.field.MCS  = Value;
+common/cmm_profile.c:					pAd->ApCfg.MBSSID[i].DesiredTransmitSetting.field.MCS  = MCS_AUTO;
+common/cmm_profile.c:						(pAd->ApCfg.MBSSID[i].DesiredTransmitSetting.field.MCS == MCS_AUTO ? "AUTO" : "Fixed"),
+common/cmm_profile.c:						pAd->ApCfg.MBSSID[i].DesiredTransmitSetting.field.MCS));
+common/cmm_profile.c:				pAd->StaCfg.DesiredTransmitSetting.field.MCS  = Value;
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[MAIN_MBSSID].DesiredTransmitSetting.field.MCS  = Value;
+common/cmm_profile.c:				pAd->StaCfg.bAutoTxRateSwitch = FALSE;
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("HT: MCS = %d\n", pAd->StaCfg.DesiredTransmitSetting.field.MCS));
+common/cmm_profile.c:				pAd->StaCfg.DesiredTransmitSetting.field.MCS  = MCS_AUTO;
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[MAIN_MBSSID].DesiredTransmitSetting.field.MCS  = MCS_AUTO;
+common/cmm_profile.c:				pAd->StaCfg.bAutoTxRateSwitch = TRUE;
+common/cmm_profile.c:			pAd->CommonCfg.RegTransmitSetting.field.STBC = STBC_USE;
+common/cmm_profile.c:			pAd->CommonCfg.RegTransmitSetting.field.STBC = STBC_NONE;
+common/cmm_profile.c:		DBGPRINT(RT_DEBUG_TRACE, ("HT: STBC = %d\n", pAd->CommonCfg.RegTransmitSetting.field.STBC));
+common/cmm_profile.c:			pAd->CommonCfg.bForty_Mhz_Intolerant = FALSE;
+common/cmm_profile.c:			pAd->CommonCfg.bForty_Mhz_Intolerant = TRUE;
+common/cmm_profile.c:		DBGPRINT(RT_DEBUG_TRACE, ("HT: 40MHZ INTOLERANT = %d\n", pAd->CommonCfg.bForty_Mhz_Intolerant));
+common/cmm_profile.c:				pAd->CommonCfg.TxStream = 1;
+common/cmm_profile.c:				pAd->CommonCfg.TxStream = 2;
+common/cmm_profile.c:				pAd->CommonCfg.TxStream = 3;
+common/cmm_profile.c:				if (pAd->MACVersion < RALINK_2883_VERSION)
+common/cmm_profile.c:					pAd->CommonCfg.TxStream = 2; /* only 2 tx streams for RT2860 series*/
+common/cmm_profile.c:		DBGPRINT(RT_DEBUG_TRACE, ("HT: Tx Stream = %d\n", pAd->CommonCfg.TxStream));
+common/cmm_profile.c:				pAd->CommonCfg.RxStream = 1;
+common/cmm_profile.c:				pAd->CommonCfg.RxStream = 2;
+common/cmm_profile.c:				pAd->CommonCfg.RxStream = 3;
+common/cmm_profile.c:				if (pAd->MACVersion < RALINK_2883_VERSION)
+common/cmm_profile.c:					pAd->CommonCfg.RxStream = 2; /* only 2 rx streams for RT2860 series*/
+common/cmm_profile.c:		DBGPRINT(RT_DEBUG_TRACE, ("HT: Rx Stream = %d\n", pAd->CommonCfg.RxStream));
+common/cmm_profile.c:			pAd->ApCfg.bGreenAPEnable = FALSE;
+common/cmm_profile.c:			pAd->ApCfg.bGreenAPEnable = TRUE;
+common/cmm_profile.c:		DBGPRINT(RT_DEBUG_TRACE, ("HT: Green AP= %d\n", pAd->ApCfg.bGreenAPEnable));
+common/cmm_profile.c:			pAd->CommonCfg.HT_DisallowTKIP = TRUE;
+common/cmm_profile.c:			pAd->CommonCfg.HT_DisallowTKIP = FALSE;
+common/cmm_profile.c:		DBGPRINT(RT_DEBUG_TRACE, ("HT: Disallow TKIP mode = %s\n", (pAd->CommonCfg.HT_DisallowTKIP == TRUE) ? "ON" : "OFF" ));
+common/cmm_profile.c:								pAd->CommonCfg.Dot11OBssScanPassiveDwell = ObssScanValue;	/* Unit : TU. 5~1000*/
+common/cmm_profile.c:								pAd->CommonCfg.Dot11OBssScanActiveDwell = ObssScanValue;	/* Unit : TU. 10~1000*/
+common/cmm_profile.c:							pAd->CommonCfg.Dot11BssWidthTriggerScanInt = ObssScanValue;	/* Unit : Second*/
+common/cmm_profile.c:								pAd->CommonCfg.Dot11OBssScanPassiveTotalPerChannel = ObssScanValue;	/* Unit : TU. 200~10000*/
+common/cmm_profile.c:								pAd->CommonCfg.Dot11OBssScanActiveTotalPerChannel = ObssScanValue;	/* Unit : TU. 20~10000*/
+common/cmm_profile.c:							pAd->CommonCfg.Dot11BssWidthChanTranDelayFactor = ObssScanValue;
+common/cmm_profile.c:							pAd->CommonCfg.Dot11OBssScanActivityThre = ObssScanValue;	/* Unit : percentage*/
+common/cmm_profile.c:					pAd->CommonCfg.Dot11OBssScanPassiveDwell = dot11OBSSScanPassiveDwell;	/* Unit : TU. 5~1000*/
+common/cmm_profile.c:					pAd->CommonCfg.Dot11OBssScanActiveDwell = dot11OBSSScanActiveDwell;	/* Unit : TU. 10~1000*/
+common/cmm_profile.c:					pAd->CommonCfg.Dot11BssWidthTriggerScanInt = dot11BSSWidthTriggerScanInterval;	/* Unit : Second	*/
+common/cmm_profile.c:					pAd->CommonCfg.Dot11OBssScanPassiveTotalPerChannel = dot11OBSSScanPassiveTotalPerChannel;	/* Unit : TU. 200~10000*/
+common/cmm_profile.c:					pAd->CommonCfg.Dot11OBssScanActiveTotalPerChannel = dot11OBSSScanActiveTotalPerChannel;	/* Unit : TU. 20~10000*/
+common/cmm_profile.c:					pAd->CommonCfg.Dot11BssWidthChanTranDelayFactor = dot11BSSWidthChannelTransactionDelayFactor;
+common/cmm_profile.c:					pAd->CommonCfg.Dot11OBssScanActivityThre = dot11BSSScanActivityThreshold;	/* Unit : percentage*/
+common/cmm_profile.c:				pAd->CommonCfg.Dot11BssWidthChanTranDelay = (pAd->CommonCfg.Dot11BssWidthTriggerScanInt * pAd->CommonCfg.Dot11BssWidthChanTranDelayFactor);
+common/cmm_profile.c:							DBGPRINT(RT_DEBUG_TRACE, ("OBSSScanParam for Dot11BssWidthChanTranDelay=%ld\n", pAd->CommonCfg.Dot11BssWidthChanTranDelay));
+common/cmm_profile.c:				pAd->CommonCfg.bBssCoexEnable = ((Value == 1) ? TRUE : FALSE);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("HT: 20/40 BssCoexSupport = %s\n", (pAd->CommonCfg.bBssCoexEnable == TRUE) ? "ON" : "OFF" ));
+common/cmm_profile.c:				pAd->CommonCfg.BssCoexApCntThr = simple_strtol(pValueStr, 0, 10);;
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("HT: 20/40 BssCoexApCntThr = %d\n", pAd->CommonCfg.BssCoexApCntThr));
+common/cmm_profile.c:		pAd->CommonCfg.bRalinkBurstMode = ((Value == 1) ? 1 : 0);
+common/cmm_profile.c:		DBGPRINT(RT_DEBUG_TRACE, ("HT: RaBurstMode= %d\n", pAd->CommonCfg.bRalinkBurstMode));
+common/cmm_profile.c:	pAd->CommonCfg.SsidLen = (UCHAR) strlen(SSID);
+common/cmm_profile.c:	NdisZeroMemory(pAd->CommonCfg.Ssid, NDIS_802_11_LENGTH_SSID);
+common/cmm_profile.c:	NdisMoveMemory(pAd->CommonCfg.Ssid, SSID, pAd->CommonCfg.SsidLen);
+common/cmm_profile.c:	pAd->CommonCfg.LastSsidLen= pAd->CommonCfg.SsidLen;
+common/cmm_profile.c:	NdisZeroMemory(pAd->CommonCfg.LastSsid, NDIS_802_11_LENGTH_SSID);
+common/cmm_profile.c:	NdisMoveMemory(pAd->CommonCfg.LastSsid, SSID, pAd->CommonCfg.LastSsidLen);
+common/cmm_profile.c:	pAd->MlmeAux.AutoReconnectSsidLen = pAd->CommonCfg.SsidLen;
+common/cmm_profile.c:	NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, NDIS_802_11_LENGTH_SSID);
+common/cmm_profile.c:	NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid, SSID, pAd->MlmeAux.AutoReconnectSsidLen);
+common/cmm_profile.c:	pAd->MlmeAux.SsidLen = pAd->CommonCfg.SsidLen;
+common/cmm_profile.c:	NdisZeroMemory(pAd->MlmeAux.Ssid, NDIS_802_11_LENGTH_SSID);
+common/cmm_profile.c:	NdisMoveMemory(pAd->MlmeAux.Ssid, SSID, pAd->MlmeAux.SsidLen);
+common/cmm_profile.c:	if ((pAd->StaCfg.AuthMode != Ndis802_11AuthModeWPAPSK) &&
+common/cmm_profile.c:		(pAd->StaCfg.AuthMode != Ndis802_11AuthModeWPA2PSK) &&
+common/cmm_profile.c:		(pAd->StaCfg.AuthMode != Ndis802_11AuthModeWPANone) 
+common/cmm_profile.c:		&& (pAd->StaCfg.AuthMode != Ndis802_11AuthModeWAICERT)
+common/cmm_profile.c:		&& (pAd->StaCfg.AuthMode != Ndis802_11AuthModeWAIPSK)
+common/cmm_profile.c:		ret = RT_CfgSetWPAPSKKey(pAd, PassPh, strlen(PassPh), (PUCHAR)pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen, pAd->StaCfg.PMK);
+common/cmm_profile.c:		RTMPZeroMemory(pAd->StaCfg.WpaPassPhrase, 64);
+common/cmm_profile.c:		RTMPMoveMemory(pAd->StaCfg.WpaPassPhrase, PassPh, strlen(PassPh));
+common/cmm_profile.c:		pAd->StaCfg.WpaPassPhraseLen= strlen(PassPh);
+common/cmm_profile.c:	    if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+common/cmm_profile.c:			(pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+common/cmm_profile.c:			pAd->StaCfg.WpaState = SS_START;
+common/cmm_profile.c:		else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
+common/cmm_profile.c:			pAd->StaCfg.WpaState = SS_NOTUSE;
+common/cmm_profile.c:		NdisZeroMemory(pAd->StaCfg.WscControl.WpaPsk, 64);
+common/cmm_profile.c:		pAd->StaCfg.WscControl.WpaPskLen = 0;
+common/cmm_profile.c:			NdisMoveMemory(pAd->StaCfg.WscControl.WpaPsk, PassPh, strlen(PassPh));
+common/cmm_profile.c:			pAd->StaCfg.WscControl.WpaPskLen = strlen(PassPh);
+common/cmm_profile.c:	pAd->StaCfg.PairCipher		= WepStatus;
+common/cmm_profile.c:	pAd->StaCfg.GroupCipher 	= WepStatus;
+common/cmm_profile.c:	pAd->StaCfg.bMixCipher 		= FALSE;
+common/cmm_profile.c:	RTMP_SEM_LOCK(&pAd->StaCtIf.Lock);
+common/cmm_profile.c:	if ((pAd->StaCtIf.Changeable== FALSE) || (pAd->StaCtIf.SsidLen > NDIS_802_11_LENGTH_SSID))
+common/cmm_profile.c:		RTMP_SEM_UNLOCK(&pAd->StaCtIf.Lock);
+common/cmm_profile.c:	NdisMoveMemory(ssidStr, pAd->StaCtIf.Ssid, pAd->StaCtIf.SsidLen);
+common/cmm_profile.c:	pAd->StaCfg.AuthMode = pAd->StaCtIf.AuthMode;
+common/cmm_profile.c:	pAd->StaCfg.WepStatus = pAd->StaCtIf.WepStatus;
+common/cmm_profile.c:	pAd->StaCfg.IEEE8021X = pAd->StaCtIf.IEEE8021X;
+common/cmm_profile.c:	pAd->StaCfg.DesireSharedKeyId = pAd->StaCtIf.DefaultKeyId; 
+common/cmm_profile.c:	pAd->StaCfg.DefaultKeyId = pAd->StaCtIf.DefaultKeyId; 
+common/cmm_profile.c:	NdisMoveMemory( pAd->StaCfg.PMK, pAd->StaCtIf.PMK, 32);
+common/cmm_profile.c:	RTMPMoveMemory(pAd->StaCfg.WpaPassPhrase, pAd->StaCtIf.WpaPassPhrase, pAd->StaCfg.WpaPassPhraseLen);
+common/cmm_profile.c:	pAd->StaCfg.WpaPassPhraseLen = pAd->StaCtIf.WpaPassPhraseLen;
+common/cmm_profile.c:		NdisMoveMemory(&pAd->SharedKey[BSS0][idx], &pAd->StaCtIf.SharedKey[BSS0][idx], sizeof(CIPHER_KEY));
+common/cmm_profile.c:		NdisMoveMemory(&pAd->StaCfg.DesireSharedKey[idx], &pAd->StaCtIf.SharedKey[BSS0][idx], sizeof(CIPHER_KEY));
+common/cmm_profile.c:	 if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+common/cmm_profile.c:			(pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+common/cmm_profile.c:			pAd->StaCfg.WpaState = SS_START;
+common/cmm_profile.c:	else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
+common/cmm_profile.c:			pAd->StaCfg.WpaState = SS_NOTUSE;
+common/cmm_profile.c:	RTMP_SEM_UNLOCK(&pAd->StaCtIf.Lock);
+common/cmm_profile.c:	RTMP_SEM_LOCK(&pAd->StaCtIf.Lock);
+common/cmm_profile.c:	pAd->StaCtIf.Changeable = TRUE;
+common/cmm_profile.c: 	pAd->StaCtIf.SsidLen = pAd->CommonCfg.SsidLen;
+common/cmm_profile.c:	NdisMoveMemory(pAd->StaCtIf.Ssid, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen);
+common/cmm_profile.c:	pAd->StaCtIf.AuthMode = pAd->StaCfg.AuthMode;
+common/cmm_profile.c:	pAd->StaCtIf.WepStatus = pAd->StaCfg.WepStatus;
+common/cmm_profile.c:	pAd->StaCtIf.DefaultKeyId = pAd->StaCfg.DefaultKeyId; 
+common/cmm_profile.c:	pAd->StaCtIf.DefaultKeyId = pAd->StaCfg.DesireSharedKeyId; 
+common/cmm_profile.c:	pAd->StaCtIf.IEEE8021X = pAd->StaCfg.IEEE8021X;
+common/cmm_profile.c:	NdisMoveMemory(pAd->StaCtIf.PMK, pAd->StaCfg.PMK, 32);
+common/cmm_profile.c:	RTMPMoveMemory(pAd->StaCtIf.WpaPassPhrase, pAd->StaCfg.WpaPassPhrase, pAd->StaCfg.WpaPassPhraseLen);
+common/cmm_profile.c:	pAd->StaCtIf.WpaPassPhraseLen = pAd->StaCfg.WpaPassPhraseLen;
+common/cmm_profile.c:		NdisMoveMemory(&pAd->StaCtIf.SharedKey[BSS0][idx], &pAd->SharedKey[BSS0][idx], sizeof(CIPHER_KEY));
+common/cmm_profile.c:	RTMP_SEM_UNLOCK(&pAd->StaCtIf.Lock);
+common/cmm_profile.c:	NdisMoveMemory(pAd->CommonCfg.CountryCode, CountryCode , 2);
+common/cmm_profile.c:	pAd->CommonCfg.CountryCode[2] = ' ';
+common/cmm_profile.c:		NdisMoveMemory(pAd->StaCfg.StaOriCountryCode, CountryCode , 2);
+common/cmm_profile.c:	if (strlen((PSTRING) pAd->CommonCfg.CountryCode) != 0)
+common/cmm_profile.c:		pAd->CommonCfg.bCountryFlag = TRUE;
+common/cmm_profile.c:	DBGPRINT(RT_DEBUG_TRACE, ("CountryCode=%s\n", pAd->CommonCfg.CountryCode));
+common/cmm_profile.c:											PRINT_MAC(pAd->CurrentAddress)));
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("CountryRegion=%d\n", pAd->CommonCfg.CountryRegion));
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("CountryRegionABand=%d\n", pAd->CommonCfg.CountryRegionForABand));
+common/cmm_profile.c:			pAd->bEEPROMFile = (UCHAR) simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("EfuseBufferMode=%d\n", pAd->bUseEfuse));
+common/cmm_profile.c:		if (pAd->CommonCfg.bCountryFlag == 0)
+common/cmm_profile.c:				pAd->CommonCfg.Geography = Geography;
+common/cmm_profile.c:				pAd->CommonCfg.CountryCode[2] =
+common/cmm_profile.c:					(pAd->CommonCfg.Geography == BOTH) ? ' ' : ((pAd->CommonCfg.Geography == IDOR) ? 'I' : 'O');
+common/cmm_profile.c:					pAd->StaCfg.StaOriGeography = pAd->CommonCfg.Geography;
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("ChannelGeography=%d\n", pAd->CommonCfg.Geography));
+common/cmm_profile.c:			pAd->CommonCfg.Geography = BOTH;
+common/cmm_profile.c:			pAd->CommonCfg.CountryCode[2] = ' ';
+common/cmm_profile.c:				pAd->ApCfg.BssidNum = (UCHAR) simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				if(pAd->ApCfg.BssidNum > MAX_MBSSID_NUM(pAd))
+common/cmm_profile.c:					pAd->ApCfg.BssidNum = MAX_MBSSID_NUM(pAd);
+common/cmm_profile.c:					DBGPRINT(RT_DEBUG_TRACE, ("BssidNum=%d(MAX_MBSSID_NUM is %d)\n", pAd->ApCfg.BssidNum,MAX_MBSSID_NUM(pAd)));
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("BssidNum=%d\n", pAd->ApCfg.BssidNum));
+common/cmm_profile.c:			if (HW_BEACON_OFFSET > (HW_BEACON_MAX_SIZE(pAd) / pAd->ApCfg.BssidNum))
+common/cmm_profile.c:			pAd->ApCfg.BssidNum = 1;
+common/cmm_profile.c:				//PRINT(RT_DEBUG_TRACE, ("pAd->ApCfg.BssidNum=%d\n", pAd->ApCfg.BssidNum));
+common/cmm_profile.c:				for (i = 0; i < pAd->ApCfg.BssidNum; i++)
+common/cmm_profile.c:							NdisMoveMemory(pAd->ApCfg.MBSSID[i].Ssid, tmpbuf , strlen(tmpbuf));
+common/cmm_profile.c:					    	pAd->ApCfg.MBSSID[i].Ssid[strlen(tmpbuf)] = '\0';
+common/cmm_profile.c:								    	pAd->ApCfg.MBSSID[i].SsidLen = strlen((PSTRING) pAd->ApCfg.MBSSID[i].Ssid);
+common/cmm_profile.c:					    	DBGPRINT(RT_DEBUG_TRACE, ("SSID[%d]=%s\n", i, pAd->ApCfg.MBSSID[i].Ssid));
+common/cmm_profile.c:						if (pAd->ApCfg.BssidNum != BssidCountSupposed)
+common/cmm_profile.c:							DBGPRINT_ERR(("Your no. of SSIDs( = %d) does not match your BssidNum( = %d)!\n", BssidCountSupposed, pAd->ApCfg.BssidNum));
+common/cmm_profile.c:						if (pAd->ApCfg.BssidNum > 1)
+common/cmm_profile.c:								if (i < pAd->ApCfg.BssidNum)
+common/cmm_profile.c:								NdisMoveMemory(pAd->ApCfg.MBSSID[apidx].Ssid, macptr , strlen(macptr));
+common/cmm_profile.c:				    			pAd->ApCfg.MBSSID[apidx].Ssid[strlen(macptr)] = '\0';
+common/cmm_profile.c:							   pAd->ApCfg.MBSSID[apidx].SsidLen = strlen((PSTRING) pAd->ApCfg.MBSSID[apidx].Ssid);
+common/cmm_profile.c:				    			DBGPRINT(RT_DEBUG_TRACE, ("SSID[%d]=%s\n", i, pAd->ApCfg.MBSSID[apidx].Ssid));
+common/cmm_profile.c:								NdisMoveMemory(pAd->ApCfg.MBSSID[BSS0].Ssid, tmpbuf , strlen(tmpbuf));
+common/cmm_profile.c:						    	pAd->ApCfg.MBSSID[BSS0].Ssid[strlen(tmpbuf)] = '\0';
+common/cmm_profile.c:									    	pAd->ApCfg.MBSSID[BSS0].SsidLen = strlen((PSTRING) pAd->ApCfg.MBSSID[BSS0].Ssid);
+common/cmm_profile.c:								DBGPRINT(RT_DEBUG_TRACE, ("SSID=%s\n", pAd->ApCfg.MBSSID[BSS0].Ssid));
+common/cmm_profile.c:				pAd->bConfigChanged = TRUE;
+common/cmm_profile.c:					pAd->StaCfg.BssType = BSS_ADHOC;
+common/cmm_profile.c:					pAd->StaCfg.BssType = BSS_INFRA;
+common/cmm_profile.c:				pAd->StaCfg.WpaState = SS_NOTUSE;
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("%s::(NetworkType=%d)\n", __FUNCTION__, pAd->StaCfg.BssType));
+common/cmm_profile.c:			pAd->CommonCfg.Channel = (UCHAR) simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("Channel=%d\n", pAd->CommonCfg.Channel));
+common/cmm_profile.c:				if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:				pAd->ApCfg.MBSSID[i].PhyMode = cfgmode_2_wmode(cfg_mode);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("BSS%d PhyMode=%d\n", i, pAd->ApCfg.MBSSID[i].PhyMode));
+common/cmm_profile.c:						for(IdBss=1; IdBss<pAd->ApCfg.BssidNum; IdBss++)
+common/cmm_profile.c:							pAd->ApCfg.MBSSID[IdBss].PhyMode = pAd->ApCfg.MBSSID[0].PhyMode;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("PhyMode=%d\n", pAd->CommonCfg.PhyMode));
+common/cmm_profile.c:			pAd->CommonCfg.BasicRateBitmap = (ULONG) simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:			pAd->CommonCfg.BasicRateBitmapOld = (ULONG) simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("BasicRate=%ld\n", pAd->CommonCfg.BasicRateBitmap));
+common/cmm_profile.c:				pAd->CommonCfg.BeaconPeriod = bcn_val;
+common/cmm_profile.c:				pAd->CommonCfg.BeaconPeriod = 100;	/* Default value*/
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("BeaconPeriod=%d\n", pAd->CommonCfg.BeaconPeriod));
+common/cmm_profile.c:		PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_profile.c:			pAd->Dot11_H.bDFSIndoor = (USHORT) (simple_strtol(tmpbuf, 0, 10) != 0);
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("DfsIndoor=%d\n", pAd->Dot11_H.bDFSIndoor));
+common/cmm_profile.c:			for(k = 0; k < 4*pAd->chipCap.DfsEngineNum; k++) 
+common/cmm_profile.c:				UINT8 DfsEngineNum = pAd->chipCap.DfsEngineNum;
+common/cmm_profile.c:				pAd->ApCfg.DtimPeriod = (UCHAR) simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("DtimPeriod=%d\n", pAd->ApCfg.DtimPeriod));
+common/cmm_profile.c:			pAd->CommonCfg.TxPowerPercentage = (ULONG) simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				pAd->CommonCfg.TxPowerDefault = pAd->CommonCfg.TxPowerPercentage;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("TxPower=%ld\n", pAd->CommonCfg.TxPowerPercentage));
+common/cmm_profile.c:	/*		pAd->CommonCfg.UseBGProtection = 2; disable b/g protection for throughput test*/
+common/cmm_profile.c:					pAd->CommonCfg.UseBGProtection = 1;
+common/cmm_profile.c:					pAd->CommonCfg.UseBGProtection = 2;
+common/cmm_profile.c:					pAd->CommonCfg.UseBGProtection = 0;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("BGProtection=%ld\n", pAd->CommonCfg.UseBGProtection));
+common/cmm_profile.c:					pAd->CommonCfg.DisableOLBCDetect = 1;
+common/cmm_profile.c:					pAd->CommonCfg.DisableOLBCDetect = 0;
+common/cmm_profile.c:					pAd->CommonCfg.DisableOLBCDetect= 0;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("OLBCDetection=%ld\n", pAd->CommonCfg.DisableOLBCDetect));
+common/cmm_profile.c:					pAd->CommonCfg.TxPreamble = Rt802_11PreambleShort;
+common/cmm_profile.c:					pAd->CommonCfg.TxPreamble = Rt802_11PreambleLong;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("TxPreamble=%ld\n", pAd->CommonCfg.TxPreamble));
+common/cmm_profile.c:				pAd->CommonCfg.RtsThreshold  = (USHORT)RtsThresh;
+common/cmm_profile.c:				pAd->CommonCfg.RtsThreshold = MAX_RTS_THRESHOLD;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("RTSThreshold=%d\n", pAd->CommonCfg.RtsThreshold));
+common/cmm_profile.c:			pAd->CommonCfg.bUseZeroToDisableFragment = FALSE;
+common/cmm_profile.c:				pAd->CommonCfg.FragmentThreshold = MAX_FRAG_THRESHOLD;
+common/cmm_profile.c:				pAd->CommonCfg.bUseZeroToDisableFragment = TRUE;
+common/cmm_profile.c:				pAd->CommonCfg.FragmentThreshold = (USHORT)(FragThresh - 1);
+common/cmm_profile.c:				pAd->CommonCfg.FragmentThreshold = (USHORT)FragThresh;
+common/cmm_profile.c:			/*pAd->CommonCfg.AllowFragSize = (pAd->CommonCfg.FragmentThreshold) - LENGTH_802_11 - LENGTH_CRC;*/
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("FragThreshold=%d\n", pAd->CommonCfg.FragmentThreshold));
+common/cmm_profile.c:	/*						pAd->CommonCfg.bEnableTxBurst = FALSE;*/
+common/cmm_profile.c:				pAd->CommonCfg.bEnableTxBurst = TRUE;
+common/cmm_profile.c:				pAd->CommonCfg.bEnableTxBurst = FALSE;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("TxBurst=%d\n", pAd->CommonCfg.bEnableTxBurst));
+common/cmm_profile.c:				pAd->CommonCfg.bAggregationCapable = TRUE;
+common/cmm_profile.c:				pAd->CommonCfg.bAggregationCapable = FALSE;
+common/cmm_profile.c:			pAd->CommonCfg.bPiggyBackCapable = pAd->CommonCfg.bAggregationCapable;
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("PktAggregate=%d\n", pAd->CommonCfg.bAggregationCapable));
+common/cmm_profile.c:		pAd->CommonCfg.bAggregationCapable = FALSE;
+common/cmm_profile.c:		pAd->CommonCfg.bPiggyBackCapable = FALSE;
+common/cmm_profile.c:					if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:					if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:						pAd->ApCfg.MBSSID[i].IsolateInterStaTraffic = TRUE;
+common/cmm_profile.c:						pAd->ApCfg.MBSSID[i].IsolateInterStaTraffic = FALSE;
+common/cmm_profile.c:					DBGPRINT(RT_DEBUG_TRACE, ("I/F(ra%d) NoForwarding=%ld\n", i, pAd->ApCfg.MBSSID[i].IsolateInterStaTraffic));
+common/cmm_profile.c:					pAd->ApCfg.IsolateInterStaTrafficBTNBSSID = TRUE;
+common/cmm_profile.c:					pAd->ApCfg.IsolateInterStaTrafficBTNBSSID = FALSE;
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("NoForwardingBTNBSSID=%ld\n", pAd->ApCfg.IsolateInterStaTrafficBTNBSSID));
+common/cmm_profile.c:					if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:						pAd->ApCfg.MBSSID[apidx].bHideSsid = TRUE;								
+common/cmm_profile.c:						pAd->ApCfg.MBSSID[apidx].WscControl.WscV2Info.bWpsEnable = FALSE;
+common/cmm_profile.c:						pAd->ApCfg.MBSSID[apidx].bHideSsid = FALSE;								
+common/cmm_profile.c:					DBGPRINT(RT_DEBUG_TRACE, ("I/F(ra%d) HideSSID=%d\n", i, pAd->ApCfg.MBSSID[apidx].bHideSsid));
+common/cmm_profile.c:					if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:					pAd->ApCfg.MBSSID[apidx].StationKeepAliveTime = simple_strtol(macptr, 0, 10);
+common/cmm_profile.c:					DBGPRINT(RT_DEBUG_TRACE, ("I/F(ra%d) StationKeepAliveTime=%d\n", i, pAd->ApCfg.MBSSID[apidx].StationKeepAliveTime));
+common/cmm_profile.c:						pAd->ApCfg.bAutoChannelAtBootup = FALSE;
+common/cmm_profile.c:						pAd->ApCfg.bAutoChannelAtBootup = TRUE;
+common/cmm_profile.c:						pAd->ApCfg.AutoChannelAlg = SelAlg;
+common/cmm_profile.c:					pAd->ApCfg.bAutoChannelAtBootup = FALSE;
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("AutoChannelAtBootup=%d\n", pAd->ApCfg.bAutoChannelAtBootup));
+common/cmm_profile.c:				pAd->ApCfg.AutoChannelSkipListNum = delimitcnt(tmpbuf, ";") + 1;
+common/cmm_profile.c:				if ( pAd->ApCfg.AutoChannelSkipListNum > 10 )
+common/cmm_profile.c:					DBGPRINT(RT_DEBUG_TRACE, ("Your no. of AutoChannelSkipList( %d ) is larger than 10 (boundary)\n",pAd->ApCfg.AutoChannelSkipListNum));
+common/cmm_profile.c:					pAd->ApCfg.AutoChannelSkipListNum = 10;
+common/cmm_profile.c:					if (i < pAd->ApCfg.AutoChannelSkipListNum )
+common/cmm_profile.c:						pAd->ApCfg.AutoChannelSkipList[i] = simple_strtol(macptr, 0, 10);
+common/cmm_profile.c:						DBGPRINT(RT_DEBUG_TRACE, (" AutoChannelSkipList[%d]= %d \n", i, pAd->ApCfg.AutoChannelSkipList[i]));
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("ShortSlot=%d\n", pAd->CommonCfg.bUseShortSlotTime));
+common/cmm_profile.c:		if (pAd->chipCap.FlgHwTxBfCap)
+common/cmm_profile.c:				pAd->CommonCfg.RegTransmitSetting.field.ITxBfEn = (simple_strtol(tmpbuf, 0, 10) != 0);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("ITxBfEn = %d\n", pAd->CommonCfg.RegTransmitSetting.field.ITxBfEn));
+common/cmm_profile.c:				pAd->CommonCfg.ITxBfTimeout = simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("ITxBfTimeout = %ld\n", pAd->CommonCfg.ITxBfTimeout));
+common/cmm_profile.c:				pAd->CommonCfg.ETxBfEnCond = simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("ETxBfEnCond = %ld\n", pAd->CommonCfg.ETxBfEnCond));
+common/cmm_profile.c:				if (pAd->CommonCfg.ETxBfEnCond)
+common/cmm_profile.c:					pAd->CommonCfg.RegTransmitSetting.field.TxBF = TRUE;
+common/cmm_profile.c:					pAd->CommonCfg.RegTransmitSetting.field.TxBF = FALSE;
+common/cmm_profile.c:				pAd->CommonCfg.ETxBfTimeout = simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("ETxBfTimeout = %ld\n", pAd->CommonCfg.ETxBfTimeout));
+common/cmm_profile.c:				pAd->CommonCfg.ETxBfNoncompress = simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("ETxBfNoncompress = %d\n", pAd->CommonCfg.ETxBfNoncompress));
+common/cmm_profile.c:				pAd->CommonCfg.ETxBfIncapable = simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("ETxBfIncapable = %d\n", pAd->CommonCfg.ETxBfIncapable));
+common/cmm_profile.c:			pAd->CommonCfg.PreAntSwitch = (simple_strtol(tmpbuf, 0, 10) != 0);
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("PreAntSwitch = %d\n", pAd->CommonCfg.PreAntSwitch));
+common/cmm_profile.c:		if (pAd->chipCap.FlgHwStreamMode)
+common/cmm_profile.c:				pAd->CommonCfg.StreamMode = (simple_strtol(tmpbuf, 0, 10) & 0x03);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("StreamMode= %d\n", pAd->CommonCfg.StreamMode));
+common/cmm_profile.c:						AtoH(tmpbuf, &pAd->CommonCfg.StreamModeMac[i][j], 1);
+common/cmm_profile.c:			if (NdisEqualMemory(ZERO_MAC_ADDR, &pAd->CommonCfg.StreamModeMac[0][0], MAC_ADDR_LEN))
+common/cmm_profile.c:				NdisMoveMemory(&pAd->CommonCfg.StreamModeMac[0][0], BROADCAST_ADDR, MAC_ADDR_LEN);
+common/cmm_profile.c:			pAd->CommonCfg.DebugFlags = simple_strtol(tmpbuf, 0, 16);
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("DebugFlags = 0x%02lx\n", pAd->CommonCfg.DebugFlags));
+common/cmm_profile.c:					pAd->CommonCfg.bIEEE80211H = TRUE;
+common/cmm_profile.c:					pAd->CommonCfg.bIEEE80211H = FALSE;
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("IEEE80211H=%d\n", pAd->CommonCfg.bIEEE80211H));
+common/cmm_profile.c:				pAd->Dot11_H.CSPeriod = simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				pAd->Dot11_H.CSPeriod = 0;
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("CSPeriod=%d\n", pAd->Dot11_H.CSPeriod));
+common/cmm_profile.c:							pAd->CommonCfg.RDDurRegion = JAP_W53;
+common/cmm_profile.c:							pAd->CommonCfg.RDDurRegion = JAP_W56;
+common/cmm_profile.c:							pAd->CommonCfg.RDDurRegion = JAP;
+common/cmm_profile.c:							pAd->CommonCfg.RDDurRegion = FCC;
+common/cmm_profile.c:							pAd->CommonCfg.RDDurRegion = CE;
+common/cmm_profile.c:							pAd->CommonCfg.RDDurRegion = CE;
+common/cmm_profile.c:						DBGPRINT(RT_DEBUG_TRACE, ("RDRegion=%d\n", pAd->CommonCfg.RDDurRegion));
+common/cmm_profile.c:			pAd->CommonCfg.RDDurRegion = CE;
+common/cmm_profile.c:			RtmpOsWlanEventSet(pAd, &pAd->CommonCfg.bWirelessEvent, FlgIsWEntSup);
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("WirelessEvent=%d\n", pAd->CommonCfg.bWirelessEvent));
+common/cmm_profile.c:		   		for (i = 0, macptr = rstrtok(tmpbuf,";"); (macptr && i < pAd->ApCfg.BssidNum); macptr = rstrtok(NULL,";"), i++)
+common/cmm_profile.c:	                            pAd->StaCfg.AuthMode = Ndis802_11AuthModeAutoSwitch;
+common/cmm_profile.c:	                            pAd->StaCfg.AuthMode = Ndis802_11AuthModeShared;
+common/cmm_profile.c:	                            pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPAPSK;
+common/cmm_profile.c:	                            pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPANone;
+common/cmm_profile.c:							    pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPA2PSK;
+common/cmm_profile.c:			                    pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPA;
+common/cmm_profile.c:							    pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPA2;  
+common/cmm_profile.c:	                            pAd->StaCfg.AuthMode = Ndis802_11AuthModeWAICERT;  
+common/cmm_profile.c:	                            pAd->StaCfg.AuthMode = Ndis802_11AuthModeWAIPSK;  
+common/cmm_profile.c:	                            pAd->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
+common/cmm_profile.c:	                        pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("%s::(AuthMode=%d)\n", __FUNCTION__, pAd->StaCfg.AuthMode));
+common/cmm_profile.c:				for ( i= 0; i<pAd->ApCfg.BssidNum; i++)
+common/cmm_profile.c:					pAd->ApCfg.MBSSID[i].WepStatus = Ndis802_11WEPDisabled;
+common/cmm_profile.c:					if (i<pAd->ApCfg.BssidNum)
+common/cmm_profile.c:		            			pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11WEPDisabled;
+common/cmm_profile.c:		            			pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11WEPEnabled;
+common/cmm_profile.c:		            			pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11Encryption4Enabled;
+common/cmm_profile.c:		            			pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11Encryption2Enabled;
+common/cmm_profile.c:		            			pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11Encryption3Enabled;
+common/cmm_profile.c:					            			pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11EncryptionSMS4Enabled;									
+common/cmm_profile.c:		            			pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11WEPDisabled;
+common/cmm_profile.c:						if (pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11Encryption4Enabled)	
+common/cmm_profile.c:							pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus = Ndis802_11Encryption2Enabled;		
+common/cmm_profile.c:							pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus = pAd->ApCfg.MBSSID[apidx].WepStatus;
+common/cmm_profile.c:	        			/*RTMPMakeRSNIE(pAd, pAd->ApCfg.MBSSID[apidx].AuthMode, pAd->ApCfg.MBSSID[apidx].WepStatus, apidx);*/
+common/cmm_profile.c:		        		DBGPRINT(RT_DEBUG_TRACE, ("I/F(ra%d) EncrypType=%d\n", i, pAd->ApCfg.MBSSID[apidx].WepStatus));
+common/cmm_profile.c:					pAd->StaCfg.WepStatus	= Ndis802_11WEPEnabled;
+common/cmm_profile.c:					pAd->StaCfg.WepStatus	= Ndis802_11Encryption2Enabled;													
+common/cmm_profile.c:					pAd->StaCfg.WepStatus	= Ndis802_11Encryption3Enabled;														 
+common/cmm_profile.c:		            pAd->StaCfg.WepStatus	= Ndis802_11EncryptionSMS4Enabled;									
+common/cmm_profile.c:					pAd->StaCfg.WepStatus	= Ndis802_11WEPDisabled;													
+common/cmm_profile.c:				RTMPSetSTACipherSuites(pAd, pAd->StaCfg.WepStatus);
+common/cmm_profile.c:				/*RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus, 0);*/
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("%s::(EncrypType=%d)\n", __FUNCTION__, pAd->StaCfg.WepStatus));
+common/cmm_profile.c:							if (pAd->ApCfg.MBSSID[i].AuthMode != Ndis802_11AuthModeWPA1WPA2 && 
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].AuthMode != Ndis802_11AuthModeWPA1PSKWPA2PSK)
+common/cmm_profile.c:							if (pAd->ApCfg.MBSSID[i].WepStatus != Ndis802_11Encryption4Enabled)
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WpaMixPairCipher = WPA_AES_WPA2_TKIPAES;																			
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WpaMixPairCipher = WPA_AES_WPA2_TKIP;								 						
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WpaMixPairCipher = WPA_TKIP_WPA2_AES;								
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WpaMixPairCipher = WPA_TKIP_WPA2_TKIPAES;
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WpaMixPairCipher = WPA_TKIPAES_WPA2_AES;
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WpaMixPairCipher = WPA_TKIPAES_WPA2_TKIPAES;
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WpaMixPairCipher = WPA_TKIPAES_WPA2_TKIP;
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WpaMixPairCipher = WPA_TKIPAES_WPA2_TKIPAES;
+common/cmm_profile.c:							DBGPRINT(RT_DEBUG_OFF, ("I/F(ra%d) MixWPACipher=0x%02x\n", i, pAd->ApCfg.MBSSID[i].WpaMixPairCipher));
+common/cmm_profile.c:							PRT_WPA_REKEY pRekeyInfo = &pAd->ApCfg.MBSSID[i].WPAREKEY;
+common/cmm_profile.c:							for (i = 1; i < pAd->ApCfg.BssidNum; i++)
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WPAREKEY.ReKeyMethod = 
+common/cmm_profile.c:										pAd->ApCfg.MBSSID[0].WPAREKEY.ReKeyMethod;
+common/cmm_profile.c:													i, pAd->ApCfg.MBSSID[i].WPAREKEY.ReKeyMethod));
+common/cmm_profile.c:							PRT_WPA_REKEY pRekeyInfo = &pAd->ApCfg.MBSSID[i].WPAREKEY;
+common/cmm_profile.c:							for (i = 1; i < pAd->ApCfg.BssidNum; i++)
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WPAREKEY.ReKeyInterval = 
+common/cmm_profile.c:										pAd->ApCfg.MBSSID[0].WPAREKEY.ReKeyInterval;
+common/cmm_profile.c:															i, pAd->ApCfg.MBSSID[i].WPAREKEY.ReKeyInterval));
+common/cmm_profile.c:							pAd->ApCfg.MBSSID[i].PMKCachePeriod = 
+common/cmm_profile.c:														i, pAd->ApCfg.MBSSID[i].PMKCachePeriod));
+common/cmm_profile.c:							for (i = 1; i < pAd->ApCfg.BssidNum; i++)
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].PMKCachePeriod = 
+common/cmm_profile.c:										pAd->ApCfg.MBSSID[0].PMKCachePeriod;
+common/cmm_profile.c:															i, pAd->ApCfg.MBSSID[i].PMKCachePeriod));					
+common/cmm_profile.c:						//DBGPRINT(RT_DEBUG_TRACE, ("pAd->ApCfg.BssidNum=%d\n", pAd->ApCfg.BssidNum));
+common/cmm_profile.c:						for (i = 0; i < pAd->ApCfg.BssidNum; i++)
+common/cmm_profile.c:								if (pAd->ApCfg.BssidNum == 1)
+common/cmm_profile.c:						for (i = 0; i < pAd->ApCfg.BssidNum; i++)
+common/cmm_profile.c:												DBGPRINT(RT_DEBUG_TRACE, ("%02x:", pAd->ApCfg.MBSSID[i].PMK[j]));
+common/cmm_profile.c:					for (i = 0; i < pAd->ApCfg.BssidNum; i++)
+common/cmm_profile.c:							NdisZeroMemory(&pAd->ApCfg.MBSSID[i].WscControl.WscDefaultSsid, sizeof(NDIS_802_11_SSID));
+common/cmm_profile.c:							NdisMoveMemory(pAd->ApCfg.MBSSID[i].WscControl.WscDefaultSsid.Ssid, tmpbuf , strlen(tmpbuf));
+common/cmm_profile.c:							pAd->ApCfg.MBSSID[i].WscControl.WscDefaultSsid.SsidLength = strlen(tmpbuf);
+common/cmm_profile.c:							DBGPRINT(RT_DEBUG_TRACE, ("WscDefaultSSID[%d]=%s\n", i, pAd->ApCfg.MBSSID[i].WscControl.WscDefaultSsid.Ssid));
+common/cmm_profile.c:							if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WscControl.WscConfMode = WscConfMode;
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WscControl.WscConfMode = WSC_DISABLE;
+common/cmm_profile.c:							DBGPRINT(RT_DEBUG_TRACE, ("I/F(ra%d) WscConfMode=%d\n", i, pAd->ApCfg.MBSSID[i].WscControl.WscConfMode));
+common/cmm_profile.c:							if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:							pAd->ApCfg.MBSSID[i].WscControl.WscConfStatus = (INT) simple_strtol(macptr, 0, 10);
+common/cmm_profile.c:							DBGPRINT(RT_DEBUG_TRACE, ("I/F(ra%d) WscConfStatus=%d\n", i, pAd->ApCfg.MBSSID[i].WscControl.WscConfStatus));
+common/cmm_profile.c:							if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:							pAd->ApCfg.MBSSID[i].WscControl.WscConfigMethods = (USHORT)simple_strtol(macptr, 0, 16);
+common/cmm_profile.c:							DBGPRINT(RT_DEBUG_TRACE, ("I/F(ra%d) WscConfMethods=0x%x\n", i, pAd->ApCfg.MBSSID[i].WscControl.WscConfigMethods));
+common/cmm_profile.c:							if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WscControl.WscKeyASCII = Value;
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WscControl.WscKeyASCII = Value;
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WscControl.WscKeyASCII = 8;
+common/cmm_profile.c:							DBGPRINT(RT_DEBUG_WARN, ("WscKeyASCII=%d\n", pAd->ApCfg.MBSSID[i].WscControl.WscKeyASCII));
+common/cmm_profile.c:						for (i= 0; i<pAd->ApCfg.BssidNum; i++)					
+common/cmm_profile.c:							pAd->ApCfg.MBSSID[i].WscSecurityMode = WPAPSKTKIP;
+common/cmm_profile.c:							if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WscSecurityMode = tmpMode;
+common/cmm_profile.c:								i, pAd->ApCfg.MBSSID[i].WscSecurityMode));
+common/cmm_profile.c:						for (i = 0; i < pAd->ApCfg.BssidNum; i++)
+common/cmm_profile.c:							pAd->ApCfg.MBSSID[i].WscControl.bWCNTest = bEn;
+common/cmm_profile.c:					for (i = 0; i < pAd->ApCfg.BssidNum; i++)
+common/cmm_profile.c:						PWSC_CTRL	pWpsCtrl = &pAd->ApCfg.MBSSID[i].WscControl;
+common/cmm_profile.c:					for (i = 0; i < pAd->ApCfg.BssidNum; i++)
+common/cmm_profile.c:						PWSC_CTRL	pWpsCtrl = &pAd->ApCfg.MBSSID[i].WscControl;
+common/cmm_profile.c:							pAd->CommonCfg.CarrierDetect.Enable = FALSE;
+common/cmm_profile.c:							pAd->CommonCfg.CarrierDetect.Enable = TRUE;
+common/cmm_profile.c:							pAd->CommonCfg.CarrierDetect.Enable = FALSE;
+common/cmm_profile.c:						DBGPRINT(RT_DEBUG_TRACE, ("CarrierDetect.Enable=%d\n", pAd->CommonCfg.CarrierDetect.Enable));
+common/cmm_profile.c:						pAd->CommonCfg.CarrierDetect.Enable = FALSE;
+common/cmm_profile.c:						if (pAd->StaCfg.BssType == BSS_INFRA)
+common/cmm_profile.c:								if (pAd->StaCfg.bWindowsACCAMEnable == FALSE)
+common/cmm_profile.c:									pAd->StaCfg.WindowsPowerMode = Ndis802_11PowerModeMAX_PSP;
+common/cmm_profile.c:								pAd->StaCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeMAX_PSP;
+common/cmm_profile.c:								pAd->StaCfg.DefaultListenCount = 5;
+common/cmm_profile.c:								if (pAd->StaCfg.bWindowsACCAMEnable == FALSE)
+common/cmm_profile.c:									pAd->StaCfg.WindowsPowerMode = Ndis802_11PowerModeFast_PSP;
+common/cmm_profile.c:								pAd->StaCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeFast_PSP;
+common/cmm_profile.c:								pAd->StaCfg.DefaultListenCount = 3;
+common/cmm_profile.c:								if (pAd->StaCfg.bWindowsACCAMEnable == FALSE)
+common/cmm_profile.c:									pAd->StaCfg.WindowsPowerMode = Ndis802_11PowerModeLegacy_PSP;
+common/cmm_profile.c:								pAd->StaCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeLegacy_PSP;
+common/cmm_profile.c:								pAd->StaCfg.DefaultListenCount = 3;
+common/cmm_profile.c:								pAd->StaCfg.DefaultListenCount = 1;
+common/cmm_profile.c:								if (pAd->StaCfg.bWindowsACCAMEnable == FALSE)
+common/cmm_profile.c:									pAd->StaCfg.WindowsPowerMode = Ndis802_11PowerModeCAM;
+common/cmm_profile.c:								pAd->StaCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeCAM;
+common/cmm_profile.c:							DBGPRINT(RT_DEBUG_TRACE, ("PSMode=%ld\n", pAd->StaCfg.WindowsPowerMode));
+common/cmm_profile.c:							pAd->StaCfg.bAutoRoaming = FALSE;
+common/cmm_profile.c:							pAd->StaCfg.bAutoRoaming = TRUE;
+common/cmm_profile.c:						DBGPRINT(RT_DEBUG_TRACE, ("AutoRoaming=%d\n", pAd->StaCfg.bAutoRoaming));
+common/cmm_profile.c:							pAd->StaCfg.dBmToRoam = -70;
+common/cmm_profile.c:							pAd->StaCfg.dBmToRoam = (CHAR)(-1)*lInfo;
+common/cmm_profile.c:						DBGPRINT(RT_DEBUG_TRACE, ("RoamThreshold=%d  dBm\n", pAd->StaCfg.dBmToRoam));
+common/cmm_profile.c:							pAd->StaCfg.bTGnWifiTest = FALSE;
+common/cmm_profile.c:							pAd->StaCfg.bTGnWifiTest = TRUE;
+common/cmm_profile.c:							DBGPRINT(RT_DEBUG_TRACE, ("TGnWifiTest=%d\n", pAd->StaCfg.bTGnWifiTest));
+common/cmm_profile.c:							pAd->StaCfg.BeaconLostTime = (lInfo * OS_HZ);
+common/cmm_profile.c:						DBGPRINT(RT_DEBUG_TRACE, ("BeaconLostTime=%ld \n", pAd->StaCfg.BeaconLostTime));
+common/cmm_profile.c:							pAd->StaCfg.bAutoConnectIfNoSSID = FALSE;
+common/cmm_profile.c:							pAd->StaCfg.bAutoConnectIfNoSSID = TRUE;
+common/cmm_profile.c:							pAd->StaCfg.TdlsInfo.bTDLSCapable = TRUE;
+common/cmm_profile.c:							pAd->StaCfg.TdlsInfo.bTDLSCapable = FALSE;
+common/cmm_profile.c:						DBGPRINT(RT_DEBUG_TRACE, ("bTDLSCapable=%d\n", pAd->StaCfg.TdlsInfo.bTDLSCapable));
+common/cmm_profile.c:							pAd->StaCfg.TdlsInfo.TdlsAutoLink = TRUE;
+common/cmm_profile.c:							pAd->StaCfg.TdlsInfo.TdlsAutoLink = FALSE;
+common/cmm_profile.c:						DBGPRINT(RT_DEBUG_TRACE, ("TdlsAutoLink=%d\n", pAd->StaCfg.TdlsInfo.TdlsAutoLink));
+common/cmm_profile.c:							pAd->StaCfg.TdlsInfo.TdlsChSwitchSupp = TRUE;
+common/cmm_profile.c:							pAd->StaCfg.TdlsInfo.TdlsChSwitchSupp = FALSE;
+common/cmm_profile.c:						DBGPRINT(RT_DEBUG_TRACE, ("TdlsSwitchChSupp=%d\n", pAd->StaCfg.TdlsInfo.TdlsChSwitchSupp));
+common/cmm_profile.c:							pAd->StaCfg.TdlsInfo.TdlsPsmSupp = TRUE;
+common/cmm_profile.c:							pAd->StaCfg.TdlsInfo.TdlsPsmSupp = FALSE;
+common/cmm_profile.c:						DBGPRINT(RT_DEBUG_TRACE, ("TdlsPsmSupp=%d\n", pAd->StaCfg.TdlsInfo.TdlsPsmSupp));
+common/cmm_profile.c:						pAd->CommonCfg.TDLS_bAPSDAC_BE = FlgIsAcUapsdEnabled[0];
+common/cmm_profile.c:						pAd->CommonCfg.TDLS_bAPSDAC_BK = FlgIsAcUapsdEnabled[1];
+common/cmm_profile.c:						pAd->CommonCfg.TDLS_bAPSDAC_VI = FlgIsAcUapsdEnabled[2];
+common/cmm_profile.c:						pAd->CommonCfg.TDLS_bAPSDAC_VO = FlgIsAcUapsdEnabled[3];
+common/cmm_profile.c:						pAd->CommonCfg.TDLS_MaxSPLength = simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:						DBGPRINT(RT_DEBUG_TRACE, ("TDLS MaxSPLength=%d\n", pAd->CommonCfg.TDLS_MaxSPLength));
+common/cmm_profile.c:							pAd->StaCfg.bFastConnect = FALSE;
+common/cmm_profile.c:							pAd->StaCfg.bFastConnect = TRUE;
+common/cmm_profile.c:						DBGPRINT(RT_DEBUG_TRACE, ("FastConnect=%d\n", pAd->StaCfg.bFastConnect));
+common/cmm_profile.c:									pAd->CommonCfg.MCastPhyMode.field.BW = pAd->CommonCfg.RegTransmitSetting.field.BW;
+common/cmm_profile.c:											NdisMoveMemory(&pAd->CommonCfg.MCastPhyMode,
+common/cmm_profile.c:												&pAd->MacTab.Content[MCAST_WCID].HTPhyMode, sizeof(HTTRANSMIT_SETTING));
+common/cmm_profile.c:											pAd->CommonCfg.MCastPhyMode.field.MODE = MODE_CCK;
+common/cmm_profile.c:											pAd->CommonCfg.MCastPhyMode.field.BW =  BW_20;
+common/cmm_profile.c:											pAd->CommonCfg.MCastPhyMode.field.MODE = MODE_OFDM;
+common/cmm_profile.c:											pAd->CommonCfg.MCastPhyMode.field.MODE = MODE_HTMIX;
+common/cmm_profile.c:									NdisMoveMemory(&pAd->CommonCfg.MCastPhyMode,
+common/cmm_profile.c:										&pAd->MacTab.Content[MCAST_WCID].HTPhyMode, sizeof(HTTRANSMIT_SETTING));
+common/cmm_profile.c:						switch(pAd->CommonCfg.MCastPhyMode.field.MODE)
+common/cmm_profile.c:									pAd->CommonCfg.MCastPhyMode.field.MCS = Mcs;
+common/cmm_profile.c:									pAd->CommonCfg.MCastPhyMode.field.MCS = Mcs;
+common/cmm_profile.c:								pAd->CommonCfg.MCastPhyMode.field.MCS = Mcs;
+common/cmm_profile.c:						pAd->CommonCfg.MCastPhyMode.field.MCS = 0;
+common/cmm_profile.c:							if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WscControl.WscEnrollee4digitPinCode = TRUE;
+common/cmm_profile.c:								pAd->ApCfg.MBSSID[i].WscControl.WscEnrollee4digitPinCode = FALSE;
+common/cmm_profile.c:							DBGPRINT(RT_DEBUG_TRACE, ("I/F(ra%d) Wsc4digitPinCode=%d\n", i, pAd->ApCfg.MBSSID[i].WscControl.WscEnrollee4digitPinCode));
+common/cmm_profile.c:							pAd->StaCfg.WscControl.WscEnrollee4digitPinCode = TRUE;
+common/cmm_profile.c:							pAd->StaCfg.WscControl.WscEnrollee4digitPinCode = FALSE;
+common/cmm_profile.c:						DBGPRINT(RT_DEBUG_TRACE, ("Wsc4digitPinCode=%d\n", pAd->StaCfg.WscControl.WscEnrollee4digitPinCode));
+common/cmm_profile.c:						pWscContrl = &pAd->ApCfg.MBSSID[BSS0].WscControl;
+common/cmm_profile.c:						pWscContrl = &pAd->StaCfg.WscControl;
+common/cmm_profile.c:							if (i >= pAd->ApCfg.BssidNum)
+common/cmm_profile.c:							pAd->ApCfg.MBSSID[i].WscControl.WscV2Info.bEnableWpsV2 = bEnable;
+common/cmm_profile.c:						pAd->StaCfg.WscControl.WscV2Info.bEnableWpsV2 = bEnable;
+common/cmm_profile.c:						pAd->ApCfg.EntryLifeCheck = LifeCheckCnt;
+common/cmm_profile.c:						pAd->ApCfg.EntryLifeCheck = MAC_ENTRY_LIFE_CHECK_CNT;
+common/cmm_profile.c:					DBGPRINT(RT_DEBUG_ERROR, ("EntryLifeCheck=%ld\n", pAd->ApCfg.EntryLifeCheck));
+common/cmm_profile.c:					pAd->CommonCfg.AntGain= AntGain;
+common/cmm_profile.c:					DBGPRINT(RT_DEBUG_TRACE, ("AntGain=%d\n", pAd->CommonCfg.AntGain));
+common/cmm_profile.c:					pAd->CommonCfg.BandedgeDelta = Bandedge;
+common/cmm_profile.c:					DBGPRINT(RT_DEBUG_TRACE, ("BandedgeDelta=%d\n", pAd->CommonCfg.BandedgeDelta));
+common/cmm_profile.c:				pAd->P2pCfg.GoIntentIdx = simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_ERROR, ("P2P_GOIntent=%d\n", pAd->P2pCfg.GoIntentIdx));
+common/cmm_profile.c:					pAd->P2pCfg.DeviceNameLen = (UCHAR) strlen(tmpbuf);
+common/cmm_profile.c:					NdisZeroMemory(pAd->P2pCfg.DeviceName, 32);
+common/cmm_profile.c:					NdisMoveMemory(pAd->P2pCfg.DeviceName, tmpbuf, pAd->P2pCfg.DeviceNameLen);
+common/cmm_profile.c:				pAd->P2pCfg.ListenChannel = simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_ERROR, ("P2P_ListChannel=%d\n", pAd->P2pCfg.ListenChannel));
+common/cmm_profile.c:				pAd->P2pCfg.GroupChannel = simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_ERROR, ("P2P_OpChannel=%d\n", pAd->P2pCfg.GroupChannel));
+common/cmm_profile.c:				if (pAd->P2pCfg.WscMode == WSC_PIN_MODE)
+common/cmm_profile.c:						pAd->P2pCfg.DefaultConfigMethod = P2P_REG_CM_DISPLAY;
+common/cmm_profile.c:						pAd->P2pCfg.DefaultConfigMethod = P2P_REG_CM_KEYPAD;
+common/cmm_profile.c:				else if (pAd->P2pCfg.WscMode == WSC_PBC_MODE)
+common/cmm_profile.c:					pAd->P2pCfg.DefaultConfigMethod = P2P_REG_CM_PBC;
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_ERROR, ("P2P_WscCfgMethod=%d\n", pAd->P2pCfg.DefaultConfigMethod));
+common/cmm_profile.c:					pAd->P2pCfg.bExtListen = FALSE;
+common/cmm_profile.c:					pAd->P2pCfg.bExtListen = TRUE;
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_ERROR, ("P2P_ExtListen=%d\n", pAd->P2pCfg.bExtListen));
+common/cmm_profile.c:				pAd->P2pCfg.ExtListenPeriod = simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_ERROR, ("P2P_ExtListenPrd=%d\n", pAd->P2pCfg.ExtListenPeriod));
+common/cmm_profile.c:				pAd->P2pCfg.ExtListenInterval = simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_ERROR, ("P2P_ExtenListenInv=%d\n", pAd->P2pCfg.ExtListenInterval));
+common/cmm_profile.c:					pAd->P2pCfg.bIntraBss = FALSE;
+common/cmm_profile.c:					pAd->P2pCfg.bIntraBss = TRUE;
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_ERROR, ("P2P_IntraBss=%d\n", pAd->P2pCfg.bIntraBss));
+common/cmm_profile.c:				pAd->P2pCfg.GONoASchedule.Count = simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_ERROR, ("P2P_NoACnt=%d\n", pAd->P2pCfg.GONoASchedule.Count));
+common/cmm_profile.c:				pAd->P2pCfg.GONoASchedule.Duration = simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_ERROR, ("P2P_NoADuration=%ld\n", pAd->P2pCfg.GONoASchedule.Duration));
+common/cmm_profile.c:				pAd->P2pCfg.GONoASchedule.Interval = simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_ERROR, ("P2P_NoAInv=%d\n", pAd->P2pCfg.GONoASchedule.Interval));
+common/cmm_profile.c:				pAd->P2pCfg.p2pMaxEntry= simple_strtol(tmpbuf, 0, 10);
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_ERROR, ("P2P_MaxEntry=%d\n", pAd->P2pCfg.p2pMaxEntry));
+common/cmm_profile.c:				if (strlen(tmpbuf) < sizeof(pAd->MC_FileName))
+common/cmm_profile.c:					pAd->MC_RowID = card_match_id; /* base 0 */
+common/cmm_profile.c:					NdisMoveMemory(pAd->MC_FileName, tmpbuf , strlen(tmpbuf));
+common/cmm_profile.c:					pAd->MC_FileName[strlen(tmpbuf)] = '\0';
+common/cmm_profile.c:							("Card Profile Name = %s\n", pAd->MC_FileName));
+common/cmm_profile.c:		pWscControl = &pAd->ApCfg.MBSSID[i].WscControl;
+common/cmm_profile.c:	pWscControl = &pAd->ApCfg.ApCliTab[0].WscControl;
+common/cmm_profile.c:	pWscControl = &pAd->StaCfg.WscControl;
+common/cmm_profile.c:	            pAd->MulTestTab.WdsEntry[i].PhyMode = MODE_CCK;
+common/cmm_profile.c:	            pAd->MulTestTab.WdsEntry[i].PhyMode = MODE_OFDM;
+common/cmm_profile.c:	            pAd->MulTestTab.WdsEntry[i].PhyMode = MODE_HTMIX;
+common/cmm_profile.c:	            pAd->MulTestTab.WdsEntry[i].PhyMode = MODE_HTGREENFIELD;
+common/cmm_profile.c:	            pAd->MulTestTab.WdsEntry[i].PhyMode = 0xff;
+common/cmm_profile.c:	        DBGPRINT(RT_DEBUG_TRACE, ("If/wds%d - WdsPhyMode=%d\n", i, pAd->MulTestTab.WdsEntry[i].PhyMode));	    
+common/cmm_profile.c:					if (pAd->MulTestTab.WdsEntry[iii].Valid == FALSE)
+common/cmm_profile.c:						pAd->MulTestTab.WdsEntry[iii].Valid = TRUE;
+common/cmm_profile.c:						pAd->MulTestTab.Size ++;
+common/cmm_profile.c:						COPY_MAC_ADDR(pAd->MulTestTab.WdsEntry[iii].PeerWdsAddr, macAddress);
+common/cmm_profile.c:					else if (MAC_ADDR_EQUAL(pAd->MulTestTab.WdsEntry[iii].PeerWdsAddr, macAddress))
+common/cmm_profile.c:	            pAd->MulTestTab.WdsEntry[i].WepStatus = Ndis802_11WEPDisabled;
+common/cmm_profile.c:	            pAd->MulTestTab.WdsEntry[i].WepStatus = Ndis802_11WEPEnabled;
+common/cmm_profile.c:	            pAd->MulTestTab.WdsEntry[i].WepStatus = Ndis802_11Encryption2Enabled;
+common/cmm_profile.c:	            pAd->MulTestTab.WdsEntry[i].WepStatus = Ndis802_11Encryption3Enabled;
+common/cmm_profile.c:	            pAd->MulTestTab.WdsEntry[i].WepStatus = Ndis802_11EncryptionSMS4Enabled;
+common/cmm_profile.c:	            pAd->MulTestTab.WdsEntry[i].WepStatus = Ndis802_11WEPDisabled;
+common/cmm_profile.c:	        DBGPRINT(RT_DEBUG_TRACE, ("WdsEncrypType[%d]=%d(%s)\n", i, pAd->MulTestTab.WdsEntry[i].WepStatus, GetEncryptType(pAd->MulTestTab.WdsEntry[i].WepStatus)));
+common/cmm_profile.c:				pAd->MulTestTab.WdsEntry[j].WepStatus = pAd->MulTestTab.WdsEntry[0].WepStatus;	
+common/cmm_profile.c:				DBGPRINT(RT_DEBUG_TRACE, ("@WdsEncrypType[%d]=%d(%s)\n", j, pAd->MulTestTab.WdsEntry[i].WepStatus, GetEncryptType(pAd->MulTestTab.WdsEntry[i].WepStatus)));	
+common/cmm_profile.c:			NdisZeroMemory(&pAd->MulTestTab.WdsEntry[i].WdsKey, sizeof(CIPHER_KEY));
+common/cmm_profile.c:		if (((pAd->MulTestTab.WdsEntry[0].WepStatus == Ndis802_11Encryption2Enabled)
+common/cmm_profile.c:				|| (pAd->MulTestTab.WdsEntry[0].WepStatus == Ndis802_11Encryption3Enabled))
+common/cmm_profile.c:			if (pAd->MulTestTab.WdsEntry[0].WepStatus == Ndis802_11Encryption3Enabled)
+common/cmm_profile.c:				pAd->MulTestTab.WdsEntry[0].WdsKey.CipherAlg = CIPHER_AES;
+common/cmm_profile.c:				pAd->MulTestTab.WdsEntry[0].WdsKey.CipherAlg = CIPHER_TKIP;
+common/cmm_profile.c:			NdisMoveMemory(&pAd->MulTestTab.WdsEntry[0].WdsKey.Key, keyMaterial, 16);
+common/cmm_profile.c:			pAd->MulTestTab.WdsEntry[0].WdsKey.KeyLen = 16;
+common/cmm_profile.c:			NdisMoveMemory(&pAd->MulTestTab.WdsEntry[0].WdsKey.RxMic, keyMaterial+16, 8);
+common/cmm_profile.c:			NdisMoveMemory(&pAd->MulTestTab.WdsEntry[0].WdsKey.TxMic, keyMaterial+16, 8);
+common/cmm_profile.c:		if (pAd->MulTestTab.WdsEntry[0].WdsKey.KeyLen == 16)
+common/cmm_profile.c:				NdisMoveMemory(&pAd->MulTestTab.WdsEntry[j].WdsKey, &pAd->MulTestTab.WdsEntry[0].WdsKey, sizeof(CIPHER_KEY));								
+common/cmm_profile.c:				if (pAd->MulTestTab.WdsEntry[i].WepStatus == Ndis802_11Encryption1Enabled)
+common/cmm_profile.c:						pAd->MulTestTab.WdsEntry[i].WdsKey.KeyLen = KeyLen;
+common/cmm_profile.c:						NdisMoveMemory(pAd->MulTestTab.WdsEntry[i].WdsKey.Key, tmpbuf, KeyLen);
+common/cmm_profile.c:						pAd->MulTestTab.WdsEntry[i].WdsKey.CipherAlg = CipherAlg;
+common/cmm_profile.c:						pAd->MulTestTab.WdsEntry[i].WdsKey.KeyLen = KeyLen / 2;
+common/cmm_profile.c:						AtoH(tmpbuf, pAd->MulTestTab.WdsEntry[i].WdsKey.Key, KeyLen / 2);						
+common/cmm_profile.c:						pAd->MulTestTab.WdsEntry[i].WdsKey.CipherAlg = CipherAlg;
+common/cmm_profile.c:						pAd->MulTestTab.WdsEntry[i].WepStatus = Ndis802_11EncryptionDisabled;
+common/cmm_profile.c:						NdisZeroMemory(&pAd->MulTestTab.WdsEntry[i].WdsKey, sizeof(CIPHER_KEY));
+common/cmm_profile.c:				else if ((pAd->MulTestTab.WdsEntry[i].WepStatus == Ndis802_11Encryption2Enabled)
+common/cmm_profile.c:					|| (pAd->MulTestTab.WdsEntry[i].WepStatus == Ndis802_11Encryption3Enabled)
+common/cmm_profile.c:					|| (pAd->MulTestTab.WdsEntry[i].WepStatus == Ndis802_11EncryptionSMS4Enabled)
+common/cmm_profile.c:						if (pAd->MulTestTab.WdsEntry[i].WepStatus == Ndis802_11Encryption3Enabled)
+common/cmm_profile.c:							pAd->MulTestTab.WdsEntry[i].WdsKey.CipherAlg = CIPHER_AES;
+common/cmm_profile.c:						else if (pAd->MulTestTab.WdsEntry[i].WepStatus == Ndis802_11EncryptionSMS4Enabled)
+common/cmm_profile.c:							pAd->MulTestTab.WdsEntry[i].WdsKey.CipherAlg = CIPHER_SMS4;
+common/cmm_profile.c:							pAd->MulTestTab.WdsEntry[i].WdsKey.CipherAlg = CIPHER_TKIP;
+common/cmm_profile.c:						NdisMoveMemory(&pAd->MulTestTab.WdsEntry[i].WdsKey.Key, keyMaterial, 16);
+common/cmm_profile.c:						pAd->MulTestTab.WdsEntry[i].WdsKey.KeyLen = 16;
+common/cmm_profile.c:						NdisMoveMemory(&pAd->MulTestTab.WdsEntry[i].WdsKey.RxMic, keyMaterial+16, 8);
+common/cmm_profile.c:						NdisMoveMemory(&pAd->MulTestTab.WdsEntry[i].WdsKey.TxMic, keyMaterial+16, 8);
+common/cmm_profile.c:						pAd->MulTestTab.WdsEntry[i].WepStatus = Ndis802_11EncryptionDisabled;
+common/cmm_profile.c:						NdisZeroMemory(&pAd->MulTestTab.WdsEntry[i].WdsKey, sizeof(CIPHER_KEY));
+common/cmm_profile.c:					pAd->MulTestTab.WdsEntry[i].WepStatus = Ndis802_11EncryptionDisabled;
+common/cmm_profile.c:					NdisZeroMemory(&pAd->MulTestTab.WdsEntry[i].WdsKey, sizeof(CIPHER_KEY));
+common/cmm_profile.c:				pAd->MulTestTab.WdsEntry[i].KeyIdx = (UCHAR) (KeyIdx - 1);
+common/cmm_profile.c:				pAd->MulTestTab.WdsEntry[i].KeyIdx = 0;
+common/cmm_profile.c:			if ((pAd->MulTestTab.WdsEntry[i].WepStatus == Ndis802_11Encryption2Enabled)
+common/cmm_profile.c:					|| (pAd->MulTestTab.WdsEntry[i].WepStatus == Ndis802_11Encryption3Enabled))
+common/cmm_profile.c:				pAd->MulTestTab.WdsEntry[i].KeyIdx = 0;	
+common/cmm_profile.c:			DBGPRINT(RT_DEBUG_TRACE, ("IF/wds%d - WdsDefaultKeyID(0~3)=%d\n", i, pAd->MulTestTab.WdsEntry[i].KeyIdx));	
+common/cmm_profile.c:	if (pAd->TxPowerCtrl.bInternalTxALC != TRUE)
+common/cmm_profile.c:	DlListInit(&pAd->SingleSkuPwrList);
+common/cmm_profile.c:					DlListAddTail(&pAd->SingleSkuPwrList, &pwr->List);
+common/cmm_profile.c:						DlListAddTail(&pAd->SingleSkuPwrList, &StartCh->List);
+common/cmm_profile.c:		DlListForEachSafe(ch, ch_temp, &pAd->SingleSkuPwrList, CH_POWER, List)
+common/cmm_profile.c:	UCHAR base_pwr = pAd->DefaultTargetPwr;
+common/cmm_profile.c:	DlListForEachSafe(ch, ch_temp, &pAd->SingleSkuPwrList, CH_POWER, List)
+common/cmm_profile.c:			if (pAd->CommonCfg.BBPCurrentBW == BW_40)
+common/cmm_profile.c:	UCHAR rate_pwr = pAd->DefaultTargetPwr;
+common/cmm_profile.c:	DlListForEachSafe(ch, ch_temp, &pAd->SingleSkuPwrList, CH_POWER, List)
+common/cmm_profile.c:	if ( rate_pwr > pAd->DefaultTargetPwr )
+common/cmm_profile.c:		rate_pwr = pAd->DefaultTargetPwr;
+common/cmm_profile.c:		Adata = ((rate_table[i*4] + pAd->chipCap.Apwrdelta ) & 0x3F )+ ( ((rate_table[i*4 + 1] + pAd->chipCap.Apwrdelta) & 0x3F) << 8);
+common/cmm_profile.c:		Gdata = ((rate_table[i*4] + pAd->chipCap.Gpwrdelta ) & 0x3F ) + ( ((rate_table[i*4 + 1] + pAd->chipCap.Gpwrdelta) & 0x3F) << 8);
+common/cmm_profile.c:			Adata |= ( ((rate_table[i*4 + 2] + pAd->chipCap.Apwrdelta ) & 0x3F) << 16) + ( ((rate_table[i*4 + 3] + pAd->chipCap.Apwrdelta) & 0x3F) << 24);
+common/cmm_profile.c:			Gdata |= ( ((rate_table[i*4 + 2] + pAd->chipCap.Gpwrdelta ) & 0x3F) << 16) + ( ((rate_table[i*4 + 3] + pAd->chipCap.Gpwrdelta) & 0x3F) << 24);
+common/cmm_profile.c:		pAd->Tx20MPwrCfgABand[i] = data;
+common/cmm_profile.c:		pAd->Tx20MPwrCfgGBand[i] = data;
+common/cmm_profile.c:		pAd->Tx40MPwrCfgABand[i] = Adata;
+common/cmm_profile.c:		pAd->Tx40MPwrCfgGBand[i] = Gdata;
+common/multi_channel.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/multi_channel.c:	NdisZeroMemory(pAd->NullFrBuf, sizeof(pAd->NullFrBuf));
+common/multi_channel.c:	pTxWI = (TXWI_STRUC *)&pAd->NullFrBuf[0];
+common/multi_channel.c:	pNullFrame = &pAd->NullFrBuf[TXWISize];
+common/multi_channel.c:		pApCliEntry = &pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx];
+common/multi_channel.c:		COPY_MAC_ADDR(pNullFr->Addr2, pAd->CurrentAddress);
+common/multi_channel.c:		COPY_MAC_ADDR(pNullFr->Addr3, pAd->CommonCfg.Bssid);
+common/multi_channel.c:	pNullFr->Duration = pAd->CommonCfg.Dsifs + RTMPCalcDuration(pAd, pAd->CommonCfg.TxRate, 14);
+common/multi_channel.c:	pNullFr->Sequence = pAd->Sequence;
+common/multi_channel.c:	pAd->Sequence = (pAd->Sequence+1) & MAXSEQ; /* next sequence  */
+common/multi_channel.c:		0, 0, (UCHAR)pAd->CommonCfg.MlmeTransmit.field.MCS, IFS_HTTXOP, FALSE, &pAd->CommonCfg.MlmeTransmit);
+common/multi_channel.c:	hex_dump("RtmpPrepareHwNullFrame", pAd->NullFrBuf, TXWISize + frameLen);
+common/multi_channel.c:	pAd->NullFrLen = totalLen;
+common/multi_channel.c:	ptr = pAd->NullFrBuf;
+common/multi_channel.c:	NdisMoveMemory(pNullFrBuf, pAd->NullFrBuf, totalLen);
+common/multi_channel.c:			RTMP_IO_WRITE32(pAd, pAd->NullBufOffset[0] + i, longValue);
+common/multi_channel.c:			RTMP_IO_WRITE32(pAd, pAd->NullBufOffset[1] + i, longValue);
+common/multi_channel.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/multi_channel.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s - Send NULL Frame @%d Mbps...\n", __FUNCTION__, RateIdToMbps[pAd->CommonCfg.TxRate]));
+common/multi_channel.c:	pNullFr = (PHEADER_802_11)((&pAd->NullFrBuf[0]) +TXWISize);
+common/multi_channel.c:	pNullFr->Duration = pAd->CommonCfg.Dsifs + RTMPCalcDuration(pAd, TxRate, 14);
+common/multi_channel.c:	pNullFr->Sequence = pAd->Sequence;
+common/multi_channel.c:	pAd->Sequence = (pAd->Sequence+1) & MAXSEQ; /* next sequence  */
+common/multi_channel.c:	//hex_dump("RtmpPrepareHwNullFrame", pAd->NullFrBuf,  pAd->NullFrLen);
+common/multi_channel.c:		ptr = pAd->NullFrBuf + TXWISize;
+common/multi_channel.c:		RTMP_IO_WRITE32(pAd, pAd->NullBufOffset[0] + TXWISize, longValue);
+common/multi_channel.c:		ptr = pAd->NullFrBuf + TXWISize + 20;	// update Sequence
+common/multi_channel.c:		RTMP_IO_WRITE32(pAd, pAd->NullBufOffset[0] + TXWISize + 20, longValue);
+common/multi_channel.c:		ptr = pAd->NullFrBuf + TXWISize;
+common/multi_channel.c:		RTMP_IO_WRITE32(pAd, pAd->NullBufOffset[1] + TXWISize, longValue);
+common/multi_channel.c:		ptr = pAd->NullFrBuf + TXWISize + 20;	// update Sequence
+common/multi_channel.c:		RTMP_IO_WRITE32(pAd, pAd->NullBufOffset[1] + TXWISize + 20, longValue);
+common/p2p_table.c:	pAd->P2pTable.PerstNumber = pP2pPerstTab->PerstNumber;
+common/p2p_table.c:	if (pAd->P2pTable.PerstNumber == 0)
+common/p2p_table.c:			pAd->P2pTable.PerstEntry[i].bValid = FALSE;
+common/p2p_table.c:		RTMPMoveMemory(&pAd->P2pTable.PerstEntry[i], &pP2pPerstTab->PerstEntry[i], sizeof(RT_P2P_PERSISTENT_ENTRY));
+common/p2p_table.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p_table.c:			PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[i];
+common/p2p_table.c:		if ((bAllPsm == TRUE) && (pAd->MacTab.Size > 0))
+common/p2p_table.c:		else if (P2P_TEST_BIT(pAd->P2pCfg.CTWindows, P2P_OPPS_BIT))
+common/p2p_table.c:		if (pAd->P2pTable.Client[pAd->P2pCfg.p2pidxForServiceCbReq].ConfigTimeOut > 0)
+common/p2p_table.c:			pAd->P2pTable.Client[pAd->P2pCfg.p2pidxForServiceCbReq].ConfigTimeOut--;
+common/p2p_table.c:		if (pAd->P2pTable.Client[pAd->P2pCfg.p2pidxForServiceCbReq].P2pClientState == P2PSTATE_SERVICE_COMEBACK_COMMAND
+common/p2p_table.c:			&& (pAd->P2pTable.Client[pAd->P2pCfg.p2pidxForServiceCbReq].ConfigTimeOut == 0))
+common/p2p_table.c:			/*P2pSendComebackReq(pAd, pAd->P2pCfg.p2pidxForServiceCbReq, pAd->P2pTable.Client[pAd->P2pCfg.p2pidxForServiceCbReq].addr); */
+common/p2p_table.c:			pP2pEntry = &pAd->P2pTable.Client[i];
+common/p2p_table.c:			pP2pEntry = &pAd->P2pTable.Client[i];
+common/p2p_table.c:				P2PSendDevDisRsp(pAd, P2PSTATUS_SUCCESS, pAd->P2pCfg.LatestP2pPublicFrame.Token, pAd->P2pCfg.LatestP2pPublicFrame.p80211Header.Addr2, &TotalFrameLen);
+common/p2p_table.c:	else if ((pAd->flg_p2p_OpStatusFlags == 0) &&
+common/p2p_table.c:			pP2pEntry = &pAd->P2pTable.Client[i];
+common/p2p_table.c:				pAd->StaCfg.WscControl.WscState = WSC_STATE_OFF;
+common/p2p_table.c:				pAd->P2pCfg.GoIntentIdx = 15;
+common/p2p_table.c:	pEntry = &pAd->MacTab.Content[Macindex];
+common/p2p_table.c:	pP2pEntry = &pAd->P2pTable.Client[P2pindex];
+common/p2p_table.c:	pEntry = &pAd->MacTab.Content[Macindex];
+common/p2p_table.c:	pP2pEntry = &pAd->P2pTable.Client[P2pindex];
+common/p2p_table.c:	PRT_P2P_TABLE	Tab = &pAd->P2pTable;
+common/p2p_table.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_table.c:		pP2pEntry = &pAd->P2pTable.Client[i];
+common/p2p_table.c:			pMsgElem->PortNum = pAd->PortList[pAd->P2pCfg.PortNumber]->PortNumber;
+common/p2p_table.c:			if (pAd->P2pTable.ClientNumber > 0)
+common/p2p_table.c:				pAd->P2pTable.ClientNumber--;
+common/p2p_table.c:	PRT_P2P_TABLE	Tab = &pAd->P2pTable;
+common/p2p_table.c:	RTMP_SEM_LOCK(&pAd->P2pTableSemLock);
+common/p2p_table.c:		RTMP_SEM_UNLOCK(&pAd->P2pTableSemLock);
+common/p2p_table.c:		RTMP_SEM_UNLOCK(&pAd->P2pTableSemLock);
+common/p2p_table.c:			RTMP_SEM_UNLOCK(&pAd->P2pTableSemLock);
+common/p2p_table.c:			pAd->P2pTable.Client[i].Dbm = 0;
+common/p2p_table.c:			pAd->P2pTable.Client[i].GoIntent = 0;
+common/p2p_table.c:			pAd->P2pTable.Client[i].MyGOIndex = 0xff;
+common/p2p_table.c:			pAd->P2pTable.Client[i].Peerip = 0;
+common/p2p_table.c:			pAd->P2pTable.Client[i].ConfigTimeOut = 0;
+common/p2p_table.c:			pAd->P2pTable.Client[i].OpChannel = 0;
+common/p2p_table.c:			pAd->P2pTable.Client[i].ListenChannel = 0;
+common/p2p_table.c:			pAd->P2pTable.Client[i].GeneralToken = RandomByte(pAd);
+common/p2p_table.c:			pAd->P2pTable.Client[i].DevCapability = DevCap;
+common/p2p_table.c:			pAd->P2pTable.Client[i].GroupCapability = GrpCap;
+common/p2p_table.c:			pAd->P2pTable.Client[i].ReTransmitCnt = 0;
+common/p2p_table.c:			if ((pAd->P2pTable.Client[i].GeneralToken == 0)
+common/p2p_table.c:				 || (pAd->P2pTable.Client[i].GeneralToken > 245))
+common/p2p_table.c:				 pAd->P2pTable.Client[i].GeneralToken = 6;
+common/p2p_table.c:			pAd->P2pTable.Client[i].Dpid = DEV_PASS_ID_NOSPEC;
+common/p2p_table.c:			pAd->P2pTable.Client[i].P2pFlag = 0;
+common/p2p_table.c:				pAd->P2pTable.Client[i].Rule = P2P_IS_GO;
+common/p2p_table.c:				pAd->P2pTable.Client[i].Rule = P2P_IS_CLIENT;
+common/p2p_table.c:			RTMP_SEM_UNLOCK(&pAd->P2pTableSemLock);
+common/p2p_table.c:	RTMP_SEM_UNLOCK(&pAd->P2pTableSemLock);
+common/p2p_table.c:	RTMP_SEM_LOCK(&pAd->P2pTableSemLock);
+common/p2p_table.c:		pP2pEntry = &pAd->P2pTable.Client[index];
+common/p2p_table.c:		if ((pAd->P2pTable.ClientNumber > 0) && (pP2pEntry->P2pClientState != P2PSTATE_NONE))
+common/p2p_table.c:			pAd->P2pTable.ClientNumber--;
+common/p2p_table.c:	RTMP_SEM_UNLOCK(&pAd->P2pTableSemLock);
+common/p2p_table.c:	PRT_P2P_TABLE	Tab = &pAd->P2pTable;
+common/p2p_table.c:		pP2pPerstEntry = &pAd->P2pTable.PerstEntry[i];
+common/p2p_table.c:	pAd->P2pTable.PerstNumber = 0;
+common/p2p_table.c:	PRT_P2P_TABLE	Tab = &pAd->P2pTable;
+common/p2p_table.c:	PRT_P2P_TABLE	Tab = &pAd->P2pTable;
+common/p2p_table.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p_table.c:	PRT_P2P_TABLE	Tab = &pAd->P2pTable;
+common/p2p_table.c:		pCrednEntry = &pAd->P2pTable.TempCredential[i];
+common/p2p_table.c:	PRT_P2P_TABLE	Tab = &pAd->P2pTable;
+common/p2p_table.c:	PRT_P2P_TABLE	Tab = &pAd->P2pTable;
+common/p2p_table.c:	if (pAd->P2pCfg.bSigmaEnabled == TRUE)
+common/p2p_table.c:			p2p_all_info.P2PChannel = pAd->CommonCfg.Channel;
+common/p2p_table.c:			RtmpOSWrielessEventSend(pAd->p2p_dev, RT_WLAN_EVENT_CUSTOM, RT_P2P_DEVICE_FIND, NULL, &p2p_all_info, sizeof(RT_P2P_ALL_INFO));
+common/p2p_table.c:				PRT_P2P_CONFIG pP2pCtrl = &pAd->P2pCfg;
+common/p2p_table.c:				p2p_all_info.P2PChannel = pAd->CommonCfg.Channel;
+common/p2p_table.c:				RtmpOSWrielessEventSend(pAd->p2p_dev, RT_WLAN_EVENT_CUSTOM, RT_P2P_RECV_PROV_REQ, NULL, &p2p_all_info, sizeof(RT_P2P_ALL_INFO));
+common/p2p_table.c:			RtmpOSWrielessEventSend(pAd->p2p_dev, RT_WLAN_EVENT_CUSTOM, RT_P2P_RECV_PROV_RSP, NULL, &p2p_prov_disc_rsp, sizeof(RT_P2P_PROV_DISC_RESP));
+common/p2p_table.c:				PRT_P2P_CONFIG pP2pCtrl = &pAd->P2pCfg;
+common/p2p_table.c:				RtmpOSWrielessEventSend(pAd->p2p_dev, RT_WLAN_EVENT_CUSTOM, RT_P2P_RECV_INVITE_REQ, NULL, &p2p_dev_info, sizeof(RT_P2P_DEV_FOUND));
+common/p2p_table.c:				PRT_P2P_CONFIG pP2pCtrl = &pAd->P2pCfg;
+common/p2p_table.c:				RtmpOSWrielessEventSend(pAd->p2p_dev, RT_WLAN_EVENT_CUSTOM, RT_P2P_RECV_GO_NEGO_REQ, NULL, &p2p_dev_info, sizeof(RT_P2P_DEV_FOUND));                       
+common/p2p_table.c:				p2p_all_info.P2PChannel = pAd->CommonCfg.Channel;
+common/p2p_table.c:				RtmpOSWrielessEventSend(pAd->p2p_dev, RT_WLAN_EVENT_CUSTOM, RT_P2P_RECV_GO_NEGO_REQ, NULL, &p2p_all_info, sizeof(RT_P2P_ALL_INFO));
+common/p2p_table.c:			RtmpOSWrielessEventSend(pAd->p2p_dev, RT_WLAN_EVENT_CUSTOM, RT_P2P_GO_NEG_COMPLETED, NULL, NULL, 0);
+common/p2p_table.c:			RtmpOSWrielessEventSend(pAd->p2p_dev, RT_WLAN_EVENT_CUSTOM, RT_P2P_WPS_COMPLETED, NULL, NULL, 0);
+common/p2p_table.c:					pWScControl = &pAd->ApCfg.MBSSID[0].WscControl;
+common/p2p_table.c:					RTMPMoveMemory(p2p_all_info.Bssid, pAd->P2PCurrentAddress, MAC_ADDR_LEN);
+common/p2p_table.c:					RTMPMoveMemory(p2p_all_info.Ssid, pAd->ApCfg.MBSSID[MAIN_MBSSID].Ssid, pAd->ApCfg.MBSSID[MAIN_MBSSID].SsidLen);
+common/p2p_table.c:					p2p_all_info.P2PChannel = pAd->CommonCfg.Channel;
+common/p2p_table.c:					pWScControl = &pAd->ApCfg.ApCliTab[0].WscControl;
+common/p2p_table.c:					RTMPMoveMemory(p2p_all_info.Bssid, pAd->P2pCfg.Bssid, MAC_ADDR_LEN);
+common/p2p_table.c:					RTMPMoveMemory(p2p_all_info.Ssid, pAd->P2pCfg.SSID, pAd->P2pCfg.SSIDLen);
+common/p2p_table.c:					p2p_all_info.P2PChannel = pAd->CommonCfg.Channel;
+common/p2p_table.c:                                                pP2pEntry = &pAd->P2pTable.Client[p2pIdx];
+common/p2p_table.c:							p2p_all_info.wfd_devive_type = pAd->P2pTable.Client[p2pIdx].WfdEntryInfo.wfd_devive_type;
+common/p2p_table.c:							p2p_all_info.source_coupled = pAd->P2pTable.Client[p2pIdx].WfdEntryInfo.source_coupled;
+common/p2p_table.c:							p2p_all_info.session_avail = pAd->P2pTable.Client[p2pIdx].WfdEntryInfo.session_avail;
+common/p2p_table.c:							p2p_all_info.sink_coupled = pAd->P2pTable.Client[p2pIdx].WfdEntryInfo.sink_coupled;
+common/p2p_table.c:							p2p_all_info.wfd_service_discovery = pAd->P2pTable.Client[p2pIdx].WfdEntryInfo.wfd_service_discovery;
+common/p2p_table.c:							p2p_all_info.wfd_PC = pAd->P2pTable.Client[p2pIdx].WfdEntryInfo.wfd_PC;
+common/p2p_table.c:							p2p_all_info.wfd_CP = pAd->P2pTable.Client[p2pIdx].WfdEntryInfo.wfd_CP;
+common/p2p_table.c:							p2p_all_info.wfd_time_sync = pAd->P2pTable.Client[p2pIdx].WfdEntryInfo.wfd_time_sync;
+common/p2p_table.c:							p2p_all_info.rtsp_port = pAd->P2pTable.Client[p2pIdx].WfdEntryInfo.rtsp_port;
+common/p2p_table.c:							p2p_all_info.max_throughput = pAd->P2pTable.Client[p2pIdx].WfdEntryInfo.max_throughput;
+common/p2p_table.c:							RTMPMoveMemory(p2p_all_info.assoc_addr, pAd->P2pTable.Client[p2pIdx].WfdEntryInfo.assoc_addr, MAC_ADDR_LEN);
+common/p2p_table.c:							p2p_all_info.coupled_sink_status.CoupledStat = pAd->P2pTable.Client[p2pIdx].WfdEntryInfo.coupled_sink_status.CoupledStat;
+common/p2p_table.c:				RtmpOSWrielessEventSend(pAd->p2p_dev, RT_WLAN_EVENT_CUSTOM, RT_P2P_CONNECTED, NULL, &p2p_all_info, sizeof(RT_P2P_ALL_INFO));
+common/p2p_table.c:			RtmpOSWrielessEventSend(pAd->p2p_dev, RT_WLAN_EVENT_CUSTOM, RT_P2P_DISCONNECTED, NULL, NULL, 0);
+common/p2p_table.c:			RtmpOSWrielessEventSend(pAd->p2p_dev, RT_WLAN_EVENT_CUSTOM, RT_P2P_CONNECT_FAIL, NULL, NULL, 0);
+common/p2p_table.c:			RtmpOSWrielessEventSend(pAd->p2p_dev, RT_WLAN_EVENT_CUSTOM, RT_P2P_LEGACY_CONNECTED, NULL, Addr, MAC_ADDR_LEN);
+common/p2p_table.c:			RtmpOSWrielessEventSend(pAd->p2p_dev, RT_WLAN_EVENT_CUSTOM, RT_P2P_LEGACY_DISCONNECTED, NULL, Addr, MAC_ADDR_LEN);
+common/p2p_table.c:			RtmpOSWrielessEventSend(pAd->p2p_dev, RT_WLAN_EVENT_CUSTOM, RT_P2P_AP_STA_CONNECTED, NULL, &p2p_ap_sta_connected, sizeof(RT_P2P_AP_STA_CONNECTED_REPORT));
+common/p2p_table.c:			RtmpOSWrielessEventSend(pAd->p2p_dev, RT_WLAN_EVENT_CUSTOM, RT_P2P_AP_STA_DISCONNECTED, NULL, &p2p_ap_sta_connected, sizeof(RT_P2P_AP_STA_CONNECTED_REPORT));
+common/wsc_v2.c:	PWSC_V2_INFO	pWpsV2Info = &pAd->ApCfg.MBSSID[ApIdx & 0x0F].WscControl.WscV2Info;
+common/wsc_v2.c:		pAd->ApCfg.MBSSID[ApIdx & 0x0F].WscIEBeacon.ValueLen = 0;
+common/wsc_v2.c:		pAd->ApCfg.MBSSID[ApIdx & 0x0F].WscIEProbeResp.ValueLen = 0;
+common/wsc_v2.c:		if (pAd->ApCfg.MBSSID[ApIdx & 0x0F].WscControl.WscConfMode != WSC_DISABLE)
+common/wsc_v2.c:			IsAPConfigured = pAd->ApCfg.MBSSID[ApIdx & 0x0F].WscControl.WscConfStatus;
+common/wsc_v2.c:	pACL = &pAd->ApCfg.MBSSID[ApIdx].AccessControlList;
+common/p2p_ctrl.c:	pAd->P2pCfg.CtrlCurrentState = P2P_CTRL_IDLE;
+common/p2p_ctrl.c:	P2P_CTRL_STATE *pCurrState = &(pAd->P2pCfg.CtrlCurrentState);
+common/p2p_ctrl.c:	P2P_CTRL_STATE *pCurrState = &(pAd->P2pCfg.CtrlCurrentState);
+common/p2p_ctrl.c:	/*PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;*/
+common/p2p_ctrl.c:	P2P_CTRL_STATE *pCurrState = &(pAd->P2pCfg.CtrlCurrentState);
+common/p2p_ctrl.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s::  P2P Device Discovery Finished, found total %d p2p devices.\n", __FUNCTION__, pAd->P2pTable.ClientNumber));
+common/p2p_ctrl.c:		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &bCancelled);
+common/p2p_ctrl.c:		pAd->MlmeAux.Channel = 0;
+common/p2p_ctrl.c:	P2P_CTRL_STATE *pCurrState = &(pAd->P2pCfg.CtrlCurrentState);
+common/p2p_ctrl.c:	/*PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;*/
+common/p2p_ctrl.c:	P2P_CTRL_STATE *pCurrState = &(pAd->P2pCfg.CtrlCurrentState);
+common/p2p_ctrl.c:	/*pAd->StaCfg.bAutoReconnect = TRUE;*/
+common/p2p_ctrl.c:	DBGPRINT(RT_DEBUG_ERROR, ("auto re-conect to GO[%s]\n", pAd->MlmeAux.Ssid));
+common/p2p_disc_mng.c:	pAd->P2pCfg.DiscCurrentState = P2P_DISC_IDLE;
+common/p2p_disc_mng.c:	P2P_DISC_STATE *pCurrState = &(pAd->P2pCfg.DiscCurrentState);
+common/p2p_disc_mng.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p_disc_mng.c:		/*pAd->StaCfg.bSkipAutoScanConn = TRUE;*/
+common/p2p_disc_mng.c:		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &Cancelled);
+common/p2p_disc_mng.c:		pAd->MlmeAux.Channel = 0;
+common/p2p_disc_mng.c:	pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+common/p2p_disc_mng.c:/*	pAd->StaCfg.bSkipAutoScanConn = FALSE;*/
+common/p2p_disc_mng.c:	P2P_DISC_STATE *pCurrState = &(pAd->P2pCfg.DiscCurrentState);
+common/p2p_disc_mng.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p_disc_mng.c:	if (INFRA_ON(pAd) || (pAd->flg_p2p_OpStatusFlags != P2P_DISABLE))
+common/p2p_disc_mng.c:		if ((pAd->CommonCfg.Channel != pAd->CommonCfg.CentralChannel) && (pAd->CommonCfg.BBPCurrentBW == BW_40))
+common/p2p_disc_mng.c:			channel = pAd->CommonCfg.CentralChannel;
+common/p2p_disc_mng.c:			channel = pAd->CommonCfg.Channel;
+common/p2p_disc_mng.c:	p2pindex = P2pGroupTabSearch(pAd, pAd->P2pCfg.ConnectingMAC);
+common/p2p_disc_mng.c:		if (pAd->P2pTable.Client[p2pindex].P2pClientState > P2PSTATE_DISCOVERY_UNKNOWN)
+common/p2p_disc_mng.c:	if (bGoBack && (channel != pAd->LatchRfRegs.Channel))
+common/p2p_disc_mng.c:		if (pAd->CommonCfg.BBPCurrentBW == BW_40)
+common/p2p_disc_mng.c:	P2P_DISC_STATE *pCurrState = &(pAd->P2pCfg.DiscCurrentState);
+common/p2p_disc_mng.c:	/*PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;*/
+common/p2p_disc_mng.c:	P2P_DISC_STATE *pCurrState = &(pAd->P2pCfg.DiscCurrentState);
+common/p2p_disc_mng.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p_disc_mng.c:	if (pAd->LatchRfRegs.Channel != pP2PCtrl->ListenChannel)
+common/p2p_disc_mng.c:	P2P_DISC_STATE *pCurrState = &(pAd->P2pCfg.DiscCurrentState);
+common/p2p_disc_mng.c:	/*PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;*/
+common/p2p_disc_mng.c:	P2P_DISC_STATE *pCurrState = &(pAd->P2pCfg.DiscCurrentState);
+common/p2p_disc_mng.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p_disc_mng.c:	pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+common/p2p_disc_mng.c:	P2P_DISC_STATE *pCurrState = &(pAd->P2pCfg.DiscCurrentState);
+Binary file common/p2p.o matches
+common/cmm_cmd.c:		NdisAcquireSpinLock(&pAd->CmdQLock);
+common/cmm_cmd.c:		if (pAd->CmdQ.CmdQState & RTMP_TASK_CAN_DO_INSERT)
+common/cmm_cmd.c:			EnqueueCmd((&pAd->CmdQ), cmdqelmt);
+common/cmm_cmd.c:		NdisReleaseSpinLock(&pAd->CmdQLock);
+common/cmm_cmd.c:			RTCMDUp(&pAd->cmdQTask);
+common/p2p_nego_mng.c:	pAd->P2pCfg.GoFormCurrentState = P2P_GO_FORM_IDLE;
+common/p2p_nego_mng.c:	if (pAd->P2pCfg.GoFormCurrentState != P2P_GO_FORM_IDLE && pAd->P2pCfg.GoFormCurrentState != P2P_WAIT_GO_FORM_CONF )
+common/p2p_nego_mng.c:	P2P_GO_FORM_STATE *pCurrState = &(pAd->P2pCfg.GoFormCurrentState);
+common/p2p_nego_mng.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p_nego_mng.c:			pAd->P2pTable.Client[pP2PCtrl->P2pProvIndex].ReTransmitCnt = 0;
+common/p2p_nego_mng.c:		pAd->P2pCfg.P2pCounter.UserAccept = 0;
+common/p2p_nego_mng.c:	pAd->StaCfg.bSkipAutoScanConn = TRUE;
+common/p2p_nego_mng.c:	if (pAd->P2pCfg.GoFormCurrentState != P2P_GO_FORM_IDLE && pAd->P2pCfg.GoFormCurrentState != P2P_WAIT_GO_FORM_RSP )
+common/p2p_nego_mng.c:	P2P_GO_FORM_STATE *pCurrState = &(pAd->P2pCfg.GoFormCurrentState);
+common/p2p_nego_mng.c:	P2P_GO_FORM_STATE *pCurrState = &(pAd->P2pCfg.GoFormCurrentState);
+common/p2p_nego_mng.c:	if (pAd->P2pCfg.GoFormCurrentState != P2P_WAIT_GO_FORM_CONF)
+common/p2p_nego_mng.c:	pAd->StaCfg.bSkipAutoScanConn = FALSE;
+common/p2p_nego_mng.c:	P2P_GO_FORM_STATE *pCurrState = &(pAd->P2pCfg.GoFormCurrentState);
+common/p2p_nego_mng.c:	if (pAd->P2pCfg.GoFormCurrentState != P2P_GO_FORM_IDLE)
+common/p2p_nego_mng.c:	pAd->StaCfg.bSkipAutoScanConn = TRUE;
+common/p2p_nego_mng.c:	P2P_GO_FORM_STATE *pCurrState = &(pAd->P2pCfg.GoFormCurrentState);
+common/p2p_nego_mng.c:	if (pAd->P2pCfg.GoFormCurrentState != P2P_WAIT_GO_FORM_PROV_RSP && pAd->P2pCfg.GoFormCurrentState != P2P_GO_FORM_IDLE)
+common/p2p_nego_mng.c:	pAd->StaCfg.bSkipAutoScanConn = FALSE;
+common/p2p_nego_mng.c:	P2P_GO_FORM_STATE *pCurrState = &(pAd->P2pCfg.GoFormCurrentState);
+common/p2p_nego_mng.c:	if (pAd->P2pCfg.GoFormCurrentState != P2P_WAIT_GO_FORM_DEV_DISC_RSP)
+common/p2p_nego_mng.c:	P2P_GO_FORM_STATE *pCurrState = &(pAd->P2pCfg.GoFormCurrentState);
+common/p2p_nego_mng.c:	if (pAd->P2pCfg.GoFormCurrentState != P2P_GO_FORM_IDLE )
+common/p2p_nego_mng.c:	pAd->StaCfg.bSkipAutoScanConn = TRUE;
+common/p2p_nego_mng.c:	P2P_GO_FORM_STATE *pCurrState = &(pAd->P2pCfg.GoFormCurrentState);
+common/p2p_nego_mng.c:	if (pAd->P2pCfg.GoFormCurrentState != P2P_WAIT_GO_FORM_INVITE_RSP)
+common/p2p_nego_mng.c:	pAd->StaCfg.bSkipAutoScanConn = FALSE;
+common/p2p_nego_mng.c:	P2P_GO_FORM_STATE *pCurrState = &(pAd->P2pCfg.GoFormCurrentState);
+common/p2p_nego_mng.c:	if (pAd->P2pCfg.GoFormCurrentState != P2P_GO_FORM_IDLE)
+common/p2p_nego_mng.c:	P2P_GO_FORM_STATE *pCurrState = &(pAd->P2pCfg.GoFormCurrentState);
+common/p2p_nego_mng.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p_nego_mng.c:	P2P_GO_FORM_STATE *pCurrState = &(pAd->P2pCfg.GoFormCurrentState);
+common/p2p_nego_mng.c:	if (pAd->P2pTable.Client[p2pIdx].Rule == P2P_IS_GO)
+common/p2p_nego_mng.c:		RTMPMoveMemory(&Addr, pAd->P2pTable.Client[p2pIdx].bssid, sizeof(Addr));
+common/p2p_nego_mng.c:		RTMPMoveMemory(&Addr, pAd->P2pTable.Client[p2pIdx].addr, sizeof(Addr));
+common/p2p_nego_mng.c:	if (pAd->P2pCfg.Dpid != DEV_PASS_ID_NOSPEC)
+common/p2p_nego_mng.c:		if ((pAd->P2pCfg.Dpid == DEV_PASS_ID_USER) && ((pAd->P2pTable.Client[p2pIdx].ConfigMethod & WSC_CONFMET_DISPLAY) != 0))
+common/p2p_nego_mng.c:			pAd->P2pTable.Client[p2pIdx].P2pClientState = P2PSTATE_SENT_PROVISION_REQ;
+common/p2p_nego_mng.c:			P2PSendProvisionReq(pAd, WSC_CONFMET_DISPLAY, pAd->P2pTable.Client[p2pIdx].GeneralToken, pAd->P2pTable.Client[p2pIdx].addr, &FrameLen);
+common/p2p_nego_mng.c:		else if ((pAd->P2pCfg.Dpid == DEV_PASS_ID_PBC) && ((pAd->P2pTable.Client[p2pIdx].ConfigMethod & WSC_CONFMET_PBC) != 0))
+common/p2p_nego_mng.c:			pAd->P2pTable.Client[p2pIdx].P2pClientState = P2PSTATE_SENT_PROVISION_REQ;
+common/p2p_nego_mng.c:			P2PSendProvisionReq(pAd, WSC_CONFMET_PBC, pAd->P2pTable.Client[p2pIdx].GeneralToken, pAd->P2pTable.Client[p2pIdx].addr, &FrameLen);
+common/p2p_nego_mng.c:		else if ((pAd->P2pCfg.Dpid == DEV_PASS_ID_REG) && ((pAd->P2pTable.Client[p2pIdx].ConfigMethod&WSC_CONFMET_KEYPAD) != 0))
+common/p2p_nego_mng.c:			pAd->P2pTable.Client[p2pIdx].P2pClientState = P2PSTATE_SENT_PROVISION_REQ;
+common/p2p_nego_mng.c:			P2PSendProvisionReq(pAd, WSC_CONFMET_KEYPAD, pAd->P2pTable.Client[p2pIdx].GeneralToken, pAd->P2pTable.Client[p2pIdx].addr, &FrameLen);
+common/p2p_nego_mng.c:			pAd->P2pTable.Client[p2pIdx].P2pClientState = P2PSTATE_SENT_PROVISION_REQ;
+common/p2p_nego_mng.c:			if (pAd->P2pCfg.ConfigMethod == WSC_CONFMET_DISPLAY)
+common/p2p_nego_mng.c:				P2PSendProvisionReq(pAd, WSC_CONFMET_KEYPAD, pAd->P2pTable.Client[p2pIdx].GeneralToken, Addr/*pAd->P2pTable.Client[p2pIdx].addr*/, &FrameLen);
+common/p2p_nego_mng.c:			else if (pAd->P2pCfg.ConfigMethod == WSC_CONFMET_KEYPAD)
+common/p2p_nego_mng.c:				P2PSendProvisionReq(pAd, WSC_CONFMET_DISPLAY, pAd->P2pTable.Client[p2pIdx].GeneralToken, Addr/*pAd->P2pTable.Client[p2pIdx].addr*/, &FrameLen);
+common/p2p_nego_mng.c:				P2PSendProvisionReq(pAd, WSC_CONFMET_PBC, pAd->P2pTable.Client[p2pIdx].GeneralToken, Addr/*pAd->P2pTable.Client[p2pIdx].addr*/, &FrameLen);
+common/p2p_nego_mng.c:		pAd->P2pTable.Client[p2pIdx].P2pClientState = P2PSTATE_SENT_PROVISION_REQ;
+common/p2p_nego_mng.c:		P2PSendProvisionReq(pAd, PeerWscMethod, pAd->P2pTable.Client[p2pIdx].GeneralToken, pAd->P2pTable.Client[p2pIdx].addr, &FrameLen);
+common/p2p_nego_mng.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p_nego_mng.c:	P2P_GO_FORM_STATE *pCurrState = &(pAd->P2pCfg.GoFormCurrentState);
+common/p2p_nego_mng.c:		perstindex = P2pPerstTabSearch(pAd, pAd->P2pTable.Client[p2pIndex].addr, pAd->P2pTable.Client[p2pIndex].bssid, pAd->P2pTable.Client[p2pIndex].InterfaceAddr);
+common/p2p_nego_mng.c:			P2pInvite(pAd, pAd->P2pTable.Client[p2pIndex].addr, perstindex, p2pIndex);
+common/p2p_nego_mng.c:			pAd->P2pCfg.P2PConnectState = P2P_INVITE;
+common/p2p_nego_mng.c:	P2P_GO_FORM_STATE *pCurrState = &(pAd->P2pCfg.GoFormCurrentState);
+common/p2p_nego_mng.c:	P2pClientDiscovery(pAd, pAd->P2pTable.Client[p2pIdx].addr, p2pIdx);
+common/p2p_nego_mng.c:	P2P_GO_FORM_STATE *pCurrState = &(pAd->P2pCfg.GoFormCurrentState);
+common/p2p_nego_mng.c:	P2pSendServiceReqCmd(pAd, pAd->P2pTable.Client[p2pIdx].addr, p2pIdx);
+common/p2p_nego_mng.c:	pAd->P2pTable.Client[p2pIdx].P2pClientState = P2PSTATE_DISCOVERY;
+common/p2p_nego_mng.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p_nego_mng.c:	P2P_GO_FORM_STATE *pCurrState = &(pAd->P2pCfg.GoFormCurrentState);
+common/p2p_nego_mng.c:	P2pStartGroupForm(pAd, pAd->P2pTable.Client[pP2pCmd->Idx].addr, pP2pCmd->Idx);
+common/p2p_nego_mng.c:	P2P_GO_FORM_STATE *pCurrState = &(pAd->P2pCfg.GoFormCurrentState);
+common/rt_led.c:	pWscControl = &pAd->ApCfg.MBSSID[MAIN_MBSSID].WscControl;
+common/rt_led.c:	pWscControl = &pAd->StaCfg.WscControl;
+common/rt_led.c:			pAd->LedCntl.LedIndicatorStrength = 0;
+common/rt_led.c:			if (pAd->CommonCfg.Channel > 14)
+common/rt_led.c:		pAd->LedCntl.LedStatus = Status;
+common/rt_led.c:	if (pAd->LedCntl.MCULedCntl.field.LedMode == LED_MODE_SIGNAL_STREGTH)
+common/rt_led.c:		if (pAd->LedCntl.LedIndicatorStrength != nLed)
+common/rt_led.c:			AsicSendCommandToMcu(pAd, MCU_SET_LED_GPIO_SIGNAL_CFG, 0xff, nLed, pAd->LedCntl.MCULedCntl.field.Polarity, FALSE);
+common/rt_led.c:			pAd->LedCntl.LedIndicatorStrength = nLed;
+common/rt_led.c:	/*if (pAd->StaCfg.WscControl.bWPSSession == FALSE) */
+common/rt_led.c:	/*if (pAd->StaCfg.WscControl.WscConfMode != WSC_DISABLE && pAd->StaCfg.WscControl.bWscTrigger) */
+common/rt_led.c:	if (pAd->StaCfg.WscControl.WscConfMode == WSC_DISABLE)
+common/rt_led.c:			if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeOpen) 
+common/rt_led.c:					&& (pAd->StaCfg.WepStatus == Ndis802_11WEPDisabled))
+common/rt_led.c:	/*if (pAd->StaCfg.WscControl.bWPSSession == FALSE) */
+common/rt_led.c:	if (pAd->StaCfg.WscControl.WscConfMode == WSC_DISABLE)
+common/rt_led.c:				if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeOpen) && (pAd->StaCfg.WepStatus == Ndis802_11WEPDisabled))
+common/rt_led.c:	PLED_CONTROL pLedCntl = &pAd->LedCntl;
+common/rt_led.c:	PLED_CONTROL pLedCntl = &pAd->LedCntl;
+common/rt_led.c:	pAd->LedCntl.LedIndicatorStrength = 0xFF;
+common/mlme.c:		Status = MlmeQueueInit(pAd, &pAd->Mlme.Queue);
+common/mlme.c:		pAd->Mlme.bRunning = FALSE;
+common/mlme.c:		NdisAllocateSpinLock(pAd, &pAd->Mlme.TaskLock);
+common/mlme.c:			BssTableInit(&pAd->ScanTab);
+common/mlme.c:			AssocStateMachineInit(pAd, &pAd->Mlme.AssocMachine, pAd->Mlme.AssocFunc);
+common/mlme.c:			AuthStateMachineInit(pAd, &pAd->Mlme.AuthMachine, pAd->Mlme.AuthFunc);
+common/mlme.c:			AuthRspStateMachineInit(pAd, &pAd->Mlme.AuthRspMachine, pAd->Mlme.AuthRspFunc);
+common/mlme.c:			SyncStateMachineInit(pAd, &pAd->Mlme.SyncMachine, pAd->Mlme.SyncFunc);
+common/mlme.c:			DlsStateMachineInit(pAd, &pAd->Mlme.DlsMachine, pAd->Mlme.DlsFunc);
+common/mlme.c:			TDLS_StateMachineInit(pAd, &pAd->Mlme.TdlsMachine, pAd->Mlme.TdlsFunc);
+common/mlme.c:			IWSC_StateMachineInit(pAd, &pAd->Mlme.IWscMachine, pAd->Mlme.IWscFunc);
+common/mlme.c:			MlmeCntlInit(pAd, &pAd->Mlme.CntlMachine, NULL);
+common/mlme.c:				RTMPInitTimer(pAd, &pAd->Mlme.PsPollTimer, GET_TIMER_FUNCTION(PsPollWakeExec), pAd, FALSE);
+common/mlme.c:				RTMPInitTimer(pAd, &pAd->Mlme.RadioOnOffTimer, GET_TIMER_FUNCTION(RadioOnExec), pAd, FALSE);
+common/mlme.c:			RTMPInitTimer(pAd, &pAd->Mlme.LinkDownTimer, GET_TIMER_FUNCTION(LinkDownExec), pAd, FALSE);
+common/mlme.c:			RTMPInitTimer(pAd, &pAd->StaCfg.StaQuickResponeForRateUpTimer, GET_TIMER_FUNCTION(StaQuickResponeForRateUpExec), pAd, FALSE);
+common/mlme.c:			pAd->StaCfg.StaQuickResponeForRateUpTimerRunning = FALSE;
+common/mlme.c:			RTMPInitTimer(pAd, &pAd->StaCfg.WpaDisassocAndBlockAssocTimer, GET_TIMER_FUNCTION(WpaDisassocApAndBlockAssoc), pAd, FALSE);
+common/mlme.c:			RTMPInitTimer(pAd, &pAd->Mlme.AutoWakeupTimer, GET_TIMER_FUNCTION(RtmpUsbStaAsicForceWakeupTimeout), pAd, FALSE);
+common/mlme.c:			pAd->Mlme.AutoWakeupTimerRunning = FALSE;
+common/mlme.c:			APAssocStateMachineInit(pAd, &pAd->Mlme.ApAssocMachine, pAd->Mlme.ApAssocFunc);
+common/mlme.c:			APAuthStateMachineInit(pAd, &pAd->Mlme.ApAuthMachine, pAd->Mlme.ApAuthFunc);
+common/mlme.c:			APSyncStateMachineInit(pAd, &pAd->Mlme.ApSyncMachine, pAd->Mlme.ApSyncFunc);
+common/mlme.c:			ApCliAuthStateMachineInit(pAd, &pAd->Mlme.ApCliAuthMachine, pAd->Mlme.ApCliAuthFunc);
+common/mlme.c:			ApCliAssocStateMachineInit(pAd, &pAd->Mlme.ApCliAssocMachine, pAd->Mlme.ApCliAssocFunc);
+common/mlme.c:			ApCliSyncStateMachineInit(pAd, &pAd->Mlme.ApCliSyncMachine, pAd->Mlme.ApCliSyncFunc);
+common/mlme.c:			ApCliCtrlStateMachineInit(pAd, &pAd->Mlme.ApCliCtrlMachine, pAd->Mlme.ApCliCtrlFunc);
+common/mlme.c:		WscStateMachineInit(pAd, &pAd->Mlme.WscMachine, pAd->Mlme.WscFunc);
+common/mlme.c:		WpaStateMachineInit(pAd, &pAd->Mlme.WpaMachine, pAd->Mlme.WpaFunc);
+common/mlme.c:		ActionStateMachineInit(pAd, &pAd->Mlme.ActMachine, pAd->Mlme.ActFunc);
+common/mlme.c:		RTMPInitTimer(pAd, &pAd->Mlme.PeriodicTimer, GET_TIMER_FUNCTION(MlmePeriodicExec), pAd, TRUE);
+common/mlme.c:		RTMPSetTimer(&pAd->Mlme.PeriodicTimer, MLME_TASK_EXEC_INTV);
+common/mlme.c:		RTMPInitTimer(pAd, &pAd->Mlme.RxAntEvalTimer, GET_TIMER_FUNCTION(AsicRxAntEvalTimeout), pAd, FALSE);
+common/mlme.c:			RTMPInitTimer(pAd, &pAd->Mlme.APSDPeriodicTimer, GET_TIMER_FUNCTION(APSDPeriodicExec), pAd, TRUE);
+common/mlme.c:			RTMPSetTimer(&pAd->Mlme.APSDPeriodicTimer, 50);
+common/mlme.c:			RTMPInitTimer(pAd, &pAd->ApCfg.ApQuickResponeForRateUpTimer, GET_TIMER_FUNCTION(APQuickResponeForRateUpExec), pAd, FALSE);
+common/mlme.c:			pAd->ApCfg.ApQuickResponeForRateUpTimerRunning = FALSE;
+common/mlme.c:			P2PCtrlStateMachineInit(pAd, &pAd->P2pCfg.P2PCtrlMachine, pAd->P2pCfg.P2PCtrlFunc);
+common/mlme.c:			P2PDiscoveryStateMachineInit(pAd, &pAd->P2pCfg.P2PDiscMachine, pAd->P2pCfg.P2PDiscFunc);
+common/mlme.c:			P2PGoFormationStateMachineInit(pAd, &pAd->P2pCfg.P2PGoFormMachine, pAd->P2pCfg.P2PGoFormFunc);
+common/mlme.c:			P2PStateMachineInit(pAd, &pAd->P2pCfg.P2PActionMachine, pAd->P2pCfg.P2PActionFunc);
+common/mlme.c:			RTMPInitTimer(pAd, &pAd->P2pCfg.P2pCTWindowTimer, GET_TIMER_FUNCTION(P2PCTWindowTimer), pAd, FALSE);
+common/mlme.c:			RTMPInitTimer(pAd, &pAd->P2pCfg.P2pSwNoATimer, GET_TIMER_FUNCTION(P2pSwNoATimeOut), pAd, FALSE);
+common/mlme.c:			RTMPInitTimer(pAd, &pAd->P2pCfg.P2pPreAbsenTimer, GET_TIMER_FUNCTION(P2pPreAbsenTimeOut), pAd, FALSE);
+common/mlme.c:			RTMPInitTimer(pAd, &pAd->P2pCfg.P2pWscTimer, GET_TIMER_FUNCTION(P2pWscTimeOut), pAd, FALSE);
+common/mlme.c:			RTMPInitTimer(pAd, &pAd->P2pCfg.P2pReSendTimer, GET_TIMER_FUNCTION(P2pReSendTimeOut), pAd, FALSE);
+common/mlme.c:			RTMPInitTimer(pAd, &pAd->P2pCfg.P2pCliReConnectTimer, GET_TIMER_FUNCTION(P2pCliReConnectTimeOut), pAd, FALSE);
+common/mlme.c:				APAssocStateMachineInit(pAd, &pAd->Mlme.ApAssocMachine, pAd->Mlme.ApAssocFunc);
+common/mlme.c:				APAuthStateMachineInit(pAd, &pAd->Mlme.ApAuthMachine, pAd->Mlme.ApAuthFunc);
+common/mlme.c:				APSyncStateMachineInit(pAd, &pAd->Mlme.ApSyncMachine, pAd->Mlme.ApSyncFunc);
+common/mlme.c:				ApCliAuthStateMachineInit(pAd, &pAd->Mlme.ApCliAuthMachine, pAd->Mlme.ApCliAuthFunc);
+common/mlme.c:				ApCliAssocStateMachineInit(pAd, &pAd->Mlme.ApCliAssocMachine, pAd->Mlme.ApCliAssocFunc);
+common/mlme.c:				ApCliSyncStateMachineInit(pAd, &pAd->Mlme.ApCliSyncMachine, pAd->Mlme.ApCliSyncFunc);
+common/mlme.c:				ApCliCtrlStateMachineInit(pAd, &pAd->Mlme.ApCliCtrlMachine, pAd->Mlme.ApCliCtrlFunc);
+common/mlme.c:				RTMPInitTimer(pAd, &pAd->Mlme.APSDPeriodicTimer, GET_TIMER_FUNCTION(APSDPeriodicExec), pAd, TRUE);
+common/mlme.c:				RTMPSetTimer(&pAd->Mlme.APSDPeriodicTimer, 50);
+common/mlme.c:	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
+common/mlme.c:	if(pAd->Mlme.bRunning) 
+common/mlme.c:		NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
+common/mlme.c:		pAd->Mlme.bRunning = TRUE;
+common/mlme.c:	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
+common/mlme.c:	while (!MlmeQueueEmpty(&pAd->Mlme.Queue)) 
+common/mlme.c:			DBGPRINT(RT_DEBUG_TRACE, ("Device Halted or Removed or MlmeRest, exit MlmeHandler! (queue num = %ld)\n", pAd->Mlme.Queue.Num));
+common/mlme.c:		if (MlmeDequeue(&pAd->Mlme.Queue, &Elem)) 
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->Mlme.AssocMachine,
+common/mlme.c:										Elem, pAd->Mlme.AssocMachine.CurrState);
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->Mlme.AuthMachine,
+common/mlme.c:										Elem, pAd->Mlme.AuthMachine.CurrState);
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->Mlme.AuthRspMachine,
+common/mlme.c:										Elem, pAd->Mlme.AuthRspMachine.CurrState);
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->Mlme.SyncMachine,
+common/mlme.c:										Elem, pAd->Mlme.SyncMachine.CurrState);
+common/mlme.c:					MlmeCntlMachinePerformAction(pAd, &pAd->Mlme.CntlMachine, Elem);
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->Mlme.WpaPskMachine,
+common/mlme.c:										Elem, pAd->Mlme.WpaPskMachine.CurrState);
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->Mlme.DlsMachine,
+common/mlme.c:										Elem, pAd->Mlme.DlsMachine.CurrState);
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->Mlme.TdlsMachine,
+common/mlme.c:										Elem, pAd->Mlme.TdlsMachine.CurrState);
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->Mlme.ActMachine,
+common/mlme.c:										Elem, pAd->Mlme.ActMachine.CurrState);
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->Mlme.ApAssocMachine,
+common/mlme.c:									Elem, pAd->Mlme.ApAssocMachine.CurrState);
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->Mlme.ApAuthMachine, 
+common/mlme.c:									Elem, pAd->Mlme.ApAuthMachine.CurrState);
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->Mlme.ApSyncMachine,
+common/mlme.c:									Elem, pAd->Mlme.ApSyncMachine.CurrState);
+common/mlme.c:						StateMachinePerformAction(pAd, &pAd->Mlme.ApCliAuthMachine, Elem,
+common/mlme.c:							(pAd->ApCfg.ApCliTab[apcliIfIndex].AuthCurrState));
+common/mlme.c:						StateMachinePerformAction(pAd, &pAd->Mlme.ApCliAssocMachine, Elem,
+common/mlme.c:							(pAd->ApCfg.ApCliTab[apcliIfIndex].AssocCurrState));
+common/mlme.c:						StateMachinePerformAction(pAd, &pAd->Mlme.ApCliSyncMachine, Elem,
+common/mlme.c:							(pAd->ApCfg.ApCliTab[apcliIfIndex].SyncCurrState));
+common/mlme.c:						StateMachinePerformAction(pAd, &pAd->Mlme.ApCliCtrlMachine, Elem,
+common/mlme.c:							(pAd->ApCfg.ApCliTab[apcliIfIndex].CtrlCurrState));
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->Mlme.WpaMachine, Elem, pAd->Mlme.WpaMachine.CurrState);
+common/mlme.c:					if (pAd->pWscElme)
+common/mlme.c:						RTMP_SEM_LOCK(&pAd->WscElmeLock);
+common/mlme.c:						NdisMoveMemory(pAd->pWscElme, Elem, sizeof(MLME_QUEUE_ELEM));
+common/mlme.c:						RTMP_SEM_UNLOCK(&pAd->WscElmeLock);
+common/mlme.c:/*						WAKE_UP(&(pAd->wscTask));*/
+common/mlme.c:/*						RTMP_SEM_EVENT_UP(&(pAd->wscTask.taskSema));*/
+common/mlme.c:						RtmpOsTaskWakeUp(&(pAd->wscTask));
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->Mlme.IWscMachine, Elem, pAd->Mlme.IWscMachine.CurrState);
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->P2pCfg.P2PCtrlMachine, Elem,
+common/mlme.c:							pAd->P2pCfg.CtrlCurrentState);
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->P2pCfg.P2PDiscMachine, Elem,
+common/mlme.c:							pAd->P2pCfg.DiscCurrentState);
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->P2pCfg.P2PGoFormMachine, Elem,
+common/mlme.c:							pAd->P2pCfg.GoFormCurrentState);
+common/mlme.c:					StateMachinePerformAction(pAd, &pAd->P2pCfg.P2PActionMachine, Elem,
+common/mlme.c:							pAd->P2pCfg.ActionState);
+common/mlme.c:	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
+common/mlme.c:	pAd->Mlme.bRunning = FALSE;
+common/mlme.c:	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
+common/mlme.c:	RTMPCancelTimer(&pAd->Mlme.PeriodicTimer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->MlmeAux.AssocTimer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->MlmeAux.AuthTimer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &Cancelled);
+common/mlme.c:			&&(pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))
+common/mlme.c:	   	    RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled);
+common/mlme.c:		    RTMPCancelTimer(&pAd->Mlme.RadioOnOffTimer, &Cancelled);
+common/mlme.c:			RTMPCancelTimer(&pAd->StaCfg.DLSEntry[i].Timer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->Mlme.LinkDownTimer, &Cancelled);
+common/mlme.c:		if (pAd->Mlme.AutoWakeupTimerRunning)
+common/mlme.c:			RTMPCancelTimer(&pAd->Mlme.AutoWakeupTimer, &Cancelled);
+common/mlme.c:			pAd->Mlme.AutoWakeupTimerRunning = FALSE;
+common/mlme.c:		if (pAd->StaCfg.WscControl.WscProfileRetryTimerRunning)
+common/mlme.c:			pAd->StaCfg.WscControl.WscProfileRetryTimerRunning = FALSE;
+common/mlme.c:			RTMPCancelTimer(&pAd->StaCfg.WscControl.WscProfileRetryTimer, &Cancelled);
+common/mlme.c:		if (pAd->StaCfg.StaQuickResponeForRateUpTimerRunning)
+common/mlme.c:			RTMPCancelTimer(&pAd->StaCfg.StaQuickResponeForRateUpTimer, &Cancelled);
+common/mlme.c:			pAd->StaCfg.StaQuickResponeForRateUpTimerRunning = FALSE;
+common/mlme.c:		RTMPCancelTimer(&pAd->StaCfg.WpaDisassocAndBlockAssocTimer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->StaCfg.IWscInfo.IWscT1Timer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->StaCfg.IWscInfo.IWscT2Timer, &Cancelled);
+common/mlme.c:	RTMPCancelTimer(&pAd->Mlme.RxAntEvalTimer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->Mlme.APSDPeriodicTimer, &Cancelled);
+common/mlme.c:		if (pAd->ApCfg.ApQuickResponeForRateUpTimerRunning == TRUE)
+common/mlme.c:			RTMPCancelTimer(&pAd->ApCfg.ApQuickResponeForRateUpTimer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->ApCliMlmeAux.ProbeTimer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->ApCliMlmeAux.ApCliAssocTimer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->ApCliMlmeAux.ApCliAuthTimer, &Cancelled);
+common/mlme.c:		if (pAd->ApCfg.ApCliTab[BSS0].WscControl.WscProfileRetryTimerRunning)
+common/mlme.c:			pAd->ApCfg.ApCliTab[BSS0].WscControl.WscProfileRetryTimerRunning = FALSE;
+common/mlme.c:			RTMPCancelTimer(&pAd->ApCfg.ApCliTab[BSS0].WscControl.WscProfileRetryTimer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->MlmeAux.APScanTimer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->P2pCfg.P2pCTWindowTimer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->P2pCfg.P2pSwNoATimer, &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->P2pCfg.P2pPreAbsenTimer, &Cancelled);
+common/mlme.c:		if (pAd->P2pCfg.bP2pCliReConnectTimerRunning)
+common/mlme.c:			pAd->P2pCfg.bP2pCliReConnectTimerRunning = FALSE;
+common/mlme.c:			RTMPCancelTimer(&pAd->P2pCfg.P2pCliReConnectTimer, &Cancelled);
+common/mlme.c:			RTMPCancelTimer(&pAd->Mlme.APSDPeriodicTimer,	&Cancelled);
+common/mlme.c:			RTMPCancelTimer(&pAd->ApCliMlmeAux.ProbeTimer, &Cancelled);
+common/mlme.c:			RTMPCancelTimer(&pAd->ApCliMlmeAux.ApCliAssocTimer, &Cancelled);
+common/mlme.c:			RTMPCancelTimer(&pAd->ApCliMlmeAux.ApCliAuthTimer, &Cancelled);
+common/mlme.c:			if (pAd->ApCfg.ApCliTab[BSS0].WscControl.WscProfileRetryTimerRunning)
+common/mlme.c:				pAd->ApCfg.ApCliTab[BSS0].WscControl.WscProfileRetryTimerRunning = FALSE;
+common/mlme.c:				RTMPCancelTimer(&pAd->ApCfg.ApCliTab[BSS0].WscControl.WscProfileRetryTimer, &Cancelled);
+common/mlme.c:			RTMPCancelTimer(&pAd->MlmeAux.APScanTimer,	&Cancelled);
+common/mlme.c:		RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
+common/mlme.c:	MlmeQueueDestroy(&pAd->Mlme.Queue);
+common/mlme.c:	NdisFreeSpinLock(&pAd->Mlme.TaskLock);
+common/mlme.c:	pAd->RalinkCounters.LastOneSecRxOkDataCnt = pAd->RalinkCounters.OneSecRxOkDataCnt;
+common/mlme.c:		NdisZeroMemory(&pAd->RalinkCounters,
+common/mlme.c:						(UINT32)&pAd->RalinkCounters.OneSecEnd -
+common/mlme.c:						(UINT32)&pAd->RalinkCounters.OneSecStart);
+common/mlme.c:	if (pAd->CountDowntoPsm > 0)
+common/mlme.c:		pAd->CountDowntoPsm--;
+common/mlme.c:		if ((pAd->Mlme.PeriodicRound & 0x1) &&
+common/mlme.c:			((pAd->MACVersion & 0xffff) == 0x0101))
+common/mlme.c:			if (pAd->CommonCfg.IOTestParm.bToggle == FALSE)
+common/mlme.c:				pAd->CommonCfg.IOTestParm.bToggle = TRUE;
+common/mlme.c:				pAd->CommonCfg.IOTestParm.bToggle = FALSE;
+common/mlme.c:	pAd->bUpdateBcnCntDone = FALSE;
+common/mlme.c:	pAd->Mlme.PeriodicRound ++;
+common/mlme.c:	pAd->Mlme.GPIORound++;
+common/mlme.c:	if (pAd->CommonCfg.CarrierDetect.Enable)
+common/mlme.c:	if ((pAd->ra_interval) && 
+common/mlme.c:		((pAd->Mlme.PeriodicRound % (pAd->ra_interval / 100)) == 0) && 
+common/mlme.c:			if ((pAd->CommonCfg.Channel > 14) && (pAd->CommonCfg.bIEEE80211H == TRUE))
+common/mlme.c:	if (pAd->chipCap.FreqCalibrationSupport)
+common/mlme.c:		if ((pAd->FreqCalibrationCtrl.bEnableFrequencyCalibration == TRUE) && 
+common/mlme.c:	if (pAd->Mlme.PeriodicRound %MLME_TASK_EXEC_MULTIPLE == 0)
+common/mlme.c:		pAd->Mlme.OneSecPeriodicRound ++;
+common/mlme.c:		NdisGetSystemUpTime(&pAd->Mlme.Now32);
+common/mlme.c:		if (pAd->RalinkCounters.MgmtRingFullCount >= 2)
+common/mlme.c:			pAd->RalinkCounters.MgmtRingFullCount = 0;
+common/mlme.c:			if (pAd->Mlme.bEnableAutoAntennaCheck)
+common/mlme.c:				TxTotalCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount + 
+common/mlme.c:								 pAd->RalinkCounters.OneSecTxRetryOkCount + 
+common/mlme.c:								 pAd->RalinkCounters.OneSecTxFailCount;
+common/mlme.c:					if (pAd->Mlme.OneSecPeriodicRound % 10 == 0)
+common/mlme.c:					if (pAd->Mlme.OneSecPeriodicRound % 3 == 0)
+common/mlme.c:			if ((pAd->Mlme.OneSecPeriodicRound % 10) == 0)
+common/mlme.c:			if ((pAd->RalinkCounters.OneSecBeaconSentCnt == 0)
+common/mlme.c:				&& ((pAd->CommonCfg.bIEEE80211H != 1)
+common/mlme.c:					|| (pAd->Dot11_H.RDMode != RD_SILENCE_MODE))				
+common/mlme.c:				pAd->macwd ++;
+common/mlme.c:				pAd->macwd = 0;
+common/mlme.c:			if (pAd->macwd > 1)
+common/mlme.c:    			if (IS_TDLS_SUPPORT(pAd) && (pAd->StaCfg.TdlsInfo.TdlsAutoLink))
+common/mlme.c:	pAd->bUpdateBcnCntDone = FALSE;
+common/mlme.c:	POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/mlme.c:	RTMP_CHIP_HIGH_POWER_TUNING(pAd, &pAd->StaCfg.RssiSample);
+common/mlme.c:    if (pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_DISABLE)    
+common/mlme.c:		if (pAd->StaCfg.bBlockAssoc && 
+common/mlme.c:			RTMP_TIME_AFTER(pAd->Mlme.Now32, pAd->StaCfg.LastMicErrorTime + (60*OS_HZ)))
+common/mlme.c:    		pAd->StaCfg.bBlockAssoc = FALSE;
+common/mlme.c:	/*	&& (pAd->StaCfg.PSControl.field.EnablePSinIdle == TRUE)*/
+common/mlme.c:		&& (pAd->StaCfg.WindowsPowerMode > 0)
+common/mlme.c:		&& (pAd->OpMode == OPMODE_STA) && (IDLE_ON(pAd)) 
+common/mlme.c:		&& (pAd->Mlme.SyncMachine.CurrState == SYNC_IDLE)
+common/mlme.c:		&& (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
+common/mlme.c:		&& (pAd->StaCfg.WscControl.WscState == WSC_STATE_OFF)
+common/mlme.c:	TxTotalCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount + 
+common/mlme.c:					 pAd->RalinkCounters.OneSecTxRetryOkCount + 
+common/mlme.c:					 pAd->RalinkCounters.OneSecTxFailCount;
+common/mlme.c:		if (pAd->StaCfg.bImprovedScan)
+common/mlme.c:		if (NdisEqualMemory(ZERO_MAC_ADDR, pAd->P2pCfg.ConnectingMAC, MAC_ADDR_LEN) == FALSE)
+common/mlme.c:			p2pindex = P2pGroupTabSearch(pAd, pAd->P2pCfg.ConnectingMAC);
+common/mlme.c:				if (pAd->P2pTable.Client[p2pindex].P2pClientState > P2PSTATE_DISCOVERY_UNKNOWN)
+common/mlme.c:			MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[BSSID_WCID];
+common/mlme.c:			MlmeCalculateChannelQuality(pAd, pEntry, pAd->Mlme.Now32);
+common/mlme.c:		RTMP_OS_NETDEV_WAKE_QUEUE(pAd->net_dev);
+common/mlme.c:		RTMP_OS_NETDEV_STOP_QUEUE(pAd->net_dev);
+common/mlme.c:	pAd->RalinkCounters.LastOneSecTotalTxCount = TxTotalCnt;
+common/mlme.c:	if (IS_RT3290(pAd) && (pAd->CommonCfg.BBPCurrentBW == BW_40))
+common/mlme.c:		if ((pAd->RalinkCounters.LastOneSecTotalTxCount + pAd->RalinkCounters.LastOneSecRxOkDataCnt) >= 2000)
+common/mlme.c:		else if ((pAd->RalinkCounters.LastOneSecTotalTxCount + pAd->RalinkCounters.LastOneSecRxOkDataCnt) <= 500)
+common/mlme.c:		((pAd->NicConfig3.word != 0xFFFF) && (pAd->NicConfig3.field.CoexAnt == TRUE)) && 
+common/mlme.c:		((pAd->Mlme.OneSecPeriodicRound % 5) == 4))	
+common/mlme.c:		DBGPRINT(RT_DEBUG_INFO, ("!!! BBP_R150 = %d, BT_EN = %d\n",pAd->BbpWriteLatch[BBP_R150], pAd->BtFunCtrl.field.BT_EN));
+common/mlme.c:		if ((((pAd->WlanFunInfo.field.COEX_MODE&0x1E) == 0) || (pAd->BtFunCtrl.field.BT_EN == 0)) && (pAd->BbpWriteLatch[BBP_R150] != 0xc0))
+common/mlme.c:			DBGPRINT(RT_DEBUG_TRACE, ("!!! EN BBP_R150 = %d\n",pAd->BbpWriteLatch[BBP_R150]));
+common/mlme.c:			RTMP_SEM_LOCK(&pAd->WlanEnLock);
+common/mlme.c:				pAd->WlanFunCtrl.word = WlanFunCtrl.word;	
+common/mlme.c:			RTMP_SEM_UNLOCK(&pAd->WlanEnLock);
+common/mlme.c:			pAd->NicConfig2.field.AntDiversity = FALSE;	
+common/mlme.c:		else if(((pAd->WlanFunInfo.field.COEX_MODE&0x1E) != 0) && (pAd->BbpWriteLatch[BBP_R150] != 0x00))
+common/mlme.c:			DBGPRINT(RT_DEBUG_TRACE, ("!!! DISABLE BBP_R150 = %d\n",pAd->BbpWriteLatch[BBP_R150]));
+common/mlme.c:			pAd->NicConfig2.word = pAd->EEPROMDefaultValue[EEPROM_NIC_CFG2_OFFSET];
+common/mlme.c:	if ((pAd->Mlme.PeriodicRound % MLME_TASK_EXEC_MULTIPLE == 0) && (P2P_GO_ON(pAd)
+common/mlme.c:		if (pAd->CommonCfg.bHTProtect)
+common/mlme.c:			if (pAd->CommonCfg.IOTestParm.bRTSLongProtOn == FALSE)
+common/mlme.c:				AsicUpdateProtect(pAd, (USHORT)pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode, ALLN_SETPROTECT, FALSE, pAd->MacTab.fAnyStationNonGF);
+common/mlme.c:		if ((pAd->StaCfg.bImprovedScan) &&
+common/mlme.c:			(pAd->Mlme.SyncMachine.CurrState == SCAN_PENDING))
+common/mlme.c:			pAd->StaCfg.LastScanTime = pAd->Mlme.Now32;
+common/mlme.c:			ScanParmFill(pAd, &ScanReq, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen, BSS_ANY, SCAN_ACTIVE);
+common/mlme.c:			if (pAd->Mlme.PeriodicRound % MLME_TASK_EXEC_MULTIPLE == 0)
+common/mlme.c:		MlmeCheckPsmChange(pAd, pAd->Mlme.Now32);
+common/mlme.c:			(RTMP_TIME_AFTER(pAd->Mlme.Now32, pAd->StaCfg.LastBeaconRxTime + (1*OS_HZ))))
+common/mlme.c:			BPtoJiffies = (((pAd->CommonCfg.BeaconPeriod * 1024 / 1000) * OS_HZ) / 1000);
+common/mlme.c:			timeDiff = (pAd->Mlme.Now32 - pAd->StaCfg.LastBeaconRxTime) / BPtoJiffies;
+common/mlme.c:				pAd->StaCfg.LastBeaconRxTime += (timeDiff * BPtoJiffies);
+common/mlme.c:			if (RTMP_TIME_AFTER(pAd->StaCfg.LastBeaconRxTime, pAd->Mlme.Now32))
+common/mlme.c:								pAd->StaCfg.LastBeaconRxTime, pAd->Mlme.Now32));
+common/mlme.c:		if ((RTMP_TIME_AFTER(pAd->Mlme.Now32, pAd->StaCfg.LastBeaconRxTime + (1*OS_HZ))) &&
+common/mlme.c:			(pAd->StaCfg.bImprovedScan == FALSE) &&
+common/mlme.c:			((TxTotalCnt + pAd->RalinkCounters.OneSecRxOkCnt) < 600))
+common/mlme.c:		if ((pAd->Antenna.field.TxPath == 1)&&
+common/mlme.c:		(pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE) && 
+common/mlme.c:			(pAd->CommonCfg.BACapability.field.Policy == BA_NOTUSE)
+common/mlme.c:			if ((pAd->RalinkCounters.OneSecOsTxCount[QID_AC_VO] == 0) &&
+common/mlme.c:			(pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BK] == 0) &&
+common/mlme.c:			(pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BE] < 50) &&								      
+common/mlme.c:			(pAd->RalinkCounters.OneSecOsTxCount[QID_AC_VI] >= 1000))
+common/mlme.c:			(pAd->RalinkCounters.OneSecOsTxCount[QID_AC_VO] == 0) &&
+common/mlme.c:			(pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BK] == 0) &&
+common/mlme.c:			(pAd->RalinkCounters.OneSecOsTxCount[QID_AC_VI] == 0) &&								      
+common/mlme.c:			(pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BE] >= 300)&&
+common/mlme.c:			(pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BE] <= 1500)&&
+common/mlme.c:			(pAd->CommonCfg.IOTestParm.bRTSLongProtOn==FALSE))
+common/mlme.c:			else if ((pAd->RalinkCounters.OneSecOsTxCount[QID_AC_VO] == 0) &&
+common/mlme.c:			(pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BK] == 0) &&
+common/mlme.c:			(pAd->RalinkCounters.OneSecOsTxCount[QID_AC_VI] == 0) &&								      
+common/mlme.c:			(pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BE] < 10))
+common/mlme.c:		pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BE] = 0;
+common/mlme.c:		pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BK] = 0;
+common/mlme.c:		pAd->RalinkCounters.OneSecOsTxCount[QID_AC_VI] = 0;
+common/mlme.c:		pAd->RalinkCounters.OneSecOsTxCount[QID_AC_VO] = 0;
+common/mlme.c:		pAd->RalinkCounters.OneSecDmaDoneCount[QID_AC_BE] = 0;
+common/mlme.c:		pAd->RalinkCounters.OneSecDmaDoneCount[QID_AC_BK] = 0;
+common/mlme.c:		pAd->RalinkCounters.OneSecDmaDoneCount[QID_AC_VI] = 0;
+common/mlme.c:		pAd->RalinkCounters.OneSecDmaDoneCount[QID_AC_VO] = 0;
+common/mlme.c:		pAd->RalinkCounters.OneSecTxDoneCount = 0;
+common/mlme.c:		pAd->RalinkCounters.OneSecTxAggregationCount = 0;
+common/mlme.c:        /*if ((pAd->RalinkCounters.OneSecTxNoRetryOkCount == 0) &&*/
+common/mlme.c:        /*    (pAd->RalinkCounters.OneSecTxRetryOkCount == 0))*/
+common/mlme.c:    		if (pAd->StaCfg.UapsdInfo.bAPSDCapable && pAd->CommonCfg.APEdcaParm.bAPSDCapable)
+common/mlme.c:    			if ((pAd->Mlme.OneSecPeriodicRound % 20) == 8)
+common/mlme.c:    				RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE, pAd->CommonCfg.bAPSDForcePowerSave ? PWR_SAVE : pAd->StaCfg.Psm);
+common/mlme.c:    			if ((pAd->Mlme.OneSecPeriodicRound % 10) == 8)
+common/mlme.c:								  pAd->CommonCfg.TxRate, 
+common/mlme.c:								  (pAd->CommonCfg.bWmmCapable & pAd->CommonCfg.APEdcaParm.bValid),
+common/mlme.c:								  pAd->CommonCfg.bAPSDForcePowerSave ? PWR_SAVE : pAd->StaCfg.Psm);
+common/mlme.c:						pAd->CommonCfg.TxRate, 
+common/mlme.c:						(pAd->CommonCfg.bWmmCapable & pAd->CommonCfg.APEdcaParm.bValid),
+common/mlme.c:						pAd->CommonCfg.bAPSDForcePowerSave ? PWR_SAVE : pAd->StaCfg.Psm, 0);
+common/mlme.c:					pAd->Mlme.bSendNullFrameAfterWareUp = TRUE;
+common/mlme.c:		if (CQI_IS_DEAD(pAd->Mlme.ChannelQuality))
+common/mlme.c:			DBGPRINT(RT_DEBUG_TRACE, ("MMCHK - No BEACON. Dead CQI. Auto Recovery attempt #%ld\n", pAd->RalinkCounters.BadCQIAutoRecoveryCount));
+common/mlme.c:			if (pAd->StaCfg.bAutoConnectByBssid)
+common/mlme.c:				pAd->StaCfg.bAutoConnectByBssid = FALSE;
+common/mlme.c:			if ((pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE) &&
+common/mlme.c:				(pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2))
+common/mlme.c:				pAd->StaCfg.bLostAp = TRUE;
+common/mlme.c:			pAd->MlmeAux.CurrReqIsFromNdis = FALSE;
+common/mlme.c:                        if (pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_DISABLE)
+common/mlme.c:		else if (CQI_IS_BAD(pAd->Mlme.ChannelQuality))
+common/mlme.c:			pAd->RalinkCounters.BadCQIAutoRecoveryCount ++;
+common/mlme.c:			DBGPRINT(RT_DEBUG_TRACE, ("MMCHK - Bad CQI. Auto Recovery attempt #%ld\n", pAd->RalinkCounters.BadCQIAutoRecoveryCount));
+common/mlme.c:		if (pAd->StaCfg.bAutoRoaming)
+common/mlme.c:			CHAR	dBmToRoam = pAd->StaCfg.dBmToRoam;
+common/mlme.c:										  pAd->StaCfg.RssiSample.LastRssi0, 
+common/mlme.c:										  pAd->StaCfg.RssiSample.LastRssi1, 
+common/mlme.c:										  pAd->StaCfg.RssiSample.LastRssi2);			
+common/mlme.c:			if (pAd->StaCfg.bAutoConnectByBssid)
+common/mlme.c:				pAd->StaCfg.bAutoConnectByBssid = FALSE;
+common/mlme.c:				(pAd->Mlme.SyncMachine.CurrState == SYNC_IDLE) &&
+common/mlme.c:					if ((pAd->StaCfg.LastScanTime + 10 * OS_HZ) < pAd->Mlme.Now32)
+common/mlme.c:						pAd->StaCfg.LastScanTime = pAd->Mlme.Now32;
+common/mlme.c:		if (/*(RTMP_TIME_AFTER(pAd->Mlme.Now32, pAd->StaCfg.LastBeaconRxTime + ADHOC_BEACON_LOST_TIME)
+common/mlme.c:			|| (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+common/mlme.c:				MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[i];
+common/mlme.c:				if (RTMP_TIME_AFTER(pAd->Mlme.Now32, pEntry->LastBeaconRxTime + ADHOC_BEACON_LOST_TIME)
+common/mlme.c:					&& (pAd->StaCfg.WscControl.bWscTrigger == FALSE)
+common/mlme.c:            if (pAd->MacTab.Size == 0)
+common/mlme.c:		if (pAd->StaCfg.WpaSupplicantUP & WPA_SUPPLICANT_ENABLE_WPS)
+common/mlme.c:		if (pAd->StaCfg.bSkipAutoScanConn &&
+common/mlme.c:			RTMP_TIME_BEFORE(pAd->Mlme.Now32, pAd->StaCfg.LastScanTime + (30 * OS_HZ)))
+common/mlme.c:			pAd->StaCfg.bSkipAutoScanConn = FALSE;
+common/mlme.c:		if ((pAd->StaCfg.bAutoReconnect == TRUE)
+common/mlme.c:			&& (MlmeValidateSSID(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen) == TRUE))
+common/mlme.c:			if ((pAd->ScanTab.BssNr==0) && (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
+common/mlme.c:				if (RTMP_TIME_AFTER(pAd->Mlme.Now32, pAd->StaCfg.LastScanTime + (10 * OS_HZ))
+common/mlme.c:					|| (pAd->StaCfg.LastScanTime == 0)
+common/mlme.c:					|| (pAd->StaCfg.bNotFirstScan == FALSE))
+common/mlme.c:					DBGPRINT(RT_DEBUG_TRACE, ("STAMlmePeriodicExec():CNTL - ScanTab.BssNr==0, start a new ACTIVE scan SSID[%s]\n", pAd->MlmeAux.AutoReconnectSsid));
+common/mlme.c:					if (pAd->StaCfg.BssType == BSS_ADHOC)	
+common/mlme.c:						pAd->StaCfg.bNotFirstScan = TRUE;
+common/mlme.c:					ScanParmFill(pAd, &ScanReq, (PSTRING) pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen, BSS_ANY, SCAN_ACTIVE);
+common/mlme.c:					pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+common/mlme.c:					pAd->StaCfg.LastScanTime = pAd->Mlme.Now32;
+common/mlme.c:			else if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
+common/mlme.c:				if (pAd->CommonCfg.CarrierDetect.Enable == TRUE)
+common/mlme.c:					if ((pAd->Mlme.OneSecPeriodicRound % 5) == 1)
+common/mlme.c:					if(pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_ENABLE)
+common/mlme.c:    if ((pAd->MacTab.Content[BSSID_WCID].TXBAbitmap !=0) && (pAd->MacTab.fAnyBASession == FALSE)
+common/mlme.c:		pAd->MacTab.fAnyBASession = TRUE;
+common/mlme.c:	else if ((pAd->MacTab.Content[BSSID_WCID].TXBAbitmap ==0) && (pAd->MacTab.fAnyBASession == TRUE)
+common/mlme.c:		pAd->MacTab.fAnyBASession = FALSE;
+common/mlme.c:		AsicUpdateProtect(pAd, pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode,  ALLN_SETPROTECT, FALSE, FALSE);
+common/mlme.c:		if (pAd->Mlme.OneSecPeriodicRound % 2 == 0)
+common/mlme.c:		if (pAd->Mlme.OneSecPeriodicRound % 2 == 1)
+common/mlme.c:				PAPCLI_STRUCT pApCliEntry = &pAd->ApCfg.ApCliTab[loop];
+common/mlme.c:						(RTMP_TIME_AFTER(pAd->Mlme.Now32, pApCliEntry->ApCliRcvBeaconTime + (1*OS_HZ))))
+common/mlme.c:						timeDiff = (pAd->Mlme.Now32 - pApCliEntry->ApCliRcvBeaconTime) / BPtoJiffies;
+common/mlme.c:						if (RTMP_TIME_AFTER(pApCliEntry->ApCliRcvBeaconTime, pAd->Mlme.Now32))
+common/mlme.c:														pApCliEntry->ApCliRcvBeaconTime, pAd->Mlme.Now32));
+common/mlme.c:						&pAd->MacTab.Content[pApCliEntry->MacTabWCID], Now32);
+common/mlme.c:		(pAd->CommonCfg.Dot11BssWidthTriggerScanInt != 0) && 
+common/mlme.c:		((pAd->Mlme.OneSecPeriodicRound % pAd->CommonCfg.Dot11BssWidthTriggerScanInt) == (pAd->CommonCfg.Dot11BssWidthTriggerScanInt-1)))
+common/mlme.c:								pAd->RalinkCounters.LastOneSecTotalTxCount,
+common/mlme.c:								pAd->RalinkCounters.LastOneSecRxOkDataCnt));
+common/mlme.c:		if ((pAd->RalinkCounters.LastOneSecTotalTxCount < 70) && (pAd->RalinkCounters.LastOneSecRxOkDataCnt < 70))
+common/mlme.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+common/mlme.c:			pAd->CommonCfg.BSSCoexist2040.field.InfoReq = 1;
+common/mlme.c:							pAd->RalinkCounters.LastOneSecTotalTxCount, 
+common/mlme.c:							pAd->RalinkCounters.LastOneSecRxOkDataCnt));	
+common/mlme.c:		if ((pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED) &&
+common/mlme.c:			DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
+common/mlme.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+common/mlme.c:		    pAd->ExtraInfo = GENERAL_LINK_DOWN;
+common/mlme.c:	if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
+common/mlme.c:					pAd->MlmeAux.AutoReconnectSsidLen, 
+common/mlme.c:					pAd->MlmeAux.AutoReconnectSsid, 0);
+common/mlme.c:	PWSC_CTRL           pWscControl = &pAd->StaCfg.WscControl;
+common/mlme.c:			(pAd->StaCfg.BssType == BSS_INFRA))
+common/mlme.c:			NdisMoveMemory(pWscControl->WscBssid, pAd->ScanTab.BssEntry[ApIdx].Bssid, MAC_ADDR_LEN);
+common/mlme.c:			pAd->MlmeAux.Channel = pAd->ScanTab.BssEntry[ApIdx].Channel;
+common/mlme.c:	if (pAd->StaCfg.bAutoConnectByBssid)
+common/mlme.c:									PRINT_MAC(pAd->MlmeAux.Bssid)));
+common/mlme.c:		pAd->MlmeAux.Channel = pAd->CommonCfg.Channel;
+common/mlme.c:			 pAd->MlmeAux.Bssid, 0);
+common/mlme.c:		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+common/mlme.c:	else if ((pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) && 
+common/mlme.c:		(MlmeValidateSSID(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen) == TRUE))
+common/mlme.c:		OidSsid.SsidLength = pAd->MlmeAux.AutoReconnectSsidLen;
+common/mlme.c:		NdisMoveMemory(OidSsid.Ssid, pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen);
+common/mlme.c:		DBGPRINT(RT_DEBUG_TRACE, ("Driver auto reconnect to last OID_802_11_SSID setting - %s, len - %d\n", pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen));
+common/mlme.c:	BSS_TABLE  *pRoamTab = &pAd->MlmeAux.RoamTab;
+common/mlme.c:	for (i = 0; i < pAd->ScanTab.BssNr; i++)
+common/mlme.c:		pBss = &pAd->ScanTab.BssEntry[i];
+common/mlme.c:		if (RTMP_TIME_AFTER(Now32, pBss->LastBeaconRxTime + pAd->StaCfg.BeaconLostTime))
+common/mlme.c:		if (MAC_ADDR_EQUAL(pBss->Bssid, pAd->CommonCfg.Bssid))
+common/mlme.c:		if (pBss->Rssi < (pAd->StaCfg.RssiSample.LastRssi0 + RSSI_DELTA))
+common/mlme.c:		if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
+common/mlme.c:			pAd->RalinkCounters.PoorCQIRoamingCount ++;
+common/mlme.c:			DBGPRINT(RT_DEBUG_TRACE, ("MMCHK - Roaming attempt #%ld\n", pAd->RalinkCounters.PoorCQIRoamingCount));
+common/mlme.c:	BSS_TABLE	*pRoamTab = &pAd->MlmeAux.RoamTab;
+common/mlme.c:	for (i = 0; i < pAd->ScanTab.BssNr; i++)
+common/mlme.c:		pBss = &pAd->ScanTab.BssEntry[i];
+common/mlme.c:        if ((pBss->Rssi <= -50) && (pBss->Channel == pAd->CommonCfg.Channel))
+common/mlme.c:		if (MAC_ADDR_EQUAL(pBss->Bssid, pAd->CommonCfg.Bssid))
+common/mlme.c:		if (!SSID_EQUAL(pBss->Ssid, pBss->SsidLen, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen))
+common/mlme.c:        if (pBss->Rssi < (RTMPMaxRssi(pAd, pAd->StaCfg.RssiSample.LastRssi0, pAd->StaCfg.RssiSample.LastRssi1, pAd->StaCfg.RssiSample.LastRssi2) + RSSI_DELTA)) 
+common/mlme.c:        DBGPRINT(RT_DEBUG_TRACE, ("LastRssi0 = %d, pBss->Rssi = %d\n", RTMPMaxRssi(pAd, pAd->StaCfg.RssiSample.LastRssi0, pAd->StaCfg.RssiSample.LastRssi1, pAd->StaCfg.RssiSample.LastRssi2), pBss->Rssi));
+common/mlme.c:		if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
+common/mlme.c:			pAd->RalinkCounters.PoorCQIRoamingCount ++;
+common/mlme.c:			DBGPRINT(RT_DEBUG_TRACE, ("MMCHK - Roaming attempt #%ld\n", pAd->RalinkCounters.PoorCQIRoamingCount));
+common/mlme.c:		1. change pAd->StaCfg.Psm to PWR_SAVE or leave it untouched
+common/mlme.c:	PowerMode = pAd->StaCfg.WindowsPowerMode;
+common/mlme.c:		(pAd->StaCfg.Psm == PWR_ACTIVE) &&
+common/mlme.c:		(pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE)
+common/mlme.c:		&&		(pAd->CountDowntoPsm == 0)
+common/mlme.c:		(pAd->RalinkCounters.OneSecTxNoRetryOkCount == 0) &&
+common/mlme.c:		(pAd->RalinkCounters.OneSecTxRetryOkCount == 0)*/)
+common/mlme.c:		NdisGetSystemUpTime(&pAd->Mlme.LastSendNULLpsmTime);
+common/mlme.c:		pAd->RalinkCounters.RxCountSinceLastNULL = 0;
+common/mlme.c:		if (!(pAd->StaCfg.UapsdInfo.bAPSDCapable && pAd->CommonCfg.APEdcaParm.bAPSDCapable))
+common/mlme.c:			RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) ? TRUE:FALSE), pAd->CommonCfg.bAPSDForcePowerSave ? PWR_SAVE : pAd->StaCfg.Psm);
+common/mlme.c:			RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE, pAd->CommonCfg.bAPSDForcePowerSave ? PWR_SAVE : pAd->StaCfg.Psm);
+common/mlme.c:	USHORT PsmOld = pAd->StaCfg.Psm;
+common/mlme.c:	pAd->StaCfg.Psm = psm;	  
+common/mlme.c:	/* pAd->StaCfg.Psm must be updated before calling the function */
+common/mlme.c:	ULONG BeaconLostTime = pAd->StaCfg.BeaconLostTime;
+common/mlme.c:	if (pAd->CommonCfg.CarrierDetect.Enable == TRUE)
+common/mlme.c:		BeaconLostTime = pAd->StaCfg.BeaconLostTime + (pAd->StaCfg.BeaconLostTime/2);
+common/mlme.c:			LastBeaconRxTime = pAd->ApCfg.ApCliTab[pMacEntry->MatchAPCLITabIdx].ApCliRcvBeaconTime; 
+common/mlme.c:			LastBeaconRxTime = pAd->StaCfg.LastBeaconRxTime;
+common/mlme.c:			OneSecRxOkCnt = pAd->RalinkCounters.OneSecRxOkCnt;
+common/mlme.c:			OneSecRxFcsErrCnt = pAd->RalinkCounters.OneSecRxFcsErrCnt;
+common/mlme.c:			pRssiSample = &pAd->MacTab.Content[0].RssiSample;
+common/mlme.c:			OneSecTxNoRetryOkCount = pAd->RalinkCounters.OneSecTxNoRetryOkCount;
+common/mlme.c:			OneSecTxRetryOkCount = pAd->RalinkCounters.OneSecTxRetryOkCount;
+common/mlme.c:			OneSecTxFailCount = pAd->RalinkCounters.OneSecTxFailCount;
+common/mlme.c:			OneSecRxOkCnt = pAd->RalinkCounters.OneSecRxOkCnt;
+common/mlme.c:			OneSecRxFcsErrCnt = pAd->RalinkCounters.OneSecRxFcsErrCnt;
+common/mlme.c:	if ((pAd->OpMode == OPMODE_STA) &&
+common/mlme.c:	if (pAd->OpMode == OPMODE_STA)
+common/mlme.c:		pAd->Mlme.ChannelQuality = (ChannelQuality > 100) ? 100 : ChannelQuality;
+common/mlme.c:	if (pAd->OpMode == OPMODE_AP)
+common/mlme.c:		switch (pAd->CommonCfg.DesireRate[i] & 0x7f)
+common/mlme.c:			pHtPhy = &pAd->ApCfg.MBSSID[idx].HTPhyMode;	
+common/mlme.c:			pMaxHtPhy = &pAd->ApCfg.MBSSID[idx].MaxHTPhyMode;
+common/mlme.c:			pMinHtPhy = &pAd->ApCfg.MBSSID[idx].MinHTPhyMode;
+common/mlme.c:			auto_rate_cur_p = &pAd->ApCfg.MBSSID[idx].bAutoTxRateSwitch;	
+common/mlme.c:			HtMcs = pAd->ApCfg.MBSSID[idx].DesiredTransmitSetting.field.MCS;
+common/mlme.c:				pHtPhy = &pAd->ApCfg.ApCliTab[idx].HTPhyMode;	
+common/mlme.c:				pMaxHtPhy = &pAd->ApCfg.ApCliTab[idx].MaxHTPhyMode;
+common/mlme.c:				pMinHtPhy = &pAd->ApCfg.ApCliTab[idx].MinHTPhyMode;
+common/mlme.c:				auto_rate_cur_p = &pAd->ApCfg.ApCliTab[idx].bAutoTxRateSwitch;	
+common/mlme.c:				HtMcs = pAd->ApCfg.ApCliTab[idx].DesiredTransmitSetting.field.MCS;
+common/mlme.c:			if ((apidx < pAd->ApCfg.BssidNum) &&
+common/mlme.c:				pHtPhy = &pAd->ApCfg.MBSSID[apidx].HTPhyMode;
+common/mlme.c:				pMaxHtPhy = &pAd->ApCfg.MBSSID[apidx].MaxHTPhyMode;
+common/mlme.c:				pMinHtPhy = &pAd->ApCfg.MBSSID[apidx].MinHTPhyMode;
+common/mlme.c:				auto_rate_cur_p = &pAd->ApCfg.MBSSID[apidx].bAutoTxRateSwitch;
+common/mlme.c:				HtMcs = pAd->ApCfg.MBSSID[apidx].DesiredTransmitSetting.field.MCS;
+common/mlme.c:			pHtPhy = &pAd->StaCfg.HTPhyMode;
+common/mlme.c:			pMaxHtPhy = &pAd->StaCfg.MaxHTPhyMode;
+common/mlme.c:			pMinHtPhy = &pAd->StaCfg.MinHTPhyMode;	
+common/mlme.c:			auto_rate_cur_p = &pAd->StaCfg.bAutoTxRateSwitch;
+common/mlme.c:			HtMcs = pAd->StaCfg.DesiredTransmitSetting.field.MCS;
+common/mlme.c:			if ((pAd->StaCfg.BssType == BSS_ADHOC) &&
+common/mlme.c:				WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_B) &&
+common/mlme.c:	pAd->CommonCfg.MaxDesiredRate = MaxDesire;
+common/mlme.c:	if ((ADHOC_ON(pAd) || INFRA_ON(pAd)) && (pAd->OpMode == OPMODE_STA)
+common/mlme.c:		pSupRate = &pAd->StaActive.SupRate[0];
+common/mlme.c:		pExtRate = &pAd->StaActive.ExtRate[0];
+common/mlme.c:		SupRateLen = pAd->StaActive.SupRateLen;
+common/mlme.c:		ExtRateLen = pAd->StaActive.ExtRateLen;
+common/mlme.c:		pSupRate = &pAd->CommonCfg.SupRate[0];
+common/mlme.c:		pExtRate = &pAd->CommonCfg.ExtRate[0];
+common/mlme.c:		SupRateLen = pAd->CommonCfg.SupRateLen;
+common/mlme.c:		ExtRateLen = pAd->CommonCfg.ExtRateLen;
+common/mlme.c:		pAd->CommonCfg.ExpectedACKRate[i] = CurrBasicRate;
+common/mlme.c:		pAd->CommonCfg.MaxTxRate = MaxSupport;
+common/mlme.c:		pAd->CommonCfg.MaxTxRate = MaxDesire;
+common/mlme.c:	pAd->CommonCfg.MinTxRate = MinSupport;
+common/mlme.c:			dbm = pAd->StaCfg.RssiSample.AvgRssi0 - pAd->BbpRssiToDbmDelta;
+common/mlme.c:			pAd->CommonCfg.TxRate = RATE_24;
+common/mlme.c:			pAd->CommonCfg.TxRate = pAd->CommonCfg.MaxTxRate; 
+common/mlme.c:			pAd->CommonCfg.TxRate = RATE_11;
+common/mlme.c:			pAd->CommonCfg.TxRate = RATE_24;
+common/mlme.c:		if (pAd->CommonCfg.TxRate > pAd->CommonCfg.MaxTxRate)
+common/mlme.c:			pAd->CommonCfg.TxRate = pAd->CommonCfg.MaxTxRate; 
+common/mlme.c:		pAd->CommonCfg.TxRateIndex = 0;
+common/mlme.c:		pAd->CommonCfg.TxRate = pAd->CommonCfg.MaxTxRate;
+common/mlme.c:		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.STBC = pHtPhy->field.STBC;
+common/mlme.c:		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.ShortGI = pHtPhy->field.ShortGI;
+common/mlme.c:		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MCS = pHtPhy->field.MCS;
+common/mlme.c:		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE	= pHtPhy->field.MODE;
+common/mlme.c:	if (pAd->CommonCfg.TxRate <= RATE_11)
+common/mlme.c:			pMaxHtPhy->field.MCS = pAd->CommonCfg.TxRate;
+common/mlme.c:			pMinHtPhy->field.MCS = pAd->CommonCfg.MinTxRate;
+common/mlme.c:			pMaxHtPhy->field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.TxRate];
+common/mlme.c:			if (pAd->CommonCfg.MinTxRate >= RATE_6 && (pAd->CommonCfg.MinTxRate <= RATE_54))
+common/mlme.c:				pMinHtPhy->field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MinTxRate];
+common/mlme.c:				pMinHtPhy->field.MCS = pAd->CommonCfg.MinTxRate;
+common/mlme.c:	if (bLinkUp && (pAd->OpMode == OPMODE_STA))
+common/mlme.c:		pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word = pHtPhy->word;
+common/mlme.c:		pAd->MacTab.Content[BSSID_WCID].MaxHTPhyMode.word = pMaxHtPhy->word;
+common/mlme.c:		pAd->MacTab.Content[BSSID_WCID].MinHTPhyMode.word = pMinHtPhy->word;
+common/mlme.c:		if (WMODE_CAP(pAd->CommonCfg.PhyMode, WMODE_B) &&
+common/mlme.c:			pAd->CommonCfg.Channel <= 14)
+common/mlme.c:			pAd->CommonCfg.MlmeRate = RATE_1;
+common/mlme.c:			pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
+common/mlme.c:			pAd->CommonCfg.MlmeTransmit.field.MCS = RATE_1;				
+common/mlme.c:			pAd->CommonCfg.RtsRate = RATE_11;
+common/mlme.c:			pAd->CommonCfg.MlmeRate = RATE_6;
+common/mlme.c:			pAd->CommonCfg.RtsRate = RATE_6;
+common/mlme.c:			pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
+common/mlme.c:			pAd->CommonCfg.MlmeTransmit.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
+common/mlme.c:		pAd->MacTab.Content[MCAST_WCID].HTPhyMode.word = pAd->CommonCfg.MlmeTransmit.word;
+common/mlme.c:		if (pAd->CommonCfg.MlmeTransmit.field.MODE == MODE_OFDM)
+common/mlme.c:			pAd->MacTab.Content[MCAST_WCID].HTPhyMode.field.MCS = OfdmRateToRxwiMCS[RATE_24];
+common/mlme.c:			pAd->MacTab.Content[MCAST_WCID].HTPhyMode.field.MCS = RATE_1;
+common/mlme.c:		pAd->CommonCfg.BasicMlmeRate = pAd->CommonCfg.MlmeRate;
+common/mlme.c:			if (memcmp(&pAd->CommonCfg.MCastPhyMode, &tPhyMode, sizeof(HTTRANSMIT_SETTING)) == 0)
+common/mlme.c:				memmove(&pAd->CommonCfg.MCastPhyMode, &pAd->MacTab.Content[MCAST_WCID].HTPhyMode,
+common/mlme.c:				RateIdToMbps[pAd->CommonCfg.MaxTxRate],
+common/mlme.c:				RateIdToMbps[pAd->CommonCfg.MinTxRate], 
+common/mlme.c:				__FUNCTION__, RateIdToMbps[pAd->CommonCfg.TxRate],
+common/mlme.c:				RateIdToMbps[pAd->CommonCfg.RtsRate], BasicRateBitmap));
+common/mlme.c:				__FUNCTION__, pAd->CommonCfg.MlmeTransmit.word,
+common/mlme.c:				pAd->MacTab.Content[BSSID_WCID].MinHTPhyMode.word,
+common/mlme.c:				pAd->MacTab.Content[BSSID_WCID].MaxHTPhyMode.word,
+common/mlme.c:				pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word ));
+common/mlme.c:			pDesireHtPhy	= &pAd->ApCfg.MBSSID[idx].DesiredHtPhyInfo;
+common/mlme.c:			pActiveHtPhy	= &pAd->ApCfg.MBSSID[idx].DesiredHtPhyInfo;
+common/mlme.c:			pHtPhy 			= &pAd->ApCfg.MBSSID[idx].HTPhyMode;	
+common/mlme.c:			pMaxHtPhy		= &pAd->ApCfg.MBSSID[idx].MaxHTPhyMode;
+common/mlme.c:			pMinHtPhy		= &pAd->ApCfg.MBSSID[idx].MinHTPhyMode;
+common/mlme.c:			auto_rate_cur_p = &pAd->ApCfg.MBSSID[idx].bAutoTxRateSwitch;									
+common/mlme.c:				pDesireHtPhy	= &pAd->ApCfg.ApCliTab[idx].DesiredHtPhyInfo;
+common/mlme.c:				pActiveHtPhy	= &pAd->ApCfg.ApCliTab[idx].DesiredHtPhyInfo;
+common/mlme.c:				pHtPhy 			= &pAd->ApCfg.ApCliTab[idx].HTPhyMode;	
+common/mlme.c:				pMaxHtPhy		= &pAd->ApCfg.ApCliTab[idx].MaxHTPhyMode;
+common/mlme.c:				pMinHtPhy		= &pAd->ApCfg.ApCliTab[idx].MinHTPhyMode;
+common/mlme.c:				auto_rate_cur_p = &pAd->ApCfg.ApCliTab[idx].bAutoTxRateSwitch;
+common/mlme.c:			if ((apidx < pAd->ApCfg.BssidNum) && (apidx < HW_BEACON_MAX_NUM))
+common/mlme.c:				pDesireHtPhy	= &pAd->ApCfg.MBSSID[apidx].DesiredHtPhyInfo;
+common/mlme.c:				pActiveHtPhy	= &pAd->ApCfg.MBSSID[apidx].DesiredHtPhyInfo;
+common/mlme.c:				pHtPhy 			= &pAd->ApCfg.MBSSID[apidx].HTPhyMode;	
+common/mlme.c:				pMaxHtPhy		= &pAd->ApCfg.MBSSID[apidx].MaxHTPhyMode;
+common/mlme.c:				pMinHtPhy		= &pAd->ApCfg.MBSSID[apidx].MinHTPhyMode;
+common/mlme.c:				auto_rate_cur_p = &pAd->ApCfg.MBSSID[apidx].bAutoTxRateSwitch;
+common/mlme.c:			pDesireHtPhy	= &pAd->StaCfg.DesiredHtPhyInfo;
+common/mlme.c:			pActiveHtPhy	= &pAd->StaCfg.DesiredHtPhyInfo;
+common/mlme.c:			pHtPhy 		= &pAd->StaCfg.HTPhyMode;
+common/mlme.c:			pMaxHtPhy	= &pAd->StaCfg.MaxHTPhyMode;
+common/mlme.c:			pMinHtPhy	= &pAd->StaCfg.MinHTPhyMode;		
+common/mlme.c:			auto_rate_cur_p = &pAd->StaCfg.bAutoTxRateSwitch;
+common/mlme.c:	if ((ADHOC_ON(pAd) || INFRA_ON(pAd)) && (pAd->OpMode == OPMODE_STA)
+common/mlme.c:		if (pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE)
+common/mlme.c:		pRtHtCap = &pAd->StaActive.SupportedHtPhy;
+common/mlme.c:		pActiveHtPhy = &pAd->StaActive.SupportedPhyInfo;
+common/mlme.c:		StbcMcs = (UCHAR)pAd->MlmeAux.AddHtInfo.AddHtInfo3.StbcMcs;
+common/mlme.c:		BasicMCS =pAd->MlmeAux.AddHtInfo.MCSSet[0]+(pAd->MlmeAux.AddHtInfo.MCSSet[1]<<8)+(StbcMcs<<16);
+common/mlme.c:		if ((pAd->CommonCfg.DesiredHtPhy.TxSTBC) && (pRtHtCap->RxSTBC) && (pAd->Antenna.field.TxPath == 2))
+common/mlme.c:		pRtHtCap = &pAd->CommonCfg.DesiredHtPhy;
+common/mlme.c:		StbcMcs = (UCHAR)pAd->CommonCfg.AddHTInfo.AddHtInfo3.StbcMcs;
+common/mlme.c:		BasicMCS = pAd->CommonCfg.AddHTInfo.MCSSet[0]+(pAd->CommonCfg.AddHTInfo.MCSSet[1]<<8)+(StbcMcs<<16);
+common/mlme.c:		if ((pAd->CommonCfg.DesiredHtPhy.TxSTBC) && (pAd->Antenna.field.TxPath >= 2))
+common/mlme.c:	if ((pRtHtCap->GF) && (pAd->CommonCfg.DesiredHtPhy.GF))
+common/mlme.c:    if ((pAd->CommonCfg.DesiredHtPhy.ChannelWidth) && (pRtHtCap->ChannelWidth))
+common/mlme.c:		pMaxHtPhy->field.ShortGI = (pAd->CommonCfg.DesiredHtPhy.ShortGIfor20 & pRtHtCap->ShortGIfor20);
+common/mlme.c:		pMaxHtPhy->field.ShortGI = (pAd->CommonCfg.DesiredHtPhy.ShortGIfor40 & pRtHtCap->ShortGIfor40);
+common/mlme.c:	if ( (pAd->OpMode == OPMODE_STA) && (pDesireHtPhy->MCSSet[0] != 0xff)
+common/mlme.c:	DBGPRINT(RT_DEBUG_TRACE, (" %s():<---.AMsduSize = %d  \n", __FUNCTION__, pAd->CommonCfg.DesiredHtPhy.AmsduSize ));
+common/mlme.c:	NdisAllocateSpinLock(pAd, &pAd->BATabLock);
+common/mlme.c:		NdisFreeSpinLock(&pAd->BATable.BARecEntry[i].RxReRingLock);
+common/mlme.c:	NdisFreeSpinLock(&pAd->BATabLock);
+common/mlme.c:				if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, ie_list->Bssid) ||
+common/mlme.c:					SSID_EQUAL(pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen, ie_list->Ssid, ie_list->SsidLen)
+common/mlme.c:					|| MAC_ADDR_EQUAL(pAd->ApCliMlmeAux.Bssid, ie_list->Bssid)
+common/mlme.c:					|| SSID_EQUAL(pAd->ApCliMlmeAux.Ssid, pAd->ApCliMlmeAux.SsidLen, ie_list->Ssid, ie_list->SsidLen)
+common/mlme.c:					|| SSID_EQUAL(pAd->Cfg_pending_Ssid, pAd->Cfg_pending_SsidLen, ie_list->Ssid, ie_list->SsidLen)
+common/mlme.c:					pAd->Cfg_pending_SsidLen = 0;
+common/mlme.c:					NdisZeroMemory(pAd->Cfg_pending_Ssid, MAX_LEN_OF_SSID);
+common/mlme.c:		pAd->CommonCfg.TriggerEventTab.EventA[i].bValid = FALSE;
+common/mlme.c:	pAd->CommonCfg.TriggerEventTab.EventANo = 0;
+common/mlme.c:	pAd->CommonCfg.TriggerEventTab.EventBCountDown = 0;
+common/mlme.c:		Tab->EventBCountDown = pAd->CommonCfg.Dot11BssWidthChanTranDelay;
+common/mlme.c:	PWSC_CTRL	pWpsCtrl = &pAd->StaCfg.WscControl;
+common/mlme.c:		(pAd->StaCfg.bAutoConnectIfNoSSID == FALSE))
+common/mlme.c:	for (i = 0; i < pAd->ScanTab.BssNr; i++) 
+common/mlme.c:		BSS_ENTRY *pInBss = &pAd->ScanTab.BssEntry[i];
+common/mlme.c:		if ( ((pAd->CommonCfg.bIEEE80211H == 1) && 
+common/mlme.c:				(pAd->MlmeAux.Channel > 14) && 
+common/mlme.c:             || (pAd->CommonCfg.CarrierDetect.Enable == TRUE)
+common/mlme.c:		if ((pInBss->BssType == pAd->StaCfg.BssType) && 
+common/mlme.c:			if (pAd->StaCfg.WpaSupplicantUP & WPA_SUPPLICANT_ENABLE_WPS)
+common/mlme.c:			if ((pAd->StaCfg.IEEE80211dClientMode == Rt802_11_D_Strict) &&
+common/mlme.c:				(WMODE_HT_ONLY(pAd->CommonCfg.PhyMode)))
+common/mlme.c:			if ((pAd->CommonCfg.PhyMode == (WMODE_G | WMODE_GN)) &&
+common/mlme.c:			if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)
+common/mlme.c:				if ((pAd->StaCfg.AuthMode != pInBss->AuthMode) && (pAd->StaCfg.AuthMode != pInBss->AuthModeAux))
+common/mlme.c:				if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK))
+common/mlme.c:						if (pAd->StaCfg.WepStatus != pInBss->WPA.GroupCipher)
+common/mlme.c:					if ((pAd->StaCfg.WepStatus < pInBss->WPA.GroupCipher) &&
+common/mlme.c:					if ((pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled) && 
+common/mlme.c:						(pAd->StaCfg.WepStatus != pInBss->WPA.PairCipher) && 
+common/mlme.c:						(pAd->StaCfg.WepStatus != pInBss->WPA.PairCipherAux))
+common/mlme.c:				else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+common/mlme.c:						if (pAd->StaCfg.WepStatus != pInBss->WPA2.GroupCipher)
+common/mlme.c:					if ((pAd->StaCfg.WepStatus < pInBss->WPA.GroupCipher) &&
+common/mlme.c:					if ((pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled) && 
+common/mlme.c:						(pAd->StaCfg.WepStatus != pInBss->WPA2.PairCipher) && 
+common/mlme.c:						(pAd->StaCfg.WepStatus != pInBss->WPA2.PairCipherAux))
+common/mlme.c:				else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAICERT) || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAIPSK))
+common/mlme.c:					if ((pAd->StaCfg.WepStatus != pInBss->WAPI.GroupCipher) || 
+common/mlme.c:						(pAd->StaCfg.WepStatus != pInBss->WAPI.PairCipher))
+common/mlme.c:			else if (pAd->StaCfg.WepStatus != pInBss->WepStatus)
+common/mlme.c:				DBGPRINT(RT_DEBUG_TRACE,("StaCfg.WepStatus=%d, while pInBss->WepStatus=%d\n", pAd->StaCfg.WepStatus, pInBss->WepStatus));
+common/mlme.c:		else if ((pInBss->BssType == pAd->StaCfg.BssType) && (SsidLen == 0))
+common/mlme.c:				WMODE_HT_ONLY(pAd->CommonCfg.PhyMode))
+common/mlme.c:			if ((pAd->CommonCfg.PhyMode == (WMODE_G | WMODE_GN)) &&
+common/mlme.c:			if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)
+common/mlme.c:				if ((pAd->StaCfg.AuthMode != pInBss->AuthMode) && (pAd->StaCfg.AuthMode != pInBss->AuthModeAux))
+common/mlme.c:				if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK))
+common/mlme.c:						if (pAd->StaCfg.WepStatus != pInBss->WPA.GroupCipher)
+common/mlme.c:					if (pAd->StaCfg.WepStatus < pInBss->WPA.GroupCipher)
+common/mlme.c:					if ((pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled) && 
+common/mlme.c:						(pAd->StaCfg.WepStatus != pInBss->WPA.PairCipher) && 
+common/mlme.c:						(pAd->StaCfg.WepStatus != pInBss->WPA.PairCipherAux))
+common/mlme.c:				else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+common/mlme.c:						if (pAd->StaCfg.WepStatus != pInBss->WPA2.GroupCipher)
+common/mlme.c:					if (pAd->StaCfg.WepStatus < pInBss->WPA2.GroupCipher)
+common/mlme.c:					if ((pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled) && 
+common/mlme.c:						(pAd->StaCfg.WepStatus != pInBss->WPA2.PairCipher) && 
+common/mlme.c:						(pAd->StaCfg.WepStatus != pInBss->WPA2.PairCipherAux))
+common/mlme.c:				else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAICERT) || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAIPSK))
+common/mlme.c:					if ((pAd->StaCfg.WepStatus != pInBss->WAPI.GroupCipher) || 
+common/mlme.c:						(pAd->StaCfg.WepStatus != pInBss->WAPI.PairCipher))
+common/mlme.c:			else if (pAd->StaCfg.WepStatus != pInBss->WepStatus)
+common/mlme.c:			NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
+common/mlme.c:			NdisMoveMemory(pAd->MlmeAux.Ssid, pInBss->Ssid, pInBss->SsidLen);
+common/mlme.c:			pAd->MlmeAux.SsidLen = pInBss->SsidLen;
+common/mlme.c:			NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, MAX_LEN_OF_SSID);
+common/mlme.c:			NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
+common/mlme.c:			pAd->MlmeAux.AutoReconnectSsidLen = pAd->MlmeAux.SsidLen;
+common/mlme.c: *	\pre the station has the following information in the pAd->StaCfg
+common/mlme.c:		COPY_MAC_ADDR(pHdr80211->Addr2, pAd->CurrentAddress);
+common/mlme.c:	MLME_QUEUE	*Queue = (MLME_QUEUE *)&pAd->Mlme.Queue;
+common/mlme.c:	MLME_QUEUE	*Queue = (MLME_QUEUE *)&pAd->Mlme.Queue;
+common/mlme.c:			if (!MAC_ADDR_EQUAL(pFrame->Hdr.Addr1, pAd->CurrentAddress) &&
+common/mlme.c:			if (!MAC_ADDR_EQUAL(pFrame->Hdr.Addr1, pAd->CurrentAddress) &&
+common/mlme.c:				!MAC_ADDR_EQUAL(pAd->ApCliMlmeAux.Bssid, ZERO_MAC_ADDR)
+common/mlme.c:				&& MAC_ADDR_EQUAL(pAd->ApCliMlmeAux.Bssid, pFrame->Hdr.Addr2))
+common/mlme.c:	Queue->Entry[Tail].Channel = pAd->LatchRfRegs.Channel;
+common/mlme.c:	MLME_QUEUE	*Queue = (MLME_QUEUE *)&pAd->Mlme.Queue;
+common/mlme.c:		RTMPCancelTimer(&pAd->MlmeAux.AssocTimer,	  &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer,   &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer,  &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->MlmeAux.AuthTimer,	   &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer,	   &Cancelled);
+common/mlme.c:		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer,	   &Cancelled);
+common/mlme.c:			RTMPCancelTimer(&pAd->StaCfg.DLSEntry[i].Timer, &Cancelled);
+common/mlme.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[BSS0];
+common/mlme.c:	AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+common/mlme.c:	AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+common/mlme.c:		pAd->Mlme.CntlMachine.CurrState    = CNTL_IDLE;
+common/mlme.c:		pAd->Mlme.AssocMachine.CurrState   = ASSOC_IDLE;
+common/mlme.c:		pAd->Mlme.AuthMachine.CurrState    = AUTH_REQ_IDLE;
+common/mlme.c:		pAd->Mlme.AuthRspMachine.CurrState = AUTH_RSP_IDLE;
+common/mlme.c:		pAd->Mlme.SyncMachine.CurrState    = SYNC_IDLE;
+common/mlme.c:		pAd->Mlme.ActMachine.CurrState    = ACT_IDLE;
+common/mlme.c:		pAd->Mlme.DlsMachine.CurrState    = DLS_IDLE;
+common/mlme.c:		pAd->Mlme.TdlsMachine.CurrState    = TDLS_IDLE;
+common/mlme.c:		if (pAd->StaCfg.WscControl.WscState >= WSC_STATE_LINK_UP)
+common/mlme.c:	if (pAd->Mlme.ShiftReg == 0)
+common/mlme.c:	NdisGetSystemUpTime((ULONG *)&pAd->Mlme.ShiftReg);
+common/mlme.c:		if (pAd->Mlme.ShiftReg & 0x00000001) 
+common/mlme.c:			pAd->Mlme.ShiftReg = ((pAd->Mlme.ShiftReg ^ LFSR_MASK) >> 1) | 0x80000000;
+common/mlme.c:			pAd->Mlme.ShiftReg = pAd->Mlme.ShiftReg >> 1;
+common/mlme.c:	if (WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_B))
+common/mlme.c:	for (k = 0;k < pAd->ChannelListNum;k++)
+common/mlme.c:		if (pAd->ChannelList[k].Channel == UpperChannel)
+common/mlme.c:		if (pAd->ChannelList[k].Channel == LowerChannel)
+common/mlme.c:		FALSE if pAd->CommonCfg.SupportedHtPhy doesn't accept the pHtCapability.  (AP Mode)
+common/mlme.c:	if (pAd->CommonCfg.DesiredHtPhy.AmsduEnable)
+common/mlme.c:		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid], fCLIENT_STATUS_AMSDU_INUSED);
+common/mlme.c:		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid], fCLIENT_STATUS_SGI20_CAPABLE);
+common/mlme.c:		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid], fCLIENT_STATUS_SGI40_CAPABLE);
+common/mlme.c:		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid], fCLIENT_STATUS_TxSTBC_CAPABLE);
+common/mlme.c:		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid], fCLIENT_STATUS_RxSTBC_CAPABLE);
+common/mlme.c:	if (pAd->CommonCfg.bRdg && pHtCapability->ExtHtCapInfo.RDGSupport)
+common/mlme.c:		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid], fCLIENT_STATUS_RDG_CAPABLE);
+common/mlme.c:		pAd->MacTab.Content[Wcid].MpduDensity = pHtCapability->HtCapParm.MpduDensity;
+common/mlme.c:	NdisZeroMemory(&pAd->MlmeAux.HtCapability.MCSSet[0], 16);
+common/mlme.c:	pAd->MlmeAux.HtCapability.MCSSet[4] = 0x1;
+common/mlme.c:	switch (pAd->CommonCfg.RxStream)
+common/mlme.c:			pAd->MlmeAux.HtCapability.MCSSet[2] = 0xff;
+common/mlme.c:			pAd->MlmeAux.HtCapability.MCSSet[1] = 0xff;
+common/mlme.c:			pAd->MlmeAux.HtCapability.MCSSet[0] = 0xff;
+common/mlme.c:	pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth = pAddHtInfo->AddHtInfo.RecomWidth & pAd->CommonCfg.DesiredHtPhy.ChannelWidth;
+common/mlme.c:	if (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40)
+common/mlme.c:		if (RTMPCheckChannel(pAd, pAd->MlmeAux.CentralChannel, pAd->MlmeAux.Channel) == FALSE)
+common/mlme.c:			pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth = BW_20;
+common/mlme.c:		pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth, pAddHtInfo->AddHtInfo.RecomWidth, pAd->CommonCfg.DesiredHtPhy.ChannelWidth,
+common/mlme.c:		pAd->NicConfig2.field.BW40MAvailForA, pAd->NicConfig2.field.BW40MAvailForG, pAd->CommonCfg.PhyMode));
+common/mlme.c:	pAd->MlmeAux.HtCapability.HtCapInfo.GF =  pHtCapability->HtCapInfo.GF &pAd->CommonCfg.DesiredHtPhy.GF;
+common/mlme.c:	pAd->MlmeAux.HtCapability.HtCapInfo.AMsduSize =  pAd->CommonCfg.DesiredHtPhy.AmsduSize;
+common/mlme.c:	pAd->MlmeAux.HtCapability.HtCapInfo.MimoPs =  pAd->CommonCfg.DesiredHtPhy.MimoPs;
+common/mlme.c:	pAd->MlmeAux.HtCapability.HtCapInfo.ShortGIfor20 =  (pAd->CommonCfg.DesiredHtPhy.ShortGIfor20) & (pHtCapability->HtCapInfo.ShortGIfor20);
+common/mlme.c:	pAd->MlmeAux.HtCapability.HtCapInfo.ShortGIfor40 =  (pAd->CommonCfg.DesiredHtPhy.ShortGIfor40) & (pHtCapability->HtCapInfo.ShortGIfor40);
+common/mlme.c:	pAd->MlmeAux.HtCapability.HtCapInfo.TxSTBC =  (pAd->CommonCfg.DesiredHtPhy.TxSTBC)&(pHtCapability->HtCapInfo.RxSTBC);
+common/mlme.c:	pAd->MlmeAux.HtCapability.HtCapInfo.RxSTBC =  (pAd->CommonCfg.DesiredHtPhy.RxSTBC)&(pHtCapability->HtCapInfo.TxSTBC);
+common/mlme.c:	pAd->MlmeAux.HtCapability.HtCapParm.MaxRAmpduFactor = pAd->CommonCfg.DesiredHtPhy.MaxRAmpduFactor;
+common/mlme.c:    pAd->MlmeAux.HtCapability.HtCapParm.MpduDensity = pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity;
+common/mlme.c:	pAd->MlmeAux.HtCapability.ExtHtCapInfo.PlusHTC = pHtCapability->ExtHtCapInfo.PlusHTC;
+common/mlme.c:	pAd->MacTab.Content[Wcid].HTCapability.ExtHtCapInfo.PlusHTC = pHtCapability->ExtHtCapInfo.PlusHTC;
+common/mlme.c:	if (pAd->CommonCfg.bRdg)
+common/mlme.c:		pAd->MlmeAux.HtCapability.ExtHtCapInfo.RDGSupport = pHtCapability->ExtHtCapInfo.RDGSupport;
+common/mlme.c:        pAd->MlmeAux.HtCapability.ExtHtCapInfo.PlusHTC = 1;
+common/mlme.c:    if (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_20)
+common/mlme.c:        pAd->MlmeAux.HtCapability.MCSSet[4] = 0x0;  /* BW20 can't transmit MCS32*/
+common/mlme.c:	if (pAd->chipCap.FlgHwTxBfCap)
+common/mlme.c:	    setETxBFCap(pAd, &pAd->MlmeAux.HtCapability.TxBFCap);
+common/mlme.c:		FALSE if pAd->CommonCfg.SupportedHtPhy doesn't accept the pHtCapability.  (AP Mode)
+common/mlme.c:	pEntry = &pAd->MacTab.Content[Wcid];
+common/mlme.c:	NdisZeroMemory(&pAd->MlmeAux.vht_cap.mcs_set, sizeof(VHT_MCS_SET));
+common/mlme.c:	pAd->MlmeAux.vht_cap.mcs_set.rx_high_rate = pAd->CommonCfg.RxStream * 325;
+common/mlme.c:	pAd->MlmeAux.vht_cap.mcs_set.tx_high_rate = pAd->CommonCfg.TxStream * 325;
+common/mlme.c:	//pAd->MlmeAux.vht_cap.vht_cap.ch_width = vht_cap_info->ch_width;
+common/mlme.c:	switch (pAd->CommonCfg.PhyMode) 
+common/mlme.c:			if ((pAd->MlmeAux.SupRateLen == 4) &&
+common/mlme.c:				(pAd->MlmeAux.ExtRateLen == 0))
+common/mlme.c:			if (pAd->MlmeAux.Channel <= 14)
+common/mlme.c:			if (pAd->MlmeAux.Channel <= 14)
+common/mlme.c:	if (WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_B))
+common/mlme.c:		if (WMODE_CAP(pAd->CommonCfg.PhyMode, WMODE_B))
+common/mlme.c:			if ((pAd->MlmeAux.SupRateLen == 4) && (pAd->MlmeAux.ExtRateLen == 0))
+common/mlme.c:			if (pAd->MlmeAux.Channel <= 14)
+common/mlme.c:	for (i = 0; i < pAd->MlmeAux.SupRateLen; i++)
+common/mlme.c:			if ((pAd->MlmeAux.SupRate[i] & 0x7f) == RateIdTo500Kbps[j])
+common/mlme.c:	for (i = 0; i < pAd->MlmeAux.ExtRateLen; i++)
+common/mlme.c:			if ((pAd->MlmeAux.ExtRate[i] & 0x7f) == RateIdTo500Kbps[j])
+common/mlme.c:	pAd->CommonCfg.MlmeRate = MinimumRate;
+common/mlme.c:	pAd->CommonCfg.RtsRate = ProperMlmeRate;
+common/mlme.c:	if (pAd->CommonCfg.MlmeRate >= RATE_6)
+common/mlme.c:		pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
+common/mlme.c:		pAd->CommonCfg.MlmeTransmit.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
+common/mlme.c:		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MODE = MODE_OFDM;
+common/mlme.c:		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
+common/mlme.c:		pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
+common/mlme.c:		pAd->CommonCfg.MlmeTransmit.field.MCS = pAd->CommonCfg.MlmeRate;
+common/mlme.c:		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MODE = MODE_CCK;
+common/mlme.c:		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MCS = pAd->CommonCfg.MlmeRate;
+common/mlme.c:	DBGPRINT(RT_DEBUG_TRACE, ("RTMPUpdateMlmeRate ==>   MlmeTransmit = 0x%x  \n" , pAd->CommonCfg.MlmeTransmit.word));
+common/mlme.c:	if(pAd->Antenna.field.RxPath == 3)
+common/mlme.c:	else if(pAd->Antenna.field.RxPath == 2)
+common/mlme.c:	if ((pAd->Antenna.field.RxPath == 1) && (Rssi0 != 0))
+common/mlme.c:	if ((pAd->Antenna.field.RxPath >= 2) && (Rssi1 != 0))
+common/mlme.c:	if ((pAd->Antenna.field.RxPath == 3) && (Rssi2 != 0))
+common/mlme.c:	if (pAd->Antenna.field.RxPath == 1) 
+common/mlme.c:	if ((pAd->Antenna.field.RxPath >= 2) && (Snr1 != 0))
+common/mlme.c:	if (IS_RT3290(pAd) && (pAd->RalinkCounters.OneSecTransmittedByteCount >= 500))
+common/mlme.c:/*			if (pAd->CommonCfg.bRxAntDiversity == ANT_DIVERSITY_DISABLE)*/
+common/mlme.c:			if (pAd->MacTab.Size > 0)
+common/mlme.c:			if (pAd->StaCfg.Psm == PWR_SAVE)
+common/mlme.c:			rtmp_bbp_set_rxpath(pAd, pAd->Antenna.field.RxPath);
+common/mlme.c:				ULONG	TxTotalCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount + 
+common/mlme.c:									pAd->RalinkCounters.OneSecTxRetryOkCount + 
+common/mlme.c:									pAd->RalinkCounters.OneSecTxFailCount;
+common/mlme.c:					RTMPSetTimer(&pAd->Mlme.RxAntEvalTimer, 20);
+common/mlme.c:					pAd->Mlme.bLowThroughput = FALSE;
+common/mlme.c:					RTMPSetTimer(&pAd->Mlme.RxAntEvalTimer, 300);
+common/mlme.c:					pAd->Mlme.bLowThroughput = TRUE;
+common/mlme.c:/*			if (pAd->CommonCfg.bRxAntDiversity == ANT_DIVERSITY_DISABLE)*/
+common/mlme.c:			if (pAd->StaCfg.Psm == PWR_SAVE)
+common/mlme.c:			if (pAd->Mlme.bLowThroughput == TRUE)
+common/mlme.c:				rssi0 = pAd->StaCfg.RssiSample.LastRssi0;
+common/mlme.c:				rssi1 = pAd->StaCfg.RssiSample.LastRssi1;
+common/mlme.c:				rssi2 = pAd->StaCfg.RssiSample.LastRssi2;
+common/mlme.c:				rssi0 = pAd->StaCfg.RssiSample.AvgRssi0;
+common/mlme.c:				rssi1 = pAd->StaCfg.RssiSample.AvgRssi1;
+common/mlme.c:				rssi2 = pAd->StaCfg.RssiSample.AvgRssi2;
+common/mlme.c:			if(pAd->Antenna.field.RxPath == 3)
+common/mlme.c:				if (pAd->CommonCfg.TxStream >= 3)
+common/mlme.c:					pAd->Mlme.RealRxPath = 3;
+common/mlme.c:					pAd->Mlme.RealRxPath = 2;
+common/mlme.c:					pAd->Mlme.RealRxPath = 3;
+common/mlme.c:			else if(pAd->Antenna.field.RxPath == 2)
+common/mlme.c:					pAd->Mlme.RealRxPath = 1;
+common/mlme.c:					pAd->Mlme.RealRxPath = 2;
+common/mlme.c:			rtmp_bbp_set_rxpath(pAd, pAd->Mlme.RealRxPath);
+common/mlme.c:	pAd->CommonCfg.TriggerTimerCount++;
+common/mlme.c:	if (pAd->CommonCfg.bAPSDCapable && pAd->CommonCfg.APEdcaParm.bAPSDCapable
+common/mlme.c:		&& (pAd->CommonCfg.bNeedSendTriggerFrame ||
+common/mlme.c:		(((pAd->CommonCfg.TriggerTimerCount%20) == 19) && (!pAd->CommonCfg.bAPSDAC_BE || !pAd->CommonCfg.bAPSDAC_BK || !pAd->CommonCfg.bAPSDAC_VI || !pAd->CommonCfg.bAPSDAC_VO))))
+common/mlme.c:		RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE);
+common/mlme.c:		pAd->CommonCfg.bNeedSendTriggerFrame = FALSE;
+common/mlme.c:		pAd->CommonCfg.TriggerTimerCount = 0;
+common/mlme.c:		pAd->CommonCfg.bInServicePeriod = TRUE;
+common/mlme.c:			result = pAd->ApCfg.MBSSID[pEntry->apidx].bAutoTxRateSwitch;
+common/mlme.c:			result = pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].bAutoTxRateSwitch;
+common/mlme.c:			result = pAd->ApCfg.MBSSID[pEntry->apidx].bAutoTxRateSwitch;
+common/mlme.c:			result = pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].bAutoTxRateSwitch;
+common/mlme.c:			result = pAd->StaCfg.bAutoTxRateSwitch;
+common/mlme.c:		for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/mlme.c:			if (pAd->ApCfg.MBSSID[apidx].bAutoTxRateSwitch)
+common/mlme.c:			if (pAd->ApCfg.ApCliTab[apidx].bAutoTxRateSwitch)
+common/mlme.c:		if (pAd->StaCfg.bAutoTxRateSwitch)
+common/mlme.c:			tx_mode = (UCHAR)pAd->ApCfg.MBSSID[pEntry->apidx].DesiredTransmitSetting.field.FixedTxMode;
+common/mlme.c:			tx_mode = (UCHAR)pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].DesiredTransmitSetting.field.FixedTxMode;
+common/mlme.c:			tx_mode = (UCHAR)pAd->ApCfg.MBSSID[pEntry->apidx].DesiredTransmitSetting.field.FixedTxMode;
+common/mlme.c:			tx_mode = (UCHAR)pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].DesiredTransmitSetting.field.FixedTxMode;
+common/mlme.c:		tx_mode = (UCHAR)pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode;
+common/mlme.c:	if (pAd->MACVersion == 0x28600100)
+common/mlme.c:	if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)  /* no R66 tuning when SCANNING*/
+common/mlme.c:	if ((pAd->OpMode == OPMODE_STA) 
+common/mlme.c:		if (pAd->Antenna.field.RxPath > 1)
+common/mlme.c:			Rssi = (pAd->StaCfg.RssiSample.AvgRssi0 + pAd->StaCfg.RssiSample.AvgRssi1) >> 1;
+common/mlme.c:			Rssi = pAd->StaCfg.RssiSample.AvgRssi0;
+common/mlme.c:				if (pAd->BbpWriteLatch[BBP_R77] != 0x27)
+common/mlme.c:				if (pAd->BbpWriteLatch[BBP_R77] != 0x58)
+common/mlme.c:	if (pAd->chipOps.ChipAGCInit != NULL)
+common/mlme.c:		pAd->chipOps.ChipAGCInit(pAd, BandWidth);
+common/mlme.c:	for(IdChan=0; IdChan<pAd->ChannelListNum; IdChan++)
+common/mlme.c:		if (pAd->ChannelList[IdChan].Channel == ChanNum)
+common/mlme.c:			if ((pAd->ChannelList[IdChan].Flags & Property) == Property)
+common/cmm_dfs.c:	pAd->Dot11_H.InServiceMonitorCount++;
+common/cmm_dfs.c:	for (i=0; i<pAd->ChannelListNum; i++)
+common/cmm_dfs.c:		if (pAd->ChannelList[i].RemainingTimeForUse > 0)
+common/cmm_dfs.c:			pAd->ChannelList[i].RemainingTimeForUse --;
+common/cmm_dfs.c:			if ((pAd->Mlme.PeriodicRound%5) == 0)
+common/cmm_dfs.c:					pAd->ChannelList[i].Channel, pAd->ChannelList[i].RemainingTimeForUse));
+common/cmm_dfs.c:	if ((pAd->CommonCfg.Channel > 14)
+common/cmm_dfs.c:		&& (pAd->CommonCfg.bIEEE80211H == 1)
+common/cmm_dfs.c:		&& RadarChannelCheck(pAd, pAd->CommonCfg.Channel))
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	PDFS_SW_DETECT_PARAM pDfsSwParam = &pAd->CommonCfg.RadarDetect.DfsSwParam;
+common/cmm_dfs.c:	PDFS_PROGRAM_PARAM pDfsProgramParam = &pAd->CommonCfg.RadarDetect.DfsProgramParam;
+common/cmm_dfs.c:	else if ((simple_strtol(arg, 0, 10) >= 1) && (simple_strtol(arg, 0, 10) <= pAd->CommonCfg.RadarDetect.EnabledChMask))
+common/cmm_dfs.c:	PDFS_PROGRAM_PARAM pDfsProgramParam = &pAd->CommonCfg.RadarDetect.DfsProgramParam;
+common/cmm_dfs.c:	PDFS_SW_DETECT_PARAM pDfsSwParam = &pAd->CommonCfg.RadarDetect.DfsSwParam;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	PDFS_SW_DETECT_PARAM pDfsSwParam = &pAd->CommonCfg.RadarDetect.DfsSwParam;
+common/cmm_dfs.c:	PDFS_SW_DETECT_PARAM pDfsSwParam = &pAd->CommonCfg.RadarDetect.DfsSwParam;
+common/cmm_dfs.c:	PDFS_SW_DETECT_PARAM pDfsSwParam = &pAd->CommonCfg.RadarDetect.DfsSwParam;
+common/cmm_dfs.c:	PDFS_SW_DETECT_PARAM pDfsSwParam = &pAd->CommonCfg.RadarDetect.DfsSwParam;
+common/cmm_dfs.c:	PDFS_SW_DETECT_PARAM pDfsSwParam = &pAd->CommonCfg.RadarDetect.DfsSwParam;
+common/cmm_dfs.c:	PDFS_SW_DETECT_PARAM pDfsSwParam = &pAd->CommonCfg.RadarDetect.DfsSwParam;
+common/cmm_dfs.c:	PDFS_SW_DETECT_PARAM pDfsSwParam = &pAd->CommonCfg.RadarDetect.DfsSwParam;
+common/cmm_dfs.c:	PDFS_SW_DETECT_PARAM pDfsSwParam = &pAd->CommonCfg.RadarDetect.DfsSwParam;
+common/cmm_dfs.c:	PDFS_SW_DETECT_PARAM pDfsSwParam = &pAd->CommonCfg.RadarDetect.DfsSwParam;
+common/cmm_dfs.c:	PDFS_SW_DETECT_PARAM pDfsSwParam = &pAd->CommonCfg.RadarDetect.DfsSwParam;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	PDFS_PROGRAM_PARAM pDfsProgramParam = &pAd->CommonCfg.RadarDetect.DfsProgramParam;
+common/cmm_dfs.c:	PDFS_SW_DETECT_PARAM pDfsSwParam = &pAd->CommonCfg.RadarDetect.DfsSwParam;
+common/cmm_dfs.c:	printk("1 %x\n", pAd->LatchRfRegs.R1);
+common/cmm_dfs.c:	printk("2 %x\n", pAd->LatchRfRegs.R2);
+common/cmm_dfs.c:	printk("3 %x\n", pAd->LatchRfRegs.R3);
+common/cmm_dfs.c:	printk("4 %x\n", pAd->LatchRfRegs.R4);
+common/cmm_dfs.c:	for (i=0; i<pAd->ChannelListNum; i++)
+common/cmm_dfs.c:		if (pAd->ChannelList[i].RemainingTimeForUse != 0)
+common/cmm_dfs.c:				pAd->ChannelList[i].Channel, pAd->ChannelList[i].RemainingTimeForUse));
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	pRadarDetect->EnabledChMask = ((1 << pAd->chipCap.DfsEngineNum) -1);
+common/cmm_dfs.c:	for (i=0; i < pAd->chipCap.DfsEngineNum; i++)
+common/cmm_dfs.c:		    (pAd->CommonCfg.RDDurRegion == FCC || pAd->CommonCfg.RDDurRegion == JAP))
+common/cmm_dfs.c:	/*pAd->CommonCfg.ce_sw_check = CE_SW_CHECK;*/
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	if ((pAd->CommonCfg.RDDurRegion == CE) && RESTRICTION_BAND_1(pAd))
+common/cmm_dfs.c:		pAd->Dot11_H.ChMovingTime = 605;
+common/cmm_dfs.c:		pAd->Dot11_H.ChMovingTime = 65;
+common/cmm_dfs.c:	if (pAd->CommonCfg.RDDurRegion == FCC)
+common/cmm_dfs.c:	else if (pAd->CommonCfg.RDDurRegion == CE)
+common/cmm_dfs.c:		if ((pAd->CommonCfg.Channel >= 52) && (pAd->CommonCfg.Channel <= 64))
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	if (pAd->CommonCfg.RDDurRegion != CE)
+common/cmm_dfs.c:		if (pAd->CommonCfg.RDDurRegion == FCC)
+common/cmm_dfs.c:		else /* if (pAd->CommonCfg.RDDurRegion == JAP)*/
+common/cmm_dfs.c:				if (pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40)
+common/cmm_dfs.c:					if ( (pAd->Dot11_H.RDMode == RD_SILENCE_MODE) ||
+common/cmm_dfs.c:					if ( (pAd->Dot11_H.RDMode == RD_SILENCE_MODE) || 
+common/cmm_dfs.c:								/*if (((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40) && (T[1] > minPeriod)) ||*/
+common/cmm_dfs.c:								/*	((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_20) && (T[1] > (minPeriod >> 1))) )*/
+common/cmm_dfs.c:											ULONG T1 = (pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40)? (T[1]>>1) : T[1];
+common/cmm_dfs.c:						if (IS_FCC_RADAR_1((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40), T[0]))
+common/cmm_dfs.c:									if ( IS_FCC_RADAR_1((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40), pDfsSwParam->DFS_T[id][idx1].period) )
+common/cmm_dfs.c:						if (IS_W56_RADAR_3((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40), T[0]))
+common/cmm_dfs.c:									if ( IS_W56_RADAR_3((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40), pDfsSwParam->DFS_T[id][idx1].period) )
+common/cmm_dfs.c:					if ((pRadarDetect->MCURadarRegion == NEW_DFS_JAP_W53) && (id <= 2) && IS_W53_RADAR_2((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40), T[0]))
+common/cmm_dfs.c:							if ( IS_W53_RADAR_2((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40), pDfsSwParam->DFS_T[id][idx1].period) )
+common/cmm_dfs.c:			if (pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40)
+common/cmm_dfs.c:				if ( (pAd->Dot11_H.RDMode == RD_SILENCE_MODE) ||
+common/cmm_dfs.c:				if ( (pAd->Dot11_H.RDMode == RD_SILENCE_MODE) || 
+common/cmm_dfs.c:							if (((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40) && (T[1] > 66666)) ||
+common/cmm_dfs.c:								((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_20) && (T[1] > 33333)) )
+common/cmm_dfs.c:	PDFS_PROGRAM_PARAM pDfsProgramParam = &pAd->CommonCfg.RadarDetect.DfsProgramParam;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:			if ((pAd->ApCfg.RssiSample.AvgRssi0) && (pAd->ApCfg.RssiSample.AvgRssi0 > pRadarDetect->DfsRssiHigh))
+common/cmm_dfs.c:			else if ((pAd->ApCfg.RssiSample.AvgRssi0) && (pAd->ApCfg.RssiSample.AvgRssi0 < pRadarDetect->DfsRssiLow))
+common/cmm_dfs.c:				("%d %d %d %d\n", pRadarDetect->ch_idle_sum, pRadarDetect->ch_busy_sum, pAd->ApCfg.RssiSample.AvgRssi0, pRadarDetect->ch_busy));
+common/cmm_dfs.c:	if (pAd->CommonCfg.RDDurRegion == FCC)
+common/cmm_dfs.c:	else if (pAd->CommonCfg.RDDurRegion == CE)
+common/cmm_dfs.c:		if ((pAd->CommonCfg.Channel >= 52) && (pAd->CommonCfg.Channel <= 64))
+common/cmm_dfs.c:	for (i = 0; i < pAd->chipCap.DfsEngineNum; i++)
+common/cmm_dfs.c:			PDFS_PROGRAM_PARAM pDfsProgramParam = &pAd->CommonCfg.RadarDetect.DfsProgramParam;
+common/cmm_dfs.c:	UINT8 DfsEngineNum = pAd->chipCap.DfsEngineNum;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	/*pRadarDetect->MCURadarRegion = pAd->CommonCfg.RDDurRegion;*/
+common/cmm_dfs.c:	if (pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40)
+common/cmm_dfs.c:		if (pAd->chipCap.DfsEngineNum > 4 && (idx==4 || idx==5))
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;	
+common/cmm_dfs.c:	if (pAd->Dot11_H.RDMode == RD_SWITCHING_MODE)
+common/cmm_dfs.c:	for (i=0; i<pAd->ChannelListNum; i++)
+common/cmm_dfs.c:		if (pAd->CommonCfg.Channel == pAd->ChannelList[i].Channel)
+common/cmm_dfs.c:			if (pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth == BW_40)
+common/cmm_dfs.c:				if ((pAd->ChannelList[i].Channel >> 2) & 1)
+common/cmm_dfs.c:					if ((pAd->ChannelList[i+1].Channel - pAd->ChannelList[i].Channel) == 4 )
+common/cmm_dfs.c:						DBGPRINT(RT_DEBUG_TRACE, ("Find extend channel = %u\n", pAd->ChannelList[i+1].Channel));
+common/cmm_dfs.c:						pAd->ChannelList[i+1].RemainingTimeForUse = 1800;
+common/cmm_dfs.c:					if ((pAd->ChannelList[i].Channel - pAd->ChannelList[i-1].Channel) == 4 )
+common/cmm_dfs.c:						DBGPRINT(RT_DEBUG_TRACE, ("Find extend channel = %u\n", pAd->ChannelList[i-1].Channel));
+common/cmm_dfs.c:						pAd->ChannelList[i-1].RemainingTimeForUse = 1800;
+common/cmm_dfs.c:			pAd->ChannelList[i].RemainingTimeForUse = 1800;/*30 min = 1800 sec*/
+common/cmm_dfs.c:	if ((pAd->CommonCfg.RDDurRegion == CE) && RESTRICTION_BAND_1(pAd))
+common/cmm_dfs.c:		pAd->Dot11_H.ChMovingTime = 605;
+common/cmm_dfs.c:		pAd->Dot11_H.ChMovingTime = 65;
+common/cmm_dfs.c:	if (pAd->CommonCfg.RDDurRegion == JAP_W56)
+common/cmm_dfs.c:		for (i = 0; i < pAd->ChannelListNum ; i++)
+common/cmm_dfs.c:			pAd->CommonCfg.Channel = APAutoSelectChannel(pAd, FALSE);
+common/cmm_dfs.c:			if ((pAd->CommonCfg.Channel >= 100) && (pAd->CommonCfg.Channel <= 140))
+common/cmm_dfs.c:	else if (pAd->CommonCfg.RDDurRegion == JAP_W53)
+common/cmm_dfs.c:		for (i = 0; i < pAd->ChannelListNum ; i++)
+common/cmm_dfs.c:			pAd->CommonCfg.Channel = APAutoSelectChannel(pAd, FALSE);
+common/cmm_dfs.c:			if ((pAd->CommonCfg.Channel >= 36) && (pAd->CommonCfg.Channel <= 60))
+common/cmm_dfs.c:		pAd->CommonCfg.Channel = APAutoSelectChannel(pAd, FALSE);
+common/cmm_dfs.c:	if (pAd->Dot11_H.RDMode == RD_NORMAL_MODE)
+common/cmm_dfs.c:		pAd->Dot11_H.RDMode = RD_SWITCHING_MODE;
+common/cmm_dfs.c:		pAd->Dot11_H.CSCount = 0;
+common/cmm_dfs.c:	else if (pAd->Dot11_H.RDMode == RD_SILENCE_MODE)
+common/cmm_dfs.c:		pAd->Dot11_H.RDMode = RD_SWITCHING_MODE;
+common/cmm_dfs.c:	PDFS_SW_DETECT_PARAM pDfsSwParam = &pAd->CommonCfg.RadarDetect.DfsSwParam;
+common/cmm_dfs.c:		if (pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40)
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	if (pAd->CommonCfg.RDDurRegion == CE)	
+common/cmm_dfs.c:	if (pAd->CommonCfg.RDDurRegion == CE)
+common/cmm_dfs.c:		if (pAd->CommonCfg.RDDurRegion == FCC)
+common/cmm_dfs.c:		else if (pAd->CommonCfg.RDDurRegion == JAP)
+common/cmm_dfs.c:	if (pAd->CommonCfg.RDDurRegion == CE)
+common/cmm_dfs.c:	if (pAd->CommonCfg.RDDurRegion == CE)
+common/cmm_dfs.c:		if (pAd->CommonCfg.RDDurRegion == FCC)
+common/cmm_dfs.c:		else if (pAd->CommonCfg.RDDurRegion == JAP)
+common/cmm_dfs.c:	for (k = 0; k < pAd->chipCap.DfsEngineNum; k++)
+common/cmm_dfs.c:	for (k = 0; k < pAd->chipCap.DfsEngineNum; k++)
+common/cmm_dfs.c:	UINT8 DfsEngineNum = pAd->chipCap.DfsEngineNum;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	if (pAd->CommonCfg.RDDurRegion == FCC)
+common/cmm_dfs.c:	else if (pAd->CommonCfg.RDDurRegion == CE)
+common/cmm_dfs.c:		if ((pAd->CommonCfg.Channel >= 52) && (pAd->CommonCfg.Channel <= 64))
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:				if (id < pAd->chipCap.DfsEngineNum)
+common/cmm_dfs.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_dfs.c:    pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_dfs.c:		for (i = 0; i < pAd->chipCap.DfsEngineNum; i++)
+common/wsc.c:		NdisMoveMemory(&uuid_t.node[0], &pAd->ApCfg.MBSSID[apIdx].Bssid[0], sizeof(uuid_t.node));
+common/wsc.c:			NdisMoveMemory(&uuid_t.node[0], &pAd->ApCfg.MBSSID[MAIN_MBSSID].Bssid[0], sizeof(uuid_t.node));
+common/wsc.c:		NdisMoveMemory(&uuid_t.node[0], &pAd->CurrentAddress[0], sizeof(uuid_t.node));
+common/wsc.c:			pWScControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/wsc.c:			pWScControl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/wsc.c:		pWScControl = &pAd->StaCfg.WscControl;
+common/wsc.c:		pWScControl = &pAd->ApCfg.MBSSID[MAIN_MBSSID].WscControl;
+common/wsc.c:		pWScControl = &pAd->ApCfg.ApCliTab[MAIN_MBSSID].WscControl;
+common/wsc.c:									pWscData, dataLen, 0, 0, &pAd->CurrentAddress[0], AP_MODE);
+common/wsc.c:		pWpsCtrl = &pAd->ApCfg.MBSSID[pEntry->apidx].WscControl;
+common/wsc.c:		if ((pAd->StaCfg.BssType == BSS_ADHOC) &&
+common/wsc.c:		pWpsCtrl = &pAd->StaCfg.WscControl;
+common/wsc.c:        if ((pWscControl->WscActionMode == WSC_PROXY) && (pAd->OpMode == OPMODE_AP))
+common/wsc.c:				pAd->WriteWscCfgToDatFile = pWscControl->EntryIfIdx;
+common/wsc.c:/*				WAKE_UP(&(pAd->wscTask)); */
+common/wsc.c:/*				RTMP_SEM_EVENT_UP(&(pAd->wscTask.taskSema)); */
+common/wsc.c:				RtmpOsTaskWakeUp(&(pAd->wscTask));
+common/wsc.c:			if ((pAd->OpMode == OPMODE_STA) &&
+common/wsc.c:				(pAd->StaCfg.BssType == BSS_ADHOC) &&
+common/wsc.c:				(pAd->StaCfg.WscControl.WscConfMode == WSC_ENROLLEE))
+common/wsc.c:				pAd->StaCfg.IWscInfo.bReStart = TRUE;
+common/wsc.c:				&& (pAd->StaCfg.BssType == BSS_INFRA)
+common/wsc.c:				if ((pAd->StaCfg.BssType == BSS_INFRA) && (CurOpMode == STA_MODE))
+common/wsc.c:					WscSendEapolStart(pAd, pAd->CommonCfg.Bssid, CurOpMode);
+common/wsc.c:				if ((pWscControl->EntryIfIdx & 0x0F) < pAd->ApCfg.BssidNum)
+common/wsc.c:				pAd->StaCfg.bAutoConnectByBssid = FALSE;
+common/wsc.c:				RTMPZeroMemory(pAd->MlmeAux.AutoReconnectSsid, MAX_LEN_OF_SSID);
+common/wsc.c:				pAd->MlmeAux.AutoReconnectSsidLen = pAd->CommonCfg.SsidLen;
+common/wsc.c:				RTMPMoveMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen);
+common/wsc.c:		pWpsCtrl = &pAd->ApCfg.MBSSID[pEntry->apidx].WscControl;
+common/wsc.c:						  &pAd->ApCfg.MBSSID[pEntry->apidx].Bssid[0], 
+common/wsc.c:		pWpsCtrl = &pAd->StaCfg.WscControl;
+common/wsc.c:						  &pAd->CurrentAddress[0], 
+common/wsc.c:			pDevAddr = &pAd->ApCfg.ApCliTab[bssIdx].CurrentAddress[0];
+common/wsc.c:		pDevAddr = &pAd->ApCfg.MBSSID[bssIdx].Bssid[0];
+common/wsc.c:		pDevAddr = &pAd->CurrentAddress[0];
+common/wsc.c:			RtmpOSWrielessEventSend(pAd->net_dev, RT_WLAN_EVENT_CUSTOM, RT_WSC_UPNP_EVENT_FLAG, NULL, pBuf, pNLMsgHdr->segLen + sizeof(RTMP_WSC_NLMSG_HDR));
+common/wsc.c:		pWpsCtrl = &pAd->ApCfg.MBSSID[apidx & 0x0F].WscControl;
+common/wsc.c:		pWpsCtrl = &pAd->StaCfg.WscControl;
+common/wsc.c:		(pAd->StaCfg.BssType == BSS_ADHOC))
+common/wsc.c:			if (pAd->StaCfg.WscControl.WscMode == WSC_PIN_MODE)
+common/wsc.c:			if (pAd->StaCfg.IWscInfo.bLimitedUI)
+common/wsc.c:		if (WMODE_CAP_5G(pAd->CommonCfg.PhyMode))
+common/wsc.c:		if (pAd->CommonCfg.Channel > 14)
+common/wsc.c:	if ((pAd->StaCfg.BssType == BSS_ADHOC) &&
+common/wsc.c:			pIWscInfo = &pAd->StaCfg.IWscInfo;
+common/wsc.c:		tempVal = htons(pAd->StaCfg.IWscInfo.IpConfMethod);
+common/wsc.c:		if (pAd->StaCfg.WscControl.WscConfMode == WSC_REGISTRAR)
+common/wsc.c:	templen = AppendWSCTLV(WSC_ID_DEVICE_NAME, pData, &pAd->P2pCfg.DeviceName, pAd->P2pCfg.DeviceNameLen);
+common/wsc.c:		memcpy(pAd->ApCfg.MBSSID[apidx].WscIEBeacon.Value, &ieHdr, sizeof(WSC_IE_HEADER));
+common/wsc.c:		memcpy(pAd->ApCfg.MBSSID[apidx].WscIEBeacon.Value + sizeof(WSC_IE_HEADER), Data, Len);
+common/wsc.c:		pAd->ApCfg.MBSSID[apidx].WscIEBeacon.ValueLen = sizeof(WSC_IE_HEADER) + Len;
+common/wsc.c:		memcpy(pAd->StaCfg.WpsIEBeacon.Value, &ieHdr, sizeof(WSC_IE_HEADER));
+common/wsc.c:		memcpy(pAd->StaCfg.WpsIEBeacon.Value + sizeof(WSC_IE_HEADER), Data, Len);
+common/wsc.c:		pAd->StaCfg.WpsIEBeacon.ValueLen = sizeof(WSC_IE_HEADER) + Len;
+common/wsc.c:		pWpsCtrl = &pAd->ApCfg.MBSSID[apidx & 0x0F].WscControl;
+common/wsc.c:		pWpsCtrl = &pAd->StaCfg.WscControl;
+common/wsc.c:		(pAd->StaCfg.BssType == BSS_ADHOC))
+common/wsc.c:			(pAd->StaCfg.IWscInfo.bSelRegStart == FALSE))
+common/wsc.c:				if (pAd->StaCfg.IWscInfo.bLimitedUI)
+common/wsc.c:		if ((CurOpMode == STA_MODE) && pAd->StaCfg.IWscInfo.bSelRegStart)
+common/wsc.c:			templen = AppendWSCTLV(WSC_ID_MAC_ADDR, pData, pAd->StaCfg.IWscInfo.RegMacAddr, 0);
+common/wsc.c:			pAd->StaCfg.IWscInfo.bSelRegStart = FALSE;
+common/wsc.c:		if (pAd->P2pCfg.bSigmaEnabled) 
+common/wsc.c:		if (WMODE_CAP_5G(pAd->CommonCfg.PhyMode))
+common/wsc.c:		if (pAd->CommonCfg.Channel > 14)
+common/wsc.c:	if ((pAd->StaCfg.BssType == BSS_ADHOC) &&
+common/wsc.c:			pIWscInfo = &pAd->StaCfg.IWscInfo;
+common/wsc.c:		tempVal = htons(pAd->StaCfg.IWscInfo.IpConfMethod);
+common/wsc.c:		memcpy(pAd->ApCfg.MBSSID[apidx & 0xF].WscIEProbeResp.Value, &ieHdr, sizeof(WSC_IE_HEADER));
+common/wsc.c:		memcpy(pAd->ApCfg.MBSSID[apidx & 0xF].WscIEProbeResp.Value + sizeof(WSC_IE_HEADER), Data, Len);
+common/wsc.c:		pAd->ApCfg.MBSSID[apidx & 0xF].WscIEProbeResp.ValueLen = sizeof(WSC_IE_HEADER) + Len;
+common/wsc.c:		memcpy(pAd->StaCfg.WpsIEProbeResp.Value, &ieHdr, sizeof(WSC_IE_HEADER));
+common/wsc.c:		memcpy(pAd->StaCfg.WpsIEProbeResp.Value + sizeof(WSC_IE_HEADER), Data, Len);
+common/wsc.c:		pAd->StaCfg.WpsIEProbeResp.ValueLen = sizeof(WSC_IE_HEADER) + Len;
+common/wsc.c:					  &pAd->ApCfg.MBSSID[apidx].Bssid[0],
+common/wsc.c:						  &pAd->CurrentAddress[0], 
+common/wsc.c:    PWSC_REG_DATA	pReg = (PWSC_REG_DATA) &pAd->ApCfg.MBSSID[ApIdx].WscControl.RegData;
+common/wsc.c:	if (pAd->ApCfg.MBSSID[ApIdx].WscControl.WscV2Info.bEnableWpsV2)
+common/wsc.c:		WscGenV2Msg(&pAd->ApCfg.MBSSID[ApIdx].WscControl, 
+common/wsc.c:	PWSC_CTRL	pWscCtrl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/wsc.c:	PWSC_REG_DATA	pReg = (PWSC_REG_DATA) &pAd->StaCfg.WscControl.RegData;
+common/wsc.c:	if ((CurOpMode == STA_MODE) && (pAd->StaCfg.BssType == BSS_ADHOC))
+common/wsc.c:	if (pAd->StaCfg.WscControl.WscConfMode == WSC_REGISTRAR)
+common/wsc.c:	else if (pAd->StaCfg.WscControl.WscConfMode == WSC_ENROLLEE)
+common/wsc.c:	if (pAd->StaCfg.WscControl.WscV2Info.bEnableWpsV2)
+common/wsc.c:			tempVal = pAd->StaCfg.WscControl.WscConfigMethods;
+common/wsc.c:		tempVal = (pAd->StaCfg.WscControl.WscConfigMethods & 0x00FF);
+common/wsc.c:		(pAd->StaCfg.BssType == BSS_ADHOC))
+common/wsc.c:		if (pAd->StaCfg.IWscInfo.bLimitedUI)
+common/wsc.c:	if ((pAd->StaCfg.BssType == BSS_ADHOC) &&
+common/wsc.c:		tempVal = htons(pAd->StaCfg.IWscInfo.IpMethod);
+common/wsc.c:	if (pAd->StaCfg.WscControl.WscV2Info.bEnableWpsV2)
+common/wsc.c:		WscGenV2Msg(&pAd->StaCfg.WscControl, 
+common/wsc.c:    if (pEntry->apidx >= pAd->ApCfg.BssidNum)
+common/wsc.c:    if (MAC_ADDR_EQUAL(pEntry->Addr, pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryAddr))
+common/wsc.c:        NdisZeroMemory(pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryAddr, MAC_ADDR_LEN);
+common/wsc.c:        RTMPCancelTimer(&pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EapolTimer, &Cancelled);
+common/wsc.c:        pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EapolTimerRunning = FALSE;
+common/wsc.c:        pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.WscState = WSC_STATE_CONFIGURED;
+common/wsc.c:    pEntry = MacTableLookup(pAd, pAd->ApCfg.MBSSID[apidx].WscControl.EntryAddr);
+common/wsc.c:	if ((pWscControl->EntryIfIdx & 0x0F)< pAd->ApCfg.BssidNum)
+common/wsc.c:		pAd->MlmeAux.AutoReconnectSsidLen = pAd->MlmeAux.SsidLen;
+common/wsc.c:		NdisZeroMemory(&pAd->MlmeAux.AutoReconnectSsid[0], MAX_LEN_OF_SSID);
+common/wsc.c:		NdisMoveMemory(&pAd->MlmeAux.AutoReconnectSsid[0], &pAd->MlmeAux.Ssid[0], pAd->MlmeAux.SsidLen);
+common/wsc.c:			pAd->ApCfg.MBSSID[apidx].WscIEBeacon.ValueLen = 0;
+common/wsc.c:			pAd->ApCfg.MBSSID[apidx].WscIEProbeResp.ValueLen = 0;
+common/wsc.c:			pWscControl = &pAd->ApCfg.ApCliTab[BssIndex & 0x0F].WscControl;
+common/wsc.c:			pWscControl = &pAd->ApCfg.MBSSID[BssIndex & 0x0F].WscControl;
+common/wsc.c:			pWscControl = &pAd->ApCfg.MBSSID[MAIN_MBSSID].WscControl;
+common/wsc.c:			pWscControl = &pAd->ApCfg.ApCliTab[MAIN_MBSSID].WscControl;
+common/wsc.c:			pWscControl = &pAd->StaCfg.WscControl;
+common/wsc.c:				pAd->ApCfg.MBSSID[BssIndex & 0x0F].WscIEBeacon.ValueLen = 0;
+common/wsc.c:				pAd->ApCfg.MBSSID[BssIndex & 0x0F].WscIEProbeResp.ValueLen = 0;
+common/wsc.c:				pAd->ApCfg.MBSSID[MAIN_MBSSID].WscIEBeacon.ValueLen = 0;
+common/wsc.c:				pAd->ApCfg.MBSSID[MAIN_MBSSID].WscIEProbeResp.ValueLen = 0;
+common/wsc.c:			NdisZeroMemory(pAd->ApCfg.MBSSID[CurApIdx].Ssid, MAX_LEN_OF_SSID);
+common/wsc.c:			NdisMoveMemory(pAd->ApCfg.MBSSID[CurApIdx].Ssid, pCredential->SSID.Ssid, pCredential->SSID.SsidLength);
+common/wsc.c:			pAd->ApCfg.MBSSID[CurApIdx].SsidLen = pCredential->SSID.SsidLength;
+common/wsc.c:				NdisZeroMemory(pAd->P2pCfg.SSID, MAX_LEN_OF_SSID);
+common/wsc.c:				pAd->P2pCfg.SSIDLen = pCredential->SSID.SsidLength;
+common/wsc.c:				NdisMoveMemory(pAd->P2pCfg.SSID, pCredential->SSID.Ssid, pAd->P2pCfg.SSIDLen);
+common/wsc.c:			pAd->MlmeAux.AutoReconnectSsidLen = pCredential->SSID.SsidLength;
+common/wsc.c:			NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, NDIS_802_11_LENGTH_SSID);
+common/wsc.c:			NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid, pCredential->SSID.Ssid, pAd->MlmeAux.AutoReconnectSsidLen);
+common/wsc.c:			pAd->MlmeAux.SsidLen = pCredential->SSID.SsidLength;
+common/wsc.c:			NdisZeroMemory(pAd->MlmeAux.Ssid, NDIS_802_11_LENGTH_SSID);
+common/wsc.c:			NdisMoveMemory(pAd->MlmeAux.Ssid, pCredential->SSID.Ssid, pAd->MlmeAux.SsidLen);
+common/wsc.c:			if (!NdisEqualMemory(pCredential->MacAddr, pAd->CurrentAddress, MAC_ADDR_LEN))
+common/wsc.c:				NdisZeroMemory(pAd->MlmeAux.Bssid, MAC_ADDR_LEN);
+common/wsc.c:				NdisMoveMemory(pAd->MlmeAux.Bssid, pCredential->MacAddr, MAC_ADDR_LEN);
+common/wsc.c:				pAd->StaCfg.WpaState = SS_START;
+common/wsc.c:					pAd->ApCfg.MBSSID[CurApIdx].DefaultKeyId = 1;
+common/wsc.c:					pAd->StaCfg.DefaultKeyId = 0;
+common/wsc.c:						pPMKBuf = pAd->ApCfg.MBSSID[CurApIdx].PMK;
+common/wsc.c:						pSSIDStr = (PUCHAR)pAd->ApCfg.MBSSID[CurApIdx].Ssid;
+common/wsc.c:						ssidLen = pAd->ApCfg.MBSSID[CurApIdx].SsidLen;
+common/wsc.c:						RTMPZeroMemory(pAd->StaCfg.WpaPassPhrase, 64);
+common/wsc.c:						RTMPMoveMemory(pAd->StaCfg.WpaPassPhrase, pCredential->Key, pWscControl->WpaPskLen);
+common/wsc.c:						pAd->StaCfg.WpaPassPhraseLen = pCredential->KeyLength;
+common/wsc.c:						pPMKBuf = pAd->StaCfg.PMK;
+common/wsc.c:						pAd->ApCfg.MBSSID[CurApIdx].DefaultKeyId = WepKeyId;
+common/wsc.c:						pAd->StaCfg.DefaultKeyId = WepKeyId;
+common/wsc.c:							pAd->SharedKey[CurApIdx][WepKeyId].KeyLen = (UCHAR)WepKeyLen;
+common/wsc.c:							memcpy(pAd->SharedKey[CurApIdx][WepKeyId].Key, 
+common/wsc.c:								pAd->SharedKey[CurApIdx][WepKeyId].CipherAlg = CIPHER_WEP64;
+common/wsc.c:								pAd->SharedKey[CurApIdx][WepKeyId].CipherAlg = CIPHER_WEP128;
+common/wsc.c:							pAd->SharedKey[CurApIdx][WepKeyId].KeyLen = (UCHAR)(WepKeyLen/2);
+common/wsc.c:							AtoH((PSTRING) pCredential->Key, pAd->SharedKey[CurApIdx][WepKeyId].Key, WepKeyLen/2);
+common/wsc.c:								pAd->SharedKey[CurApIdx][WepKeyId].CipherAlg = CIPHER_WEP64;
+common/wsc.c:								pAd->SharedKey[CurApIdx][WepKeyId].CipherAlg = CIPHER_WEP128;
+common/wsc.c:						pAd->ApCfg.MBSSID[CurApIdx].DefaultKeyId = 0;
+common/wsc.c:						pAd->StaCfg.DefaultKeyId = 0;
+common/wsc.c:			pAd->ApCfg.MBSSID[CurApIdx].DefaultKeyId = 1;
+common/wsc.c:			NdisZeroMemory(pAd->ApCfg.MBSSID[CurApIdx].Ssid, MAX_LEN_OF_SSID);
+common/wsc.c:			NdisMoveMemory(pAd->ApCfg.MBSSID[CurApIdx].Ssid, pCredential->SSID.Ssid, pCredential->SSID.SsidLength);
+common/wsc.c:			pAd->ApCfg.MBSSID[CurApIdx].SsidLen = pCredential->SSID.SsidLength;
+common/wsc.c:				AtoH((PSTRING) pWscControl->WpaPsk, pAd->ApCfg.MBSSID[CurApIdx].PMK, 32);
+common/wsc.c:							 (PUCHAR) pAd->ApCfg.MBSSID[CurApIdx].Ssid, 
+common/wsc.c:							 pAd->ApCfg.MBSSID[CurApIdx].SsidLen, 
+common/wsc.c:				NdisMoveMemory(pAd->ApCfg.MBSSID[CurApIdx].PMK, keyMaterial, 32);
+common/wsc.c:		if ((pAd->StaCfg.BssType == BSS_INFRA) &&
+common/wsc.c:		if ((pAd->StaCfg.BssType == BSS_ADHOC) && 
+common/wsc.c:			(pAd->StaCfg.IWscInfo.RegDepth != 0) &&
+common/wsc.c:			(pAd->StaCfg.IWscInfo.AvaSubMaskListCount != 0))
+common/wsc.c:				pAd->StaCfg.IWscInfo.AvaSubMaskListCount = 0;
+common/wsc.c:			for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/wsc.c:				NdisMoveMemory(pTempStr + offset, pAd->ApCfg.MBSSID[apidx].Ssid, pAd->ApCfg.MBSSID[apidx].SsidLen);
+common/wsc.c:			UINT profile_idx = pAd->StaCfg.WscControl.WscProfile.ApplyProfileIdx;
+common/wsc.c:			PWSC_CREDENTIAL pCredential = &pAd->StaCfg.WscControl.WscProfile.Profile[profile_idx];
+common/wsc.c:		for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/wsc.c:				NdisMoveMemory(pTempStr + offset, pAd->ApCfg.MBSSID[apidx].Ssid, pAd->ApCfg.MBSSID[apidx].SsidLen);
+common/wsc.c:			for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/wsc.c:				pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/wsc.c:			pWscControl = &pAd->StaCfg.WscControl;
+common/wsc.c:		for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/wsc.c:				pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/wsc.c:			pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeAutoSwitch;
+common/wsc.c:			pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeOpen;
+common/wsc.c:			pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeShared;
+common/wsc.c:			pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPAPSK;
+common/wsc.c:			pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPA;
+common/wsc.c:			pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPA2PSK;
+common/wsc.c:			pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPA2;
+common/wsc.c:			pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPA1WPA2;
+common/wsc.c:			pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPA1PSKWPA2PSK;
+common/wsc.c:			pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeOpen;
+common/wsc.c:			if (IS_ENTRY_CLIENT(&pAd->MacTab.Content[i]))
+common/wsc.c:				pAd->MacTab.Content[i].PortSecured  = WPA_802_1X_PORT_NOT_SECURED;
+common/wsc.c:		pAd->ApCfg.MBSSID[apidx].PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+common/wsc.c:		/*RTMPMakeRSNIE(pAd, pAd->ApCfg.MBSSID[apidx].AuthMode, pAd->ApCfg.MBSSID[apidx].WepStatus, apidx); */
+common/wsc.c:		pAd->ApCfg.MBSSID[apidx].DefaultKeyId  = 0;
+common/wsc.c:		if(pAd->ApCfg.MBSSID[apidx].AuthMode >= Ndis802_11AuthModeWPA)
+common/wsc.c:			pAd->ApCfg.MBSSID[apidx].DefaultKeyId = 0;
+common/wsc.c:		DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d) %s::(AuthMode=%d)\n", apidx, __FUNCTION__, pAd->ApCfg.MBSSID[apidx].AuthMode));    
+common/wsc.c:			pAd->StaCfg.AuthMode = Ndis802_11AuthModeAutoSwitch;
+common/wsc.c:			pAd->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
+common/wsc.c:			pAd->StaCfg.AuthMode = Ndis802_11AuthModeShared;
+common/wsc.c:			pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPAPSK;
+common/wsc.c:			pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPANone;
+common/wsc.c:			pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPA2PSK;    
+common/wsc.c:			pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPA;    
+common/wsc.c:			pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPA2;
+common/wsc.c:		if ((pAd->StaCfg.BssType == BSS_ADHOC) && (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK))
+common/wsc.c:			pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPANone;
+common/wsc.c:		pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+common/wsc.c:		DBGPRINT(RT_DEBUG_TRACE, ("WscSetAuthMode::(AuthMode=%d)\n", pAd->StaCfg.AuthMode));
+common/wsc.c:		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11WEPDisabled;
+common/wsc.c:		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11WEPEnabled;
+common/wsc.c:		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11Encryption2Enabled;
+common/wsc.c:		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11Encryption3Enabled;
+common/wsc.c:		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11Encryption4Enabled;
+common/wsc.c:		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11WEPDisabled;
+common/wsc.c:	if (pAd->ApCfg.MBSSID[apidx].WepStatus >= Ndis802_11Encryption2Enabled)
+common/wsc.c:		pAd->ApCfg.MBSSID[apidx].DefaultKeyId = 0;
+common/wsc.c:	/*RTMPMakeRSNIE(pAd, pAd->ApCfg.MBSSID[apidx].AuthMode, pAd->ApCfg.MBSSID[apidx].WepStatus, apidx); */
+common/wsc.c:	DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d) %s::(EncrypType=%d)\n", apidx, __FUNCTION__, pAd->ApCfg.MBSSID[apidx].WepStatus));
+common/wsc.c:			if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)
+common/wsc.c:			pAd->StaCfg.WepStatus     = Ndis802_11WEPDisabled;
+common/wsc.c:			pAd->StaCfg.PairCipher    = Ndis802_11WEPDisabled;
+common/wsc.c:			pAd->StaCfg.GroupCipher   = Ndis802_11WEPDisabled;
+common/wsc.c:			if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)
+common/wsc.c:			pAd->StaCfg.WepStatus     = Ndis802_11WEPEnabled;
+common/wsc.c:			pAd->StaCfg.PairCipher    = Ndis802_11WEPEnabled;
+common/wsc.c:			pAd->StaCfg.GroupCipher   = Ndis802_11WEPEnabled;
+common/wsc.c:			if (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA)
+common/wsc.c:			pAd->StaCfg.WepStatus     = Ndis802_11Encryption2Enabled;
+common/wsc.c:			pAd->StaCfg.PairCipher    = Ndis802_11Encryption2Enabled;
+common/wsc.c:			pAd->StaCfg.GroupCipher   = Ndis802_11Encryption2Enabled;
+common/wsc.c:			if (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA)
+common/wsc.c:			pAd->StaCfg.WepStatus     = Ndis802_11Encryption3Enabled;
+common/wsc.c:			pAd->StaCfg.PairCipher    = Ndis802_11Encryption3Enabled;
+common/wsc.c:			pAd->StaCfg.GroupCipher   = Ndis802_11Encryption3Enabled;
+common/wsc.c:		DBGPRINT(RT_DEBUG_TRACE, ("WscSetEncrypType::(EncrypType=%d)\n", pAd->StaCfg.WepStatus));
+common/wsc.c:		pAd->StaCfg.bNotFirstScan = TRUE;
+common/wsc.c:			if (pAd->StaCfg.BssType == BSS_INFRA)
+common/wsc.c:			RTMPZeroMemory(pAd->MlmeAux.AutoReconnectSsid, MAX_LEN_OF_SSID);
+common/wsc.c:			pAd->MlmeAux.AutoReconnectSsidLen = pAd->CommonCfg.SsidLen;
+common/wsc.c:			RTMPMoveMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen);
+common/wsc.c:	pAd->MlmeAux.CurrReqIsFromNdis = FALSE; 
+common/wsc.c:	if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+common/wsc.c:	                   pAd->ApCfg.ApCliTab[BSS0].CurrentAddress, 
+common/wsc.c:		snprintf(ChStr, sizeof(ChStr), "%d", pAd->MlmeAux.Channel);
+common/wsc.c:		if(pAd->ApCfg.ApCliTab[BSS0].Enable == TRUE)
+common/wsc.c:			pAd->ApCfg.ApCliTab[BSS0].Enable = FALSE;
+common/wsc.c:	    pAd->ApCfg.ApCliTab[BSS0].Enable = TRUE;
+common/wsc.c:		if (pAd->StaCfg.BssType == BSS_INFRA)
+common/wsc.c:				(VOID *)&pAd->StaCfg.WscControl.WscSsid, 0);
+common/wsc.c:				if ((pAd->OpMode == OPMODE_STA) &&
+common/wsc.c:					(pAd->StaCfg.BssType == BSS_ADHOC))
+common/wsc.c:		if ((pAd->StaCfg.BssType == BSS_ADHOC) && 
+common/wsc.c:	pWscControl = &pAd->ApCfg.ApCliTab[BSS0].WscControl;
+common/wsc.c:	pWscControl = &pAd->StaCfg.WscControl;
+common/wsc.c:	for (i = 0; i < pAd->ScanTab.BssNr; i++) 
+common/wsc.c:		pInBss  = (PBSS_ENTRY) &pAd->ScanTab.BssEntry[i];		
+common/wsc.c:		if ((CurOpMode == STA_MODE) && (pInBss->BssType != pAd->StaCfg.BssType))
+common/wsc.c:		pAd->MlmeAux.Channel = ApUuidBssid[0].Channel;
+common/wsc.c:		NdisZeroMemory(pAd->ApCfg.ApCliTab[BSS0].CfgSsid, MAX_LEN_OF_SSID);
+common/wsc.c:		NdisMoveMemory(pAd->ApCfg.ApCliTab[BSS0].CfgSsid, ApUuidBssid[0].Ssid, ApUuidBssid[0].SsidLen);
+common/wsc.c:		pAd->ApCfg.ApCliTab[BSS0].CfgSsidLen = (UCHAR)ApUuidBssid[0].SsidLen;
+common/wsc.c:				 (pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK)) &&
+common/wsc.c:				switch (pAd->ApCfg.MBSSID[apidx].WscSecurityMode)			
+common/wsc.c:					if (pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11Encryption2Enabled)
+common/wsc.c:					if (pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11Encryption3Enabled)
+common/wsc.c:				authType = WscGetAuthType(pAd->ApCfg.MBSSID[apidx].AuthMode);
+common/wsc.c:				encyType = WscGetEncryType(pAd->ApCfg.MBSSID[apidx].WepStatus);
+common/wsc.c:			WepKeyId = pAd->ApCfg.MBSSID[apidx].DefaultKeyId;
+common/wsc.c:			authType = WscGetAuthType(pAd->ApCfg.ApCliTab[apidx].AuthMode);
+common/wsc.c:			encyType = WscGetEncryType(pAd->ApCfg.ApCliTab[apidx].WepStatus);
+common/wsc.c:			WepKeyId = pAd->ApCfg.ApCliTab[apidx].DefaultKeyId;
+common/wsc.c:		authType = WscGetAuthType(pAd->StaCfg.AuthMode);
+common/wsc.c:		encyType = WscGetEncryType(pAd->StaCfg.WepStatus);
+common/wsc.c:		WepKeyId = pAd->StaCfg.DefaultKeyId;
+common/wsc.c:		  || (((OpMode & 0x0F) == STA_MODE) && (pAd->StaCfg.BssType == BSS_ADHOC))
+common/wsc.c:			if (pAd->StaCfg.IWscInfo.IWscDefaultSecurity == 1)
+common/wsc.c:			else if (pAd->StaCfg.IWscInfo.IWscDefaultSecurity == 2)
+common/wsc.c:				if (((OpMode & 0x0F) == AP_MODE || (OpMode & 0x0F) == STA_MODE) && pAd->SharedKey[apidx][WepKeyId].KeyLen)
+common/wsc.c:					for (i=0; i<pAd->SharedKey[apidx][WepKeyId].KeyLen; i++)
+common/wsc.c:						snprintf((PSTRING) pCredential->Key, 64, "%s%02x", pCredential->Key, pAd->SharedKey[apidx][WepKeyId].Key[i]);
+common/wsc.c:					pCredential->KeyLength = pAd->SharedKey[apidx][WepKeyId].KeyLen*2;
+common/wsc.c:				else if ((OpMode == AP_CLIENT_MODE) && (pAd->ApCfg.ApCliTab[apidx].SharedKey[WepKeyId].KeyLen) && 
+common/wsc.c:					for (i=0; i<pAd->ApCfg.ApCliTab[apidx].SharedKey[WepKeyId].KeyLen; i++)
+common/wsc.c:						snprintf((PSTRING) pCredential->Key, 64, "%s%02x", pCredential->Key, pAd->ApCfg.ApCliTab[apidx].SharedKey[WepKeyId].Key[i]);
+common/wsc.c:					pCredential->KeyLength = pAd->SharedKey[apidx][WepKeyId].KeyLen*2;
+common/wsc.c:			NdisMoveMemory(pCredential->MacAddr, pAd->ApCfg.MBSSID[apidx].Bssid, 6);
+common/wsc.c:				NdisMoveMemory(pCredential->SSID.Ssid, pAd->ApCfg.MBSSID[apidx].Ssid, pAd->ApCfg.MBSSID[apidx].SsidLen);
+common/wsc.c:				pCredential->SSID.SsidLength = pAd->ApCfg.MBSSID[apidx].SsidLen;
+common/wsc.c:			NdisMoveMemory(pCredential->MacAddr, APCLI_ROOT_BSSID_GET(pAd, pAd->ApCfg.ApCliTab[apidx].MacTabWCID), 6);
+common/wsc.c:			NdisMoveMemory(pCredential->SSID.Ssid, pAd->ApCfg.ApCliTab[apidx].Ssid, pAd->ApCfg.ApCliTab[apidx].SsidLen);
+common/wsc.c:			pCredential->SSID.SsidLength = pAd->ApCfg.ApCliTab[apidx].SsidLen;
+common/wsc.c:		if (pAd->StaCfg.BssType == BSS_INFRA)
+common/wsc.c:			NdisMoveMemory(pCredential->MacAddr, pAd->CommonCfg.Bssid, 6);
+common/wsc.c:			NdisMoveMemory(pCredential->MacAddr, pAd->CurrentAddress, 6);
+common/wsc.c:		NdisMoveMemory(pCredential->SSID.Ssid, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen);
+common/wsc.c:		pCredential->SSID.SsidLength = pAd->CommonCfg.SsidLen;
+common/wsc.c:		pApCliTab = &pAd->ApCfg.ApCliTab[CurApIdx];
+common/wsc.c:		NdisZeroMemory(pAd->P2pCfg.SSID, MAX_LEN_OF_SSID);
+common/wsc.c:		pAd->P2pCfg.SSIDLen = pCredential->SSID.SsidLength;
+common/wsc.c:		NdisMoveMemory(pAd->P2pCfg.SSID, pCredential->SSID.Ssid, pAd->P2pCfg.SSIDLen);
+common/wsc.c:    BOOLEAN apcliEn = pAd->ApCfg.ApCliTab[apidx].Enable;	
+common/wsc.c:                   pAd->ApCfg.ApCliTab[apidx].CurrentAddress, 
+common/wsc.c:		pAd->ApCfg.ApCliTab[apidx].Enable = FALSE;
+common/wsc.c:    pAd->ApCfg.ApCliTab[apidx].Enable = apcliEn;
+common/wsc.c:	memcpy(mac_addr, pAd->ApCfg.ApCliTab[apidx].CurrentAddress, MAC_ADDR_LEN);
+common/wsc.c:			pWpsCtrl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/wsc.c:			pWpsCtrl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/wsc.c:		pWpsCtrl = &pAd->StaCfg.WscControl;
+common/wsc.c:		StateMachinePerformAction(pAd, &pAd->Mlme.WscMachine, Elem, pAd->Mlme.WscMachine.CurrState);
+common/wsc.c:		StateMachinePerformAction(pAd, &pAd->Mlme.WscMachine, Elem, pAd->Mlme.WscMachine.CurrState);
+common/wsc.c:			StateMachinePerformAction(pAd, &pAd->Mlme.WscMachine, Elem, pAd->Mlme.WscMachine.CurrState);
+common/wsc.c:			StateMachinePerformAction(pAd, &pAd->Mlme.WscMachine, Elem, pAd->Mlme.WscMachine.CurrState);
+common/wsc.c:					StateMachinePerformAction(pAd, &pAd->Mlme.WscMachine, Elem, pAd->Mlme.WscMachine.CurrState);
+common/wsc.c: 					StateMachinePerformAction(pAd, &pAd->Mlme.WscMachine, Elem, pAd->Mlme.WscMachine.CurrState);
+common/wsc.c:						StateMachinePerformAction(pAd, &pAd->Mlme.WscMachine, Elem, pAd->Mlme.WscMachine.CurrState);
+common/wsc.c:				StateMachinePerformAction(pAd, &pAd->Mlme.WscMachine, Elem, pAd->Mlme.WscMachine.CurrState);
+common/wsc.c:					StateMachinePerformAction(pAd, &pAd->Mlme.WscMachine, Elem, pAd->Mlme.WscMachine.CurrState);
+common/wsc.c:						StateMachinePerformAction(pAd, &pAd->Mlme.WscMachine, Elem, pAd->Mlme.WscMachine.CurrState);
+common/wsc.c:		WscSendUPnPConfReqMsg(pAd, apIdx, (PUCHAR)pAd->ApCfg.MBSSID[apIdx].Ssid, 
+common/wsc.c:									pAd->ApCfg.MBSSID[apIdx].Bssid, 3, 0, AP_MODE);
+common/wsc.c:		DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
+common/wsc.c:		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+common/wsc.c:		pAd->MlmeAux.CurrReqIsFromNdis = TRUE;
+common/wsc.c:	if (pAd->StaCfg.WscControl.WscConfMode != WSC_DISABLE)
+common/wsc.c:		if (pAd->StaCfg.BssType == BSS_ADHOC)
+common/wsc.c:			pAd->StaCfg.IWscInfo.bSendEapolStart = FALSE;
+common/wsc.c:			pAd->StaCfg.WscControl.WscState = WSC_STATE_LINK_UP;
+common/wsc.c:			pAd->StaCfg.WscControl.WscStatus = STATUS_WSC_LINK_UP;
+common/wsc.c:			WscSendEapolStart(pAd, pAd->StaCfg.WscControl.WscPeerMAC, STA_MODE);
+common/wsc.c:		pAd->StaCfg.WscControl.WscState = WSC_STATE_START;
+common/wsc.c:		pAd->bConfigChanged = TRUE;
+common/wsc.c:		pAd->StaCfg.WscControl.bWscTrigger = FALSE;
+common/wsc.c:		if (pAd->StaCfg.BssType == BSS_INFRA)
+common/wsc.c:			BssTableDeleteEntry(&pAd->ScanTab, pAd->CommonCfg.Bssid, pAd->CommonCfg.Channel);
+common/wsc.c:			pAd->MlmeAux.SsidBssTab.BssNr = 0;
+common/wsc.c:						pAd->MlmeAux.Bssid, 0);
+common/wsc.c:			if (pAd->StaCfg.IWscInfo.bReStart)
+common/wsc.c:				pAd->StaCfg.bNotFirstScan = FALSE;
+common/wsc.c:				pAd->StaCfg.bAutoConnectByBssid = FALSE;
+common/wsc.c:				pAd->StaCfg.IWscInfo.bReStart = FALSE;
+common/wsc.c:				pAd->StaCfg.IWscInfo.bDoNotChangeBSSID = TRUE;
+common/wsc.c:	            pAd->ExtraInfo = GENERAL_LINK_DOWN;
+common/wsc.c:				if (pAd->StaCfg.WscControl.WscStatus != STATUS_WSC_CONFIGURED)
+common/wsc.c:					Ssid.SsidLength = pAd->CommonCfg.SsidLen;
+common/wsc.c:					NdisMoveMemory(Ssid.Ssid, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen);
+common/wsc.c:					Ssid.SsidLength = pAd->MlmeAux.SsidLen;
+common/wsc.c:					NdisMoveMemory(Ssid.Ssid, pAd->MlmeAux.Ssid, Ssid.SsidLength);
+common/wsc.c:	pAd->StaCfg.WscControl.RegData.ReComputePke = 1;
+common/wsc.c:	PWSC_CTRL	pWscControl = &pAd->StaCfg.WscControl;
+common/wsc.c:	for (i = 0; i < pAd->ScanTab.BssNr; i++) 
+common/wsc.c:		pBss = &pAd->ScanTab.BssEntry[i];
+common/wsc.c:	PWSC_STA_PBC_PROBE_INFO	pWscStaPbcProbeInfo = &pAd->CommonCfg.WscStaPbcProbeInfo;
+common/wsc.c:	pAd->CommonCfg.WscPBCOverlap = FALSE;
+common/wsc.c:			pAd->CommonCfg.WscPBCOverlap = TRUE;
+common/wsc.c:	PWSC_STA_PBC_PROBE_INFO	pWscStaPbcProbeInfo = &pAd->CommonCfg.WscStaPbcProbeInfo;
+common/wsc.c:	UCHAR			apidx = (pAd->WriteWscCfgToDatFile & 0x0F);
+common/wsc.c:		if (apidx > pAd->ApCfg.BssidNum)
+common/wsc.c:		pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/wsc.c:		snprintf((PSTRING) WepKeyName, sizeof(WepKeyName), "Key%dStr%d=", pAd->ApCfg.MBSSID[apidx].DefaultKeyId+1, apidx+1);
+common/wsc.c:		snprintf((PSTRING) WepKeyFormatName, sizeof(WepKeyFormatName), "Key%dType=", pAd->ApCfg.MBSSID[apidx].DefaultKeyId+1);
+common/wsc.c:		pWscControl = &pAd->StaCfg.WscControl;
+common/wsc.c:		snprintf(WepKeyName, sizeof(WepKeyName), "Key%dStr=", pAd->StaCfg.DefaultKeyId+1);
+common/wsc.c:		snprintf(WepKeyFormatName, sizeof(WepKeyFormatName), "Key%dType=", pAd->StaCfg.DefaultKeyId+1);
+common/wsc.c:					if (pAd->StaCfg.BssType == BSS_ADHOC)
+common/wsc.c:						for (index = 0; index < pAd->ApCfg.BssidNum; index++)
+common/wsc.c:							if (pAd->ApCfg.MBSSID[index].SsidLen)
+common/wsc.c:									snprintf(pTempStr, 512, "%s%s", pTempStr, RTMPGetRalinkAuthModeStr(pAd->ApCfg.MBSSID[index].AuthMode));
+common/wsc.c:									snprintf(pTempStr, 512, "%s;%s", pTempStr, RTMPGetRalinkAuthModeStr(pAd->ApCfg.MBSSID[index].AuthMode));
+common/wsc.c:						USHORT auth_flag = WscGetAuthType(pAd->StaCfg.AuthMode);
+common/wsc.c:						for (index = 0; index < pAd->ApCfg.BssidNum; index++)
+common/wsc.c:								snprintf(pTempStr, 512, "%s%s", pTempStr, RTMPGetRalinkEncryModeStr(pAd->ApCfg.MBSSID[index].WepStatus));
+common/wsc.c:								snprintf(pTempStr, 512, "%s;%s", pTempStr, RTMPGetRalinkEncryModeStr(pAd->ApCfg.MBSSID[index].WepStatus));
+common/wsc.c:						USHORT encrypt_flag = WscGetEncryType(pAd->StaCfg.WepStatus);
+common/wsc.c:						for (index = 0; index < pAd->ApCfg.BssidNum; index++)
+common/wsc.c:							pWscControl = &pAd->ApCfg.MBSSID[index].WscControl;
+common/wsc.c:						for (index = 0; index < pAd->ApCfg.BssidNum; index++)
+common/wsc.c:							pWscControl = &pAd->ApCfg.MBSSID[index].WscControl;
+common/wsc.c:						for (index = 0; index < pAd->ApCfg.BssidNum; index++)
+common/wsc.c:								snprintf(pTempStr, 512, "%s%d", pTempStr, pAd->ApCfg.MBSSID[index].DefaultKeyId+1);
+common/wsc.c:								snprintf(pTempStr, 512, "%s;%d", pTempStr, pAd->ApCfg.MBSSID[index].DefaultKeyId+1);
+common/wsc.c:						snprintf(pTempStr, 512, "%s%d", pTempStr, pAd->StaCfg.DefaultKeyId+1);
+common/wsc.c:					pCredentail = &pAd->ApCfg.MBSSID[apidx].WscControl.WscProfile.Profile[0];
+common/wsc.c:					if (pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11WEPEnabled)
+common/wsc.c:						for (idx = 0; idx < pAd->ApCfg.BssidNum; idx++)
+common/wsc.c:							if (apidx < (pAd->ApCfg.BssidNum - 1))
+common/wsc.c:					pCredentail = &pAd->ApCfg.MBSSID[apidx].WscControl.WscProfile.Profile[0];
+common/wsc.c:					if (pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11WEPEnabled)
+common/wsc.c:					if (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled)                           
+common/wsc.c:					if (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled)                           
+common/wsc.c:		pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/wsc.c:		snprintf((PSTRING) WepKeyName, sizeof(WepKeyName), "Key%dStr1=", pAd->ApCfg.MBSSID[MAIN_MBSSID].DefaultKeyId+1);
+common/wsc.c:		snprintf((PSTRING) WepKeyFormatName, sizeof(WepKeyFormatName), "Key%dType=", pAd->ApCfg.MBSSID[MAIN_MBSSID].DefaultKeyId+1);
+common/wsc.c:					for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/wsc.c:							NdisMoveMemory(pTempStr + offset, pAd->ApCfg.MBSSID[apidx].Ssid, pAd->ApCfg.MBSSID[apidx].SsidLen);
+common/wsc.c:							offset += pAd->ApCfg.MBSSID[apidx].SsidLen;
+common/wsc.c:						for (index = 0; index < pAd->ApCfg.BssidNum; index++)
+common/wsc.c:							if (pAd->ApCfg.MBSSID[index].SsidLen)
+common/wsc.c:									snprintf(pTempStr, 512, "%s%s", pTempStr, RTMPGetRalinkAuthModeStr(pAd->ApCfg.MBSSID[index].AuthMode));
+common/wsc.c:									snprintf(pTempStr, 512, "%s;%s", pTempStr, RTMPGetRalinkAuthModeStr(pAd->ApCfg.MBSSID[index].AuthMode));
+common/wsc.c:						for (index = 0; index < pAd->ApCfg.BssidNum; index++)
+common/wsc.c:								snprintf(pTempStr, 512, "%s%s", pTempStr, RTMPGetRalinkEncryModeStr(pAd->ApCfg.MBSSID[index].WepStatus));
+common/wsc.c:								snprintf(pTempStr, 512, "%s;%s", pTempStr, RTMPGetRalinkEncryModeStr(pAd->ApCfg.MBSSID[index].WepStatus));
+common/wsc.c:						for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/wsc.c:								pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/wsc.c:						for (index = 0; index < pAd->ApCfg.BssidNum; index++)
+common/wsc.c:							pWscControl = &pAd->ApCfg.MBSSID[index].WscControl;
+common/wsc.c:						for (index = 0; index < pAd->ApCfg.BssidNum; index++)
+common/wsc.c:							pWscControl = &pAd->ApCfg.MBSSID[index].WscControl;
+common/wsc.c:						for (index = 0; index < pAd->ApCfg.BssidNum; index++)
+common/wsc.c:							pWscControl = &pAd->ApCfg.MBSSID[index].WscControl;
+common/wsc.c:								snprintf(pTempStr, 512, "%s%d", pTempStr, pAd->ApCfg.MBSSID[apidx].DefaultKeyId+1);
+common/wsc.c:								snprintf(pTempStr, 512, "%s;%d", pTempStr, pAd->ApCfg.MBSSID[apidx].DefaultKeyId+1);
+common/wsc.c:								for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/wsc.c:									if (pAd->ApCfg.MBSSID[MAIN_MBSSID].WepStatus == Ndis802_11WEPEnabled)  
+common/wsc.c:										pCredentail = &pAd->ApCfg.MBSSID[apidx].WscControl.WscProfile.Profile[0];
+common/wsc.c:									if (apidx < (pAd->ApCfg.BssidNum - 1))
+common/wsc.c:								for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/wsc.c:									pCredentail = &pAd->ApCfg.MBSSID[apidx].WscControl.WscProfile.Profile[0];
+common/wsc.c:									if (apidx < (pAd->ApCfg.BssidNum - 1))
+common/wsc.c:							for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/wsc.c:								if ((pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11WEPEnabled))
+common/wsc.c:									pCredentail = &pAd->ApCfg.MBSSID[apidx].WscControl.WscProfile.Profile[0];
+common/wsc.c:		if (pAd->pWscElme && (pAd->pWscElme->MsgLen != 0))
+common/wsc.c:				RTMP_SEM_LOCK(&pAd->WscElmeLock);
+common/wsc.c:				NdisMoveMemory(pElme, pAd->pWscElme, sizeof(MLME_QUEUE_ELEM));
+common/wsc.c:				pAd->pWscElme->MsgLen = 0;
+common/wsc.c:				NdisZeroMemory(pAd->pWscElme->Msg, MGMT_DMA_BUFFER_SIZE);
+common/wsc.c:				RTMP_SEM_UNLOCK(&pAd->WscElmeLock);
+common/wsc.c:		if (pAd->WriteWscCfgToDatFile != 0xFF)
+common/wsc.c:			if (pAd->WriteWscCfgToDatFile != BSS0)
+common/wsc.c:			pAd->WriteWscCfgToDatFile = 0xFF;
+common/wsc.c:	ret = RtmpOSTaskKill(&pAd->wscTask);
+common/wsc.c:	if (pAd->pHmacData)
+common/wsc.c:		os_free_mem(NULL, pAd->pHmacData);
+common/wsc.c:		pAd->pHmacData = NULL;
+common/wsc.c:	if (pAd->pWscElme)
+common/wsc.c:		os_free_mem(NULL, pAd->pWscElme);
+common/wsc.c:		pAd->pWscElme = NULL;
+common/wsc.c:	NdisFreeSpinLock(&pAd->WscElmeLock);
+common/wsc.c:	if ((pAd->OpMode == OPMODE_AP)
+common/wsc.c:			PWSC_CTRL	pWpsCtrl = &pAd->ApCfg.MBSSID[ap_idx].WscControl;
+common/wsc.c:			WscStop(pAd, TRUE, &pAd->ApCfg.ApCliTab[BSS0].WscControl);
+common/wsc.c:				PWSC_CTRL       pWpsCtrl = &pAd->ApCfg.ApCliTab[index].WscControl;
+common/wsc.c:				&pAd->StaCfg.WscControl);
+common/wsc.c:		pAd->StaCfg.WscControl.WscRxBufLen = 0;
+common/wsc.c:		if (pAd->StaCfg.WscControl.pWscRxBuf)
+common/wsc.c:			os_free_mem(pAd, pAd->StaCfg.WscControl.pWscRxBuf);
+common/wsc.c:			pAd->StaCfg.WscControl.pWscRxBuf = NULL;
+common/wsc.c:		pAd->StaCfg.WscControl.WscTxBufLen = 0;
+common/wsc.c:		if (pAd->StaCfg.WscControl.pWscTxBuf)
+common/wsc.c:			os_free_mem(pAd, pAd->StaCfg.WscControl.pWscTxBuf);
+common/wsc.c:			pAd->StaCfg.WscControl.pWscTxBuf = NULL;
+common/wsc.c:		WscClearPeerList(&pAd->StaCfg.WscControl.WscPeerList);
+common/wsc.c:		NdisFreeSpinLock(&pAd->StaCfg.WscControl.WscPeerListSemLock);
+common/wsc.c:		WscClearPeerList(&pAd->StaCfg.WscControl.WscConfiguredPeerList);
+common/wsc.c:		NdisFreeSpinLock(&pAd->StaCfg.WscControl.WscConfiguredPeerListSemLock);
+common/wsc.c:	pTask = &pAd->wscTask;
+common/wsc.c:	status = RtmpOSTaskAttach(pTask, wsc_write_dat_file_thread, (ULONG)&pAd->wscTask);
+common/wsc.c:		os_alloc_mem(NULL, &pAd->pHmacData, sizeof(CHAR)*(2048));
+common/wsc.c:		if (pAd->pHmacData == NULL)
+common/wsc.c:		NdisAllocateSpinLock(pAd, &pAd->WscElmeLock);
+common/wsc.c:		os_alloc_mem(NULL, (UCHAR **)&pAd->pWscElme, sizeof(MLME_QUEUE_ELEM));
+common/wsc.c:	pAd->CommonCfg.WscHdrPshBtnCheckCount = 0;
+common/wsc.c:	pAd->CommonCfg.WscHdrPshBtnCheckCount = 0;
+common/wsc.c: 	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/wsc.c:		if (pAd->CommonCfg.WscHdrPshBtnCheckCount == WSC_HDR_BTN_CONT_TIMES)
+common/wsc.c:			pAd->CommonCfg.WscHdrPshBtnCheckCount = 0;
+common/wsc.c:		pAd->CommonCfg.WscHdrPshBtnCheckCount ++;
+common/wsc.c:		pAd->CommonCfg.WscHdrPshBtnCheckCount = 0;		
+common/wsc.c:	pMbss = &pAd->ApCfg.MBSSID[pWscControl->EntryIfIdx & 0x0F];
+common/wsc.c:		pAd->WriteWscCfgToDatFile = (pWscControl->EntryIfIdx & 0x0F);
+common/wsc.c:/*	WAKE_UP(&(pAd->wscTask)); */
+common/wsc.c:/*	RTMP_SEM_EVENT_UP(&(pAd->wscTask.taskSema)); */
+common/wsc.c:	RtmpOsTaskWakeUp(&(pAd->wscTask));
+common/wsc.c:				if ((pAd->OpMode == OPMODE_AP)
+common/wsc.c:					for (ap_idx = 0; ap_idx < pAd->ApCfg.BssidNum; ap_idx++)
+common/wsc.c:						if (NdisEqualMemory(Fr->Hdr.Addr1, pAd->ApCfg.MBSSID[ap_idx].Bssid, MAC_ADDR_LEN))
+common/wsc.c:					if (ap_idx >= pAd->ApCfg.BssidNum)
+common/wsc.c:					pWscCtrl = &pAd->ApCfg.MBSSID[ap_idx].WscControl;
+common/wsc.c:		if (pAd->StaCfg.BssType == BSS_ADHOC)
+common/wsc.c:			pWscCtrl = &pAd->StaCfg.WscControl;
+common/wsc.c:	for (ApIdx = 0; ApIdx < pAd->ApCfg.BssidNum; ApIdx++)
+common/wsc.c:		pWscControl = &pAd->ApCfg.MBSSID[ApIdx].WscControl;
+common/wsc.c:	pWscControl = &pAd->StaCfg.WscControl;
+common/frq_cal.c:	if (pAd->FreqCalibrationCtrl.bEnableFrequencyCalibration == TRUE)
+common/frq_cal.c:		InitFrequencyCalibrationMode(pAd, pAd->chipCap.FreqCalInitMode);
+common/frq_cal.c:			pAd->RfFreqOffset, pAd->RfFreqOffset));
+common/frq_cal.c:	if (pAd->FreqCalibrationCtrl.bEnableFrequencyCalibration == TRUE)
+common/frq_cal.c:			pAd->FreqCalibrationCtrl.AdaptiveFreqOffset = pAd->RfFreqOffset;	/* AdaptiveFreqOffset= RF_R12[7:0] */
+common/frq_cal.c:		pAd->FreqCalibrationCtrl.AdaptiveFreqOffset = (0x7F & ((CHAR)(pAd->RfFreqOffset))); /* C1 value control - Crystal calibration*/
+common/frq_cal.c:		pAd->FreqCalibrationCtrl.LatestFreqOffsetOverBeacon = INVALID_FREQUENCY_OFFSET;
+common/frq_cal.c:		pAd->FreqCalibrationCtrl.bSkipFirstFrequencyCalibration = TRUE;
+common/frq_cal.c:		DBGPRINT(RT_DEBUG_TRACE, ("%s: pAd->FreqCalibrationCtrl.AdaptiveFreqOffset = 0x%X\n", 
+common/frq_cal.c:			pAd->FreqCalibrationCtrl.AdaptiveFreqOffset));
+common/frq_cal.c:		rlt_rf_write(pAd, RF_BANK0, RF_R12, pAd->FreqCalibrationCtrl.AdaptiveFreqOffset);
+common/frq_cal.c:	if ((pAd->FreqCalibrationCtrl.bEnableFrequencyCalibration == TRUE) && 
+common/frq_cal.c:	     (((pAd->FreqCalibrationCtrl.bApproachFrequency == FALSE) && ((pAd->Mlme.PeriodicRound % FREQUENCY_CALIBRATION_PERIOD) == 0)) || 
+common/frq_cal.c:	       ((pAd->FreqCalibrationCtrl.bApproachFrequency == TRUE) && ((pAd->Mlme.PeriodicRound % (FREQUENCY_CALIBRATION_PERIOD / 20)) == 0))))
+common/frq_cal.c:		if (pAd->FreqCalibrationCtrl.bSkipFirstFrequencyCalibration == TRUE)
+common/frq_cal.c:			pAd->FreqCalibrationCtrl.bSkipFirstFrequencyCalibration = FALSE;
+common/frq_cal.c:			if (pAd->FreqCalibrationCtrl.LatestFreqOffsetOverBeacon != INVALID_FREQUENCY_OFFSET)
+common/frq_cal.c:				if (pAd->FreqCalibrationCtrl.BeaconPhyMode == MODE_CCK) /* CCK*/
+common/frq_cal.c:				if ((pAd->FreqCalibrationCtrl.LatestFreqOffsetOverBeacon >= HighFreqTriggerPoint) || 
+common/frq_cal.c:				     (pAd->FreqCalibrationCtrl.LatestFreqOffsetOverBeacon <= LowFreqTriggerPoint))
+common/frq_cal.c:					pAd->FreqCalibrationCtrl.bApproachFrequency = TRUE;
+common/frq_cal.c:				if (pAd->FreqCalibrationCtrl.bApproachFrequency == TRUE)
+common/frq_cal.c:					if ((pAd->FreqCalibrationCtrl.LatestFreqOffsetOverBeacon <= DecreaseFreqOffset) && 
+common/frq_cal.c:					      (pAd->FreqCalibrationCtrl.LatestFreqOffsetOverBeacon >= IncreaseFreqOffset))
+common/frq_cal.c:						pAd->FreqCalibrationCtrl.bApproachFrequency = FALSE; /* Stop approaching frquency if -10 < reported frequency offset < 10*/
+common/frq_cal.c:					else if (pAd->FreqCalibrationCtrl.LatestFreqOffsetOverBeacon > DecreaseFreqOffset)
+common/frq_cal.c:						pAd->FreqCalibrationCtrl.AdaptiveFreqOffset--;
+common/frq_cal.c:						DBGPRINT(RT_DEBUG_TRACE, ("%s: -- frequency offset = 0x%X\n", __FUNCTION__, pAd->FreqCalibrationCtrl.AdaptiveFreqOffset));
+common/frq_cal.c:						FrequencyCalibrationMode(pAd, pAd->chipCap.FreqCalMode);
+common/frq_cal.c:					else if (pAd->FreqCalibrationCtrl.LatestFreqOffsetOverBeacon < IncreaseFreqOffset)
+common/frq_cal.c:						pAd->FreqCalibrationCtrl.AdaptiveFreqOffset++;
+common/frq_cal.c:						DBGPRINT(RT_DEBUG_TRACE, ("%s: ++ frequency offset = 0x%X\n", __FUNCTION__, pAd->FreqCalibrationCtrl.AdaptiveFreqOffset));
+common/frq_cal.c:						FrequencyCalibrationMode(pAd, pAd->chipCap.FreqCalMode);
+common/frq_cal.c:					pAd->FreqCalibrationCtrl.AdaptiveFreqOffset, 
+common/frq_cal.c:					pAd->FreqCalibrationCtrl.LatestFreqOffsetOverBeacon, 
+common/frq_cal.c:					pAd->FreqCalibrationCtrl.bApproachFrequency));
+common/frq_cal.c:	if (pAd->FreqCalibrationCtrl.bEnableFrequencyCalibration)
+common/frq_cal.c:		FreqOffset = GetFrequencyOffsetField(pAd, pRxWI, pAd->chipCap.RxWIFrqOffset);
+Binary file common/rtmp_init.o matches
+Binary file common/cmm_profile.o matches
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_CountryRegion_Proc::(CountryRegion=%d)\n", pAd->CommonCfg.CountryRegion));
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_CountryRegionABand_Proc::(CountryRegion=%d)\n", pAd->CommonCfg.CountryRegionForABand));
+common/cmm_info.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_info.c:		pAd->ApCfg.MBSSID[pObj->ioctl_if].PhyMode = 
+common/cmm_info.c:			for(i=0; i<pAd->ApCfg.BssidNum; i++)
+common/cmm_info.c:				pAd->ApCfg.MBSSID[i].bWmmCapable = \
+common/cmm_info.c:										pAd->ApCfg.MBSSID[i].bWmmCapableOrg;
+common/cmm_info.c:					pAd->ApCfg.MBSSID[i].PhyMode = pAd->CommonCfg.PhyMode;
+common/cmm_info.c:			RTMPSetPhyMode(pAd, pAd->CommonCfg.PhyMode);
+common/cmm_info.c:			BssTableInit(&pAd->ScanTab);
+common/cmm_info.c:			pAd->StaCfg.LastScanTime = 0;
+common/cmm_info.c:			RTMPSetPhyMode(pAd, pAd->CommonCfg.PhyMode);
+common/cmm_info.c:			if (pAd->StaCfg.BssType == BSS_ADHOC)
+common/cmm_info.c:		DBGPRINT(RT_DEBUG_TRACE, ("Set_Cmm_WirelessMode_Proc::(=%d)\n", pAd->CommonCfg.PhyMode));
+common/cmm_info.c:				pObj->ioctl_if, pAd->ApCfg.MBSSID[pObj->ioctl_if].PhyMode));
+common/cmm_info.c:		for(i=0; i<pAd->ApCfg.BssidNum; i++)
+common/cmm_info.c:			pAd->CommonCfg.Channel = Channel;
+common/cmm_info.c:			pAd->MlmeAux.Channel = Channel;
+common/cmm_info.c:				if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) &&
+common/cmm_info.c:					pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)
+common/cmm_info.c:					rf_channel = N_SetCenCh(pAd, pAd->CommonCfg.Channel);
+common/cmm_info.c:					rf_channel = pAd->CommonCfg.Channel;
+common/cmm_info.c:							__FUNCTION__, pAd->CommonCfg.Channel,
+common/cmm_info.c:							pAd->CommonCfg.CentralChannel));
+common/cmm_info.c:		if ((WMODE_CAP_5G(pAd->CommonCfg.PhyMode))
+common/cmm_info.c:			&& (pAd->CommonCfg.bIEEE80211H == TRUE))
+common/cmm_info.c:			for (i = 0; i < pAd->ChannelListNum; i++)
+common/cmm_info.c:				if (pAd->ChannelList[i].Channel == Channel)
+common/cmm_info.c:					if (pAd->ChannelList[i].RemainingTimeForUse > 0)
+common/cmm_info.c:								pAd->ChannelList[i].RemainingTimeForUse, Channel));
+common/cmm_info.c:			pAd->CommonCfg.Channel = Channel;
+common/cmm_info.c:			if ((pAd->CommonCfg.Channel > 14 )
+common/cmm_info.c:				&& (pAd->CommonCfg.bIEEE80211H == TRUE))
+common/cmm_info.c:				if (pAd->Dot11_H.RDMode == RD_SILENCE_MODE)
+common/cmm_info.c:					NotifyChSwAnnToPeerAPs(pAd, ZERO_MAC_ADDR, pAd->CurrentAddress, 1, pAd->CommonCfg.Channel);
+common/cmm_info.c:					pAd->Dot11_H.RDMode = RD_SWITCHING_MODE;
+common/cmm_info.c:					pAd->Dot11_H.CSCount = 0;
+common/cmm_info.c:		DBGPRINT(RT_DEBUG_TRACE, ("Set_Channel_Proc::(Channel=%d)\n", pAd->CommonCfg.Channel));
+common/cmm_info.c:		DBGPRINT(RT_DEBUG_TRACE, ("Set_ShortSlot_Proc::(ShortSlot=%d)\n", pAd->CommonCfg.bUseShortSlotTime));
+common/cmm_info.c:			pAd->CommonCfg.TxPowerPercentage = TxPower;
+common/cmm_info.c:			pAd->CommonCfg.TxPowerDefault = TxPower;
+common/cmm_info.c:			pAd->CommonCfg.TxPowerPercentage = pAd->CommonCfg.TxPowerDefault;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_TxPower_Proc::(TxPowerPercentage=%ld)\n", pAd->CommonCfg.TxPowerPercentage));
+common/cmm_info.c:			pAd->CommonCfg.UseBGProtection = 0;
+common/cmm_info.c:			pAd->CommonCfg.UseBGProtection = 1;
+common/cmm_info.c:			pAd->CommonCfg.UseBGProtection = 2;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_BGProtection_Proc::(BGProtection=%ld)\n", pAd->CommonCfg.UseBGProtection));	
+common/cmm_info.c:			pAd->CommonCfg.TxPreamble = Preamble;
+common/cmm_info.c:			pAd->CommonCfg.TxPreamble = Preamble;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_TxPreamble_Proc::(TxPreamble=%ld)\n", pAd->CommonCfg.TxPreamble));
+common/cmm_info.c:		pAd->CommonCfg.RtsThreshold  = (USHORT)RtsThresh;
+common/cmm_info.c:		pAd->CommonCfg.RtsThreshold = MAX_RTS_THRESHOLD;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_RTSThreshold_Proc::(RTSThreshold=%d)\n", pAd->CommonCfg.RtsThreshold));
+common/cmm_info.c:		pAd->CommonCfg.FragmentThreshold = MAX_FRAG_THRESHOLD;
+common/cmm_info.c:		pAd->CommonCfg.FragmentThreshold = (USHORT)(FragThresh - 1);
+common/cmm_info.c:		pAd->CommonCfg.FragmentThreshold = (USHORT)FragThresh;
+common/cmm_info.c:		if (pAd->CommonCfg.FragmentThreshold == MAX_FRAG_THRESHOLD)
+common/cmm_info.c:			pAd->CommonCfg.bUseZeroToDisableFragment = TRUE;
+common/cmm_info.c:			pAd->CommonCfg.bUseZeroToDisableFragment = FALSE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_FragThreshold_Proc::(FragThreshold=%d)\n", pAd->CommonCfg.FragmentThreshold));
+common/cmm_info.c:		pAd->CommonCfg.bEnableTxBurst = TRUE;
+common/cmm_info.c:		pAd->CommonCfg.bEnableTxBurst = FALSE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_TxBurst_Proc::(TxBurst=%d)\n", pAd->CommonCfg.bEnableTxBurst));
+common/cmm_info.c:		pAd->CommonCfg.bAggregationCapable = TRUE;
+common/cmm_info.c:		pAd->CommonCfg.bAggregationCapable = FALSE;
+common/cmm_info.c:		pAd->CommonCfg.bPiggyBackCapable = pAd->CommonCfg.bAggregationCapable;
+common/cmm_info.c:		RTMPSetPiggyBack(pAd, pAd->CommonCfg.bPiggyBackCapable);
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_PktAggregate_Proc::(AGGRE=%d)\n", pAd->CommonCfg.bAggregationCapable));
+common/cmm_info.c:		if(pAd->PPAEnable==TRUE)
+common/cmm_info.c:				if (pAd->pDirectpathCb == NULL) 
+common/cmm_info.c:/*					pAd->pDirectpathCb = (PPA_DIRECTPATH_CB *) kmalloc (sizeof(PPA_DIRECTPATH_CB), GFP_ATOMIC);*/
+common/cmm_info.c:					os_alloc_mem(NULL, (UCHAR **)&(pAd->pDirectpathCb), sizeof(PPA_DIRECTPATH_CB));
+common/cmm_info.c:				pAd->pDirectpathCb->rx_fn = ifx_ra_start_xmit;
+common/cmm_info.c:				pAd->pDirectpathCb->stop_tx_fn = NULL;
+common/cmm_info.c:				pAd->pDirectpathCb->start_tx_fn = NULL;
+common/cmm_info.c:				status = ppa_hook_directpath_register_dev_fn(&g_if_id, pAd->net_dev, pAd->pDirectpathCb, PPA_F_DIRECTPATH_REGISTER|PPA_F_DIRECTPATH_ETH_IF);
+common/cmm_info.c:					pAd->g_if_id=g_if_id;
+common/cmm_info.c:					DBGPRINT(RT_DEBUG_TRACE, ("register INF_AMAZON_SE_PPA success :ret:%d id:%d:%d\n",status,pAd->g_if_id,g_if_id));
+common/cmm_info.c:					pAd->PPAEnable=TRUE;
+common/cmm_info.c:		if(pAd->PPAEnable==FALSE)
+common/cmm_info.c:				g_if_id=pAd->g_if_id;
+common/cmm_info.c:				DBGPRINT(RT_DEBUG_TRACE, ("g_if_id=%d \n",pAd->g_if_id));
+common/cmm_info.c:				status=ppa_hook_directpath_register_dev_fn(&g_if_id, pAd->net_dev, NULL, 0/*PPA_F_DIRECTPATH_REGISTER*/);
+common/cmm_info.c:					pAd->g_if_id=0;
+common/cmm_info.c:					pAd->PPAEnable=FALSE;
+common/cmm_info.c:		pAd->CommonCfg.bIEEE80211H = TRUE;
+common/cmm_info.c:		pAd->CommonCfg.bIEEE80211H = FALSE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_IEEE80211H_Proc::(IEEE80211H=%d)\n", pAd->CommonCfg.bIEEE80211H));
+common/cmm_info.c:		NdisMoveMemory(pAd->CommonCfg.CountryCode, arg, 2);
+common/cmm_info.c:		pAd->CommonCfg.bCountryFlag = TRUE;
+common/cmm_info.c:		NdisZeroMemory(pAd->CommonCfg.CountryCode, 3);
+common/cmm_info.c:		pAd->CommonCfg.bCountryFlag = FALSE;
+common/cmm_info.c:		NdisMoveMemory(CountryCode, pAd->CommonCfg.CountryCode, 2);
+common/cmm_info.c:							pAd->CommonCfg.bCountryFlag,
+common/cmm_info.c:	UCHAR	*pDfsType = &pAd->CommonCfg.DfsType;
+common/cmm_info.c:			if (strncmp((PSTRING) ChRegion[loop].CountReg, pAd->CommonCfg.CountryCode, 2) == 0)
+common/cmm_info.c:		if (pAd->CommonCfg.pChDesp == NULL)
+common/cmm_info.c:			os_alloc_mem(pAd,  &pAd->CommonCfg.pChDesp, MAX_PRECONFIG_DESP_ENTRY_SIZE*sizeof(CH_DESP));
+common/cmm_info.c:			pChDesp = (PCH_DESP) pAd->CommonCfg.pChDesp;
+common/cmm_info.c:			pChDesp = (PCH_DESP) pAd->CommonCfg.pChDesp;
+common/cmm_info.c:		NdisMoveMemory(CountryCode, pAd->CommonCfg.CountryCode, 2);
+common/cmm_info.c:			if (strncmp((PSTRING) ChRegion[loop].CountReg, pAd->CommonCfg.CountryCode, 2) == 0)
+common/cmm_info.c:	NdisMoveMemory(CountryCode, pAd->CommonCfg.CountryCode, 2);
+common/cmm_info.c:	if (pAd->CommonCfg.DfsType == MAX_RD_REGION)
+common/cmm_info.c:		pAd->CommonCfg.DfsType = pChRegion->DfsType;
+common/cmm_info.c:					(pAd->CommonCfg.DfsType == JAP) ? "JAP" :
+common/cmm_info.c:					((pAd->CommonCfg.DfsType == FCC) ? "FCC" : "CE" )));
+common/cmm_info.c:	if (pAd->CommonCfg.pChDesp != NULL)
+common/cmm_info.c:		PCH_DESP pChDesp = (PCH_DESP) pAd->CommonCfg.pChDesp;
+common/cmm_info.c:			if (strncmp((PSTRING) ChRegion[loop].CountReg, pAd->CommonCfg.CountryCode, 2) == 0)
+common/cmm_info.c:	if (pAd->CommonCfg.pChDesp == NULL)
+common/cmm_info.c:		os_alloc_mem(pAd,  &pAd->CommonCfg.pChDesp, MAX_PRECONFIG_DESP_ENTRY_SIZE*sizeof(CH_DESP));
+common/cmm_info.c:		if (pAd->CommonCfg.pChDesp)
+common/cmm_info.c:			pChDesp = (PCH_DESP) pAd->CommonCfg.pChDesp;
+common/cmm_info.c:		pChDesp = (PCH_DESP) pAd->CommonCfg.pChDesp;
+common/cmm_info.c:		if (pAd->CommonCfg.pChDesp != NULL)
+common/cmm_info.c:			os_free_mem(NULL, pAd->CommonCfg.pChDesp);
+common/cmm_info.c:		pAd->CommonCfg.pChDesp = NULL;
+common/cmm_info.c:		pAd->CommonCfg.DfsType = MAX_RD_REGION;
+common/cmm_info.c:    POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_info.c:	        pWscControl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/cmm_info.c:			pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/cmm_info.c:			pWscControl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/cmm_info.c:    	pWscControl = &pAd->StaCfg.WscControl;
+common/cmm_info.c:		PWSC_CTRL   pApWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/cmm_info.c:	POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_info.c:/*	POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;*/
+common/cmm_info.c:			pWscControl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/cmm_info.c:			pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/cmm_info.c:		pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/cmm_info.c:		pWscControl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/cmm_info.c: 		pWscControl = &pAd->StaCfg.WscControl;
+common/cmm_info.c:	NdisZeroMemory(&pAd->WlanCounters, sizeof(COUNTER_802_11));
+common/cmm_info.c:	NdisZeroMemory(&pAd->Counters8023, sizeof(COUNTER_802_3));
+common/cmm_info.c:	NdisZeroMemory(&pAd->RalinkCounters, sizeof(COUNTER_RALINK));
+common/cmm_info.c:	if (pAd->chipCap.FlgHwTxBfCap)
+common/cmm_info.c:			NdisZeroMemory(&pAd->MacTab.Content[i].TxBFCounters, sizeof(pAd->MacTab.Content[i].TxBFCounters));
+common/cmm_info.c:	POS_COOKIE	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_info.c:				/*if (MAC_ADDR_EQUAL(pAd->ApCfg.ApCliTab[ifIndex].SharedKey[i].BssId, pKey->BSSID)) */
+common/cmm_info.c:					BssIdx = pAd->ApCfg.BssidNum + MAX_MESH_NUM + ifIndex;
+common/cmm_info.c:					pAd->ApCfg.ApCliTab[ifIndex].SharedKey[i].KeyLen = 0;
+common/cmm_info.c:					pAd->ApCfg.ApCliTab[ifIndex].SharedKey[i].CipherAlg = CIPHER_NONE;
+common/cmm_info.c:				if (MAC_ADDR_EQUAL(pAd->SharedKey[BSS0][i].BssId, pKey->BSSID))
+common/cmm_info.c:					pAd->SharedKey[BSS0][i].KeyLen = 0;
+common/cmm_info.c:					pAd->SharedKey[BSS0][i].CipherAlg = CIPHER_NONE;
+common/cmm_info.c:		pAd->SharedKey[BSS0][KeyIdx].KeyLen = 0;
+common/cmm_info.c:		pAd->SharedKey[BSS0][KeyIdx].CipherAlg = CIPHER_NONE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE,("RTMPWPARemoveAllKeys(AuthMode=%d, WepStatus=%d)\n", pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus));
+common/cmm_info.c:	if (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA)
+common/cmm_info.c:	if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
+common/cmm_info.c:		DBGPRINT(RT_DEBUG_TRACE,("remove %s key #%d\n", CipherName[pAd->SharedKey[BSS0][i].CipherAlg], i));
+common/cmm_info.c:		NdisZeroMemory(&pAd->SharedKey[BSS0][i], sizeof(CIPHER_KEY));  						
+common/cmm_info.c:	pAd->CommonCfg.PhyMode = (UCHAR)phymode;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE,("RTMPSetPhyMode : PhyMode=%d, channel=%d \n", pAd->CommonCfg.PhyMode, pAd->CommonCfg.Channel));
+common/cmm_info.c:	for (i = 0; i < pAd->ChannelListNum; i++)
+common/cmm_info.c:		if (pAd->CommonCfg.Channel == pAd->ChannelList[i].Channel)
+common/cmm_info.c:	if (i == pAd->ChannelListNum)
+common/cmm_info.c:		if (pAd->CommonCfg.Channel != 0)
+common/cmm_info.c:				pAd->CommonCfg.Channel = FirstChannel(pAd);
+common/cmm_info.c:			pAd->CommonCfg.Channel = FirstChannel(pAd);
+common/cmm_info.c:		DBGPRINT(RT_DEBUG_ERROR, ("RTMPSetPhyMode: channel is out of range, use first channel=%d \n", pAd->CommonCfg.Channel));
+common/cmm_info.c:	NdisZeroMemory(pAd->CommonCfg.SupRate, MAX_LEN_OF_SUPPORTED_RATES);
+common/cmm_info.c:	NdisZeroMemory(pAd->CommonCfg.ExtRate, MAX_LEN_OF_SUPPORTED_RATES);
+common/cmm_info.c:	NdisZeroMemory(pAd->CommonCfg.DesireRate, MAX_LEN_OF_SUPPORTED_RATES);
+common/cmm_info.c:			pAd->CommonCfg.SupRate[0]  = 0x82;	  /* 1 mbps, in units of 0.5 Mbps, basic rate*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[1]  = 0x84;	  /* 2 mbps, in units of 0.5 Mbps, basic rate*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[2]  = 0x8B;	  /* 5.5 mbps, in units of 0.5 Mbps, basic rate*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[3]  = 0x96;	  /* 11 mbps, in units of 0.5 Mbps, basic rate*/
+common/cmm_info.c:			pAd->CommonCfg.SupRateLen  = 4;
+common/cmm_info.c:			pAd->CommonCfg.ExtRateLen  = 0;
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[0]  = 2;	   /* 1 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[1]  = 4;	   /* 2 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[2]  = 11;    /* 5.5 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[3]  = 22;    /* 11 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			/*pAd->CommonCfg.HTPhyMode.field.MODE = MODE_CCK;  This MODE is only FYI. not use*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[0]  = 0x82;	  /* 1 mbps, in units of 0.5 Mbps, basic rate*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[1]  = 0x84;	  /* 2 mbps, in units of 0.5 Mbps, basic rate*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[2]  = 0x8B;	  /* 5.5 mbps, in units of 0.5 Mbps, basic rate*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[3]  = 0x96;	  /* 11 mbps, in units of 0.5 Mbps, basic rate*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[4]  = 0x12;	  /* 9 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[5]  = 0x24;	  /* 18 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[6]  = 0x48;	  /* 36 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[7]  = 0x6c;	  /* 54 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.SupRateLen  = 8;
+common/cmm_info.c:			pAd->CommonCfg.ExtRate[0]  = 0x0C;	  /* 6 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.ExtRate[1]  = 0x18;	  /* 12 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.ExtRate[2]  = 0x30;	  /* 24 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.ExtRate[3]  = 0x60;	  /* 48 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.ExtRateLen  = 4;
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[0]  = 2;	   /* 1 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[1]  = 4;	   /* 2 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[2]  = 11;    /* 5.5 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[3]  = 22;    /* 11 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[4]  = 12;    /* 6 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[5]  = 18;    /* 9 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[6]  = 24;    /* 12 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[7]  = 36;    /* 18 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[8]  = 48;    /* 24 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[9]  = 72;    /* 36 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[10] = 96;    /* 48 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[11] = 108;   /* 54 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[0]  = 0x8C;	  /* 6 mbps, in units of 0.5 Mbps, basic rate*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[1]  = 0x12;	  /* 9 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[2]  = 0x98;	  /* 12 mbps, in units of 0.5 Mbps, basic rate*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[3]  = 0x24;	  /* 18 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[4]  = 0xb0;	  /* 24 mbps, in units of 0.5 Mbps, basic rate*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[5]  = 0x48;	  /* 36 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[6]  = 0x60;	  /* 48 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.SupRate[7]  = 0x6c;	  /* 54 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.SupRateLen  = 8;
+common/cmm_info.c:			pAd->CommonCfg.ExtRateLen  = 0;
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[0]  = 12;    /* 6 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[1]  = 18;    /* 9 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[2]  = 24;    /* 12 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[3]  = 36;    /* 18 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[4]  = 48;    /* 24 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[5]  = 72;    /* 36 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[6]  = 96;    /* 48 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			pAd->CommonCfg.DesireRate[7]  = 108;   /* 54 mbps, in units of 0.5 Mbps*/
+common/cmm_info.c:			/*pAd->CommonCfg.HTPhyMode.field.MODE = MODE_OFDM;  This MODE is only FYI. not use*/
+common/cmm_info.c:		for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/cmm_info.c:		for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/cmm_info.c:				if (BssIdx >= pAd->ApCfg.BssidNum)
+common/cmm_info.c:			if ((BssIdx < pAd->ApCfg.BssidNum) && (BssIdx < MAX_MBSSID_NUM(pAd)) && (BssIdx < HW_BEACON_MAX_NUM))
+common/cmm_info.c:				IEEE8021X = pAd->ApCfg.MBSSID[BssIdx].IEEE8021X;
+common/cmm_info.c:		pEntry = &(pAd->MacTab.Content[i]);
+common/cmm_info.c:		PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[i];
+common/cmm_info.c:			sprintf(msg+strlen(msg),"%-6d",RateIdToMbps[pAd->MacTab.Content[i].CurrTxRate]);
+common/cmm_info.c:			sprintf(msg+strlen(msg),"%-6d",0/*RateIdToMbps[pAd->MacTab.Content[i].HTPhyMode.word]*/); /* ToDo*/
+common/cmm_info.c:			sprintf(msg+strlen(msg),"%-10d",0/*pAd->MacTab.Content[i].HSCounter.LastDataPacketTime*/); /* ToDo*/
+common/cmm_info.c:			sprintf(msg+strlen(msg),"%-10d",0/*pAd->MacTab.Content[i].HSCounter.TotalRxByteCount*/); /* ToDo*/
+common/cmm_info.c:			sprintf(msg+strlen(msg),"%-10d\n",0/*pAd->MacTab.Content[i].HSCounter.TotalTxByteCount*/); /* ToDo*/
+common/cmm_info.c:		PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[i];
+common/cmm_info.c:			sprintf(msg+strlen(msg),"%-6d",RateIdToMbps[pAd->MacTab.Content[i].CurrTxRate]);
+common/cmm_info.c:			sprintf(msg+strlen(msg),"%-6d",0/*RateIdToMbps[pAd->MacTab.Content[i].HTPhyMode.word]*/); /* ToDo*/
+common/cmm_info.c:			sprintf(msg+strlen(msg),"%-10d",0/*pAd->MacTab.Content[i].HSCounter.LastDataPacketTime*/); /* ToDo*/
+common/cmm_info.c:			sprintf(msg+strlen(msg),"%-10d",0/*pAd->MacTab.Content[i].HSCounter.TotalRxByteCount*/); /* ToDo*/
+common/cmm_info.c:			sprintf(msg+strlen(msg),"%-10d\n",0/*pAd->MacTab.Content[i].HSCounter.TotalTxByteCount*/); /* ToDo*/
+common/cmm_info.c:/*	msg = kmalloc(sizeof(CHAR)*(pAd->ApCfg.BssidNum*(14*128)), MEM_ALLOC_FLAG);*/
+common/cmm_info.c:	os_alloc_mem(NULL, (UCHAR **)&msg, sizeof(CHAR)*(pAd->ApCfg.BssidNum*(14*128)));
+common/cmm_info.c:	memset(msg, 0 ,pAd->ApCfg.BssidNum*(14*128));
+common/cmm_info.c:	for (apidx=0; apidx<pAd->ApCfg.BssidNum; apidx++)
+common/cmm_info.c:		pMbss=&pAd->ApCfg.MBSSID[apidx];
+common/cmm_info.c:		pMbss=&pAd->ApCfg.MBSSID[0];
+common/cmm_info.c:		if(pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40)
+common/cmm_info.c:		if(pAd->CommonCfg.RegTransmitSetting.field.ShortGI == GI_800)
+common/cmm_info.c:		sprintf(msg+strlen(msg),"channelsInUse = %d\n",pAd->ChannelListNum);
+common/cmm_info.c:		sprintf(msg+strlen(msg),"channel = %d\n",pAd->CommonCfg.Channel);
+common/cmm_info.c:		pAd->CommonCfg.bBADecline = FALSE;
+common/cmm_info.c:		pAd->CommonCfg.bBADecline = TRUE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_BADecline_Proc::(BADecline=%d)\n", pAd->CommonCfg.bBADecline));
+common/cmm_info.c:		pAd->CommonCfg.RegTransmitSetting.field.BW  = BW_40;
+common/cmm_info.c:		pAd->CommonCfg.RegTransmitSetting.field.BW  = BW_20;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_HtBw_Proc::(HtBw=%d)\n", pAd->CommonCfg.RegTransmitSetting.field.BW));
+common/cmm_info.c:    POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_info.c:	if (pAd->CommonCfg.TxStream >= 3)
+common/cmm_info.c:		pAd->ApCfg.MBSSID[pObj->ioctl_if].DesiredTransmitSetting.field.MCS = HtMcs;
+common/cmm_info.c:				pAd->ApCfg.MBSSID[pObj->ioctl_if].DesiredTransmitSetting.field.MCS, pObj->ioctl_if));
+common/cmm_info.c:		pAd->StaCfg.DesiredTransmitSetting.field.MCS = HtMcs;
+common/cmm_info.c:		pAd->StaCfg.bAutoTxRateSwitch = (HtMcs == MCS_AUTO) ? TRUE:FALSE;
+common/cmm_info.c:						pAd->StaCfg.DesiredTransmitSetting.field.MCS, pAd->StaCfg.bAutoTxRateSwitch));
+common/cmm_info.c:		if ((!WMODE_CAP_N(pAd->CommonCfg.PhyMode)) ||
+common/cmm_info.c:			(pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE < MODE_HTMIX))
+common/cmm_info.c:			if ((pAd->StaCfg.DesiredTransmitSetting.field.MCS != MCS_AUTO) && 
+common/cmm_info.c:				(pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode == FIXED_TXMODE_CCK))
+common/cmm_info.c:			else if ((pAd->StaCfg.DesiredTransmitSetting.field.MCS != MCS_AUTO) && 
+common/cmm_info.c:	            			(pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode == FIXED_TXMODE_OFDM))
+common/cmm_info.c:				pAd->StaCfg.DesiredTransmitSetting.field.MCS = MCS_AUTO;
+common/cmm_info.c:	        DBGPRINT(RT_DEBUG_TRACE, ("Set_HtMcs_Proc::(FixedTxMode=%d)\n",pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode));
+common/cmm_info.c:		pAd->CommonCfg.RegTransmitSetting.field.ShortGI = GI_400;
+common/cmm_info.c:		pAd->CommonCfg.RegTransmitSetting.field.ShortGI = GI_800;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_HtGi_Proc::(ShortGI=%d)\n",pAd->CommonCfg.RegTransmitSetting.field.ShortGI));
+common/cmm_info.c:	pAd->CommonCfg.TxBASize = Size-1;
+common/cmm_info.c:		pAd->CommonCfg.HT_DisallowTKIP = TRUE;
+common/cmm_info.c:		pAd->CommonCfg.HT_DisallowTKIP = FALSE;
+common/cmm_info.c:				(pAd->CommonCfg.HT_DisallowTKIP == TRUE) ? "enabled" : "disabled"));
+common/cmm_info.c:		pAd->CommonCfg.RegTransmitSetting.field.HTMODE  = HTMODE_GF;
+common/cmm_info.c:		pAd->CommonCfg.RegTransmitSetting.field.HTMODE  = HTMODE_MM;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_HtOpMode_Proc::(HtOpMode=%d)\n",pAd->CommonCfg.RegTransmitSetting.field.HTMODE));
+common/cmm_info.c:		pAd->CommonCfg.RegTransmitSetting.field.STBC = STBC_USE;
+common/cmm_info.c:		pAd->CommonCfg.RegTransmitSetting.field.STBC = STBC_NONE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_Stbc_Proc::(HtStbc=%d)\n",pAd->CommonCfg.RegTransmitSetting.field.STBC));
+common/cmm_info.c:		pAd->HTCEnable = FALSE;
+common/cmm_info.c:        pAd->HTCEnable = TRUE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_HtHtc_Proc::(HtHtc=%d)\n",pAd->HTCEnable));
+common/cmm_info.c:		pAd->CommonCfg.RegTransmitSetting.field.EXTCHA  = EXTCHA_BELOW;
+common/cmm_info.c:		pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_ABOVE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_HtExtcha_Proc::(HtExtcha=%d)\n",pAd->CommonCfg.RegTransmitSetting.field.EXTCHA));
+common/cmm_info.c:		pAd->CommonCfg.BACapability.field.MpduDensity = Value;
+common/cmm_info.c:		pAd->CommonCfg.BACapability.field.MpduDensity = 4;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_HtMpduDensity_Proc::(HtMpduDensity=%d)\n",pAd->CommonCfg.BACapability.field.MpduDensity));
+common/cmm_info.c:		pAd->CommonCfg.REGBACapability.field.RxBAWinLimit = Value;
+common/cmm_info.c:		pAd->CommonCfg.BACapability.field.RxBAWinLimit = Value;
+common/cmm_info.c:        pAd->CommonCfg.REGBACapability.field.RxBAWinLimit = 64;
+common/cmm_info.c:		pAd->CommonCfg.BACapability.field.RxBAWinLimit = 64;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_HtBaWinSize_Proc::(HtBaWinSize=%d)\n",pAd->CommonCfg.BACapability.field.RxBAWinLimit));
+common/cmm_info.c:		pAd->CommonCfg.bRdg = FALSE;
+common/cmm_info.c:		pAd->HTCEnable = TRUE;
+common/cmm_info.c:        pAd->CommonCfg.bRdg = TRUE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_HtRdg_Proc::(HtRdg=%d)\n",pAd->CommonCfg.bRdg));
+common/cmm_info.c:		pAd->bLinkAdapt = FALSE;
+common/cmm_info.c:			pAd->HTCEnable = TRUE;
+common/cmm_info.c:			pAd->bLinkAdapt = TRUE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_HtLinkAdapt_Proc::(HtLinkAdapt=%d)\n",pAd->bLinkAdapt));
+common/cmm_info.c:		pAd->CommonCfg.BACapability.field.AmsduEnable = FALSE;
+common/cmm_info.c:        pAd->CommonCfg.BACapability.field.AmsduEnable = TRUE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_HtAmsdu_Proc::(HtAmsdu=%d)\n",pAd->CommonCfg.BACapability.field.AmsduEnable));
+common/cmm_info.c:		pAd->CommonCfg.BACapability.field.AutoBA = FALSE;
+common/cmm_info.c:		pAd->CommonCfg.BACapability.field.Policy = BA_NOTUSE;
+common/cmm_info.c:		pAd->CommonCfg.BACapability.field.AutoBA = TRUE;
+common/cmm_info.c:		pAd->CommonCfg.BACapability.field.Policy = IMMED_BA;
+common/cmm_info.c:    pAd->CommonCfg.REGBACapability.field.AutoBA = pAd->CommonCfg.BACapability.field.AutoBA;
+common/cmm_info.c:	pAd->CommonCfg.REGBACapability.field.Policy = pAd->CommonCfg.BACapability.field.Policy;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_HtAutoBa_Proc::(HtAutoBa=%d)\n",pAd->CommonCfg.BACapability.field.AutoBA));
+common/cmm_info.c:		pAd->CommonCfg.bHTProtect = FALSE;
+common/cmm_info.c:		pAd->CommonCfg.bHTProtect = TRUE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_HtProtect_Proc::(HtProtect=%d)\n",pAd->CommonCfg.bHTProtect));
+common/cmm_info.c:		pAd->CommonCfg.BACapability.field.MMPSmode = Value;
+common/cmm_info.c:		pAd->CommonCfg.BACapability.field.MMPSmode = 3;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_HtMIMOPSmode_Proc::(MIMOPS mode=%d)\n",pAd->CommonCfg.BACapability.field.MMPSmode));
+common/cmm_info.c:	if ((Value <= 3) && (Value >= 1) && (Value <= pAd->Antenna.field.TxPath)) /* 3*3*/
+common/cmm_info.c:		pAd->CommonCfg.TxStream = Value;
+common/cmm_info.c:		pAd->CommonCfg.TxStream = pAd->Antenna.field.TxPath;
+common/cmm_info.c:	if ((pAd->MACVersion < RALINK_2883_VERSION) &&
+common/cmm_info.c:		(pAd->CommonCfg.TxStream > 2))
+common/cmm_info.c:		pAd->CommonCfg.TxStream = 2; /* only 2 TX streams for RT2860 series*/
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_HtTxStream_Proc::(Tx Stream=%d)\n",pAd->CommonCfg.TxStream));
+common/cmm_info.c:	if ((Value <= 3) && (Value >= 1) && (Value <= pAd->Antenna.field.RxPath))
+common/cmm_info.c:		pAd->CommonCfg.RxStream = Value;
+common/cmm_info.c:		pAd->CommonCfg.RxStream = pAd->Antenna.field.RxPath;
+common/cmm_info.c:	if ((pAd->MACVersion < RALINK_2883_VERSION) &&
+common/cmm_info.c:		(pAd->CommonCfg.RxStream > 2)) /* 3*3*/
+common/cmm_info.c:		pAd->CommonCfg.RxStream = 2; /* only 2 RX streams for RT2860 series*/
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_HtRxStream_Proc::(Rx Stream=%d)\n",pAd->CommonCfg.RxStream));
+common/cmm_info.c:		pAd->ApCfg.bGreenAPActive=FALSE;
+common/cmm_info.c:		pAd->ApCfg.bGreenAPEnable = FALSE;
+common/cmm_info.c:		pAd->ApCfg.bGreenAPEnable = TRUE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_GreenAP_Proc::(bGreenAPEnable=%d)\n",pAd->ApCfg.bGreenAPEnable));
+common/cmm_info.c:		pAd->WIFItestbed.bShortGI = FALSE;
+common/cmm_info.c:		pAd->WIFItestbed.bShortGI = TRUE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_ForceShortGI_Proc::(ForceShortGI=%d)\n", pAd->WIFItestbed.bShortGI));
+common/cmm_info.c:		pAd->WIFItestbed.bGreenField = FALSE;
+common/cmm_info.c:		pAd->WIFItestbed.bGreenField = TRUE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_ForceGF_Proc::(ForceGF=%d)\n", pAd->WIFItestbed.bGreenField));
+common/cmm_info.c:		pAd->CommonCfg.bMIMOPSEnable = FALSE;
+common/cmm_info.c:		pAd->CommonCfg.bMIMOPSEnable = TRUE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_HtMimoPs_Proc::(HtMimoPs=%d)\n",pAd->CommonCfg.bMIMOPSEnable));
+common/cmm_info.c:	pAd->CommonCfg.bBssCoexEnable = ((bBssCoexEnable == 1) ? TRUE: FALSE);
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set bBssCoexEnable=%d!\n", pAd->CommonCfg.bBssCoexEnable));
+common/cmm_info.c:	pAd->CommonCfg.BssCoexApCntThr = simple_strtol(pParam, 0, 10);
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set BssCoexApCntThr=%d!\n", pAd->CommonCfg.BssCoexApCntThr));
+common/cmm_info.c:		pAd->CommonCfg.vht_bw = VHT_BW_80;
+common/cmm_info.c:		pAd->CommonCfg.vht_bw = VHT_BW_2040;
+common/cmm_info.c:	if (!WMODE_CAP_AC(pAd->CommonCfg.PhyMode))
+common/cmm_info.c:	if(pAd->CommonCfg.BBPCurrentBW == BW_80)
+common/cmm_info.c:		cent_ch = pAd->CommonCfg.vht_cent_ch;
+common/cmm_info.c:		cent_ch = pAd->CommonCfg.CentralChannel;
+common/cmm_info.c:						(pAd->CommonCfg.BBPCurrentBW == BW_80 ? "80":
+common/cmm_info.c:							(pAd->CommonCfg.BBPCurrentBW == BW_40 ? "40" :
+common/cmm_info.c:						pAd->CommonCfg.Channel,
+common/cmm_info.c:						(pAd->CommonCfg.BBPCurrentBW == BW_80 ? "VHT" : "HT"), cent_ch));
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_VhtBw_Proc::(VHT_BW=%d)\n", pAd->CommonCfg.vht_bw));
+common/cmm_info.c:		pAd->CommonCfg.RegTransmitSetting.field.STBC = STBC_USE;
+common/cmm_info.c:		pAd->CommonCfg.RegTransmitSetting.field.STBC = STBC_NONE;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_Stbc_Proc::(HtStbc=%d)\n",pAd->CommonCfg.RegTransmitSetting.field.STBC));
+common/cmm_info.c:    POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_info.c:		pAd->ApCfg.MBSSID[pObj->ioctl_if].DesiredTransmitSetting.field.FixedTxMode = fix_tx_mode;
+common/cmm_info.c:		pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode = fix_tx_mode;
+common/cmm_info.c:		pAd->OpMode = OPMODE_STA;
+common/cmm_info.c:		pAd->OpMode = OPMODE_AP;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_OpMode_Proc::(OpMode=%s)\n", pAd->OpMode == 1 ? "AP Mode" : "STA Mode"));
+common/cmm_info.c:	if (pAd->chipCap.FlgHwStreamMode == FALSE)
+common/cmm_info.c:	pAd->CommonCfg.StreamMode = (simple_strtol(arg, 0, 10) & 0x3);
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s():StreamMode=%d\n", __FUNCTION__, pAd->CommonCfg.StreamMode));
+common/cmm_info.c:	pAd->CommonCfg.StreamModeMCS = simple_strtol(arg, 0, 16);
+common/cmm_info.c:				__FUNCTION__, pAd->CommonCfg.StreamModeMCS));
+common/cmm_info.c:    pAd->CommonCfg.PreAntSwitch = simple_strtol(arg, 0, 10)!=0;
+common/cmm_info.c:				__FUNCTION__, pAd->CommonCfg.PreAntSwitch));
+common/cmm_info.c:    pAd->CommonCfg.PreAntSwitchRSSI = simple_strtol(arg, 0, 10);
+common/cmm_info.c:				__FUNCTION__, pAd->CommonCfg.PreAntSwitchRSSI));
+common/cmm_info.c:    pAd->CommonCfg.PreAntSwitchTimeout = simple_strtol(arg, 0, 10);
+common/cmm_info.c:				__FUNCTION__, pAd->CommonCfg.PreAntSwitchTimeout));
+common/cmm_info.c:    pAd->CommonCfg.CFOTrack = simple_strtol(arg, 0, 10);
+common/cmm_info.c:				__FUNCTION__, pAd->CommonCfg.CFOTrack));
+common/cmm_info.c:    pAd->CommonCfg.DebugFlags = simple_strtol(arg, 0, 16);
+common/cmm_info.c:    DBGPRINT(RT_DEBUG_TRACE, ("Set_DebugFlags_Proc::(DebugFlags=%02lX)\n", pAd->CommonCfg.DebugFlags));
+common/cmm_info.c:		POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_info.c:						pAd->ApCfg.MBSSID[pObj->ioctl_if].Ssid, 
+common/cmm_info.c:						pAd->ApCfg.MBSSID[pObj->ioctl_if].SsidLen);
+common/cmm_info.c:						pAd->CommonCfg.Ssid,
+common/cmm_info.c:						pAd->CommonCfg.SsidLen);
+common/cmm_info.c:	switch(pAd->CommonCfg.PhyMode)
+common/cmm_info.c:			snprintf(pBuf, BufLen, "\tUnknow Value(%d)", pAd->CommonCfg.PhyMode);
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\t%s", pAd->CommonCfg.bEnableTxBurst ? "TRUE":"FALSE");
+common/cmm_info.c:	switch(pAd->CommonCfg.TxPreamble)
+common/cmm_info.c:			snprintf(pBuf, BufLen, "\tUnknown Value(%lu)", pAd->CommonCfg.TxPreamble);
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\t%lu", pAd->CommonCfg.TxPowerPercentage);
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\t%d", pAd->CommonCfg.Channel);
+common/cmm_info.c:	switch(pAd->CommonCfg.UseBGProtection)
+common/cmm_info.c:			snprintf(pBuf, BufLen, "\tUnknow Value(%lu)", pAd->CommonCfg.UseBGProtection);
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\t%u", pAd->CommonCfg.RtsThreshold);
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\t%u", pAd->CommonCfg.FragmentThreshold);
+common/cmm_info.c:	if (pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)
+common/cmm_info.c:    POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_info.c:		snprintf(pBuf, BufLen, "\t%u", pAd->ApCfg.MBSSID[pObj->ioctl_if].DesiredTransmitSetting.field.MCS);
+common/cmm_info.c:		snprintf(pBuf, BufLen, "\t%u", pAd->StaCfg.DesiredTransmitSetting.field.MCS);
+common/cmm_info.c:	switch(pAd->CommonCfg.RegTransmitSetting.field.ShortGI)
+common/cmm_info.c:			snprintf(pBuf, BufLen, "\tUnknow Value(%u)", pAd->CommonCfg.RegTransmitSetting.field.ShortGI);
+common/cmm_info.c:	switch(pAd->CommonCfg.RegTransmitSetting.field.HTMODE)
+common/cmm_info.c:			snprintf(pBuf, BufLen, "\tUnknow Value(%u)", pAd->CommonCfg.RegTransmitSetting.field.HTMODE);
+common/cmm_info.c:	switch(pAd->CommonCfg.RegTransmitSetting.field.EXTCHA)
+common/cmm_info.c:			snprintf(pBuf, BufLen, "\tUnknow Value(%u)", pAd->CommonCfg.RegTransmitSetting.field.EXTCHA);
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\t%u", pAd->CommonCfg.BACapability.field.MpduDensity);
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\t%u", pAd->CommonCfg.BACapability.field.RxBAWinLimit);
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\t%s", pAd->CommonCfg.bRdg ? "TRUE":"FALSE");
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\t%s", pAd->CommonCfg.BACapability.field.AmsduEnable ? "TRUE":"FALSE");
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\t%s", pAd->CommonCfg.BACapability.field.AutoBA ? "TRUE":"FALSE");
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\t%d", pAd->CommonCfg.CountryRegion);
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\t%d", pAd->CommonCfg.CountryRegionForABand);
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\t%s", pAd->CommonCfg.CountryCode);
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\t%s", pAd->CommonCfg.bAggregationCapable ? "TRUE":"FALSE");
+common/cmm_info.c:    POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_info.c:		snprintf(pBuf, BufLen, "\t%s", pAd->ApCfg.MBSSID[pObj->ioctl_if].bWmmCapable ? "TRUE":"FALSE");
+common/cmm_info.c:		snprintf(pBuf, BufLen, "\t%s", pAd->CommonCfg.bWmmCapable ? "TRUE":"FALSE");
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\t%s", pAd->CommonCfg.bIEEE80211H ? "TRUE":"FALSE");
+common/cmm_info.c:	switch(pAd->StaCfg.BssType)
+common/cmm_info.c:			sprintf(pBuf, "\tUnknow Value(%d)", pAd->StaCfg.BssType);
+common/cmm_info.c:	switch(pAd->StaCfg.WscControl.WpsApBand)
+common/cmm_info.c:			snprintf(pBuf, BufLen, "\tUnknow Value(%d)", pAd->StaCfg.WscControl.WpsApBand);
+common/cmm_info.c:	if ((pAd->StaCfg.WpaPassPhraseLen >= 8) &&
+common/cmm_info.c:		(pAd->StaCfg.WpaPassPhraseLen < 64))
+common/cmm_info.c:		snprintf(pBuf, BufLen, "\tWPAPSK = %s", pAd->StaCfg.WpaPassPhrase);
+common/cmm_info.c:			snprintf(pBuf+strlen(pBuf), BufLen-strlen(pBuf), "%02X", pAd->StaCfg.WpaPassPhrase[idx]);	
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\tAutoReconnect = %d", pAd->StaCfg.bAutoReconnect);
+common/cmm_info.c:    POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_info.c:		AuthMode = pAd->ApCfg.MBSSID[pObj->ioctl_if].AuthMode;
+common/cmm_info.c:		AuthMode = pAd->StaCfg.AuthMode;
+common/cmm_info.c:    POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_info.c:		WepStatus = pAd->ApCfg.MBSSID[pObj->ioctl_if].WepStatus;
+common/cmm_info.c:		WepStatus = pAd->StaCfg.WepStatus;
+common/cmm_info.c:    POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_info.c:		DefaultKeyId = pAd->ApCfg.MBSSID[pObj->ioctl_if].DefaultKeyId;
+common/cmm_info.c:		DefaultKeyId = pAd->StaCfg.DefaultKeyId;
+common/cmm_info.c:    POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_info.c:	KeyLength = pAd->SharedKey[index][KeyIdx].KeyLen;
+common/cmm_info.c:	NdisMoveMemory(Key, pAd->SharedKey[index][KeyIdx].Key, KeyLength);		
+common/cmm_info.c:    POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_info.c:		NdisMoveMemory(PMK, pAd->ApCfg.MBSSID[pObj->ioctl_if].PMK, 32);
+common/cmm_info.c:		NdisMoveMemory(PMK, pAd->StaCfg.PMK, 32);
+common/cmm_info.c:	sprintf(pBuf+strlen(pBuf), "PreAntSwitch: %d\n", pAd->CommonCfg.PreAntSwitch);
+common/cmm_info.c:	sprintf(pBuf+strlen(pBuf), "PreAntSwitchRSSI: %d\n", pAd->CommonCfg.PreAntSwitchRSSI);
+common/cmm_info.c:	sprintf(pBuf+strlen(pBuf), "LowTrafficThrd: %d\n", pAd->CommonCfg.lowTrafficThrd);
+common/cmm_info.c:	sprintf(pBuf+strlen(pBuf), "TrainUpRule: %d\n", pAd->CommonCfg.TrainUpRule);
+common/cmm_info.c:	sprintf(pBuf+strlen(pBuf), "TrainUpRuleRSSI: %d\n", pAd->CommonCfg.TrainUpRuleRSSI);
+common/cmm_info.c:	sprintf(pBuf+strlen(pBuf), "TrainUpLowThrd: %d\n", pAd->CommonCfg.TrainUpLowThrd);
+common/cmm_info.c:	sprintf(pBuf+strlen(pBuf), "TrainUpHighThrd: %d\n", pAd->CommonCfg.TrainUpHighThrd);
+common/cmm_info.c:	sprintf(pBuf+strlen(pBuf), "StreamMode: %d\n", pAd->CommonCfg.StreamMode);
+common/cmm_info.c:	sprintf(pBuf+strlen(pBuf), "StreamModeMCS: 0x%04x\n", pAd->CommonCfg.StreamModeMCS);
+common/cmm_info.c:	sprintf(pBuf+strlen(pBuf), "ITxBfEn: %d\n", pAd->CommonCfg.RegTransmitSetting.field.ITxBfEn);
+common/cmm_info.c:	sprintf(pBuf+strlen(pBuf), "ITxBfTimeout: %ld\n", pAd->CommonCfg.ITxBfTimeout);
+common/cmm_info.c:	sprintf(pBuf+strlen(pBuf), "ETxBfTimeout: %ld\n", pAd->CommonCfg.ETxBfTimeout);
+common/cmm_info.c:	sprintf(pBuf+strlen(pBuf), "ETxBfEnCond: %ld\n", pAd->CommonCfg.ETxBfEnCond);
+common/cmm_info.c:	sprintf(pBuf+strlen(pBuf), "ETxBfNoncompress: %d\n", pAd->CommonCfg.ETxBfNoncompress);
+common/cmm_info.c:	sprintf(pBuf+strlen(pBuf), "ETxBfIncapable: %d\n", pAd->CommonCfg.ETxBfIncapable);
+common/cmm_info.c:	sprintf(pBuf+strlen(pBuf), "DebugFlags: 0x%lx\n", pAd->CommonCfg.DebugFlags);
+common/cmm_info.c:	printk("HT Operating Mode : %d\n", pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode);
+common/cmm_info.c:		PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[i];
+common/cmm_info.c:			printk("%-32s%\n", bFound ? &pAd->P2pTable.Client[index].DeviceName[0]:"N/A");
+common/cmm_info.c:	if (pAd->OpMode == OPMODE_AP)
+common/cmm_info.c:	else if (pAd->OpMode == OPMODE_STA)
+common/cmm_info.c:	pstr = wmode_2_str(pAd->CommonCfg.PhyMode);
+common/cmm_info.c:		DBGPRINT(RT_DEBUG_OFF, ("WirelessMode: %s(%d)\n", pstr, pAd->CommonCfg.PhyMode));
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_OFF, ("Channel: %d\n", pAd->CommonCfg.Channel));
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_OFF, ("\tCentralChannel: %d\n", pAd->CommonCfg.CentralChannel));
+common/cmm_info.c:	if (WMODE_CAP_AC(pAd->CommonCfg.PhyMode))
+common/cmm_info.c:		DBGPRINT(RT_DEBUG_OFF, ("\tVHT CentralChannel: %d\n", pAd->CommonCfg.vht_cent_ch));
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_OFF, ("\tRF Channel: %d\n", pAd->LatchRfRegs.Channel));
+common/cmm_info.c:	pstr = (pAd->CommonCfg.RegTransmitSetting.field.BW) ? "20/40" : "20";
+common/cmm_info.c:	if (WMODE_CAP_AC(pAd->CommonCfg.PhyMode))
+common/cmm_info.c:		if (pAd->CommonCfg.vht_bw)
+common/cmm_info.c:	sprintf(pBuf, "\tManufacturer = %s", pAd->StaCfg.WscControl.RegData.SelfInfo.Manufacturer);	
+common/cmm_info.c:	sprintf(pBuf, "\tModelName = %s", pAd->StaCfg.WscControl.RegData.SelfInfo.ModelName);
+common/cmm_info.c:	sprintf(pBuf, "\tDeviceName = %s", pAd->StaCfg.WscControl.RegData.SelfInfo.DeviceName);
+common/cmm_info.c:	sprintf(pBuf, "\tModelNumber = %s", pAd->StaCfg.WscControl.RegData.SelfInfo.ModelNumber);
+common/cmm_info.c:	sprintf(pBuf, "\tSerialNumber = %s", pAd->StaCfg.WscControl.RegData.SelfInfo.SerialNumber);
+common/cmm_info.c:	snprintf(pBuf, BufLen, "\tModuleTxpower = %d", pAd->CommonCfg.ModuleTxpower);
+common/cmm_info.c: 	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_info.c: 	if((pAd->ApCfg.ApCliTab[ifIndex].CtrlCurrState == APCLI_CTRL_CONNECTED)
+common/cmm_info.c: 		&& (pAd->ApCfg.ApCliTab[ifIndex].SsidLen != 0))
+common/cmm_info.c: 			PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[i];
+common/cmm_info.c: 						pAd->ApCfg.ApCliTab[ifIndex].Ssid));
+common/cmm_info.c:						pAd->TxPower[i].Channel, pAd->TxPower[i].Power,
+common/cmm_info.c:						pAd->TxPower[i].Power2, pAd->TxPower[i].Power3));
+common/cmm_info.c:    pAd->CommonCfg.ITxBfTimeout = t;
+common/cmm_info.c:	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R182, pAd->CommonCfg.ITxBfTimeout & 0xFF);
+common/cmm_info.c:	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R182, (pAd->CommonCfg.ITxBfTimeout>>8) & 0xFF);
+common/cmm_info.c:    DBGPRINT(RT_DEBUG_TRACE, ("Set_ITxBfTimeout_Proc::(ITxBfTimeout=%d)\n", (int)pAd->CommonCfg.ITxBfTimeout));
+common/cmm_info.c:    pAd->CommonCfg.ETxBfTimeout = t;
+common/cmm_info.c:	RTMP_IO_WRITE32(pAd, TX_TXBF_CFG_3, pAd->CommonCfg.ETxBfTimeout);
+common/cmm_info.c:    DBGPRINT(RT_DEBUG_TRACE, ("Set_ETxBfTimeout_Proc::(ETxBfTimeout=%d)\n", (int)pAd->CommonCfg.ETxBfTimeout));
+common/cmm_info.c:	pAd->CommonCfg.ETxBfNoncompress = t;
+common/cmm_info.c:	pAd->CommonCfg.ETxBfIncapable = t;
+common/cmm_info.c:	setETxBFCap(pAd, &pAd->CommonCfg.HtCapability.TxBFCap);
+common/cmm_info.c:	UCHAR channel = pAd->CommonCfg.Channel;
+common/cmm_info.c:		channel = pAd->ate.Channel;
+common/cmm_info.c:	UCHAR channel = pAd->CommonCfg.Channel;
+common/cmm_info.c:		channel = pAd->ate.Channel;
+common/cmm_info.c:	pAd->ate.calParams[0] = (UCHAR)calParams[0];
+common/cmm_info.c:	pAd->ate.calParams[1] = (UCHAR)calParams[1];
+common/cmm_info.c:				("ITxBfCal Result in ATE = [0x%02x 0x%02x]\n", pAd->ate.calParams[0], pAd->ate.calParams[1]));
+common/cmm_info.c:	pAd->CommonCfg.ETxBfEnCond = enableETxBf && (pAd->Antenna.field.TxPath > 1);
+common/cmm_info.c:	pAd->CommonCfg.RegTransmitSetting.field.TxBF = enableETxBf==0? 0: 1;
+common/cmm_info.c:	setETxBFCap(pAd, &pAd->CommonCfg.HtCapability.TxBFCap);
+common/cmm_info.c:		pEntry = &pAd->MacTab.Content[i];
+common/cmm_info.c:	if (pAd->CommonCfg.RegTransmitSetting.field.ITxBfEn || enableETxBf)
+common/cmm_info.c:		if (pAd->CommonCfg.RegTransmitSetting.field.ITxBfEn == 0)
+common/cmm_info.c:		pAd->MacTab.Content[i].noSndgCntThrd = simple_strtol(arg, 0, 10);
+common/cmm_info.c:		pAd->MacTab.Content[i].ndpSndgStreams = simple_strtol(arg, 0, 10);
+common/cmm_info.c:	pAd->CommonCfg.RegTransmitSetting.field.ITxBfEn = enableITxBF && (pAd->Antenna.field.TxPath > 1);
+common/cmm_info.c:		MAC_TABLE_ENTRY *pMacEntry = &pAd->MacTab.Content[i];
+common/cmm_info.c:		if ((!IS_ENTRY_NONE(pMacEntry)) && (pAd->Antenna.field.TxPath> 1))
+common/cmm_info.c:	if (enableITxBF || pAd->CommonCfg.ETxBfEnCond)
+common/cmm_info.c:		if (pAd->CommonCfg.ETxBfEnCond == 0)
+common/cmm_info.c:		pAd->CommonCfg.bRalinkBurstMode= TRUE;
+common/cmm_info.c:		pAd->CommonCfg.bRalinkBurstMode = FALSE;
+common/cmm_info.c:				(pAd->CommonCfg.bRalinkBurstMode == TRUE) ? "enabled" : "disabled"));
+common/cmm_info.c:	if (!WMODE_CAP_AC(pAd->CommonCfg.PhyMode))
+common/cmm_info.c:			RTMP_IRQ_LOCK(&pAd->irq_lock, irqFlags);
+common/cmm_info.c:			pAd->ra_interval = ra_time;
+common/cmm_info.c:			pAd->ra_fast_interval = ra_qtime;
+common/cmm_info.c:			if (pAd->ApCfg.ApQuickResponeForRateUpTimerRunning == TRUE)
+common/cmm_info.c:				RTMPCancelTimer(&pAd->ApCfg.ApQuickResponeForRateUpTimer, &Cancelled);	
+common/cmm_info.c:				pAd->ApCfg.ApQuickResponeForRateUpTimerRunning = FALSE;
+common/cmm_info.c:			RTMP_IRQ_UNLOCK(&pAd->irq_lock, irqFlags);
+common/cmm_info.c:	pAd->chipCap.VcoPeriod = simple_strtol(arg, 0, 10);
+common/cmm_info.c:			("VCO Period = %d seconds\n", pAd->chipCap.VcoPeriod));
+common/cmm_info.c:	pAd->CommonCfg.ModuleTxpower = Value;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("IF Set_ModuleTxpower_Proc::(ModuleTxpower=%d)\n", pAd->CommonCfg.ModuleTxpower));
+common/cmm_info.c:	pAd->tx_kick_cnt = (INT)simple_strtol(arg, 0, 10);
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s():tx_kick_cnt=%d\n", __FUNCTION__, pAd->tx_kick_cnt));
+common/cmm_info.c:	pAd->data_phy = (INT)simple_strtol(arg, 0, 10);
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s(): data_phy=%d\n", __FUNCTION__, pAd->data_phy));
+common/cmm_info.c:	pAd->data_bw = (UCHAR)simple_strtol(arg, 0, 10);
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s(): data_bw=%d\n", __FUNCTION__, pAd->data_bw));
+common/cmm_info.c:	pAd->data_mcs = ((mcs / 10) <<4) | (mcs % 10);
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s(): data_mcs=%d\n", __FUNCTION__, pAd->data_mcs));
+common/cmm_info.c:	pAd->data_gi = (UCHAR)simple_strtol(arg, 0, 10);
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s(): data_gi=%d\n", __FUNCTION__, pAd->data_gi));
+common/cmm_info.c:	pAd->data_basize = (UCHAR)simple_strtol(arg, 0, 10);
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s(): data_basize=%d\n", __FUNCTION__, pAd->data_basize));
+common/cmm_info.c:		pAd->data_phy = MODE_VHT;
+common/cmm_info.c:		pAd->data_bw = BW_80;
+common/cmm_info.c:		pAd->data_gi = 1;
+common/cmm_info.c:		pAd->data_mcs = 7;
+common/cmm_info.c:		pAd->data_basize = 31;
+common/cmm_info.c:		pAd->ApCfg.MBSSID[0].bAutoTxRateSwitch = FALSE;
+common/cmm_info.c:		pAd->ApCfg.MBSSID[0].bAutoTxRateSwitch = TRUE;
+common/cmm_info.c:		pAd->data_mcs = (1 <<4) | 7;
+common/cmm_info.c:	pAd->fpga_on = fpga_on;
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s(): fpga_on=%d\n", __FUNCTION__, pAd->fpga_on));
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s(): data_phy=%d\n", __FUNCTION__, pAd->data_phy));
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s(): data_bw=%d\n", __FUNCTION__, pAd->data_bw));
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s(): data_mcs=%d\n", __FUNCTION__, pAd->data_mcs));
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s(): data_gi=%d\n", __FUNCTION__, pAd->data_gi));
+common/cmm_info.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s(): data_basize=%d\n", __FUNCTION__, pAd->data_basize));
+common/cmm_info.c:				pAd->ApCfg.MBSSID[0].bAutoTxRateSwitch));
+common/cmm_info.c:	pAd->force_amsdu = (simple_strtol(arg, 0, 10) > 0 ? TRUE : FALSE);
+common/cmm_info.c:				__FUNCTION__, pAd->force_amsdu));
+common/scan.c:	if (pAd->CommonCfg.BBPCurrentBW != pAd->hw_cfg.bbp_bw)
+common/scan.c:		rtmp_bbp_set_bw(pAd, pAd->hw_cfg.bbp_bw);
+common/scan.c:		AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
+common/scan.c:		AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
+common/scan.c:		ch = pAd->CommonCfg.CentralChannel;
+common/scan.c:		AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+common/scan.c:		AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+common/scan.c:		ch = pAd->CommonCfg.Channel;
+common/scan.c:	switch(pAd->CommonCfg.BBPCurrentBW)
+common/scan.c:				bw, ch, pAd->ScanTab.BssNr));
+common/scan.c:			NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
+common/scan.c:			pAd->MlmeAux.SsidLen = pAd->CommonCfg.SsidLen;
+common/scan.c:			NdisMoveMemory(pAd->MlmeAux.Ssid, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen);
+common/scan.c:								pAd->CommonCfg.TxRate, 
+common/scan.c:								pAd->CommonCfg.bAPSDForcePowerSave ? PWR_SAVE : pAd->StaCfg.Psm);
+common/scan.c:                if (pAd->ApCfg.ApCliTab[MAIN_MBSSID].Valid && RTMP_CFG80211_VIF_P2P_CLI_ON(pAd))
+common/scan.c:		pAd->StaCfg.LastScanChannel = pAd->MlmeAux.Channel;
+common/scan.c:		pAd->StaCfg.ScanChannelCnt = 0;
+common/scan.c:		if ((pAd->MlmeAux.Channel != 0) &&
+common/scan.c:		(pAd->StaCfg.bImprovedScan))	/* it is scan pending*/
+common/scan.c:			pAd->Mlme.SyncMachine.CurrState = SCAN_PENDING;
+common/scan.c:			pAd->StaCfg.BssNr = pAd->ScanTab.BssNr;
+common/scan.c:			pAd->StaCfg.bImprovedScan = FALSE;
+common/scan.c:			pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+common/scan.c:			pAd->ApCfg.ApCliTab[0].CtrlCurrState = APCLI_CTRL_DISCONNECTED;
+common/scan.c:		pAd->Mlme.ApSyncMachine.CurrState = AP_SYNC_IDLE;
+common/scan.c:		if (pAd->ApCfg.bAutoChannelAtBootup==TRUE)
+common/scan.c:			pAd->CommonCfg.Channel = SelectBestChannel(pAd, pAd->ApCfg.AutoChannelAlg);
+common/scan.c:			pAd->ApCfg.bAutoChannelAtBootup = FALSE;
+common/scan.c:		if (!((pAd->CommonCfg.Channel > 14) && (pAd->CommonCfg.bIEEE80211H == TRUE)))
+common/scan.c:			pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+common/scan.c:			pAd->Mlme.ApSyncMachine.CurrState = AP_SYNC_IDLE;
+common/scan.c:		SsidLen = pAd->MlmeAux.SsidLen;
+common/scan.c:	if ((pAd->MlmeAux.ScanType == SCAN_P2P) || (pAd->MlmeAux.ScanType == SCAN_P2P_SEARCH)
+common/scan.c:		 || ((pAd->MlmeAux.ScanType == SCAN_WSC_ACTIVE) && (OpMode == OPMODE_AP) && (P2P_CLI_ON(pAd)))
+common/scan.c:		PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/scan.c:								pAd->ApCfg.MBSSID[0].Bssid,
+common/scan.c:								pAd->ApCfg.MBSSID[0].Bssid);
+common/scan.c:								pAd->CurrentAddress,
+common/scan.c:						  SsidLen,			        pAd->MlmeAux.Ssid,
+common/scan.c:						  1,                        &pAd->CommonCfg.SupRateLen,
+common/scan.c:						  pAd->CommonCfg.SupRateLen,  pAd->CommonCfg.SupRate, 
+common/scan.c:		if (pAd->CommonCfg.ExtRateLen)
+common/scan.c:							  1,                                &pAd->CommonCfg.ExtRateLen,
+common/scan.c:							  pAd->CommonCfg.ExtRateLen,          pAd->CommonCfg.ExtRate, 
+common/scan.c:	if (WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+common/scan.c:		if (pAd->bBroadComHT == TRUE)
+common/scan.c:			HtLen = pAd->MlmeAux.HtCapabilityLen + 4;
+common/scan.c:			NdisMoveMemory(&HtCapabilityTmp, &pAd->MlmeAux.HtCapability, SIZE_HT_CAP_IE);
+common/scan.c:							pAd->MlmeAux.HtCapabilityLen,     &HtCapabilityTmp, 
+common/scan.c:							pAd->MlmeAux.HtCapabilityLen,     &pAd->MlmeAux.HtCapability, 
+common/scan.c:			NdisMoveMemory(&HtCapabilityTmp, &pAd->CommonCfg.HtCapability, SIZE_HT_CAP_IE);
+common/scan.c:							HtLen,                            &pAd->CommonCfg.HtCapability, 
+common/scan.c:		if ((pAd->MlmeAux.Channel <= 14) && (pAd->CommonCfg.bBssCoexEnable == TRUE))
+common/scan.c:							  1,          			&pAd->CommonCfg.BSSCoexist2040.word, 
+common/scan.c:	if (WMODE_CAP_AC(pAd->CommonCfg.PhyMode) &&
+common/scan.c:		(pAd->MlmeAux.Channel > 14)) {		
+common/scan.c:		if ((pAd->StaCfg.WscControl.WscEnProbeReqIE) && 
+common/scan.c:			(pAd->StaCfg.WscControl.WscConfMode != WSC_DISABLE) &&
+common/scan.c:			(pAd->StaCfg.WscControl.bWscTrigger == TRUE))
+common/scan.c:		else if ((pAd->StaCfg.WscControl.WscEnProbeReqIE) && 
+common/scan.c:			(pAd->StaCfg.WscControl.WscV2Info.bEnableWpsV2))
+common/scan.c:	if ((pAd->MlmeAux.ScanType == SCAN_P2P) || (pAd->MlmeAux.ScanType == SCAN_P2P_SEARCH) ||
+common/scan.c:		((pAd->MlmeAux.ScanType == SCAN_WSC_ACTIVE) && (OpMode == OPMODE_AP) && (P2P_CLI_ON(pAd))))
+common/scan.c:		(pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE) &&
+common/scan.c:		(pAd->StaCfg.WpsProbeReqIeLen != 0))
+common/scan.c:						pAd->StaCfg.WpsProbeReqIeLen,	pAd->StaCfg.pWpsProbeReqIe,
+common/scan.c:	if ((pAd->MlmeAux.ScanType == SCAN_P2P) || (pAd->MlmeAux.ScanType == SCAN_P2P_SEARCH)
+common/scan.c:		|| ((pAd->MlmeAux.ScanType == SCAN_WSC_ACTIVE) && (OpMode == OPMODE_AP) && (P2P_CLI_ON(pAd)))
+common/scan.c:			(pAd->CommonCfg.Channel == pAd->MlmeAux.Channel))
+common/scan.c:						  pAd->CommonCfg.TxRate, 
+common/scan.c:                if (pAd->ApCfg.ApCliTab[MAIN_MBSSID].Valid && RTMP_CFG80211_VIF_P2P_CLI_ON(pAd) 
+common/scan.c:			&& (pAd->CommonCfg.Channel == pAd->MlmeAux.Channel))
+common/scan.c:	UCHAR ScanType = pAd->MlmeAux.ScanType;
+common/scan.c:	ScanPending = ((pAd->StaCfg.bImprovedScan) && (pAd->StaCfg.ScanChannelCnt>=7));
+common/scan.c:                if ( (pAd->pCfg80211ChanList != NULL) && (pAd->MlmeAux.Channel != 0))
+common/scan.c:                        for ( ChanId = 0 ; ChanId <pAd->Cfg80211ChanListLan ; ChanId++ )
+common/scan.c:                                if ( pAd->pCfg80211ChanList[ChanId] >= pAd->MlmeAux.Channel )
+common/scan.c:                                        pAd->MlmeAux.Channel = pAd->pCfg80211ChanList[ChanId];
+common/scan.c:	if ((pAd->MlmeAux.Channel == 0) || ScanPending) 
+common/scan.c:		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+common/scan.c:			if (pAd->StaCfg.Psm == PWR_SAVE)
+common/scan.c:		AsicSwitchChannel(pAd, pAd->MlmeAux.Channel, TRUE);
+common/scan.c:		AsicLockChannel(pAd, pAd->MlmeAux.Channel);
+common/scan.c:			if (pAd->MlmeAux.Channel > 14)
+common/scan.c:				if ((pAd->CommonCfg.bIEEE80211H == 1)
+common/scan.c:					&& RadarChannelCheck(pAd, pAd->MlmeAux.Channel))
+common/scan.c:			if (pAd->CommonCfg.CarrierDetect.Enable == TRUE)
+common/scan.c:		if (CHAN_PropertyCheck(pAd, pAd->MlmeAux.Channel, CHANNEL_PASSIVE_SCAN) == TRUE)
+common/scan.c:			sc_timer = &pAd->MlmeAux.APScanTimer;
+common/scan.c:			sc_timer = &pAd->MlmeAux.ScanTimer;
+common/scan.c:			pAd->StaCfg.ScanChannelCnt++;
+common/scan.c:			if ((OpMode == OPMODE_AP) && (pAd->ApCfg.bAutoChannelAtBootup))
+common/scan.c:			if (WMODE_CAP_2G(pAd->CommonCfg.PhyMode) &&
+common/scan.c:				WMODE_CAP_5G(pAd->CommonCfg.PhyMode))
+common/scan.c:				if (pAd->MlmeAux.Channel > 14)
+common/scan.c:			pAd->Mlme.SyncMachine.CurrState = SCAN_LISTEN;
+common/scan.c:			pAd->Mlme.ApSyncMachine.CurrState = AP_SCAN_LISTEN;
+common/scan.c:		rv = ((pAd->Mlme.ApSyncMachine.CurrState == AP_SCAN_LISTEN) ? TRUE : FALSE);
+common/scan.c:			if ((pAd->Mlme.SyncMachine.CurrState == SCAN_LISTEN) || (pAd->Mlme.SyncMachine.CurrState == SCAN_PENDING))
+common/scan.c:			if ((pAd->Mlme.SyncMachine.CurrState == SCAN_LISTEN) || (pAd->Mlme.SyncMachine.CurrState == SCAN_PENDING))
+common/scan.c:			rv = ((pAd->Mlme.ApSyncMachine.CurrState == AP_SCAN_LISTEN) ? TRUE : FALSE);
+common/rt_channel.c:		if (!strncmp((PSTRING) pAd->CommonCfg.CountryCode, "JP", 2))
+common/rt_channel.c:			(!WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_B)))
+common/rt_channel.c:		if ((pAd->CommonCfg.bIEEE80211H == 1) &&
+common/rt_channel.c:			(pAd->CommonCfg.RDDurRegion == FCC) &&
+common/rt_channel.c:			(pAd->Dot11_H.bDFSIndoor == 1))
+common/rt_channel.c:		else if ((pAd->CommonCfg.bIEEE80211H == 1) &&
+common/rt_channel.c:				 (pAd->CommonCfg.RDDurRegion == FCC) &&
+common/rt_channel.c:				 (pAd->Dot11_H.bDFSIndoor == 0))
+common/rt_channel.c:			if (channel == pAd->TxPower[l].Channel)
+common/rt_channel.c:				pAd->ChannelList[j].Power = pAd->TxPower[l].Power;
+common/rt_channel.c:				pAd->ChannelList[j].Power2 = pAd->TxPower[l].Power2;
+common/rt_channel.c:					pAd->ChannelList[j].Power3 = pAd->TxPower[l].Power3;
+common/rt_channel.c:		pAd->ChannelList[j].Channel = pChDesp->FirstChannel + i * increment;
+common/rt_channel.c:		pAd->ChannelList[j].MaxTxPwr = pChDesp->MaxTxPwr;
+common/rt_channel.c:		pAd->ChannelList[j].DfsReq = pChDesp->DfsReq;
+common/rt_channel.c:		pAd->ChannelList[j].RegulatoryDomain = regulatoryDomain;
+common/rt_channel.c:		if (N_ChannelGroupCheck(pAd, pAd->ChannelList[j].Channel))
+common/rt_channel.c:			pAd->ChannelList[j].Flags |= CHANNEL_40M_CAP;
+common/rt_channel.c:					pAd->pCfg80211_CB,
+common/rt_channel.c:					pAd->ChannelList[j].Channel,
+common/rt_channel.c:					pAd->ChannelList[j].MaxTxPwr,
+common/rt_channel.c:					WMODE_CAP_N(pAd->CommonCfg.PhyMode),
+common/rt_channel.c:					(pAd->CommonCfg.RegTransmitSetting.field.BW == BW_20));
+common/rt_channel.c:	pAd->ChannelListNum = j;
+common/rt_channel.c:	ChBandCheck(pAd->CommonCfg.PhyMode, &ChType);
+common/rt_channel.c:	if (pAd->CommonCfg.pChDesp != NULL)
+common/rt_channel.c:	   pChDesp = (PCH_DESP) pAd->CommonCfg.pChDesp;
+common/rt_channel.c:			if (pAd->CommonCfg.DfsType != MAX_RD_REGION)
+common/rt_channel.c:				regulatoryDomain = pAd->CommonCfg.DfsType;
+common/rt_channel.c:	pChReg = GetChRegion(pAd->CommonCfg.CountryCode);
+common/rt_channel.c:	CreateChList(pAd, pChReg, pAd->CommonCfg.Geography);
+common/rt_channel.c:	pChRegion = GetChRegion(pAd->CommonCfg.CountryCode);
+common/rt_channel.c:	ChBandCheck(pAd->CommonCfg.PhyMode, &ChType);
+common/rt_channel.c:	if (pAd->CommonCfg.pChDesp != NULL)
+common/rt_channel.c:		pChDesp = (PCH_DESP) pAd->CommonCfg.pChDesp;
+common/rt_channel.c:			(pChDesp[i].Geography == pAd->CommonCfg.Geography))
+common/rt_channel.c:	for (i = 0; i < pAd->ChannelListNum; i++)
+common/rt_channel.c:		if (pAd->ChannelList[i].Channel == channel)
+common/rt_channel.c:	if (i == pAd->ChannelListNum)
+common/rt_channel.c:	UCHAR Channel = pAd->CommonCfg.Channel;
+common/rt_channel.c:	if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) &&
+common/rt_channel.c:		(pAd->CommonCfg.RegTransmitSetting.field.BW  == BW_40))
+common/rt_channel.c:					pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = wfa_ht_ch_ext[idx + 1];
+common/rt_channel.c:				pAd->CommonCfg.RegTransmitSetting.field.BW  = BW_20;
+common/rt_channel.c:				UCHAR Dir = pAd->CommonCfg.RegTransmitSetting.field.EXTCHA;
+common/rt_channel.c:					pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = Dir;
+common/rt_channel.c:				pAd->CommonCfg.RegTransmitSetting.field.BW  = BW_20;
+common/rt_channel.c:				pAd->CommonCfg.RegTransmitSetting.field.BW  = BW_20;
+common/rt_channel.c:				/*pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_NONE; We didn't set the ExtCh as NONE due to it'll set in RTMPSetHT()*/
+common/rt_channel.c:	if (pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)
+common/rt_channel.c:		if (pAd->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_ABOVE)
+common/rt_channel.c:			pAd->CommonCfg.CentralChannel = prim_ch + 2;
+common/rt_channel.c:				pAd->CommonCfg.CentralChannel = prim_ch - 1;
+common/rt_channel.c:				pAd->CommonCfg.CentralChannel = prim_ch - 2;
+common/rt_channel.c:		pAd->CommonCfg.CentralChannel = prim_ch;
+common/rt_channel.c:	return pAd->CommonCfg.CentralChannel;
+common/rt_channel.c:	for (i = 0; i < pAd->ChannelListNum; i++)
+common/rt_channel.c:		if (pAd->ChannelList[i].Channel == channel)
+common/rt_channel.c:	if (i == pAd->ChannelListNum)
+common/rt_channel.c:	if (pAd->CommonCfg.bSKUMode == TRUE)
+common/rt_channel.c:		if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) && (pAd->CommonCfg.TxStream == 2))
+common/rt_channel.c:		if (pAd->ChannelList[i].RegulatoryDomain == FCC)
+common/rt_channel.c:			if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) &&
+common/rt_channel.c:				(pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40) &&
+common/rt_channel.c:				return (pAd->ChannelList[i].MaxTxPwr - pAd->CommonCfg.BandedgeDelta - deltaTxStreamPwr);
+common/rt_channel.c:				return (pAd->ChannelList[i].MaxTxPwr - deltaTxStreamPwr);
+common/rt_channel.c:		else if (pAd->ChannelList[i].RegulatoryDomain == CE)
+common/rt_channel.c:			return (pAd->ChannelList[i].MaxTxPwr - pAd->CommonCfg.AntGain - deltaTxStreamPwr);
+common/rt_channel.c:		return pAd->ChannelList[i].MaxTxPwr;
+Binary file common/rt_os_util.o matches
+common/cmm_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/cmm_data.c:	if (pAd->fpga_on & 0x1) {
+common/cmm_data.c:		if (pAd->tx_kick_cnt > 0) {
+common/cmm_data.c:			if (pAd->tx_kick_cnt < 0xffff) 
+common/cmm_data.c:				pAd->tx_kick_cnt--;
+common/cmm_data.c:			pAd->RalinkCounters.MgmtRingFullCount++;
+common/cmm_data.c:										QueIdx, pAd->RalinkCounters.MgmtRingFullCount));
+common/cmm_data.c:				RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+common/cmm_data.c:				RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+common/cmm_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/cmm_data.c:	if ((pAd->Dot11_H.RDMode != RD_NORMAL_MODE)
+common/cmm_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/cmm_data.c:	RTMP_SEM_LOCK(&pAd->MgmtRingLock);
+common/cmm_data.c:			RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
+common/cmm_data.c:		MlmeRate = pAd->CommonCfg.BasicMlmeRate;
+common/cmm_data.c:		MlmeRate = pAd->CommonCfg.MlmeRate;
+common/cmm_data.c:	if ((pAd->LatchRfRegs.Channel > 14) && (MlmeRate < RATE_6)) /* 11A band*/
+common/cmm_data.c:		if (WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_A | WMODE_B | WMODE_G)
+common/cmm_data.c:			|| WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_A | WMODE_B | WMODE_G | WMODE_AN | WMODE_GN)
+common/cmm_data.c:			|| WMODE_CAP(pAd->CommonCfg.PhyMode, WMODE_AC)
+common/cmm_data.c:			if (pAd->LatchRfRegs.Channel > 14)
+common/cmm_data.c:				pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
+common/cmm_data.c:				pAd->CommonCfg.MlmeTransmit.field.MCS = MCS_RATE_6;
+common/cmm_data.c:				pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
+common/cmm_data.c:				pAd->CommonCfg.MlmeTransmit.field.MCS = MCS_0;
+common/cmm_data.c:		|| pAd->isCfgDeviceInP2p
+common/cmm_data.c:		if (MAC_ADDR_EQUAL(pHeader_802_11->Addr2, pAd->P2pCfg.CurrentAddress) ||
+common/cmm_data.c:			(pAd->LatchRfRegs.Channel > 14)
+common/cmm_data.c:                	|| pAd->isCfgDeviceInP2p
+common/cmm_data.c:			pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
+common/cmm_data.c:			pAd->CommonCfg.MlmeTransmit.field.MCS = MCS_RATE_6;
+common/cmm_data.c:			pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
+common/cmm_data.c:			pAd->CommonCfg.MlmeTransmit.field.MCS = MCS_0;
+common/cmm_data.c:			pHeader_802_11->FC.PwrMgmt = PWR_ACTIVE; /* (pAd->StaCfg.Psm == PWR_SAVE);*/
+common/cmm_data.c:				pHeader_802_11->FC.PwrMgmt = pAd->CommonCfg.bAPSDForcePowerSave;
+common/cmm_data.c:		if ((pAd->OpMode == OPMODE_STA) && (pHeader_802_11->FC.SubType == SUBTYPE_PS_POLL))
+common/cmm_data.c:	pHeader_802_11->Sequence = pAd->Sequence++;
+common/cmm_data.c:	if (pAd->Sequence >0xfff)
+common/cmm_data.c:		pAd->Sequence = 0;
+common/cmm_data.c:		&& (pAd->CommonCfg.bIEEE80211H == 1)
+common/cmm_data.c:		&& (pAd->Dot11_H.RDMode != RD_NORMAL_MODE))
+common/cmm_data.c:		RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
+common/cmm_data.c:	/*pAd->CommonCfg.MlmeTransmit.field.MODE = 1;*/
+common/cmm_data.c:						(UCHAR)pAd->CommonCfg.MlmeTransmit.field.MCS, IFS_BACKOFF, FALSE,
+common/cmm_data.c:						&pAd->CommonCfg.MlmeTransmit);
+common/cmm_data.c:		if ((pAd->P2pCfg.bLowRateQoSNULL == TRUE) &&
+common/cmm_data.c:		RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
+common/cmm_data.c:	pMacEntry = &pAd->MacTab.Content[Wcid];
+common/cmm_data.c:				&& (pAd->force_amsdu == FALSE)
+common/cmm_data.c:				|| (pAd->force_amsdu == TRUE)
+common/cmm_data.c:		if ((CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_AGGREGATION_CAPABLE) && pAd->CommonCfg.bAggregationCapable) &&
+common/cmm_data.c:				pTxBlk->pTransmit = &pAd->CommonCfg.MCastPhyMode;
+common/cmm_data.c:				pTxBlk->pTransmit = &pAd->MacTab.Content[MCAST_WCID].HTPhyMode;
+common/cmm_data.c:		pTxBlk->pMacEntry = &pAd->MacTab.Content[pTxBlk->Wcid];
+common/cmm_data.c:		if (pAd->CommonCfg.AckPolicy[pTxBlk->QueIdx] != NORMAL_ACK)
+common/cmm_data.c:		if ((pAd->OpMode == OPMODE_STA) &&
+common/cmm_data.c:			if(pAd->StaCfg.PSPXlink)
+common/cmm_data.c:					pTxBlk->pApCliEntry = &pAd->ApCfg.ApCliTab[pMacEntry->MatchAPCLITabIdx];
+common/cmm_data.c:						&& !MAC_ADDR_EQUAL(pSA, pAd->ApCfg.MBSSID[pMacEntry->apidx].Bssid))
+common/cmm_data.c:				((pAd->OpMode == OPMODE_AP) && (pMacEntry->MaxHTPhyMode.field.MODE == MODE_CCK) && (pMacEntry->MaxHTPhyMode.field.MCS == RATE_1))
+common/cmm_data.c:				pTxBlk->pTransmit = &pAd->MacTab.Content[MCAST_WCID].HTPhyMode;
+common/cmm_data.c:					((pAd->CommonCfg.bRdg == TRUE) && CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_RDG_CAPABLE)))
+common/cmm_data.c:	pAd->LastTxRate = (USHORT)pTxBlk->pTransmit->word;
+common/cmm_data.c:	if ((INFRA_ON(pAd)) && (pAd->OpMode == OPMODE_STA)) /* must be unicast to AP*/
+common/cmm_data.c:	if ((MAC_ADDR_EQUAL(GET_OS_PKT_DATAPTR(pTxBlk->pPacket), GET_OS_PKT_DATAPTR(pPacket))) && (pAd->OpMode == OPMODE_AP)) /* unicast to same STA*/
+common/cmm_data.c:	RtmpDiagStruct	*pDiagStruct = &pAd->DiagStruct;
+common/cmm_data.c:			DEQUEUE_LOCK(&pAd->irq_lock, bIntContext, IrqFlags);
+common/cmm_data.c:			if (&pAd->TxSwQueue[QueIdx] == NULL)
+common/cmm_data.c:				DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
+common/cmm_data.c:			pQueue = &pAd->TxSwQueue[QueIdx];
+common/cmm_data.c:				DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
+common/cmm_data.c:				DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
+common/cmm_data.c:				pMacEntry = &pAd->MacTab.Content[RAWcid];
+common/cmm_data.c:					&& (pMacEntry->ContinueTxFailCnt >= pAd->ApCfg.EntryLifeCheck))
+common/cmm_data.c:						pMacEntry->ContinueTxFailCnt >= pAd->ApCfg.EntryLifeCheck,
+common/cmm_data.c:						pAd->ApCfg.EntryLifeCheck, the condition will not be
+common/cmm_data.c:						DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
+common/cmm_data.c:				pAd->PrivateInfo.TxRingFullCnt++;
+common/cmm_data.c:				DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
+common/cmm_data.c:					DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
+common/cmm_data.c:					DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
+common/cmm_data.c:			DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
+common/cmm_data.c:		if ((pAd->blockQueueTab[QueIdx].SwTxQueueBlockFlag == TRUE)
+common/cmm_data.c:			&& (pAd->TxSwQueue[QueIdx].Number < 1))
+common/cmm_data.c:			releaseNetIf(&pAd->blockQueueTab[QueIdx]);
+common/cmm_data.c:	if (pAd->CommonCfg.CarrierDetect.Enable == TRUE)
+common/cmm_data.c:	rtmp_bbp_get_agc(pAd, &pAd->BbpTuning.R66CurrentValue, RX_CHAIN_0);
+common/cmm_data.c:	pAd->hw_cfg.bbp_bw = pAd->CommonCfg.BBPCurrentBW;
+common/cmm_data.c:	if (pAd->CommonCfg.CarrierDetect.Enable == TRUE)
+common/cmm_data.c:	if (pAd->BbpTuning.R66CurrentValue == 0)
+common/cmm_data.c:		pAd->BbpTuning.R66CurrentValue = 0x38;
+common/cmm_data.c:	rtmp_bbp_set_agc(pAd, pAd->BbpTuning.R66CurrentValue, RX_CHAIN_ALL);
+common/cmm_data.c:	pAd->CommonCfg.BBPCurrentBW = pAd->hw_cfg.bbp_bw;
+common/cmm_data.c:	IrqState = pAd->irq_disabled;
+common/cmm_data.c:	if ((FromWhichBSSID < pAd->ApCfg.BssidNum)
+common/cmm_data.c:		VLAN_Size = (pAd->ApCfg.MBSSID[FromWhichBSSID].VLAN_VID != 0) ? LENGTH_802_1Q : 0;
+common/cmm_data.c:		VLAN_Size = (pAd->WdsTab.\
+common/cmm_data.c:/*		 pMbss = &pAd->ApCfg.MBSSID[MAIN_MBSSID];*/
+common/cmm_data.c:		pMbss = &pAd->ApCfg.MBSSID[apidx];
+common/cmm_data.c:	pMbss = &pAd->ApCfg.MBSSID[MAIN_MBSSID];
+common/cmm_data.c:				VLAN_VID = pAd->WdsTab.WdsEntry[WdsId].VLAN_VID;
+common/cmm_data.c:	if (pAd->CommonCfg.APEdcaParm.bACM[*pQueIdx])
+common/cmm_data.c:	if (pAd->CommonCfg.bDisableReordering == 0)
+common/cmm_data.c:			Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
+common/cmm_data.c:				pBAEntry = &pAd->BATable.BARecEntry[Idx];
+common/cmm_data.c:	if (pAd->CommonCfg.bDisableReordering == 0)
+common/cmm_data.c:			Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
+common/cmm_data.c:				pBAEntry = &pAd->BATable.BARecEntry[Idx];
+common/cmm_data.c:	if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMPDU) && (pAd->CommonCfg.bDisableReordering == 0))
+common/cmm_data.c:	if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMPDU) && (pAd->CommonCfg.bDisableReordering == 0))
+common/cmm_data.c:	pAd->RalinkCounters.OneSecRxAggregationCount ++;
+common/cmm_data.c:			ASSERT(pAd->FragFrame.pFragPacket);
+common/cmm_data.c:			pFragBuffer = GET_OS_PKT_DATAPTR(pAd->FragFrame.pFragPacket);
+common/cmm_data.c:			pAd->FragFrame.RxSize   = DataSize + HeaderRoom;
+common/cmm_data.c:			NdisMoveMemory(pFragBuffer,	 pHeader, pAd->FragFrame.RxSize);
+common/cmm_data.c:			pAd->FragFrame.Sequence = pHeader->Sequence;
+common/cmm_data.c:			pAd->FragFrame.LastFrag = pHeader->Frag;	   /* Should be 0*/
+common/cmm_data.c:			ASSERT(pAd->FragFrame.LastFrag == 0);
+common/cmm_data.c:		if ((pHeader->Sequence != pAd->FragFrame.Sequence) ||
+common/cmm_data.c:			(pHeader->Frag != (pAd->FragFrame.LastFrag + 1)))
+common/cmm_data.c:			RESET_FRAGFRAME(pAd->FragFrame);
+common/cmm_data.c:		else if ((pAd->FragFrame.RxSize + DataSize) > MAX_FRAME_SIZE)
+common/cmm_data.c:			RESET_FRAGFRAME(pAd->FragFrame);
+common/cmm_data.c:		pFragBuffer = GET_OS_PKT_DATAPTR(pAd->FragFrame.pFragPacket);
+common/cmm_data.c:		NdisMoveMemory((pFragBuffer + pAd->FragFrame.RxSize), pData, DataSize);
+common/cmm_data.c:		pAd->FragFrame.RxSize  += DataSize;
+common/cmm_data.c:		pAd->FragFrame.LastFrag = pHeader->Frag;	   /* Update fragment number*/
+common/cmm_data.c:			pRetPacket = pAd->FragFrame.pFragPacket;
+common/cmm_data.c:			pAd->FragFrame.pFragPacket = pNewFragPacket;
+common/cmm_data.c:			pRxBlk->DataSize = pAd->FragFrame.RxSize - HeaderRoom;
+common/cmm_data.c:			RESET_FRAGFRAME(pAd->FragFrame);
+common/cmm_data.c:	pEntry = &pAd->MacTab.Content[pRxBlk->pRxWI->RxWIWirelessCliID];
+common/cmm_data.c:	Offset = (pAd->TbttTickCount) % (BCN_TBTT_OFFSET);
+common/cmm_data.c:	pAd->TbttTickCount++;
+common/cmm_data.c:		csr.field.BeaconInterval = (pAd->CommonCfg.BeaconPeriod << 4) - 1 ;	/* ASIC register in units of 1/16 TU = 64us*/
+common/cmm_data.c:			csr.field.BeaconInterval = (pAd->CommonCfg.BeaconPeriod) << 4; /* ASIC register in units of 1/16 TU*/
+common/cmm_data.c:							pAd->ApCfg.MBSSID[apidx].Bssid,
+common/cmm_data.c:							pAd->ApCfg.MBSSID[apidx].Bssid);
+common/cmm_data.c:			COPY_MAC_ADDR(pNullFr->Addr2, pAd->CurrentAddress);
+common/cmm_data.c:			COPY_MAC_ADDR(pNullFr->Addr3, pAd->CommonCfg.Bssid);
+common/cmm_data.c:	UINT8 RXWISize = pAd->chipCap.RXWISize;
+common/cmm_data.c:		pAd->RalinkCounters.ReceivedByteCount += pRxWI->RxWIMPDUByteCnt;
+common/cmm_data.c:		pAd->RalinkCounters.OneSecReceivedByteCount += pRxWI->RxWIMPDUByteCnt;
+common/cmm_data.c:		pAd->RalinkCounters.RxCount ++;
+common/cmm_data.c:		pAd->RalinkCounters.OneSecRxCount ++;
+common/cmm_data.c:		INC_COUNTER64(pAd->WlanCounters.ReceivedFragmentCount);
+common/cmm_data.c:				  pHeader->FC.SubType, pAd->Cfg80211RegisterActionFrame, PRINT_MAC(pHeader->Addr2));
+common/cmm_data.c:                             NdisEqualMemory(pAd->ApCfg.ApCliTab[0].CfgApCliBssid, pHeader->Addr2, MAC_ADDR_LEN))
+common/cmm_data.c:				PRINT_MAC(pAd->ApCfg.ApCliTab[0].CfgApCliBssid), PRINT_MAC(pHeader->Addr2));
+common/cmm_data.c:			if (NdisEqualMemory(pAd->P2PCurrentAddress, pHeader->Addr1, MAC_ADDR_LEN) ||
+common/cmm_data.c:			     NdisEqualMemory(pAd->ApCfg.ApCliTab[0].CfgApCliBssid, pHeader->Addr2, MAC_ADDR_LEN)) ||
+common/cmm_data.c:			     NdisEqualMemory(pAd->ApCliMlmeAux.Bssid, pHeader->Addr2, MAC_ADDR_LEN))
+common/cmm_data.c:			if (NdisEqualMemory(pAd->P2PCurrentAddress, pHeader->Addr1, MAC_ADDR_LEN) ||
+common/cmm_data.c:					&& NdisEqualMemory(pAd->ApCfg.ApCliTab[0].CfgApCliBssid, pHeader->Addr2, MAC_ADDR_LEN)) ||
+common/cmm_data.c:				NdisEqualMemory(pAd->ApCliMlmeAux.Bssid, pHeader->Addr2, MAC_ADDR_LEN))
+common/cmm_data.c:	struct MCU_CTRL *MCtrl = &pAd->MCUCtrl;
+common/cmm_data.c:	PCMD_RSP_CONTEXT pCmdRspEventContext = &pAd->CmdRspEventContext;
+common/cmm_data.c:	NdisAcquireSpinLock(&pAd->MacTabLock);
+common/cmm_data.c:	pEntry = pAd->MacTab.Hash[HashIdx];
+common/cmm_data.c:	NdisReleaseSpinLock(&pAd->MacTabLock);
+common/cmm_data.c:	if (pAd->MacTab.Size >= MAX_LEN_OF_MAC_TABLE)
+common/cmm_data.c:			switch (pAd->MulTestTab.WdsEntry[WdsTabIdx].PhyMode)
+common/cmm_data.c:					HTPhyMode.field.ShortGI = pAd->MulTestTab.WdsEntry[WdsTabIdx].HTPhyMode.field.ShortGI;
+common/cmm_data.c:					HTPhyMode.field.BW = pAd->MulTestTab.WdsEntry[WdsTabIdx].HTPhyMode.field.BW;
+common/cmm_data.c:					HTPhyMode.field.STBC = pAd->MulTestTab.WdsEntry[WdsTabIdx].HTPhyMode.field.STBC;
+common/cmm_data.c:					HTPhyMode.field.ShortGI = pAd->MulTestTab.WdsEntry[WdsTabIdx].HTPhyMode.field.ShortGI;
+common/cmm_data.c:					HTPhyMode.field.BW = pAd->MulTestTab.WdsEntry[WdsTabIdx].HTPhyMode.field.BW;
+common/cmm_data.c:					HTPhyMode.field.STBC = pAd->MulTestTab.WdsEntry[WdsTabIdx].HTPhyMode.field.STBC;
+common/cmm_data.c:				if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) || (pAd->CommonCfg.bWmmCapable))
+common/cmm_data.c:				if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
+common/cmm_data.c:					if ((pAd->CommonCfg.HtCapability.HtCapInfo.GF) && (pAd->CommonCfg.DesiredHtPhy.GF))
+common/cmm_data.c:						pAd->MacTab.fAnyStationNonGF = TRUE;
+common/cmm_data.c:						pAd->CommonCfg.AddHTInfo.AddHtInfo2.NonGfPresent = 1;
+common/cmm_data.c:					if ((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth) && (pAd->CommonCfg.DesiredHtPhy.ChannelWidth))
+common/cmm_data.c:						pEntry->MaxHTPhyMode.field.ShortGI = ((pAd->CommonCfg.DesiredHtPhy.ShortGIfor40)&(pAd->CommonCfg.HtCapability.HtCapInfo.ShortGIfor40));
+common/cmm_data.c:						pEntry->MaxHTPhyMode.field.ShortGI = ((pAd->CommonCfg.DesiredHtPhy.ShortGIfor20)&(pAd->CommonCfg.HtCapability.HtCapInfo.ShortGIfor20));
+common/cmm_data.c:						pAd->MacTab.fAnyStation20Only = TRUE;
+common/cmm_data.c:						if ((pAd->ApCfg.MBSSID[pEntry->apidx].DesiredHtPhyInfo.MCSSet[j] & bitmask) && (pAd->CommonCfg.HtCapability.MCSSet[j] & bitmask))
+common/cmm_data.c:					if (pAd->ApCfg.MBSSID[pEntry->apidx].DesiredTransmitSetting.field.MCS != MCS_AUTO)
+common/cmm_data.c:							pAd->ApCfg.MBSSID[pEntry->apidx].DesiredTransmitSetting.field.MCS));
+common/cmm_data.c:						if (pAd->ApCfg.MBSSID[pEntry->apidx].DesiredTransmitSetting.field.MCS == 32)
+common/cmm_data.c:						else if (pEntry->MaxHTPhyMode.field.MCS > pAd->ApCfg.MBSSID[pEntry->apidx].HTPhyMode.field.MCS)
+common/cmm_data.c:							pEntry->MaxHTPhyMode.field.MCS = pAd->ApCfg.MBSSID[pEntry->apidx].HTPhyMode.field.MCS;
+common/cmm_data.c:					pEntry->MaxHTPhyMode.field.STBC = (pAd->CommonCfg.HtCapability.HtCapInfo.RxSTBC & (pAd->CommonCfg.DesiredHtPhy.TxSTBC));
+common/cmm_data.c:					if (pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity < 5)
+common/cmm_data.c:						pEntry->MpduDensity = pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity;
+common/cmm_data.c:					pEntry->MaxRAmpduFactor = pAd->CommonCfg.HtCapability.HtCapParm.MaxRAmpduFactor;
+common/cmm_data.c:					pEntry->MmpsMode = (UCHAR)pAd->CommonCfg.HtCapability.HtCapInfo.MimoPs;
+common/cmm_data.c:					pEntry->AMsduSize = (UCHAR)pAd->CommonCfg.HtCapability.HtCapInfo.AMsduSize;
+common/cmm_data.c:					if (pAd->CommonCfg.DesiredHtPhy.AmsduEnable && (pAd->CommonCfg.REGBACapability.field.AutoBA == FALSE))
+common/cmm_data.c:					if (pAd->CommonCfg.HtCapability.HtCapInfo.ShortGIfor20)
+common/cmm_data.c:					if (pAd->CommonCfg.HtCapability.HtCapInfo.ShortGIfor40)
+common/cmm_data.c:					if (pAd->CommonCfg.HtCapability.HtCapInfo.TxSTBC)
+common/cmm_data.c:					if (pAd->CommonCfg.HtCapability.HtCapInfo.RxSTBC)
+common/cmm_data.c:					if (pAd->CommonCfg.HtCapability.ExtHtCapInfo.PlusHTC)
+common/cmm_data.c:					if (pAd->CommonCfg.bRdg && pAd->CommonCfg.HtCapability.ExtHtCapInfo.RDGSupport)
+common/cmm_data.c:					if (pAd->CommonCfg.HtCapability.ExtHtCapInfo.MCSFeedback == 0x03)
+common/cmm_data.c:					NdisMoveMemory(&pEntry->HTCapability, &pAd->CommonCfg.HtCapability, sizeof(HT_CAPABILITY_IE));
+common/cmm_data.c:					pAd->MacTab.fAnyStationIsLegacy = TRUE;
+common/cmm_data.c:			//pEntry->MinHTPhyMode.word = pAd->MulTestTab.WdsEntry[WdsTabIdx].MinHTPhyMode.word;
+common/cmm_data.c:			if (pAd->MulTestTab.WdsEntry[WdsTabIdx].bAutoTxRateSwitch == FALSE)
+common/cmm_data.c:				pEntry->HTPhyMode.field.MCS = pAd->MulTestTab.WdsEntry[WdsTabIdx].DesiredTransmitSetting.field.MCS;
+common/cmm_data.c:				RTMPUpdateLegacyTxSetting((UCHAR)pAd->MulTestTab.WdsEntry[WdsTabIdx].DesiredTransmitSetting.field.FixedTxMode, pEntry);
+common/cmm_data.c:			pAd->MulTestTab.WdsEntry[WdsTabIdx].MacTabMatchWCID = (UCHAR)pEntry->Aid;
+common/cmm_data.c:			DBGPRINT(RT_DEBUG_TRACE, ("MacTableInsertWDSEntry - allocate entry #%d, Total= %d\n",WdsTabIdx, pAd->MacTab.Size));
+common/cmm_data.c:		if (pAd->MulTestTab.WdsEntry[index].Valid != TRUE)
+common/cmm_data.c:		MacTableInsertMulTestEntry(pAd, pAd->MulTestTab.WdsEntry[index].PeerWdsAddr, index);
+common/cmm_data.c:		pEntry = &pAd->MacTab.Content[wcid];
+common/cmm_data.c:		if (pAd->MulTestTab.WdsEntry[pEntry->MatchWDSTabIdx].Valid != TRUE)
+common/cmm_data.c:		if (((pAd->MulTestTab.WdsEntry[WdsIdex].WepStatus == Ndis802_11Encryption1Enabled) || 
+common/cmm_data.c:			   (pAd->MulTestTab.WdsEntry[WdsIdex].WepStatus == Ndis802_11Encryption2Enabled) ||
+common/cmm_data.c:			   (pAd->MulTestTab.WdsEntry[WdsIdex].WepStatus == Ndis802_11Encryption3Enabled)
+common/cmm_data.c:				|| (pAd->MulTestTab.WdsEntry[WdsIdex].WepStatus == Ndis802_11EncryptionSMS4Enabled)
+common/cmm_data.c:			   ) && (pAd->MulTestTab.WdsEntry[WdsIdex].WdsKey.KeyLen > 0))
+common/cmm_data.c:			if (pAd->MulTestTab.WdsEntry[WdsIdex].WepStatus == Ndis802_11Encryption1Enabled)
+common/cmm_data.c:				DefaultKeyId = pAd->MulTestTab.WdsEntry[pEntry->MatchWDSTabIdx].KeyIdx;
+common/cmm_data.c:			NdisMoveMemory((PUCHAR)(&pEntry->PairwiseKey), (PUCHAR)(&pAd->MulTestTab.WdsEntry[WdsIdex].WdsKey), sizeof(CIPHER_KEY));
+common/cmm_data.c:			pEntry->WepStatus = pAd->MulTestTab.WdsEntry[WdsIdex].WepStatus;
+common/cmm_data.c:				if (pAd->MulTestTab.WdsEntry[WdsIdex].WdsKey.CipherAlg == CIPHER_WEP64)
+common/cmm_data.c:				else if (pAd->MulTestTab.WdsEntry[WdsIdex].WdsKey.CipherAlg == CIPHER_WEP128)
+common/cmm_data.c:										&pAd->MulTestTab.WdsEntry[pEntry->MatchWDSTabIdx].WdsKey);
+common/cmm_data.c:									pAd->MulTestTab.WdsEntry[pEntry->MatchWDSTabIdx].WdsKey.CipherAlg,
+Binary file common/action.o matches
+common/vht.c:	if (pAd->CommonCfg.vht_bw < VHT_BW_80 || prim_ch < 36)
+common/vht.c:		pAd->CommonCfg.vht_cent_ch = 0;
+common/vht.c:		pAd->CommonCfg.vht_cent_ch2 = 0;
+common/vht.c:			pAd->CommonCfg.vht_cent_ch = vht_ch_80M[idx].cent_freq_idx;
+common/vht.c:	pAd->CommonCfg.AddHTInfo.AddHtInfo2.NonGfPresent = 1;
+common/vht.c:	pAd->MacTab.fAnyStationNonGF = TRUE;
+common/vht.c:	vht_op.vht_op_info.ch_width = (pAd->CommonCfg.vht_bw == VHT_BW_80 ? 1: 0);
+common/vht.c:			vht_op.vht_op_info.center_freq_1 = pAd->CommonCfg.vht_cent_ch;
+common/vht.c:			vht_op.vht_op_info.center_freq_1 = pAd->CommonCfg.vht_cent_ch;
+common/vht.c:			vht_op.vht_op_info.center_freq_2 = pAd->CommonCfg.vht_cent_ch2;
+common/vht.c:	switch  (pAd->CommonCfg.RxStream)
+common/vht.c:	switch  (pAd->CommonCfg.RxStream)
+common/vht.c:	switch (pAd->CommonCfg.TxStream)
+Binary file common/frq_cal.o matches
+common/cmm_mat.c:	pMATNodeEntryPoll = (MATNodeEntry *)pAd->MatCfg.MATNodeEntryPoll;
+common/cmm_mat.c:	if(pAd->MatCfg.status != MAT_ENGINE_STAT_INITED)
+common/cmm_mat.c:				pMacAddr = &pAd->ApCfg.ApCliTab[ifIdx].CurrentAddress[0];
+common/cmm_mat.c:				retSkb = pHandle->tx((PVOID)&pAd->MatCfg, RTPKT_TO_OSPKT(pPkt), pLayerHdr, pMacAddr);
+common/cmm_mat.c:	if(pAd->MatCfg.status != MAT_ENGINE_STAT_INITED)
+common/cmm_mat.c:				pMacAddr = pHandle->rx((PVOID)&pAd->MatCfg, RTPKT_TO_OSPKT(pPkt), pLayerHdr, NULL);
+common/cmm_mat.c:			if ((pAd->ApCfg.ApCliTab[i].Valid == TRUE) 
+common/cmm_mat.c:				&& (net_dev == pAd->ApCfg.ApCliTab[i].dev))
+common/cmm_mat.c:	if(pAd->MatCfg.status == MAT_ENGINE_STAT_EXITED)
+common/cmm_mat.c:			pHandle->exit(&pAd->MatCfg);
+common/cmm_mat.c:	if (pAd->MatCfg.pMATNodeEntryPoll)
+common/cmm_mat.c:		os_free_mem(pAd, pAd->MatCfg.pMATNodeEntryPoll);
+common/cmm_mat.c:		pAd->MatCfg.pMATNodeEntryPoll = NULL;
+common/cmm_mat.c:	pAd->MatCfg.status = MAT_ENGINE_STAT_EXITED;
+common/cmm_mat.c:	if(pAd->MatCfg.status == MAT_ENGINE_STAT_INITED)
+common/cmm_mat.c:/*	pAd->MatCfg.pMATNodeEntryPoll = kmalloc(sizeof(MATNodeEntry) * MAX_MAT_NODE_ENTRY_NUM, GFP_KERNEL); */
+common/cmm_mat.c:	os_alloc_mem_suspend(NULL, (UCHAR **)&(pAd->MatCfg.pMATNodeEntryPoll), sizeof(MATNodeEntry) * MAX_MAT_NODE_ENTRY_NUM);
+common/cmm_mat.c:	if (pAd->MatCfg.pMATNodeEntryPoll != NULL)
+common/cmm_mat.c:		NdisZeroMemory(pAd->MatCfg.pMATNodeEntryPoll, sizeof(MATNodeEntry) * MAX_MAT_NODE_ENTRY_NUM);
+common/cmm_mat.c:		pPtr = pAd->MatCfg.pMATNodeEntryPoll;
+common/cmm_mat.c:			status = pHandle->init(&pAd->MatCfg);
+common/cmm_mat.c:	NdisAllocateSpinLock(pAd, &pAd->MatCfg.MATDBLock);
+common/cmm_mat.c:	pAd->MatCfg.pPriv = (VOID *)pAd;
+common/cmm_mat.c:	pAd->MatCfg.status = MAT_ENGINE_STAT_INITED;
+common/cmm_mat.c:				status = pHandle->exit(&pAd->MatCfg);
+common/cmm_mat.c:	if (pAd->MatCfg.pMATNodeEntryPoll)
+common/cmm_mat.c:		os_free_mem(pAd, pAd->MatCfg.pMATNodeEntryPoll);
+common/cmm_mat.c:	pAd->MatCfg.status = MAT_ENGINE_STAT_EXITED;
+common/txpower.c:	if (pAd->CommonCfg.BBPCurrentBW == BW_80 &&
+common/txpower.c:		pAd->CommonCfg.Channel > 14)
+common/txpower.c:		CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[0].RegisterValue = pAd->Tx80MPwrCfgABand[0];
+common/txpower.c:		CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[1].RegisterValue = pAd->Tx80MPwrCfgABand[1];
+common/txpower.c:		CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[2].RegisterValue = pAd->Tx80MPwrCfgABand[2];
+common/txpower.c:		CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[3].RegisterValue = pAd->Tx80MPwrCfgABand[3];
+common/txpower.c:		CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[4].RegisterValue = pAd->Tx80MPwrCfgABand[4];
+common/txpower.c:	if (pAd->CommonCfg.BBPCurrentBW == BW_40)
+common/txpower.c:		if (pAd->CommonCfg.CentralChannel > 14)
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[0].RegisterValue = pAd->Tx40MPwrCfgABand[0];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[1].RegisterValue = pAd->Tx40MPwrCfgABand[1];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[2].RegisterValue = pAd->Tx40MPwrCfgABand[2];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[3].RegisterValue = pAd->Tx40MPwrCfgABand[3];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[4].RegisterValue = pAd->Tx40MPwrCfgABand[4];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[0].RegisterValue = pAd->Tx40MPwrCfgGBand[0];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[1].RegisterValue = pAd->Tx40MPwrCfgGBand[1];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[2].RegisterValue = pAd->Tx40MPwrCfgGBand[2];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[3].RegisterValue = pAd->Tx40MPwrCfgGBand[3];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[4].RegisterValue = pAd->Tx40MPwrCfgGBand[4];
+common/txpower.c:		if (pAd->CommonCfg.CentralChannel > 14)
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[0].RegisterValue = pAd->Tx20MPwrCfgABand[0];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[1].RegisterValue = pAd->Tx20MPwrCfgABand[1];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[2].RegisterValue = pAd->Tx20MPwrCfgABand[2];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[3].RegisterValue = pAd->Tx20MPwrCfgABand[3];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[4].RegisterValue = pAd->Tx20MPwrCfgABand[4];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[0].RegisterValue = pAd->Tx20MPwrCfgGBand[0];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[1].RegisterValue = pAd->Tx20MPwrCfgGBand[1];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[2].RegisterValue = pAd->Tx20MPwrCfgGBand[2];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[3].RegisterValue = pAd->Tx20MPwrCfgGBand[3];
+common/txpower.c:			CfgOfTxPwrCtrlOverMAC.TxPwrCtrlOverMAC[4].RegisterValue = pAd->Tx20MPwrCfgGBand[4];
+common/txpower.c:	if (pAd->Mlme.OneSecPeriodicRound % 4 == 0)
+common/txpower.c:		if (pAd->CommonCfg.Channel <= 14)
+common/txpower.c:			bAutoTxAgc = pAd->bAutoTxAgcG;
+common/txpower.c:			TssiRef = pAd->TssiRefG;
+common/txpower.c:			pTssiMinusBoundary = &pAd->TssiMinusBoundaryG[0];
+common/txpower.c:			pTssiPlusBoundary = &pAd->TssiPlusBoundaryG[0];
+common/txpower.c:			TxAgcStep = pAd->TxAgcStepG;
+common/txpower.c:			pTxAgcCompensate = &pAd->TxAgcCompensateG;
+common/txpower.c:			bAutoTxAgc = pAd->bAutoTxAgcA;
+common/txpower.c:			TssiRef = pAd->TssiRefA;
+common/txpower.c:			pTssiMinusBoundary = &pAd->TssiMinusBoundaryA[0];
+common/txpower.c:			pTssiPlusBoundary = &pAd->TssiPlusBoundaryA[0];
+common/txpower.c:			TxAgcStep = pAd->TxAgcStepA;
+common/txpower.c:			pTxAgcCompensate = &pAd->TxAgcCompensateA;
+common/txpower.c:			/* step value is defined in pAd->TxAgcStepG for tx power value */
+common/txpower.c:		if (pAd->CommonCfg.Channel <= 14)
+common/txpower.c:			bAutoTxAgc = pAd->bAutoTxAgcG;
+common/txpower.c:			pTxAgcCompensate = &pAd->TxAgcCompensateG;
+common/txpower.c:			bAutoTxAgc = pAd->bAutoTxAgcA;
+common/txpower.c:			pTxAgcCompensate = &pAd->TxAgcCompensateA;
+common/txpower.c:		0. if current radio is a noisy environment (pAd->DrsCounters.fNoisyEnvironment)
+common/txpower.c:	NOTE: Since this routine requires the value of (pAd->DrsCounters.fNoisyEnvironment),
+common/txpower.c:						   pAd->StaCfg.RssiSample.AvgRssi0, 
+common/txpower.c:						   pAd->StaCfg.RssiSample.AvgRssi1, 
+common/txpower.c:						   pAd->StaCfg.RssiSample.AvgRssi2);
+common/txpower.c:	if (pAd->CommonCfg.bSKUMode == TRUE)
+common/txpower.c:	if (pAd->Mlme.OneSecPeriodicRound % 4 == 0)
+common/txpower.c:					if (pAd->CommonCfg.bSKUMode == TRUE)
+common/txpower.c:					if ((pAd->TxPowerCtrl.bInternalTxALC == TRUE)^(pAd->chipCap.bTempCompTxALC == TRUE))
+common/txpower.c:	if (pAd->CommonCfg.Channel > 14) 
+common/txpower.c:		TxPwrInEEPROM = ((pAd->CommonCfg.DefineMaxTxPwr & 0xFF00) >> 8); /* 5G band */
+common/txpower.c:		TxPwrInEEPROM = (pAd->CommonCfg.DefineMaxTxPwr & 0x00FF); /* 2.4G band */
+common/txpower.c:	CountryTxPwr = GetCuntryMaxTxPwr(pAd, pAd->CommonCfg.Channel); 
+common/txpower.c:	if (pAd->CommonCfg.TxPowerPercentage >= 100) /* AUTO TX POWER control */
+common/txpower.c:		if ((pAd->OpMode == OPMODE_STA)
+common/txpower.c:	else if (pAd->CommonCfg.TxPowerPercentage > 90) /* 91 ~ 100% & AUTO, treat as 100% in terms of mW */
+common/txpower.c:	else if (pAd->CommonCfg.TxPowerPercentage > 60) /* 61 ~ 90%, treat as 75% in terms of mW		 DeltaPwr -= 1; */
+common/txpower.c:	else if (pAd->CommonCfg.TxPowerPercentage > 30) /* 31 ~ 60%, treat as 50% in terms of mW		 DeltaPwr -= 3; */
+common/txpower.c:	else if (pAd->CommonCfg.TxPowerPercentage > 15) /* 16 ~ 30%, treat as 25% in terms of mW		 DeltaPwr -= 6; */
+common/txpower.c:	else if (pAd->CommonCfg.TxPowerPercentage > 9) /* 10 ~ 15%, treat as 12.5% in terms of mW		 DeltaPwr -= 9; */
+common/txpower.c:			pAd->Tx20MPwrCfgABand[i] = data;
+common/txpower.c:			pAd->Tx20MPwrCfgGBand[i] = data;
+common/txpower.c:			pAd->Tx40MPwrCfgABand[i] = Adata;
+common/txpower.c:			pAd->Tx40MPwrCfgGBand[i] = Gdata;
+common/txpower.c:			pAd->TxPower[i * 2].Channel = i * 2 + 1;
+common/txpower.c:			pAd->TxPower[i * 2 + 1].Channel = i * 2 + 2;
+common/txpower.c:			pAd->TxPower[i * 2].Power = Power.field.Byte0;
+common/txpower.c:				pAd->TxPower[i * 2].Power = DEFAULT_RF_TX_POWER;
+common/txpower.c:			pAd->TxPower[i * 2 + 1].Power = Power.field.Byte1;
+common/txpower.c:				pAd->TxPower[i * 2 + 1].Power = DEFAULT_RF_TX_POWER;
+common/txpower.c:				pAd->TxPower[i * 2].Power2 = DEFAULT_RF_TX_POWER;
+common/txpower.c:				pAd->TxPower[i * 2].Power2 = Power2.field.Byte0;
+common/txpower.c:				pAd->TxPower[i * 2 + 1].Power2 = DEFAULT_RF_TX_POWER;
+common/txpower.c:				pAd->TxPower[i * 2 + 1].Power2 = Power2.field.Byte1;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 0].Channel	= 36 + i * 8 + 0;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 0].Power	= DEFAULT_RF_TX_POWER;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 0].Power2	= DEFAULT_RF_TX_POWER;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 1].Channel	= 36 + i * 8 + 2;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 1].Power	= DEFAULT_RF_TX_POWER;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 1].Power2	= DEFAULT_RF_TX_POWER;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 2].Channel	= 36 + i * 8 + 4;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 2].Power	= DEFAULT_RF_TX_POWER;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 2].Power2	= DEFAULT_RF_TX_POWER;
+common/txpower.c:				pAd->TxPower[i * 2 + choffset + 0].Power = Power.field.Byte0;
+common/txpower.c:				pAd->TxPower[i * 2 + choffset + 1].Power = Power.field.Byte1;			
+common/txpower.c:				pAd->TxPower[i * 2 + choffset + 0].Power2 = Power2.field.Byte0;
+common/txpower.c:				pAd->TxPower[i * 2 + choffset + 1].Power2 = Power2.field.Byte1;			
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 0].Channel	= 100 + i * 8 + 0;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 0].Power	= DEFAULT_RF_TX_POWER;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 0].Power2	= DEFAULT_RF_TX_POWER;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 1].Channel	= 100 + i * 8 + 2;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 1].Power	= DEFAULT_RF_TX_POWER;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 1].Power2	= DEFAULT_RF_TX_POWER;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 2].Channel	= 100 + i * 8 + 4;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 2].Power	= DEFAULT_RF_TX_POWER;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 2].Power2	= DEFAULT_RF_TX_POWER;
+common/txpower.c:		pAd->TxPower[3 * 5 + choffset + 0].Channel		= 140;
+common/txpower.c:		pAd->TxPower[3 * 5 + choffset + 0].Power		= DEFAULT_RF_TX_POWER;
+common/txpower.c:		pAd->TxPower[3 * 5 + choffset + 0].Power2		= DEFAULT_RF_TX_POWER;
+common/txpower.c:				pAd->TxPower[i * 2 + choffset + 0].Power = Power.field.Byte0;
+common/txpower.c:				pAd->TxPower[i * 2 + choffset + 1].Power = Power.field.Byte1;			
+common/txpower.c:				pAd->TxPower[i * 2 + choffset + 0].Power2 = Power2.field.Byte0;
+common/txpower.c:				pAd->TxPower[i * 2 + choffset + 1].Power2 = Power2.field.Byte1;			
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 0].Channel	= 149 + i * 8 + 0;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 0].Power	= DEFAULT_RF_TX_POWER;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 0].Power2	= DEFAULT_RF_TX_POWER;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 1].Channel	= 149 + i * 8 + 2;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 1].Power	= DEFAULT_RF_TX_POWER;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 1].Power2	= DEFAULT_RF_TX_POWER;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 2].Channel	= 149 + i * 8 + 4;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 2].Power	= DEFAULT_RF_TX_POWER;
+common/txpower.c:			pAd->TxPower[3 * i + choffset + 2].Power2	= DEFAULT_RF_TX_POWER;
+common/txpower.c:		pAd->TxPower[3 * 3 + choffset + 0].Channel		= 171;
+common/txpower.c:		pAd->TxPower[3 * 3 + choffset + 0].Power		= DEFAULT_RF_TX_POWER;
+common/txpower.c:		pAd->TxPower[3 * 3 + choffset + 0].Power2		= DEFAULT_RF_TX_POWER;
+common/txpower.c:		pAd->TxPower[3 * 3 + choffset + 1].Channel		= 173;
+common/txpower.c:		pAd->TxPower[3 * 3 + choffset + 1].Power		= DEFAULT_RF_TX_POWER;
+common/txpower.c:		pAd->TxPower[3 * 3 + choffset + 1].Power2		= DEFAULT_RF_TX_POWER;
+common/txpower.c:				pAd->TxPower[i * 2 + choffset + 0].Power = Power.field.Byte0;
+common/txpower.c:				pAd->TxPower[i * 2 + choffset + 1].Power = Power.field.Byte1;			
+common/txpower.c:				pAd->TxPower[i * 2 + choffset + 0].Power2 = Power2.field.Byte0;
+common/txpower.c:				pAd->TxPower[i * 2 + choffset + 1].Power2 = Power2.field.Byte1;			
+common/cmm_wpa.c:            (pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.WscConfMode != WSC_DISABLE) &&
+common/cmm_wpa.c:						pMbssEntry = &pAd->ApCfg.MBSSID[apidx];
+common/cmm_wpa.c:	                    	if (IS_ENTRY_CLIENT(&pAd->MacTab.Content[i]) 
+common/cmm_wpa.c:								&& (pAd->MacTab.Content[i].WpaState == AS_PTKINITDONE)
+common/cmm_wpa.c:								&& (pAd->MacTab.Content[i].apidx == apidx))
+common/cmm_wpa.c:	                        	pAd->MacTab.Content[i].GTKState = REKEY_NEGOTIATING;
+common/cmm_wpa.c:	                        	WPAStart2WayGroupHS(pAd, &pAd->MacTab.Content[i]);
+common/cmm_wpa.c:								pAd->MacTab.Content[i].ReTryCounter = GROUP_MSG1_RETRY_TIMER_CTR;
+common/cmm_wpa.c:								RTMPModTimer(&pAd->MacTab.Content[i].RetryTimer, PEER_MSG3_RETRY_EXEC_INTV);
+common/cmm_wpa.c:						if(pAd->TxSwQueue[Index].Number > 0)
+common/cmm_wpa.c:		if (pEntry->apidx < pAd->ApCfg.BssidNum)
+common/cmm_wpa.c:		pBssid = pAd->ApCfg.MBSSID[apidx].Bssid;
+common/cmm_wpa.c:		group_cipher = pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus;
+common/cmm_wpa.c:    if (MAC_ADDR_EQUAL(pEntry->Addr, pAd->ApCfg.MBSSID[apidx].WscControl.EntryAddr) &&
+common/cmm_wpa.c:        pAd->ApCfg.MBSSID[apidx].WscControl.EapMsgRunning)
+common/cmm_wpa.c:		NdisMoveMemory(&pEapolFrame->KeyDesc.KeyData[6], &pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[pEntry->PMKID_CacheIdx].PMKID, LEN_PMKID);
+common/cmm_wpa.c:    	NdisMoveMemory(&pAd->ApCfg.MBSSID[apidx].PMK, &pAd->ApCfg.MBSSID[apidx].PMKIDCache.BSSIDInfo[pEntry->PMKID_CacheIdx].PMK, PMK_LEN);
+common/cmm_wpa.c:			pCurrentAddr = pAd->ApCfg.ApCliTab[IfIndex].CurrentAddress;
+common/cmm_wpa.c:			pmk_ptr = pAd->ApCfg.ApCliTab[IfIndex].PMK;
+common/cmm_wpa.c:			group_cipher = pAd->ApCfg.ApCliTab[IfIndex].GroupCipher;
+common/cmm_wpa.c:			rsnie_ptr = pAd->ApCfg.ApCliTab[IfIndex].RSN_IE;
+common/cmm_wpa.c:			rsnie_len = pAd->ApCfg.ApCliTab[IfIndex].RSNIE_Len;
+common/cmm_wpa.c:			pCurrentAddr = pAd->ApCfg.ApCliTab[IfIndex].CurrentAddress;
+common/cmm_wpa.c:			pmk_ptr = pAd->ApCfg.ApCliTab[IfIndex].PMK;
+common/cmm_wpa.c:			group_cipher = pAd->ApCfg.ApCliTab[IfIndex].GroupCipher;
+common/cmm_wpa.c:			rsnie_ptr = pAd->ApCfg.ApCliTab[IfIndex].RSN_IE;
+common/cmm_wpa.c:			rsnie_len = pAd->ApCfg.ApCliTab[IfIndex].RSNIE_Len;
+common/cmm_wpa.c:		pCurrentAddr = pAd->CurrentAddress;
+common/cmm_wpa.c:		pmk_ptr = pAd->StaCfg.PMK;
+common/cmm_wpa.c:		group_cipher = pAd->StaCfg.GroupCipher;
+common/cmm_wpa.c:		rsnie_ptr = pAd->StaCfg.RSN_IE;
+common/cmm_wpa.c:		rsnie_len = pAd->StaCfg.RSNIE_Len;
+common/cmm_wpa.c:		if (pEntry->apidx >= pAd->ApCfg.BssidNum)
+common/cmm_wpa.c:		pBssid = pAd->ApCfg.MBSSID[apidx].Bssid;
+common/cmm_wpa.c:		pmk_ptr = pAd->ApCfg.MBSSID[apidx].PMK;
+common/cmm_wpa.c:		gtk_ptr = pAd->ApCfg.MBSSID[apidx].GTK;
+common/cmm_wpa.c:		group_cipher = pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus;
+common/cmm_wpa.c:		default_key = pAd->ApCfg.MBSSID[apidx].DefaultKeyId;
+common/cmm_wpa.c:			rsnie_len = pAd->ApCfg.MBSSID[apidx].RSNIE_Len[0];
+common/cmm_wpa.c:			rsnie_ptr = &pAd->ApCfg.MBSSID[apidx].RSN_IE[0][0];
+common/cmm_wpa.c:            if ((pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK) ||
+common/cmm_wpa.c:				(pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1WPA2)) 
+common/cmm_wpa.c:                rsnie_len = pAd->ApCfg.MBSSID[apidx].RSNIE_Len[1];
+common/cmm_wpa.c:                rsnie_ptr = &pAd->ApCfg.MBSSID[apidx].RSN_IE[1][0];
+common/cmm_wpa.c:                rsnie_len = pAd->ApCfg.MBSSID[apidx].RSNIE_Len[0];
+common/cmm_wpa.c:                rsnie_ptr = &pAd->ApCfg.MBSSID[apidx].RSN_IE[0][0];
+common/cmm_wpa.c:			pCurrentAddr = pAd->ApCfg.ApCliTab[IfIndex].CurrentAddress;
+common/cmm_wpa.c:			group_cipher = pAd->ApCfg.ApCliTab[IfIndex].GroupCipher;
+common/cmm_wpa.c:			pCurrentAddr = pAd->ApCfg.ApCliTab[IfIndex].CurrentAddress;
+common/cmm_wpa.c:			group_cipher = pAd->ApCfg.ApCliTab[IfIndex].GroupCipher;
+common/cmm_wpa.c:		pCurrentAddr = pAd->CurrentAddress;
+common/cmm_wpa.c:		group_cipher = pAd->StaCfg.GroupCipher;
+common/cmm_wpa.c:		if (pAd->P2pCfg.bP2pCliReConnectTimerRunning)
+common/cmm_wpa.c:			pAd->P2pCfg.bP2pCliReConnectTimerRunning = FALSE;
+common/cmm_wpa.c:			RTMPCancelTimer(&pAd->P2pCfg.P2pCliReConnectTimer, &Cancelled);
+common/cmm_wpa.c:		RTMPCancelTimer(&pAd->P2pCfg.P2pWscTimer, &Cancelled);
+common/cmm_wpa.c:		NdisMoveMemory(pAd->StaCfg.PTK, pEntry->PTK, LEN_PTK);
+common/cmm_wpa.c:		NdisMoveMemory(&pAd->SharedKey[BSS0][0], &pEntry->PairwiseKey, sizeof(CIPHER_KEY));
+common/cmm_wpa.c:			if (pEntry->apidx >= pAd->ApCfg.BssidNum)
+common/cmm_wpa.c:			group_cipher = pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus;			
+common/cmm_wpa.c:        if (pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.WscConfMode != WSC_DISABLE)
+common/cmm_wpa.c:				NdisMoveMemory(&PMK_key[8], pAd->ApCfg.MBSSID[pEntry->apidx].Bssid, MAC_ADDR_LEN);
+common/cmm_wpa.c:				RT_HMAC_SHA1(pAd->ApCfg.MBSSID[pEntry->apidx].PMK, PMK_LEN, PMK_key, 20, digest, SHA1_DIGEST_SIZE);
+common/cmm_wpa.c:				RTMPAddPMKIDCache(pAd, pEntry->apidx, pEntry->Addr, digest, pAd->ApCfg.MBSSID[pEntry->apidx].PMK);
+common/cmm_wpa.c:					pP2pEntry = &pAd->P2pTable.Client[p2pIndex];
+common/cmm_wpa.c:				pAd->P2pCfg.bPeriodicListen = TRUE;
+common/cmm_wpa.c:				RTMPCancelTimer(&pAd->P2pCfg.P2pWscTimer, &Cancelled);
+common/cmm_wpa.c:		if (pEntry->apidx >= pAd->ApCfg.BssidNum)
+common/cmm_wpa.c:		group_cipher = pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus;
+common/cmm_wpa.c:		default_key = pAd->ApCfg.MBSSID[apidx].DefaultKeyId;
+common/cmm_wpa.c:		gnonce_ptr = pAd->ApCfg.MBSSID[apidx].GNonce;
+common/cmm_wpa.c:		gtk_ptr = pAd->ApCfg.MBSSID[apidx].GTK;
+common/cmm_wpa.c:		pBssid = pAd->ApCfg.MBSSID[apidx].Bssid;
+common/cmm_wpa.c:			pCurrentAddr = pAd->ApCfg.ApCliTab[IfIndex].CurrentAddress;
+common/cmm_wpa.c:			group_cipher = pAd->ApCfg.ApCliTab[IfIndex].GroupCipher;
+common/cmm_wpa.c:			default_key = pAd->ApCfg.ApCliTab[IfIndex].DefaultKeyId;
+common/cmm_wpa.c:		pCurrentAddr = pAd->CurrentAddress;
+common/cmm_wpa.c:		group_cipher = pAd->StaCfg.GroupCipher;
+common/cmm_wpa.c:		default_key = pAd->StaCfg.DefaultKeyId;
+common/cmm_wpa.c:	if ((pAd->OpMode == OPMODE_STA) && INFRA_ON(pAd) && 
+common/cmm_wpa.c:		(pAd->MlmeAux.Channel == pAd->CommonCfg.Channel)
+common/cmm_wpa.c:		pAd->MlmeAux.Channel = 0;
+common/cmm_wpa.c:        MgtMacHeaderInit(pAd, &DeAuthHdr, SUBTYPE_DEAUTH, 0, pEntry->Addr, pAd->CommonCfg.Bssid);	
+common/cmm_wpa.c:        MgtMacHeaderInit(pAd, &DeAuthHdr, SUBTYPE_DEAUTH, 0, pEntry->Addr, pAd->ApCfg.MBSSID[pEntry->apidx].Bssid);
+common/cmm_wpa.c:			if (pEntry->apidx >= pAd->ApCfg.BssidNum)
+common/cmm_wpa.c:			group_cipher = pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus;			
+common/cmm_wpa.c:		if ((pAd->OpMode == OPMODE_STA) &&
+common/cmm_wpa.c:			(pAd->StaCfg.GroupCipher != Ndis802_11Encryption2Enabled) &&
+common/cmm_wpa.c:			(pAd->StaCfg.GroupCipher != Ndis802_11Encryption3Enabled)
+common/cmm_wpa.c:			UINT	GroupCipher = pAd->StaCfg.GroupCipher;
+common/cmm_wpa.c:		if ((pAd->OpMode == OPMODE_STA) &&
+common/cmm_wpa.c:			(pAd->StaCfg.GroupCipher != Ndis802_11Encryption2Enabled) &&
+common/cmm_wpa.c:			(pAd->StaCfg.GroupCipher != Ndis802_11Encryption3Enabled)
+common/cmm_wpa.c:			UINT	GroupCipher = pAd->StaCfg.GroupCipher;
+common/cmm_wpa.c:		if (apidx < pAd->ApCfg.BssidNum)		
+common/cmm_wpa.c:			PMULTISSID_STRUCT pMbss = &pAd->ApCfg.MBSSID[apidx];
+common/cmm_wpa.c:		PMULTISSID_STRUCT pMbss = &pAd->ApCfg.MBSSID[MAIN_MBSSID];
+common/cmm_wpa.c:				pAd->ApCfg.MBSSID[MAIN_MBSSID].GroupKeyWepStatus = Ndis802_11Encryption2Enabled;
+common/cmm_wpa.c:				FlexibleCipher = pAd->ApCfg.MBSSID[MAIN_MBSSID].WpaMixPairCipher;
+common/cmm_wpa.c:				pAd->ApCfg.MBSSID[MAIN_MBSSID].GroupKeyWepStatus = WepStatus;
+common/cmm_wpa.c:			pAd->ApCfg.MBSSID[MAIN_MBSSID].RSNIE_Len[0] = 0;
+common/cmm_wpa.c:			pAd->ApCfg.MBSSID[MAIN_MBSSID].RSNIE_Len[1] = 0;
+common/cmm_wpa.c:			NdisZeroMemory(pAd->ApCfg.MBSSID[MAIN_MBSSID].RSN_IE[0], MAX_LEN_OF_RSNIE);
+common/cmm_wpa.c:			NdisZeroMemory(pAd->ApCfg.MBSSID[MAIN_MBSSID].RSN_IE[1], MAX_LEN_OF_RSNIE);
+common/cmm_wpa.c:			rsnielen_cur_p = &pAd->ApCfg.MBSSID[MAIN_MBSSID].RSNIE_Len[0];
+common/cmm_wpa.c:			pRsnIe = pAd->ApCfg.MBSSID[MAIN_MBSSID].RSN_IE[0];
+common/cmm_wpa.c:			rsnielen_ex_cur_p = &pAd->ApCfg.MBSSID[MAIN_MBSSID].RSNIE_Len[1];
+common/cmm_wpa.c:			pRsnIe_ex = pAd->ApCfg.MBSSID[MAIN_MBSSID].RSN_IE[1];
+common/cmm_wpa.c:			if (pAd->ApCfg.ApCliTab[apcliIfidx].WpaSupplicantUP != WPA_SUPPLICANT_DISABLE)
+common/cmm_wpa.c:			pAd->ApCfg.ApCliTab[apcliIfidx].RSNIE_Len = 0;
+common/cmm_wpa.c:			NdisZeroMemory(pAd->ApCfg.ApCliTab[apcliIfidx].RSN_IE, MAX_LEN_OF_RSNIE);
+common/cmm_wpa.c:			rsnielen_cur_p = &pAd->ApCfg.ApCliTab[apcliIfidx].RSNIE_Len;
+common/cmm_wpa.c:			pRsnIe = pAd->ApCfg.ApCliTab[apcliIfidx].RSN_IE;
+common/cmm_wpa.c:			bMixCipher = pAd->ApCfg.ApCliTab[apcliIfidx].bMixCipher;
+common/cmm_wpa.c:			if(pAd->ApCfg.MBSSID[apidx].Hostapd)
+common/cmm_wpa.c:				pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus = Ndis802_11Encryption2Enabled;
+common/cmm_wpa.c:				FlexibleCipher = pAd->ApCfg.MBSSID[apidx].WpaMixPairCipher;
+common/cmm_wpa.c:				pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus = WepStatus;
+common/cmm_wpa.c:			pAd->ApCfg.MBSSID[apidx].RSNIE_Len[0] = 0;
+common/cmm_wpa.c:			pAd->ApCfg.MBSSID[apidx].RSNIE_Len[1] = 0;
+common/cmm_wpa.c:			NdisZeroMemory(pAd->ApCfg.MBSSID[apidx].RSN_IE[0], MAX_LEN_OF_RSNIE);
+common/cmm_wpa.c:			NdisZeroMemory(pAd->ApCfg.MBSSID[apidx].RSN_IE[1], MAX_LEN_OF_RSNIE);
+common/cmm_wpa.c:			rsnielen_cur_p = &pAd->ApCfg.MBSSID[apidx].RSNIE_Len[0];
+common/cmm_wpa.c:			pRsnIe = pAd->ApCfg.MBSSID[apidx].RSN_IE[0];
+common/cmm_wpa.c:			rsnielen_ex_cur_p = &pAd->ApCfg.MBSSID[apidx].RSNIE_Len[1];
+common/cmm_wpa.c:			pRsnIe_ex = pAd->ApCfg.MBSSID[apidx].RSN_IE[1];
+common/cmm_wpa.c:			if (pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE)
+common/cmm_wpa.c:			pAd->StaCfg.RSNIE_Len = 0;
+common/cmm_wpa.c:			NdisZeroMemory(pAd->StaCfg.RSN_IE, MAX_LEN_OF_RSNIE);
+common/cmm_wpa.c:			rsnielen_cur_p = &pAd->StaCfg.RSNIE_Len;
+common/cmm_wpa.c:			pRsnIe = pAd->StaCfg.RSN_IE;
+common/cmm_wpa.c:			bMixCipher = pAd->StaCfg.bMixCipher;
+common/cmm_wpa.c:	if ((pAd->OpMode == OPMODE_AP)
+common/cmm_wpa.c:					pAd->ApCfg.RcvdEapReqCount ++;
+common/cmm_wpa.c:					pAd->ApCfg.RcvdEapReqCount ++;
+common/cmm_wpa.c:            if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption3Enabled) {
+common/cmm_wpa.c:    		NdisMoveMemory(pAd->StaCfg.GTK, GTK, GTKLEN);
+common/cmm_wpa.c:    		pAd->StaCfg.DefaultKeyId = DefaultIdx;
+common/cmm_wpa.c:    							pAd->StaCfg.GroupCipher, 
+common/cmm_wpa.c:    							pAd->StaCfg.DefaultKeyId, 
+common/cmm_wpa.c:    							pAd->StaCfg.GTK,
+common/cmm_wpa.c:			CipherAlg = pAd->StaCfg.GroupCipher;
+common/cmm_wpa.c:		pKey = &pAd->SharedKey[pEntry->apidx][keyIdx];
+common/cmm_wpa.c:		    	pKey = &pAd->SharedKey[pEntry->apidx][keyIdx];
+common/cmm_wpa.c:			pKey = &pAd->SharedKey[pEntry->apidx][keyIdx];
+common/cmm_wpa.c:	pSharedKey = &pAd->SharedKey[BssIdx][KeyIdx];
+common/ee_prom.c:	ShiftOutBits(pAd, Offset, pAd->EEPROMAddressNum);
+common/ee_prom.c:	ShiftOutBits(pAd, Offset, pAd->EEPROMAddressNum);
+Binary file common/p2p_cfg.o matches
+common/p2p_dbg.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:			DBGPRINT(RT_DEBUG_ERROR, ("My Self PIN Code = %08u\n", pAd->ApCfg.ApCliTab[0].WscControl.WscEnrolleePinCode));
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:		pAd->P2pCfg.ListenChannel = channel;
+common/p2p_dbg.c:		pAd->P2pCfg.ListenChannel = 1;
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s:: Listen Channel = %d.\n", __FUNCTION__, pAd->P2pCfg.ListenChannel));
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:		pAd->P2pCfg.GroupChannel = channel;
+common/p2p_dbg.c:		pAd->P2pCfg.GroupChannel = 1;
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s:: Op Channel = %d.\n", __FUNCTION__, pAd->P2pCfg.GroupChannel));
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:		pAd->P2pCfg.GoIntentIdx = intent;		
+common/p2p_dbg.c:		pAd->P2pCfg.GoIntentIdx = 0;
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_ERROR, ("%s:: GO Intent = %d.\n", __FUNCTION__, pAd->P2pCfg.GoIntentIdx));
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:		pAd->P2pCfg.DeviceNameLen = (UCHAR) strlen(arg);
+common/p2p_dbg.c:		NdisZeroMemory(pAd->P2pCfg.DeviceName, 32);
+common/p2p_dbg.c:		NdisMoveMemory(pAd->P2pCfg.DeviceName, arg, pAd->P2pCfg.DeviceNameLen);
+common/p2p_dbg.c:		DBGPRINT(RT_DEBUG_ERROR, ("Set P2P Device Name - %s", pAd->P2pCfg.DeviceName));
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_ERROR, ("%s:: Device Name = %s.\n", __FUNCTION__, pAd->P2pCfg.DeviceName));
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:		pAd->P2pCfg.WscMode= wscMode;
+common/p2p_dbg.c:		pAd->P2pCfg.WscMode = WSC_PIN_MODE; /* PIN */
+common/p2p_dbg.c:		pAd->P2pCfg.Dpid = DEV_PASS_ID_NOSPEC;
+common/p2p_dbg.c:		pAd->P2pCfg.ConfigMethod = (WSC_CONFMET_PBC | WSC_CONFMET_KEYPAD | WSC_CONFMET_DISPLAY);
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	if (pAd->P2pCfg.WscMode == WSC_PIN_MODE)
+common/p2p_dbg.c:			pAd->P2pCfg.Dpid = DEV_PASS_ID_REG;
+common/p2p_dbg.c:			pAd->P2pCfg.ConfigMethod =  WSC_CONFMET_DISPLAY;
+common/p2p_dbg.c:			DBGPRINT(RT_DEBUG_TRACE, ("    *       PIN Code = %08u                     *\n", pAd->ApCfg.ApCliTab[0].WscControl.WscEnrolleePinCode));
+common/p2p_dbg.c:			pAd->P2pCfg.Dpid = DEV_PASS_ID_USER;
+common/p2p_dbg.c:			pAd->P2pCfg.ConfigMethod =  WSC_CONFMET_KEYPAD;
+common/p2p_dbg.c:	else if (pAd->P2pCfg.WscMode == WSC_PBC_MODE)
+common/p2p_dbg.c:			pAd->P2pCfg.Dpid = DEV_PASS_ID_PBC;
+common/p2p_dbg.c:			pAd->P2pCfg.ConfigMethod = WSC_CONFMET_PBC;
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s:: Config Method = %s.\n", __FUNCTION__, decodeConfigMethod(pAd->P2pCfg.ConfigMethod)));
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	pAd->P2pCfg.GONoASchedule.Count = simple_strtol(arg, 0, 10);
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s:: NoA Count = %d\n", __FUNCTION__, pAd->P2pCfg.GONoASchedule.Count));
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	pAd->P2pCfg.GONoASchedule.Duration = simple_strtol(arg, 0, 10);
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s:: NoA Duration = %ld\n", __FUNCTION__, pAd->P2pCfg.GONoASchedule.Duration));
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	pAd->P2pCfg.GONoASchedule.Interval = simple_strtol(arg, 0, 10);
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s:: NoA Interval = %ld\n", __FUNCTION__, pAd->P2pCfg.GONoASchedule.Interval));
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:		pAd->P2pCfg.bExtListen = TRUE;
+common/p2p_dbg.c:		pAd->P2pCfg.bExtListen = FALSE;
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s:: Exted Listen = %d\n", __FUNCTION__, pAd->P2pCfg.bExtListen));
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	pAd->P2pCfg.ExtListenPeriod = simple_strtol(arg, 0, 10);
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s:: Extend Listen Interval = %d\n", __FUNCTION__, pAd->P2pCfg.ExtListenPeriod));
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	pAd->P2pCfg.ExtListenInterval = simple_strtol(arg, 0, 10);
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s:: Extend Listen Interval = %d\n", __FUNCTION__, pAd->P2pCfg.ExtListenInterval));
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:		pAd->P2pCfg.bIntraBss = TRUE;
+common/p2p_dbg.c:		pAd->P2pCfg.bIntraBss = FALSE;
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s:: IntraBss = %d\n", __FUNCTION__, pAd->P2pCfg.bIntraBss));
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:		pAd->StaCfg.bAutoReconnect = FALSE;
+common/p2p_dbg.c:		pAd->StaCfg.bAutoReconnect = TRUE;
+common/p2p_dbg.c:			pAd->StaCfg.bAutoReconnect = FALSE;
+common/p2p_dbg.c:			pAd->P2pCfg.bSentProbeRSP = TRUE;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	RTMP_SEM_LOCK(&pAd->P2pTableSemLock);
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_ERROR, ("%s:: P2pTable ClientNum = %d\n", __FUNCTION__, pAd->P2pTable.ClientNumber));
+common/p2p_dbg.c:	for (i=0; i < pAd->P2pTable.ClientNumber; i++)
+common/p2p_dbg.c:		PRT_P2P_CLIENT_ENTRY pP2pEntry = &pAd->P2pTable.Client[i];
+common/p2p_dbg.c:		else if (pAd->P2pTable.Client[i].WscMode == 2)
+common/p2p_dbg.c:		DBGPRINT(RT_DEBUG_ERROR, ("                         CfgMethod = %s.        GoIntent = %d.\n", decodeConfigMethod(pAd->P2pTable.Client[i].ConfigMethod), pAd->P2pTable.Client[i].GoIntent));
+common/p2p_dbg.c:	RTMP_SEM_UNLOCK(&pAd->P2pTableSemLock);
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_ERROR, ("%s:: P2pTable ClientNum = %d\n", __FUNCTION__, pAd->P2pTable.PerstNumber));
+common/p2p_dbg.c:	for (i=0; i < pAd->P2pTable.PerstNumber; i++)
+common/p2p_dbg.c:		DBGPRINT(RT_DEBUG_ERROR, ("Table.PerstEntry[%d]: Rule = %s\n", i, decodeMyRule(pAd->P2pTable.PerstEntry[i].MyRule)));
+common/p2p_dbg.c:		DBGPRINT(RT_DEBUG_ERROR, ("                         DevAddr = %02x:%02x:%02x:%02x:%02x:%02x.\n", PRINT_MAC(pAd->P2pTable.PerstEntry[i].Addr)));
+common/p2p_dbg.c:		DBGPRINT(RT_DEBUG_ERROR, ("                         SSID[%d] = %s.\n", pAd->P2pTable.PerstEntry[i].Profile.SSID.SsidLength, pAd->P2pTable.PerstEntry[i].Profile.SSID.Ssid));
+common/p2p_dbg.c:		DBGPRINT(RT_DEBUG_ERROR, ("                         MACAddr = %02x:%02x:%02x:%02x:%02x:%02x.\n", PRINT_MAC(pAd->P2pTable.PerstEntry[i].Profile.MacAddr)));
+common/p2p_dbg.c:		DBGPRINT(RT_DEBUG_ERROR, ("                         Key[%d] = %02x %02x %02x %02x  %02x %02x %02x %02x.\n", pAd->P2pTable.PerstEntry[i].Profile.KeyIndex, pAd->P2pTable.PerstEntry[i].Profile.Key[0], pAd->P2pTable.PerstEntry[i].Profile.Key[1],
+common/p2p_dbg.c:								pAd->P2pTable.PerstEntry[i].Profile.Key[2], pAd->P2pTable.PerstEntry[i].Profile.Key[3], pAd->P2pTable.PerstEntry[i].Profile.Key[4], pAd->P2pTable.PerstEntry[i].Profile.Key[5],
+common/p2p_dbg.c:								pAd->P2pTable.PerstEntry[i].Profile.Key[6], pAd->P2pTable.PerstEntry[i].Profile.Key[7]));
+common/p2p_dbg.c:		DBGPRINT(RT_DEBUG_ERROR, ("                                  %02x %02x %02x %02x  %02x %02x %02x %02x.\n", pAd->P2pTable.PerstEntry[i].Profile.Key[8], pAd->P2pTable.PerstEntry[i].Profile.Key[9],
+common/p2p_dbg.c:								pAd->P2pTable.PerstEntry[i].Profile.Key[10], pAd->P2pTable.PerstEntry[i].Profile.Key[11], pAd->P2pTable.PerstEntry[i].Profile.Key[12], pAd->P2pTable.PerstEntry[i].Profile.Key[13],
+common/p2p_dbg.c:								pAd->P2pTable.PerstEntry[i].Profile.Key[14], pAd->P2pTable.PerstEntry[i].Profile.Key[15]));
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	if (p2pindex < pAd->P2pTable.ClientNumber)
+common/p2p_dbg.c:		pAddr = &pAd->P2pTable.Client[p2pindex].addr[0];
+common/p2p_dbg.c:/*		pAd->P2pTable.Client[P2pTabIdx].StateCount = 10; */
+common/p2p_dbg.c:/*		pAd->P2pTable.Client[P2pTabIdx].bValid = TRUE; */
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	if (p2pindex < pAd->P2pTable.ClientNumber)
+common/p2p_dbg.c:		pAddr = &pAd->P2pTable.Client[p2pindex].addr[0];
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:		MyGOIdx = pAd->P2pTable.Client[p2pindex].MyGOIndex;
+common/p2p_dbg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Start P2P Device Discoverability = %02x:%02x:%02x:%02x:%02x:%02x.	\n",  PRINT_MAC(pAd->P2pTable.Client[p2pindex].addr)));
+common/p2p_dbg.c:			pAd->P2pTable.Client[p2pindex].GeneralToken++;
+common/p2p_dbg.c:				pAd->P2pTable.Client[MyGOIdx].P2pClientState = P2PSTATE_GO_DISCO_COMMAND;
+common/p2p_dbg.c:				pAd->P2pTable.Client[p2pindex].P2pClientState = P2PSTATE_CLIENT_DISCO_COMMAND;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	if (p2pindex < pAd->P2pTable.ClientNumber)
+common/p2p_dbg.c:		pAd->P2pCfg.ConnectingIndex = 0;
+common/p2p_dbg.c:		if (pAd->P2pTable.Client[P2pTabIdx].P2pClientState == P2PSTATE_DISCOVERY)
+common/p2p_dbg.c:			pAd->P2pTable.Client[P2pTabIdx].P2pClientState = P2PSTATE_CONNECT_COMMAND;
+common/p2p_dbg.c:		COPY_MAC_ADDR(pAd->P2pCfg.ConnectingMAC, pAd->P2pTable.Client[P2pTabIdx].addr);
+common/p2p_dbg.c:		pAd->P2pTable.Client[P2pTabIdx].StateCount = 10;
+common/p2p_dbg.c:		pAd->P2pTable.Client[P2pTabIdx].bValid = TRUE;
+common/p2p_dbg.c:		pAddr = &pAd->P2pTable.Client[p2pindex].addr[0];
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	for (i=0; i < pAd->P2pTable.ClientNumber; i++)
+common/p2p_dbg.c:		if (MAC_ADDR_EQUAL(pAd->P2pTable.Client[i].addr, ConnAddr) ||
+common/p2p_dbg.c:			MAC_ADDR_EQUAL(pAd->P2pTable.Client[i].bssid, ConnAddr) ||
+common/p2p_dbg.c:			MAC_ADDR_EQUAL(pAd->P2pTable.Client[i].InterfaceAddr, ConnAddr))
+common/p2p_dbg.c:	if ((p2pindex < pAd->P2pTable.ClientNumber) && (p2pindex != P2P_NOT_FOUND))
+common/p2p_dbg.c:		pAddr = &pAd->P2pTable.Client[p2pindex].addr[0];
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	if( pAd->P2pTable.ClientNumber == 0)
+common/p2p_dbg.c:	for (i=0; i < pAd->P2pTable.ClientNumber; i++)
+common/p2p_dbg.c:		if (MAC_ADDR_EQUAL(pAd->P2pTable.Client[i].addr, ConnAddr) ||
+common/p2p_dbg.c:			MAC_ADDR_EQUAL(pAd->P2pTable.Client[i].bssid, ConnAddr) ||
+common/p2p_dbg.c:			MAC_ADDR_EQUAL(pAd->P2pTable.Client[i].InterfaceAddr, ConnAddr))
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_TRACE,("pAd->P2pTable.ClientNumber = %d, p2pindex = %d\n", pAd->P2pTable.ClientNumber, p2pindex));
+common/p2p_dbg.c:	if ((p2pindex < pAd->P2pTable.ClientNumber) && (p2pindex != P2P_NOT_FOUND))
+common/p2p_dbg.c:		pAddr = &pAd->P2pTable.Client[p2pindex].addr[0];
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_ERROR, ("p2p_OpStatus = %04x\n", pAd->flg_p2p_OpStatusFlags));
+common/p2p_dbg.c:	DBGPRINT(RT_DEBUG_ERROR, ("AutoReconn = %d\n", pAd->StaCfg.bAutoReconnect));
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	pAd->flg_p2p_OpStatusFlags = P2P_DISABLE;
+common/p2p_dbg.c:	pAd->ApCfg.MBSSID[MAIN_MBSSID].WscControl.WscConfStatus = WSC_SCSTATE_UNCONFIGURED;
+common/p2p_dbg.c:	RTMPZeroMemory(pAd->P2pCfg.SSID, MAX_LEN_OF_SSID);
+common/p2p_dbg.c:	RTMPMoveMemory(pAd->P2pCfg.SSID, WILDP2PSSID, WILDP2PSSIDLEN);
+common/p2p_dbg.c:	RTMPZeroMemory(pAd->P2pCfg.ConnectingMAC, MAC_ADDR_LEN);
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	if (p2pindex < pAd->P2pTable.ClientNumber)
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c://	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	for (i=0; i < pAd->P2pTable.ClientNumber; i++)
+common/p2p_dbg.c:		if (MAC_ADDR_EQUAL(pAd->P2pTable.Client[i].addr, ConnAddr) ||
+common/p2p_dbg.c:			MAC_ADDR_EQUAL(pAd->P2pTable.Client[i].bssid, ConnAddr) ||
+common/p2p_dbg.c:			MAC_ADDR_EQUAL(pAd->P2pTable.Client[i].InterfaceAddr, ConnAddr))
+common/p2p_dbg.c:	if ((p2pindex < pAd->P2pTable.ClientNumber) && (p2pindex != P2P_NOT_FOUND))
+common/p2p_dbg.c:		pAddr = &pAd->P2pTable.Client[p2pindex].addr[0];
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	for (i=0; i < pAd->P2pTable.ClientNumber; i++)
+common/p2p_dbg.c:		if (MAC_ADDR_EQUAL(pAd->P2pTable.Client[i].addr, ConnAddr) ||
+common/p2p_dbg.c:			MAC_ADDR_EQUAL(pAd->P2pTable.Client[i].bssid, ConnAddr) ||
+common/p2p_dbg.c:			MAC_ADDR_EQUAL(pAd->P2pTable.Client[i].InterfaceAddr, ConnAddr))
+common/p2p_dbg.c:	if ((p2pindex < pAd->P2pTable.ClientNumber) && (p2pindex != P2P_NOT_FOUND))
+common/p2p_dbg.c:		pAddr = &pAd->P2pTable.Client[p2pindex].addr[0];
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:				if (pAd->P2pTable.Client[p2pindex].Rule == P2P_IS_GO)
+common/p2p_dbg.c:					pAd->P2pTable.Client[p2pindex].P2pClientState = P2PSTATE_DISCOVERY_GO;
+common/p2p_dbg.c:					pAd->P2pTable.Client[p2pindex].P2pClientState = P2PSTATE_DISCOVERY;
+common/p2p_dbg.c:				pAd->P2pTable.Client[p2pindex].StateCount = 0;
+common/p2p_dbg.c:			pWscControl = &pAd->ApCfg.MBSSID[MAIN_MBSSID].WscControl;
+common/p2p_dbg.c:				pEntry = &pAd->MacTab.Content[i];
+common/p2p_dbg.c:			DBGPRINT(RT_DEBUG_ERROR, ("%s:: Total= %d. p2pEntry = %d.\n", __FUNCTION__, pAd->MacTab.Size, p2pEntryCnt));
+common/p2p_dbg.c:			if ((p2pEntryCnt == 0) && (pAd->flg_p2p_OpStatusFlags == P2P_GO_UP))
+common/p2p_dbg.c:			pWscControl = &pAd->ApCfg.MBSSID[MAIN_MBSSID].WscControl;
+common/p2p_dbg.c:			if (pAd->CommonCfg.BBPCurrentBW == BW_40)
+common/p2p_dbg.c:				ch = pAd->CommonCfg.CentralChannel;
+common/p2p_dbg.c:				ch = pAd->CommonCfg.Channel;
+common/p2p_dbg.c:			AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
+common/p2p_dbg.c:			AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_dbg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_dbg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_cs.c:	if (pAd->CommonCfg.CarrierDetect.CD_State == CD_SILENCE)
+common/cmm_cs.c:    POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_cs.c:	pAd->CommonCfg.CarrierDetect.Enable = (BOOLEAN)(Enable == 0 ? FALSE : TRUE);
+common/cmm_cs.c:	if (pAd->CommonCfg.CarrierDetect.Enable == TRUE)
+common/cmm_cs.c:		pAd->CommonCfg.CarrierDetect.Enable == TRUE ? "Enable Carrier Detection":"Disable Carrier Detection"));
+common/cmm_cs.c:	CD_STATE *pCD_State = &pAd->CommonCfg.CarrierDetect.CD_State;
+common/cmm_cs.c:	ULONG *pOneSecIntCount = &pAd->CommonCfg.CarrierDetect.OneSecIntCount;
+common/cmm_cs.c:	if (pAd->CommonCfg.CarrierDetect.Debug == RT_DEBUG_TRACE)
+common/cmm_cs.c:				if (pAd->CommonCfg.CarrierDetect.Debug != RT_DEBUG_TRACE)
+common/cmm_cs.c:	PCARRIER_DETECTION_STRUCT pCarrierDetect = &pAd->CommonCfg.CarrierDetect;
+common/cmm_cs.c:	if(pAd->chipCap.carrier_func==TONE_RADAR_V2)
+common/cmm_cs.c:	if(pAd->chipCap.carrier_func == TONE_RADAR_V2)
+common/cmm_cs.c:	else if(pAd->chipCap.carrier_func == TONE_RADAR_V1 &&
+common/cmm_cs.c:	pAd->CommonCfg.CarrierDetect.CD_State = CD_NORMAL;
+common/cmm_cs.c:	pAd->CommonCfg.CarrierDetect.criteria = Value;
+common/cmm_cs.c:	pAd->CommonCfg.CarrierDetect.recheck1 = simple_strtol(arg, 0, 10);
+common/cmm_cs.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set Recheck = %u\n", pAd->CommonCfg.CarrierDetect.recheck1));
+common/cmm_cs.c:	RTMP_IO_WRITE8(pAd, CD_CHECK_COUNT, pAd->CommonCfg.CarrierDetect.recheck1);
+common/cmm_cs.c:	pAd->CommonCfg.CarrierDetect.CarrierGoneThreshold = simple_strtol(arg, 0, 10);
+common/cmm_cs.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set CarrierGoneThreshold = %u\n", pAd->CommonCfg.CarrierDetect.CarrierGoneThreshold));
+common/cmm_cs.c:	pAd->CommonCfg.CarrierDetect.Debug = simple_strtol(arg, 0, 10);
+common/cmm_cs.c:	printk("pAd->CommonCfg.CarrierDetect.Debug = %ld\n", pAd->CommonCfg.CarrierDetect.Debug);
+common/cmm_cs.c:	pAd->CommonCfg.CarrierDetect.delta = simple_strtol(arg, 0, 10);
+common/cmm_cs.c:	printk("Delta = %d\n", pAd->CommonCfg.CarrierDetect.delta);
+common/cmm_cs.c:	pAd->CommonCfg.CarrierDetect.div_flag = simple_strtol(arg, 0, 10);
+common/cmm_cs.c:	printk("DivFlag = %d\n", pAd->CommonCfg.CarrierDetect.div_flag);
+common/cmm_cs.c:	pAd->CommonCfg.CarrierDetect.threshold = simple_strtol(arg, 0, 10);
+common/cmm_cs.c:	printk("CarrThrd = %d(0x%x)\n", pAd->CommonCfg.CarrierDetect.threshold, pAd->CommonCfg.CarrierDetect.threshold);
+common/cmm_cs.c:	pAd->CommonCfg.CarrierDetect.SymRund= simple_strtol(arg, 0, 10);
+common/cmm_cs.c:	printk("SymRund = %d\n", pAd->CommonCfg.CarrierDetect.SymRund);
+common/cmm_cs.c:	pAd->CommonCfg.CarrierDetect.VGA_Mask = simple_strtol(arg, 0, 10);
+common/cmm_cs.c:	pAd->CommonCfg.CarrierDetect.Packet_End_Mask = simple_strtol(arg, 0, 10);
+common/cmm_cs.c:	pAd->CommonCfg.CarrierDetect.Rx_PE_Mask = simple_strtol(arg, 0, 10);
+common/cmm_cs.c:	printk("CarrMask = %u(%x)\n", pAd->CommonCfg.CarrierDetect.VGA_Mask, pAd->CommonCfg.CarrierDetect.VGA_Mask);
+common/cmm_cs.c:	PCARRIER_DETECTION_STRUCT pCarrierDetect = &pAd->CommonCfg.CarrierDetect;
+common/cmm_cs.c:	if (pAd->CommonCfg.CarrierDetect.Enable)
+common/cmm_cs.c:		USHORT criteria = (USHORT) (pAd->CommonCfg.CarrierDetect.criteria >> 6); /* convert unit from 16us to 1ms:(2^4 /2^10)  */
+common/cmm_cs.c:		RTMP_IO_WRITE8(pAd, CD_CHECK_COUNT, pAd->CommonCfg.CarrierDetect.recheck1);
+common/cmm_cs.c:		if (pAd->infType == RTMP_DEV_INF_PCIE)
+common/cmm_cs.c:	if (pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_20)		
+common/cmm_cs.c:		threshold = pAd->CommonCfg.CarrierDetect.threshold >> 1;	
+common/cmm_cs.c:		threshold = pAd->CommonCfg.CarrierDetect.threshold;
+common/cmm_cs.c:	bbp = pAd->CommonCfg.CarrierDetect.delta << 4;
+common/cmm_cs.c:	bbp |= (pAd->CommonCfg.CarrierDetect.div_flag & 0x1) << 3;
+common/cmm_cs.c:	bbp = pAd->CommonCfg.CarrierDetect.delta |							\
+common/cmm_cs.c:			((pAd->CommonCfg.CarrierDetect.SymRund & 0x3) << 4)	 |		\
+common/cmm_cs.c:			((pAd->CommonCfg.CarrierDetect.div_flag & 0x1) << 6) |		\
+common/cmm_cs.c:	RTMP_CARRIER_IO_WRITE8(pAd, 2, pAd->CommonCfg.CarrierDetect.VGA_Mask);
+common/cmm_cs.c:	RTMP_CARRIER_IO_WRITE8(pAd, 3, pAd->CommonCfg.CarrierDetect.Packet_End_Mask);
+common/cmm_cs.c:	RTMP_CARRIER_IO_WRITE8(pAd, 4, pAd->CommonCfg.CarrierDetect.Rx_PE_Mask);
+common/cmm_wpa_adhoc.c:	pBssid = pAd->CommonCfg.Bssid;
+common/cmm_wpa_adhoc.c:	group_cipher = pAd->StaCfg.GroupCipher;	
+common/cmm_wpa_adhoc.c:        NdisMoveMemory(&PMK_key[8], pAd->CurrentAddress, MAC_ADDR_LEN);
+common/cmm_wpa_adhoc.c:        RT_HMAC_SHA1(pAd->StaCfg.PMK, PMK_LEN, PMK_key, 20, digest, LEN_PMKID);
+common/cmm_wpa_adhoc.c:	pCurrentAddr = pAd->CurrentAddress;
+common/cmm_wpa_adhoc.c:	pmk_ptr = pAd->StaCfg.PMK;
+common/cmm_wpa_adhoc.c:	group_cipher = pAd->StaCfg.GroupCipher;
+common/cmm_wpa_adhoc.c:	rsnie_ptr = pAd->StaCfg.RSN_IE;
+common/cmm_wpa_adhoc.c:	rsnie_len = pAd->StaCfg.RSNIE_Len;
+common/cmm_wpa_adhoc.c:	pBssid = pAd->CommonCfg.Bssid;
+common/cmm_wpa_adhoc.c:	pmk_ptr = pAd->StaCfg.PMK;
+common/cmm_wpa_adhoc.c:	gtk_ptr = pAd->StaCfg.GTK;
+common/cmm_wpa_adhoc.c:	group_cipher = pAd->StaCfg.GroupCipher;
+common/cmm_wpa_adhoc.c:	default_key = pAd->StaCfg.DefaultKeyId;
+common/cmm_wpa_adhoc.c:    if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+common/cmm_wpa_adhoc.c:        rsnie_len = pAd->StaCfg.RSNIE_Len;
+common/cmm_wpa_adhoc.c:        rsnie_ptr = pAd->StaCfg.RSN_IE;
+common/cmm_wpa_adhoc.c:				pAd->CurrentAddress, 
+common/cmm_wpa_adhoc.c:	pCurrentAddr = pAd->CurrentAddress;
+common/cmm_wpa_adhoc.c:	group_cipher = pAd->StaCfg.GroupCipher;
+common/cmm_wpa_adhoc.c:		group_cipher = pAd->StaCfg.GroupCipher;
+common/cmm_wpa_adhoc.c:	pCurrentAddr = pAd->CurrentAddress;
+common/cmm_wpa_adhoc.c:	group_cipher = pAd->StaCfg.GroupCipher;
+common/cmm_wpa_adhoc.c:	default_key = pAd->StaCfg.DefaultKeyId;
+common/cmm_wpa_adhoc.c:    pAd->IndicateMediaState = NdisMediaStateConnected;
+common/cmm_wpa_adhoc.c:	if ((pAd->OpMode == OPMODE_STA) && INFRA_ON(pAd) && 
+common/cmm_wpa_adhoc.c:		(pAd->MlmeAux.Channel == pAd->CommonCfg.Channel))
+common/cmm_wpa_adhoc.c:		pAd->MlmeAux.Channel = 0;
+common/cmm_wpa_adhoc.c:	compare_address = NdisCmpMemory(pAd->CurrentAddress, pEntry->Addr, MAC_ADDR_LEN);
+common/cmm_wpa_adhoc.c:		PWSC_CTRL pWpsCtrl = &pAd->StaCfg.WscControl;
+common/cmm_wpa_adhoc.c:    pAd->IndicateMediaState = NdisMediaStateConnected;
+common/cmm_wpa_adhoc.c:							pAd->StaCfg.GroupCipher, 
+common/cmm_wpa_adhoc.c:							GetEncryptType(pAd->StaCfg.GroupCipher)));        
+common/cmm_wpa_adhoc.c:					if (pAd->StaCfg.WscControl.bWscTrigger == FALSE)
+common/cmm_wpa_adhoc.c:					if (pAd->StaCfg.WscControl.bWscTrigger == FALSE)
+common/cmm_sync.c:	NdisZeroMemory(pAd->ChannelList, MAX_NUM_OF_CHANNELS * sizeof(CHANNEL_TX_POWER));
+common/cmm_sync.c:	if (!WMODE_5G_ONLY(pAd->CommonCfg.PhyMode))
+common/cmm_sync.c:			if ((pAd->CommonCfg.CountryRegion & 0x7f) ==
+common/cmm_sync.c:			DBGPRINT(RT_DEBUG_ERROR,("CountryRegion=%d not support", pAd->CommonCfg.CountryRegion));
+common/cmm_sync.c:					if (pChannelList[i] == pAd->TxPower[j].Channel)
+common/cmm_sync.c:						NdisMoveMemory(&pAd->ChannelList[index+i], &pAd->TxPower[j], sizeof(CHANNEL_TX_POWER));
+common/cmm_sync.c:						pAd->ChannelList[index + i].Flags = pChannelListFlag[i];
+common/cmm_sync.c:						if (N_ChannelGroupCheck(pAd, pAd->ChannelList[index + i].Channel))
+common/cmm_sync.c:							pAd->ChannelList[index + i].Flags |= CHANNEL_40M_CAP;
+common/cmm_sync.c:				pAd->ChannelList[index+i].MaxTxPwr = 20;
+common/cmm_sync.c:	if (WMODE_CAP_5G(pAd->CommonCfg.PhyMode))
+common/cmm_sync.c:			if ((pAd->CommonCfg.CountryRegionForABand & 0x7f) ==
+common/cmm_sync.c:			DBGPRINT(RT_DEBUG_ERROR,("CountryRegionABand=%d not support", pAd->CommonCfg.CountryRegionForABand));
+common/cmm_sync.c:				if((pAd->CommonCfg.bIEEE80211H == 0)|| ((pAd->CommonCfg.bIEEE80211H == 1) && (pAd->CommonCfg.RDDurRegion != FCC)))			 	
+common/cmm_sync.c:				else if ((pAd->CommonCfg.bIEEE80211H == 1) &&
+common/cmm_sync.c:						(pAd->CommonCfg.RDDurRegion == FCC) &&
+common/cmm_sync.c:						(pAd->Dot11_H.bDFSIndoor == 1))
+common/cmm_sync.c:				else if ((pAd->CommonCfg.bIEEE80211H == 1) &&
+common/cmm_sync.c:						(pAd->CommonCfg.RDDurRegion == FCC) &&
+common/cmm_sync.c:						(pAd->Dot11_H.bDFSIndoor == 0))
+common/cmm_sync.c:					if (pChannelList[i] == pAd->TxPower[j].Channel)
+common/cmm_sync.c:						NdisMoveMemory(&pAd->ChannelList[index+i], &pAd->TxPower[j], sizeof(CHANNEL_TX_POWER));
+common/cmm_sync.c:						pAd->ChannelList[index + i].Flags = pChannelListFlag[i];
+common/cmm_sync.c:				if (N_ChannelGroupCheck(pAd, pAd->ChannelList[index + i].Channel))
+common/cmm_sync.c:					pAd->ChannelList[index + i].Flags |= CHANNEL_40M_CAP;
+common/cmm_sync.c:						pAd->ChannelList[index+i].DfsReq = TRUE;
+common/cmm_sync.c:				pAd->ChannelList[index+i].MaxTxPwr = 20;
+common/cmm_sync.c:	pAd->ChannelListNum = index;	
+common/cmm_sync.c:		pAd->CommonCfg.CountryRegion, pAd->CommonCfg.CountryRegionForABand, pAd->RfIcType, pAd->CommonCfg.PhyMode, pAd->ChannelListNum));
+common/cmm_sync.c:	for (i=0;i<pAd->ChannelListNum;i++)
+common/cmm_sync.c:					pAd->pCfg80211_CB,
+common/cmm_sync.c:					pAd->ChannelList[i].Channel,
+common/cmm_sync.c:					pAd->ChannelList[i].MaxTxPwr,
+common/cmm_sync.c:					WMODE_CAP_N(pAd->CommonCfg.PhyMode),
+common/cmm_sync.c:					(pAd->CommonCfg.RegTransmitSetting.field.BW == BW_20));
+common/cmm_sync.c:	for (i=0;i<pAd->ChannelListNum;i++)
+common/cmm_sync.c:									 pAd->ChannelList[i].Channel, 
+common/cmm_sync.c:									 pAd->ChannelList[i].Power, 
+common/cmm_sync.c:									 pAd->ChannelList[i].Power2, 
+common/cmm_sync.c:									 pAd->ChannelList[i].Flags));
+common/cmm_sync.c:	return pAd->ChannelList[0].Channel;
+common/cmm_sync.c:	if (pAd->MlmeAux.ScanType == SCAN_P2P_SEARCH)
+common/cmm_sync.c:		for (i = 0; i < (pAd->P2pCfg.P2pProprietary.ListenChanelCount - 1); i++)
+common/cmm_sync.c:			if (CurrentChannel == pAd->P2pCfg.P2pProprietary.ListenChanel[i])
+common/cmm_sync.c:				next_channel = pAd->P2pCfg.P2pProprietary.ListenChanel[i+1];				
+common/cmm_sync.c:		P2P_INC_CHA_INDEX(pAd->P2pCfg.P2pProprietary.ListenChanelIndex, pAd->P2pCfg.P2pProprietary.ListenChanelCount);
+common/cmm_sync.c:			DBGPRINT(RT_DEBUG_INFO, ("SYNC -  ListenChannel List : %d  %d  %d\n", pAd->P2pCfg.P2pProprietary.ListenChanel[0], pAd->P2pCfg.P2pProprietary.ListenChanel[1], pAd->P2pCfg.P2pProprietary.ListenChanel[2]));
+common/cmm_sync.c:		DBGPRINT(RT_DEBUG_INFO, ("SYNC - P2P Scan return channel = %d.    Listen Channel = %d.\n", next_channel, pAd->CommonCfg.Channel));
+common/cmm_sync.c:	for (i = 0; i < (pAd->ChannelListNum - 1); i++)
+common/cmm_sync.c:		if (channel == pAd->ChannelList[i].Channel)
+common/cmm_sync.c:			if ((pAd->MlmeAux.ScanType == SCAN_2040_BSS_COEXIST) && (pAd->ChannelList[i+1].Channel >14))
+common/cmm_sync.c:				channel = pAd->ChannelList[i+1].Channel;
+common/cmm_sync.c:			next_channel = pAd->ChannelList[i+1].Channel;
+common/cmm_sync.c:		pAd->CommonCfg.TxPowerPercentage = 6; 
+common/cmm_sync.c:		pAd->CommonCfg.TxPowerPercentage = 10;
+common/cmm_sync.c:		pAd->CommonCfg.TxPowerPercentage = 25;
+common/cmm_sync.c:		pAd->CommonCfg.TxPowerPercentage = 50;
+common/cmm_sync.c:		pAd->CommonCfg.TxPowerPercentage = 75;
+common/cmm_sync.c:		pAd->CommonCfg.TxPowerPercentage = 100; /*else used maximum*/
+common/cmm_sync.c:	if (pAd->CommonCfg.TxPowerPercentage > pAd->CommonCfg.TxPowerDefault)
+common/cmm_sync.c:		pAd->CommonCfg.TxPowerPercentage = pAd->CommonCfg.TxPowerDefault;
+common/cmm_sync.c:	if (pAd->LatchRfRegs.Channel > 14)
+common/cmm_sync.c:		RssiOffset = pAd->ARssiOffset[rssi_idx];
+common/cmm_sync.c:		RssiOffset = pAd->BGRssiOffset[rssi_idx];
+common/cmm_sync.c:	if (pAd->chipCap.SnrFormula == SNR_FORMULA2)
+common/cmm_sync.c:	else if (pAd->chipCap.SnrFormula == SNR_FORMULA3)
+common/cmm_sync.c:	if ((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth == BW_40) &&
+common/cmm_sync.c:		(pAd->CommonCfg.Channel <=14))
+common/cmm_sync.c:		pAd->CommonCfg.LastRcvBSSWidthTriggerEventsTime = Now32;
+common/cmm_sync.c:		pAd->CommonCfg.bRcvBSSWidthTriggerEvents = TRUE;
+common/cmm_sync.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 0;	
+common/cmm_sync.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = 0;
+Binary file common/p2p_dbg.o matches
+common/cmm_video.c:		pAd->VideoTurbine.Enable = GLOBAL_AP_VIDEO_CONFIG.Enable;
+common/cmm_video.c:		pAd->VideoTurbine.ClassifierEnable = GLOBAL_AP_VIDEO_CONFIG.ClassifierEnable;
+common/cmm_video.c:		pAd->VideoTurbine.HighTxMode = GLOBAL_AP_VIDEO_CONFIG.HighTxMode;
+common/cmm_video.c:		pAd->VideoTurbine.TxPwr = GLOBAL_AP_VIDEO_CONFIG.TxPwr;
+common/cmm_video.c:		pAd->VideoTurbine.VideoMCSEnable = GLOBAL_AP_VIDEO_CONFIG.VideoMCSEnable;
+common/cmm_video.c:		pAd->VideoTurbine.VideoMCS = GLOBAL_AP_VIDEO_CONFIG.VideoMCS;
+common/cmm_video.c:		pAd->VideoTurbine.TxBASize = GLOBAL_AP_VIDEO_CONFIG.TxBASize;
+common/cmm_video.c:		pAd->VideoTurbine.TxLifeTimeMode = GLOBAL_AP_VIDEO_CONFIG.TxLifeTimeMode;
+common/cmm_video.c:		pAd->VideoTurbine.TxLifeTime = GLOBAL_AP_VIDEO_CONFIG.TxLifeTime;
+common/cmm_video.c:		pAd->VideoTurbine.TxRetryLimit = GLOBAL_AP_VIDEO_CONFIG.TxRetryLimit;
+common/cmm_video.c:	RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+common/cmm_video.c:	pAd->TxSwQMaxLen = qLen;
+common/cmm_video.c:		pTxQ = &pAd->TxSwQueue[qIdx];
+common/cmm_video.c:		while(pTxQ->Number >= pAd->TxSwQMaxLen)
+common/cmm_video.c:	RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+common/cmm_video.c:			__FUNCTION__, pAd->TxSwQMaxLen));
+common/cmm_video.c:	if (pAd->VideoTurbine.Enable == TRUE) 
+common/cmm_video.c:		pAd->VideoTurbine.TxBASize = GetAsicVideoTxBA(pAd);
+common/cmm_video.c:		pAd->VideoTurbine.TxBASize = GetAsicDefaultTxBA(pAd);
+common/cmm_video.c:		if ((pAd->ra_interval != DEF_RA_TIME_INTRVAL) || 
+common/cmm_video.c:			(pAd->ra_fast_interval != DEF_QUICK_RA_TIME_INTERVAL))
+common/cmm_video.c:        return pAd->CommonCfg.TxBASize;
+common/cmm_video.c:	return pAd->VideoTurbine.TxRetryLimit;
+common/cmm_video.c:	return pAd->VideoTurbine.TxBASize;
+common/cmm_video.c:	pAd->VideoTurbine.Enable = FALSE;
+common/cmm_video.c:	pAd->VideoTurbine.TxRetryLimit = 0x2F1F;
+common/cmm_video.c:	pAd->VideoTurbine.TxBASize = pAd->CommonCfg.TxBASize; 
+common/p2p_cfg.c:							pAd->flg_p2p_OpStatusFlags |= P2P_FIXED_MODE;
+common/p2p_cfg.c:							pAd->flg_p2p_OpStatusFlags &= (~P2P_FIXED_MODE);
+common/p2p_cfg.c:	POS_COOKIE	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:					pAd->P2pCfg.DeviceNameLen = wrq->u.data.length;
+common/p2p_cfg.c:					NdisZeroMemory(pAd->P2pCfg.DeviceName, 32);
+common/p2p_cfg.c:					NdisMoveMemory(pAd->P2pCfg.DeviceName, DeviceName, pAd->P2pCfg.DeviceNameLen);
+common/p2p_cfg.c:					P2pGetRandomSSID(pAd, pAd->ApCfg.MBSSID[MAIN_MBSSID].Ssid, &(pAd->ApCfg.MBSSID[MAIN_MBSSID].SsidLen));
+common/p2p_cfg.c:					DBGPRINT(RT_DEBUG_ERROR, ("%s:: Device Name = %s.\n", __FUNCTION__, pAd->P2pCfg.DeviceName));
+common/p2p_cfg.c:					pAd->P2pCfg.ListenChannel = listen_ch;
+common/p2p_cfg.c:					pAd->P2pCfg.ListenChannel = 1;
+common/p2p_cfg.c:				DBGPRINT(RT_DEBUG_TRACE, ("%s:: Listen Channel = %d.\n", __FUNCTION__, pAd->P2pCfg.ListenChannel));
+common/p2p_cfg.c:						pAd->P2pCfg.GroupChannel = op_ch;
+common/p2p_cfg.c:						pAd->P2pCfg.GroupChannel = 1;
+common/p2p_cfg.c:					DBGPRINT(RT_DEBUG_ERROR, ("%s:: Op Channel = %d.\n", __FUNCTION__, pAd->P2pCfg.GroupChannel));
+common/p2p_cfg.c:					pAd->P2pCfg.GoIntentIdx = intent;		
+common/p2p_cfg.c:					pAd->P2pCfg.GoIntentIdx = 0;
+common/p2p_cfg.c:				DBGPRINT(RT_DEBUG_ERROR, ("%s:: GO Intent = %d.\n", __FUNCTION__, pAd->P2pCfg.GoIntentIdx));
+common/p2p_cfg.c:				PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_cfg.c:					pAd->StaCfg.bAutoReconnect = FALSE;
+common/p2p_cfg.c:					pAd->StaCfg.bAutoReconnect = TRUE;
+common/p2p_cfg.c:						pAd->StaCfg.bAutoReconnect = FALSE;
+common/p2p_cfg.c:						pAd->P2pCfg.bSentProbeRSP = TRUE;
+common/p2p_cfg.c:					pAd->P2pCfg.WscMode= p2pWscMode;
+common/p2p_cfg.c:					pAd->P2pCfg.WscMode = WSC_PIN_MODE; /* PIN */
+common/p2p_cfg.c:				if (pAd->P2pCfg.WscMode == WSC_PIN_MODE)
+common/p2p_cfg.c:						pAd->P2pCfg.Dpid = DEV_PASS_ID_REG;
+common/p2p_cfg.c:						pAd->P2pCfg.ConfigMethod =  WSC_CONFMET_DISPLAY;
+common/p2p_cfg.c:						pAd->P2pCfg.Dpid = DEV_PASS_ID_USER;
+common/p2p_cfg.c:						pAd->P2pCfg.ConfigMethod =  WSC_CONFMET_KEYPAD;
+common/p2p_cfg.c:				else if (pAd->P2pCfg.WscMode == WSC_PBC_MODE)
+common/p2p_cfg.c:						pAd->P2pCfg.Dpid = DEV_PASS_ID_PBC;
+common/p2p_cfg.c:						pAd->P2pCfg.ConfigMethod = WSC_CONFMET_PBC;
+common/p2p_cfg.c:				DBGPRINT(RT_DEBUG_ERROR, ("%s:: Config Method = %s.\n", __FUNCTION__, decodeConfigMethod(pAd->P2pCfg.ConfigMethod)));
+common/p2p_cfg.c:				if (p2pindex < pAd->P2pTable.ClientNumber)
+common/p2p_cfg.c:					/*pAd->P2pCfg.ConnectingIndex = 0; */
+common/p2p_cfg.c:					/*if (pAd->P2pTable.Client[P2pTabIdx].P2pClientState == P2PSTATE_DISCOVERY) */
+common/p2p_cfg.c:					/*	pAd->P2pTable.Client[P2pTabIdx].P2pClientState = P2PSTATE_CONNECT_COMMAND; */
+common/p2p_cfg.c:					/*COPY_MAC_ADDR(pAd->P2pCfg.ConnectingMAC, pAd->P2pTable.Client[P2pTabIdx].addr); */
+common/p2p_cfg.c:					/*pAd->P2pTable.Client[P2pTabIdx].StateCount = 10; */
+common/p2p_cfg.c:					/*pAd->P2pTable.Client[P2pTabIdx].bValid = TRUE; */
+common/p2p_cfg.c:					pAddr = &pAd->P2pTable.Client[p2pindex].addr[0];
+common/p2p_cfg.c:				if (copy_from_user(&pAd->P2pTable.PerstEntry, wrq->u.data.pointer, wrq->u.data.length))
+common/p2p_cfg.c:					pAd->P2pTable.PerstNumber = 0;					
+common/p2p_cfg.c:						if (pAd->P2pTable.PerstEntry[j].bValid)
+common/p2p_cfg.c:							pAd->P2pTable.PerstNumber++;
+common/p2p_cfg.c:				if (p2pindex < pAd->P2pTable.ClientNumber)
+common/p2p_cfg.c:					pAddr = &pAd->P2pTable.Client[p2pindex].addr[0];
+common/p2p_cfg.c:				//pMBSSStruct = &pAd->ApCfg.MBSSID[0];
+common/p2p_cfg.c:				PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_cfg.c:			pEntry = pAd->MacTab.Hash[HashIdx];
+common/p2p_cfg.c:				if (pAd->ApCfg.MBSSID[apidx].Hostapd == TRUE)
+common/p2p_cfg.c:						if((pAd->ApCfg.MBSSID[apidx].WscControl.WscConfMode & WSC_PROXY))
+common/p2p_cfg.c:							if (pAd->ApCfg.MBSSID[apidx].WscControl.Wsc2MinsTimerRunning == TRUE)
+common/p2p_cfg.c:								RTMPCancelTimer(&pAd->ApCfg.MBSSID[apidx].WscControl.Wsc2MinsTimer, &Cancelled);
+common/p2p_cfg.c:							RTMPSetTimer(&pAd->ApCfg.MBSSID[apidx].WscControl.Wsc2MinsTimer, WSC_TWO_MINS_TIME_OUT);
+common/p2p_cfg.c:							pAd->ApCfg.MBSSID[apidx].WscControl.Wsc2MinsTimerRunning = TRUE;
+common/p2p_cfg.c:				if (pAd->ApCfg.MBSSID[apidx].Hostapd == TRUE)
+common/p2p_cfg.c:					pWscControl = &pAd->ApCfg.MBSSID[pObj->ioctl_if].WscControl;
+common/p2p_cfg.c:				PWSC_CTRL	pWscCtrl = &pAd->ApCfg.MBSSID[apIdx].WscControl;
+common/p2p_cfg.c:				PWSC_CTRL	pWscCtrl = &pAd->ApCfg.MBSSID[apIdx].WscControl;
+common/p2p_cfg.c:				pAd->ApCfg.MBSSID[apIdx].WscControl.Wsc_Uuid_Str[0] = '\0';
+common/p2p_cfg.c:				Status = copy_from_user(&pAd->ApCfg.MBSSID[apIdx].WscControl.Wsc_Uuid_Str[0],
+common/p2p_cfg.c:										pAd->ApCfg.MBSSID[apIdx].WscControl.Wsc_Uuid_Str));
+common/p2p_cfg.c:				Status = copy_from_user(&pAd->ApCfg.MBSSID[apIdx].WscControl.Wsc_Uuid_E[0],
+common/p2p_cfg.c:					DBGPRINT(RT_DEBUG_TRACE, ("%02x", (pAd->ApCfg.MBSSID[apIdx].WscControl.Wsc_Uuid_E[ii] & 0xff)));
+common/p2p_cfg.c:				pAd->SharedKey[pObj->ioctl_if][pAd->ApCfg.MBSSID[pObj->ioctl_if].DefaultKeyId].KeyLen = (UCHAR) pKey->KeyLength;
+common/p2p_cfg.c:				NdisMoveMemory(&pAd->SharedKey[pObj->ioctl_if][pAd->ApCfg.MBSSID[pObj->ioctl_if].DefaultKeyId].Key, &pKey->KeyMaterial, pKey->KeyLength);
+common/p2p_cfg.c:					pAd->ApCfg.MBSSID[pObj->ioctl_if].DefaultKeyId = (UCHAR) KeyIdx;
+common/p2p_cfg.c:				Status = copy_from_user(&pAd->ApCfg.MBSSID[pObj->ioctl_if].DefaultKeyId, wrq->u.data.pointer, wrq->u.data.length);
+common/p2p_cfg.c:                    if (pAd->ApCfg.MBSSID[pObj->ioctl_if].AuthMode != AuthMode)
+common/p2p_cfg.c:                        pAd->bConfigChanged = TRUE;
+common/p2p_cfg.c:                    pAd->ApCfg.MBSSID[pObj->ioctl_if].AuthMode = AuthMode;
+common/p2p_cfg.c:                pAd->ApCfg.MBSSID[pObj->ioctl_if].PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+common/p2p_cfg.c:                DBGPRINT(RT_DEBUG_TRACE, ("Set::OID_802_11_AUTHENTICATION_MODE (=%d) \n",pAd->ApCfg.MBSSID[0].AuthMode));
+common/p2p_cfg.c:                    if (pAd->ApCfg.MBSSID[pObj->ioctl_if].WepStatus != WepStatus)
+common/p2p_cfg.c:                        pAd->bConfigChanged = TRUE;
+common/p2p_cfg.c:                    pAd->ApCfg.MBSSID[pObj->ioctl_if].WepStatus     = WepStatus;
+common/p2p_cfg.c:                    if (pAd->ApCfg.MBSSID[pObj->ioctl_if].WepStatus == Ndis802_11Encryption4Enabled){
+common/p2p_cfg.c:						pAd->ApCfg.MBSSID[pObj->ioctl_if].GroupKeyWepStatus = Ndis802_11Encryption2Enabled;
+common/p2p_cfg.c:                    	pAd->ApCfg.MBSSID[pObj->ioctl_if].GroupKeyWepStatus = WepStatus;
+common/p2p_cfg.c:						NdisZeroMemory((PCHAR)pAd->ApCfg.MBSSID[pObj->ioctl_if].Ssid,MAX_LEN_OF_SSID);
+common/p2p_cfg.c:						strcpy((PCHAR)pAd->ApCfg.MBSSID[pObj->ioctl_if].Ssid,pSsidString);
+common/p2p_cfg.c:						pAd->ApCfg.MBSSID[pObj->ioctl_if].SsidLen=strlen(pSsidString);
+common/p2p_cfg.c:			pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:					KeyIdx=pAd->ApCfg.MBSSID[pEntry->apidx].DefaultKeyId;
+common/p2p_cfg.c:					pMbss = &pAd->ApCfg.MBSSID[apidx];
+common/p2p_cfg.c:						pAd->SharedKey[apidx][KeyIdx].KeyLen = (UCHAR) Key.ik_keylen;
+common/p2p_cfg.c:						NdisMoveMemory(pAd->SharedKey[apidx][KeyIdx].Key, &Key.ik_keydata, Key.ik_keylen);
+common/p2p_cfg.c:						pAd->SharedKey[apidx][KeyIdx].CipherAlg = Key.ik_type;
+common/p2p_cfg.c:						  	&pAd->SharedKey[apidx][KeyIdx]
+common/p2p_cfg.c:							pAd->SharedKey[apidx][pMbss->DefaultKeyId].CipherAlg,
+common/p2p_cfg.c:				pMbss = &pAd->ApCfg.MBSSID[apidx];
+common/p2p_cfg.c:				if (pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus == Ndis802_11Encryption2Enabled)
+common/p2p_cfg.c:					pAd->SharedKey[apidx][pMbss->DefaultKeyId].KeyLen= LEN_TK;
+common/p2p_cfg.c:					NdisMoveMemory(pAd->SharedKey[apidx][pMbss->DefaultKeyId].Key, Key.ik_keydata, 16);
+common/p2p_cfg.c:					NdisMoveMemory(pAd->SharedKey[apidx][pMbss->DefaultKeyId].RxMic, (Key.ik_keydata+16+8), 8);
+common/p2p_cfg.c:					NdisMoveMemory(pAd->SharedKey[apidx][pMbss->DefaultKeyId].TxMic, (Key.ik_keydata+16), 8);
+common/p2p_cfg.c:				if(pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus == Ndis802_11Encryption3Enabled)
+common/p2p_cfg.c:					pAd->SharedKey[apidx][pMbss->DefaultKeyId].KeyLen= LEN_TK;	
+common/p2p_cfg.c:					NdisMoveMemory(pAd->SharedKey[apidx][pMbss->DefaultKeyId].Key, Key.ik_keydata, 16);
+common/p2p_cfg.c:					NdisMoveMemory(pAd->SharedKey[apidx][pMbss->DefaultKeyId].RxMic, (Key.ik_keydata+16+8), 8);
+common/p2p_cfg.c:					NdisMoveMemory(pAd->SharedKey[apidx][pMbss->DefaultKeyId].TxMic, (Key.ik_keydata+16), 8);
+common/p2p_cfg.c:    				pAd->SharedKey[apidx][pMbss->DefaultKeyId].CipherAlg  = CIPHER_NONE;
+common/p2p_cfg.c:    				if (pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus == Ndis802_11Encryption2Enabled)
+common/p2p_cfg.c:        				pAd->SharedKey[apidx][pMbss->DefaultKeyId].CipherAlg = CIPHER_TKIP;
+common/p2p_cfg.c:    				else if (pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus == Ndis802_11Encryption3Enabled)
+common/p2p_cfg.c:        				pAd->SharedKey[apidx][pMbss->DefaultKeyId].CipherAlg = CIPHER_AES;
+common/p2p_cfg.c:					&pAd->SharedKey[apidx][pMbss->DefaultKeyId]
+common/p2p_cfg.c:									pAd->SharedKey[apidx][pMbss->DefaultKeyId].CipherAlg, Wcid, SHAREDKEYTABLE);
+common/p2p_cfg.c:				pAd->SharedKey[apidx][pMbss->DefaultKeyId].CipherAlg,
+common/p2p_cfg.c:							/*pAd->StaCfg.PortSecured= WPA_802_1X_PORT_SECURED; */
+common/p2p_cfg.c:					if (pAd->ApCfg.MBSSID[pObj->ioctl_if].IEEE8021X != TRUE) 
+common/p2p_cfg.c:					pMbss = &pAd->ApCfg.MBSSID[apidx];
+common/p2p_cfg.c:					pEntry->AuthMode=pAd->ApCfg.MBSSID[apidx].AuthMode;
+common/p2p_cfg.c:					pEntry->PairwiseKey.KeyLen = pAd->SharedKey[apidx][KeyIdx].KeyLen;
+common/p2p_cfg.c:					NdisMoveMemory(pEntry->PairwiseKey.Key, pAd->SharedKey[apidx][KeyIdx].Key, pAd->SharedKey[apidx][KeyIdx].KeyLen);
+common/p2p_cfg.c:					pEntry->PairwiseKey.CipherAlg = pAd->SharedKey[apidx][KeyIdx].CipherAlg;
+common/p2p_cfg.c:				pAd->ApCfg.MBSSID[apidx].Hostapd = hostapd_enable;
+common/p2p_cfg.c:				       if (pAd->ApCfg.MBSSID[v].Hostapd == TRUE)
+common/p2p_cfg.c:					pMBSSStruct = &pAd->ApCfg.MBSSID[v];
+common/p2p_cfg.c:							pAd->ApCfg.CMTimerRunning = FALSE;
+common/p2p_cfg.c:						        	MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[i];
+common/p2p_cfg.c:						                MlmeDeAuthAction(pAd, &pAd->MacTab.Content[i], REASON_MIC_FAILURE,FALSE);
+common/p2p_cfg.c:						        pAd->ApCfg.BANClass3Data = TRUE;        
+common/p2p_cfg.c:    					    pAd->ApCfg.BANClass3Data = FALSE;
+common/p2p_cfg.c:					pAd->ApCfg.MBSSID[apidx].HostapdWPS = TRUE;
+common/p2p_cfg.c:					pMBSSStruct = &pAd->ApCfg.MBSSID[apidx];
+common/p2p_cfg.c:					pAd->ApCfg.MBSSID[apidx].HostapdWPS = TRUE;
+common/p2p_cfg.c:					pMBSSStruct = &pAd->ApCfg.MBSSID[apidx];
+common/p2p_cfg.c:    POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->P2pCfg.ConnectingMAC, wrq->u.data.length);
+common/p2p_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->P2pCfg.Rule, wrq->u.data.length);
+common/p2p_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_MODE (Len=%d, Rule=%d)\n", sizeof(char), pAd->P2pCfg.Rule));
+common/p2p_cfg.c:			wrq->u.data.length = pAd->P2pCfg.DeviceNameLen;
+common/p2p_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, pAd->P2pCfg.DeviceName, pAd->P2pCfg.DeviceNameLen);
+common/p2p_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_DEVICE_NAME (Len=%ld, DeviceName=%s)\n", pAd->P2pCfg.DeviceNameLen, pAd->P2pCfg.DeviceName));
+common/p2p_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->P2pCfg.ListenChannel, wrq->u.data.length);
+common/p2p_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_LISTEN_CHANNEL (Len=%d, Listen_Ch=%d)\n", sizeof(char),pAd->P2pCfg.ListenChannel));
+common/p2p_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->P2pCfg.GroupChannel, wrq->u.data.length);
+common/p2p_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_OPERATION_CHANNEL (Len=%d, Op_Ch=%d)\n", sizeof(char),pAd->P2pCfg.GroupOpChannel));
+common/p2p_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, pAd->P2pCfg.CurrentAddress, wrq->u.data.length);
+common/p2p_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_DEV_ADDR (Len=%d, Addr=%02x:%02x:%02x:%02x:%02x:%02x)\n", wrq->u.data.length, PRINT_MAC(pAd->P2pCfg.CurrentAddress)));
+common/p2p_cfg.c:			pP2PCtrl = &pAd->P2pCfg;
+common/p2p_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_MODE (Len=%ld, DeviceName=%s)\n", pAd->P2pCfg.DeviceNameLen,pAd->P2pCfg.DeviceName));
+common/p2p_cfg.c:			pP2PCtrl = &pAd->P2pCfg;
+common/p2p_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_MODE (Len=%ld, DeviceName=%s)\n", pAd->P2pCfg.DeviceNameLen,pAd->P2pCfg.DeviceName));
+common/p2p_cfg.c:			pP2PCtrl = &pAd->P2pCfg;
+common/p2p_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_MODE (Len=%ld, DeviceName=%s)\n", pAd->P2pCfg.DeviceNameLen,pAd->P2pCfg.DeviceName));
+common/p2p_cfg.c:			pP2pTable = &pAd->P2pTable;
+common/p2p_cfg.c:				pUI_table->ClientNumber = pAd->P2pTable.ClientNumber;
+common/p2p_cfg.c:				for (i=0; i < pAd->P2pTable.ClientNumber; i++)
+common/p2p_cfg.c:			WscPinCode = pAd->ApCfg.ApCliTab[0].WscControl.WscEnrolleePinCode;
+common/p2p_cfg.c:				pWscControl = &pAd->ApCfg.MBSSID[0].WscControl;
+common/p2p_cfg.c:					pEntry = &pAd->MacTab.Content[i];
+common/p2p_cfg.c:				pWscControl = &pAd->ApCfg.ApCliTab[0].WscControl;
+common/p2p_cfg.c:					pEntry = &pAd->MacTab.Content[i];
+common/p2p_cfg.c:				printk("OID_802_11_P2P_PEER_GROUP_ID ssid: %s\n", pAd->ApCfg.MBSSID[MAIN_MBSSID].Ssid);
+common/p2p_cfg.c:					pP2PCtrl->CurrentAddress[3], pP2PCtrl->CurrentAddress[4], pP2PCtrl->CurrentAddress[5], pAd->ApCfg.MBSSID[MAIN_MBSSID].Ssid);
+common/p2p_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->P2pCfg.GoIntentIdx, wrq->u.data.length);
+common/p2p_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_GO_INT (GoIntentIdx=%d)\n", pAd->P2pCfg.GoIntentIdx));
+common/p2p_cfg.c:			if (wrq->u.data.length >= pAd->P2pCfg.SSIDLen)
+common/p2p_cfg.c:				wrq->u.data.length = pAd->P2pCfg.SSIDLen;
+common/p2p_cfg.c:				Status = copy_to_user(wrq->u.data.pointer, pAd->P2pCfg.SSID, wrq->u.data.length);
+common/p2p_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_SSID (SSIDLen=%d)\n", pAd->P2pCfg.SSIDLen));
+common/p2p_cfg.c:			if (copy_to_user(wrq->u.data.pointer, &pAd->RfIcType, wrq->u.data.length))
+common/p2p_cfg.c:				WscStatus = pAd->ApCfg.ApCliTab[ApCliIdx].WscControl.WscStatus;
+common/p2p_cfg.c:				WscStatus = pAd->ApCfg.ApCliTab[ApCliIdx].WscControl.WscStatus;
+common/p2p_cfg.c:				WscStatus = pAd->ApCfg.MBSSID[apidx].WscControl.WscStatus;
+common/p2p_cfg.c:				WscStatus = pAd->ApCfg.MBSSID[apidx].WscControl.WscStatus;
+common/p2p_cfg.c:						pWscControl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/p2p_cfg.c:						pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p_cfg.c:			pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p_cfg.c:			WscPinCode = pAd->ApCfg.ApCliTab[0].WscControl.WscEnrolleePinCode;
+common/p2p_cfg.c:					pWscControl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/p2p_cfg.c:					pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p_cfg.c:			pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p_cfg.c:			if (copy_to_user(wrq->u.data.pointer, pAd->ApCfg.MBSSID[apidx].Bssid, wrq->u.data.length))
+common/p2p_cfg.c:			if (copy_to_user(wrq->u.data.pointer, &pAd->ApCfg.MBSSID[apidx].WscControl.WscConfStatus, wrq->u.data.length))
+common/p2p_cfg.c:			if (pAd->ApCfg.MBSSID[apidx].WscControl.WscState > WSC_STATE_WAIT_M2)
+common/p2p_cfg.c:				if (copy_to_user(wrq->u.data.pointer, &pAd->ApCfg.MBSSID[apidx].WscControl.WscPeerInfo, wrq->u.data.length))
+common/p2p_cfg.c:					pWscControl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/p2p_cfg.c:					pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p_cfg.c:			pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::RT_OID_WSC_V2_SUPPORT (=%d)\n", pAd->ApCfg.MBSSID[apidx].WscControl.WscV2Info.bEnableWpsV2));
+common/p2p_cfg.c:			if (copy_to_user(wrq->u.data.pointer, &pAd->ApCfg.MBSSID[apidx].WscControl.WscV2Info.bEnableWpsV2, wrq->u.data.length))
+common/p2p_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::RT_OID_WSC_FRAGMENT_SIZE (=%d)\n", pAd->ApCfg.MBSSID[apidx].WscControl.WscFragSize));
+common/p2p_cfg.c:			if (copy_to_user(wrq->u.data.pointer, &pAd->ApCfg.MBSSID[apidx].WscControl.WscFragSize, wrq->u.data.length))
+common/p2p_cfg.c:            		if (IS_ENTRY_CLIENT(&pAd->MacTab.Content[i]) && (pAd->MacTab.Content[i].Sst == SST_ASSOC))
+common/p2p_cfg.c:            			COPY_MAC_ADDR(AssocTab.Entry[AssocTab.Num].Addr, &pAd->MacTab.Content[i].Addr);
+common/p2p_cfg.c:                        AssocTab.Entry[AssocTab.Num].phyMode = pAd->CommonCfg.PhyMode;
+common/p2p_cfg.c:                        AssocTab.Entry[AssocTab.Num].MOR = RateIdToMbps[pAd->ApCfg.MBSSID[apidx].MaxTxRate] * 2;
+common/p2p_cfg.c:            Status = copy_to_user(wrq->u.data.pointer, &pAd->CurrentAddress, wrq->u.data.length);
+common/p2p_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->CurrentAddress, wrq->u.data.length);
+common/p2p_cfg.c:			/*KeyIdxValue.KeyIdx = pAd->PortCfg.MBSSID[pObj->ioctl_if].DefaultKeyId; */
+common/p2p_cfg.c:			valueLen = pAd->SharedKey[pObj->ioctl_if][pAd->ApCfg.MBSSID[pObj->ioctl_if].DefaultKeyId].KeyLen;
+common/p2p_cfg.c:						   &pAd->SharedKey[pObj->ioctl_if][pAd->ApCfg.MBSSID[pObj->ioctl_if].DefaultKeyId].Key,
+common/p2p_cfg.c:			DBGPRINT(RT_DEBUG_TRACE,("DefaultKeyId = %d, total len = %d, str len=%d, KeyValue= %02x %02x %02x %02x \n", pAd->ApCfg.MBSSID[pObj->ioctl_if].DefaultKeyId, wrq->u.data.length, pAd->SharedKey[pObj->ioctl_if][pAd->ApCfg.MBSSID[pObj->ioctl_if].DefaultKeyId].KeyLen,
+common/p2p_cfg.c:			pAd->SharedKey[pObj->ioctl_if][0].Key[0],
+common/p2p_cfg.c:			pAd->SharedKey[pObj->ioctl_if][1].Key[0],
+common/p2p_cfg.c:			pAd->SharedKey[pObj->ioctl_if][2].Key[0],
+common/p2p_cfg.c:			pAd->SharedKey[pObj->ioctl_if][3].Key[0]));
+common/p2p_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->ApCfg.MBSSID[pObj->ioctl_if].DefaultKeyId, wrq->u.data.length);
+common/p2p_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("DefaultKeyId =%d \n", pAd->ApCfg.MBSSID[pObj->ioctl_if].DefaultKeyId));
+common/p2p_cfg.c:									&pAd->SharedKey[pObj->ioctl_if][pAd->ApCfg.MBSSID[pObj->ioctl_if].DefaultKeyId].KeyLen,
+common/p2p_cfg.c:						RtmpOsGetUsbDevVendorID(((POS_COOKIE)pAd->OS_Cookie)->pUsb_Dev),
+common/p2p_cfg.c:						RtmpOsGetUsbDevProductID(((POS_COOKIE)pAd->OS_Cookie)->pUsb_Dev));
+common/p2p_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("sizeof UCHAR=%d, channel=%d \n", sizeof(UCHAR), pAd->CommonCfg.Channel));
+common/p2p_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->CommonCfg.Channel, wrq->u.data.length);
+common/p2p_cfg.c:		  pStatistics->TransmittedFragmentCount.QuadPart = pAd->WlanCounters.TransmittedFragmentCount.QuadPart + pAd->WlanCounters.MulticastTransmittedFrameCount.QuadPart;
+common/p2p_cfg.c:                pStatistics->MulticastTransmittedFrameCount.QuadPart = pAd->WlanCounters.MulticastTransmittedFrameCount.QuadPart;
+common/p2p_cfg.c:                pStatistics->FailedCount.QuadPart = pAd->WlanCounters.FailedCount.QuadPart;
+common/p2p_cfg.c:                pStatistics->RetryCount.QuadPart = pAd->WlanCounters.RetryCount.QuadPart;
+common/p2p_cfg.c:                pStatistics->MultipleRetryCount.QuadPart = pAd->WlanCounters.MultipleRetryCount.QuadPart;
+common/p2p_cfg.c:                pStatistics->RTSSuccessCount.QuadPart = pAd->WlanCounters.RTSSuccessCount.QuadPart;
+common/p2p_cfg.c:                pStatistics->RTSFailureCount.QuadPart = pAd->WlanCounters.RTSFailureCount.QuadPart;
+common/p2p_cfg.c:                pStatistics->ACKFailureCount.QuadPart = pAd->WlanCounters.ACKFailureCount.QuadPart;
+common/p2p_cfg.c:                pStatistics->FrameDuplicateCount.QuadPart = pAd->WlanCounters.FrameDuplicateCount.QuadPart;
+common/p2p_cfg.c:                pStatistics->ReceivedFragmentCount.QuadPart = pAd->WlanCounters.ReceivedFragmentCount.QuadPart;
+common/p2p_cfg.c:                pStatistics->MulticastReceivedFrameCount.QuadPart = pAd->WlanCounters.MulticastReceivedFrameCount.QuadPart;
+common/p2p_cfg.c:                pStatistics->FCSErrorCount = pAd->RalinkCounters.RealFcsErrCount;
+common/p2p_cfg.c:                pStatistics->FCSErrorCount.QuadPart = pAd->WlanCounters.FCSErrorCount.QuadPart;
+common/p2p_cfg.c:                pStatistics->FrameDuplicateCount.u.LowPart = pAd->WlanCounters.FrameDuplicateCount.u.LowPart / 100;
+common/p2p_cfg.c:			pStatistics->TransmittedFrameCount.QuadPart = pAd->WlanCounters.TransmittedFragmentCount.QuadPart;
+common/p2p_cfg.c:			pStatistics->WEPUndecryptableCount.QuadPart = pAd->WlanCounters.WEPUndecryptableCount.QuadPart;
+common/p2p_cfg.c:			PMULTISSID_STRUCT	pMbss = &pAd->ApCfg.MBSSID[apidx];
+common/p2p_cfg.c:			if (pAd->chipCap.FlgHwTxBfCap)
+common/p2p_cfg.c:					if (IS_ENTRY_CLIENT(&pAd->MacTab.Content[i]) && (pAd->MacTab.Content[i].Sst == SST_ASSOC))
+common/p2p_cfg.c:						memcpy(&MacTab.Entry[MacTab.Num], &pAd->MacTab.Content[i].TxBFCounters, sizeof(RT_COUNTER_TXBF));
+common/p2p_cfg.c:				pMbss = &pAd->ApCfg.MBSSID[pObj->ioctl_if];					
+common/p2p_cfg.c:								   pAd->SharedKey[pObj->ioctl_if][pMbss->DefaultKeyId].TxTsc,
+common/p2p_cfg.c:			pMbss = &pAd->ApCfg.MBSSID[apidx];
+common/p2p_cfg.c:				NdisMoveMemory(p+2, pAd->SharedKey[apidx][ pMbss->DefaultKeyId].TxTsc, 6);
+common/p2p_cfg.c:			pMbss = &pAd->ApCfg.MBSSID[apidx];
+common/p2p_cfg.c:				if(pAd->SharedKey[apidx][ pMbss->DefaultKeyId].KeyLen!=0 && pAd->SharedKey[apidx][ pMbss->DefaultKeyId].Key!=NULL)
+common/p2p_cfg.c:					group_key.ik_keylen = pAd->SharedKey[apidx][ pMbss->DefaultKeyId].KeyLen;
+common/p2p_cfg.c:					NdisMoveMemory(group_key.ik_keydata, pAd->SharedKey[apidx][ pMbss->DefaultKeyId].Key,pAd->SharedKey[apidx][ pMbss->DefaultKeyId].KeyLen);
+common/p2p_cfg.c:					pApCliEntry = &pAd->ApCfg.ApCliTab[ApCliIdx];
+common/p2p_cfg.c:					pEntry = &pAd->MacTab.Content[pApCliEntry->MacTabWCID]; 
+common/p2p_cfg.c:						if ((pAd->ApCfg.ApCliTab[ApCliIdx].Valid == TRUE)
+common/p2p_cfg.c:		NdisMoveMemory(pAd->CommonCfg.CountryCode, arg, 2);
+common/p2p_cfg.c:		pAd->CommonCfg.bCountryFlag = TRUE;
+common/p2p_cfg.c:		NdisZeroMemory(pAd->CommonCfg.CountryCode, 3);
+common/p2p_cfg.c:		pAd->CommonCfg.bCountryFlag = FALSE;
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_CountryCode_Proc::(bCountryFlag=%d, CountryCode=%s)\n", pAd->CommonCfg.bCountryFlag, pAd->CommonCfg.CountryCode));
+common/p2p_cfg.c:		pAd->CommonCfg.Geography = Geography;
+common/p2p_cfg.c:	pAd->CommonCfg.CountryCode[2] =
+common/p2p_cfg.c:		(pAd->CommonCfg.Geography == BOTH) ? ' ' : ((pAd->CommonCfg.Geography == IDOR) ? 'I' : 'O');
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_ERROR, ("Set_ChannelGeography_Proc:: Geography = %s\n", pAd->CommonCfg.Geography == ODOR ? "out-door" : (pAd->CommonCfg.Geography == IDOR ? "in-door" : "both")));
+common/p2p_cfg.c:		if (WMODE_CAP_2G(pAd->CommonCfg.PhyMode))
+common/p2p_cfg.c:			if (pAd->CommonCfg.CountryRegionForABand & 0x80)
+common/p2p_cfg.c:					NdisZeroMemory(pAd->CommonCfg.CountryCode, 3);
+common/p2p_cfg.c:					NdisMoveMemory(pAd->CommonCfg.CountryCode, allCountry[index].IsoName, 2);
+common/p2p_cfg.c:					pAd->CommonCfg.CountryCode[2] = ' ';
+common/p2p_cfg.c:					pAd->CommonCfg.bCountryFlag = TRUE;
+common/p2p_cfg.c:					pAd->CommonCfg.CountryRegion = (UCHAR) allCountry[index].RegDomainNum11G;
+common/p2p_cfg.c:		else if (WMODE_CAP_5G(pAd->CommonCfg.PhyMode))
+common/p2p_cfg.c:			if (pAd->CommonCfg.CountryRegion & 0x80)
+common/p2p_cfg.c:					NdisZeroMemory(pAd->CommonCfg.CountryCode, 3);
+common/p2p_cfg.c:					NdisMoveMemory(pAd->CommonCfg.CountryCode, allCountry[index].IsoName, 2);
+common/p2p_cfg.c:					pAd->CommonCfg.CountryCode[2] = ' ';
+common/p2p_cfg.c:					pAd->CommonCfg.bCountryFlag = TRUE;
+common/p2p_cfg.c:					pAd->CommonCfg.CountryRegionForABand = (UCHAR) allCountry[index].RegDomainNum11A;
+common/p2p_cfg.c:							allCountry[index].pCountryName, pAd->CommonCfg.CountryRegion, pAd->CommonCfg.CountryCode));
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	NdisZeroMemory(pAd->ApCfg.MBSSID[pObj->ioctl_if].DesiredRates, MAX_LEN_OF_SUPPORTED_RATES);
+common/p2p_cfg.c:	pAd->ApCfg.MBSSID[pObj->ioctl_if].DesiredRatesIndex = simple_strtol(arg, 0, 10);
+common/p2p_cfg.c:	/* todo RTMPBuildDesireRate(pAd, pObj->ioctl_if, pAd->ApCfg.MBSSID[pObj->ioctl_if].DesiredRatesIndex); */
+common/p2p_cfg.c:		pAd->CommonCfg.BeaconPeriod = BeaconPeriod;
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_BeaconPeriod_Proc::(BeaconPeriod=%d)\n", pAd->CommonCfg.BeaconPeriod));
+common/p2p_cfg.c:		pAd->ApCfg.DtimPeriod = DtimPeriod;
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_DtimPeriod_Proc::(DtimPeriod=%d)\n", pAd->ApCfg.DtimPeriod));
+common/p2p_cfg.c:			pAd->CommonCfg.DisableOLBCDetect = 0;
+common/p2p_cfg.c:			pAd->CommonCfg.DisableOLBCDetect = 1;
+common/p2p_cfg.c:	POS_COOKIE	pObj= (POS_COOKIE)pAd->OS_Cookie;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[pObj->ioctl_if].bWmmCapable = TRUE;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[pObj->ioctl_if].bWmmCapable = FALSE;
+common/p2p_cfg.c:	pAd->ApCfg.MBSSID[pObj->ioctl_if].bWmmCapableOrg = \
+common/p2p_cfg.c:								pAd->ApCfg.MBSSID[pObj->ioctl_if].bWmmCapable;
+common/p2p_cfg.c:		rtl865x_extDev_unregisterUcastTxDev(pAd->net_dev);		
+common/p2p_cfg.c:		pObj->ioctl_if, pAd->ApCfg.MBSSID[pObj->ioctl_if].bWmmCapable));
+common/p2p_cfg.c:	POS_COOKIE	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	POS_COOKIE	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[pObj->ioctl_if].IsolateInterStaTraffic = TRUE;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[pObj->ioctl_if].IsolateInterStaTraffic = FALSE;
+common/p2p_cfg.c:		pObj->ioctl_if, pAd->ApCfg.MBSSID[pObj->ioctl_if].IsolateInterStaTraffic));
+common/p2p_cfg.c:		pAd->ApCfg.IsolateInterStaTrafficBTNBSSID = TRUE;
+common/p2p_cfg.c:		pAd->ApCfg.IsolateInterStaTrafficBTNBSSID = FALSE;
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_NoForwardingBTNSSID_Proc::(NoForwarding=%ld)\n", pAd->ApCfg.IsolateInterStaTrafficBTNBSSID));
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[pObj->ioctl_if].bHideSsid != bHideSsid)
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[pObj->ioctl_if].bHideSsid = bHideSsid;
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[pObj->ioctl_if].WscControl.WscV2Info.bEnableWpsV2)
+common/p2p_cfg.c:		WscOnOff(pAd, pObj->ioctl_if, pAd->ApCfg.MBSSID[pObj->ioctl_if].bHideSsid);
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d) Set_HideSSID_Proc::(HideSSID=%d)\n", pObj->ioctl_if, pAd->ApCfg.MBSSID[pObj->ioctl_if].bHideSsid));
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pAd->ApCfg.MBSSID[pObj->ioctl_if].VLAN_VID = simple_strtol(arg, 0, 10);
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d) Set_VLANID_Proc::(VLAN_VID=%d)\n", pObj->ioctl_if, pAd->ApCfg.MBSSID[pObj->ioctl_if].VLAN_VID));
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pAd->ApCfg.MBSSID[pObj->ioctl_if].VLAN_Priority = simple_strtol(arg, 0, 10);
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d) Set_VLANPriority_Proc::(VLAN_Priority=%d)\n", pObj->ioctl_if, pAd->ApCfg.MBSSID[pObj->ioctl_if].VLAN_Priority));
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	if (apidx >= pAd->ApCfg.BssidNum)
+common/p2p_cfg.c:		if (IS_ENTRY_CLIENT(&pAd->MacTab.Content[i]))
+common/p2p_cfg.c:			pAd->MacTab.Content[i].PortSecured  = WPA_802_1X_PORT_NOT_SECURED;
+common/p2p_cfg.c:	pAd->ApCfg.MBSSID[apidx].PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+common/p2p_cfg.c:	if(pAd->ApCfg.MBSSID[apidx].AuthMode >= Ndis802_11AuthModeWPA)
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].DefaultKeyId = 1;
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11WEPDisabled;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11WEPEnabled;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11Encryption2Enabled;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11Encryption3Enabled;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11Encryption4Enabled;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11EncryptionSMS4Enabled;
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].WepStatus >= Ndis802_11Encryption2Enabled)
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].DefaultKeyId = 1;
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11Encryption4Enabled)	
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus = Ndis802_11Encryption2Enabled;		
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus = pAd->ApCfg.MBSSID[apidx].WepStatus;
+common/p2p_cfg.c:    /*RTMPMakeRSNIE(pAd, pAd->ApCfg.MBSSID[apidx].AuthMode, pAd->ApCfg.MBSSID[apidx].WepStatus, apidx); */
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d) Set_EncrypType_Proc::(EncrypType=%d)\n", apidx, pAd->ApCfg.MBSSID[apidx].WepStatus));
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WpaMixPairCipher = WPA_AES_WPA2_TKIPAES;																			
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WpaMixPairCipher = WPA_AES_WPA2_TKIP;								 						
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WpaMixPairCipher = WPA_TKIP_WPA2_AES;								
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WpaMixPairCipher = WPA_TKIP_WPA2_TKIPAES;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WpaMixPairCipher = WPA_TKIPAES_WPA2_AES;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WpaMixPairCipher = WPA_TKIPAES_WPA2_TKIPAES;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WpaMixPairCipher = WPA_TKIPAES_WPA2_TKIP;
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("I/F(ra%d) Set_AP_WpaMixPairCipher_Proc=0x%02x\n", apidx, pAd->ApCfg.MBSSID[apidx].WpaMixPairCipher));
+common/p2p_cfg.c:	POS_COOKIE 	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WPAREKEY.ReKeyInterval = val;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WPAREKEY.ReKeyInterval = 3600;
+common/p2p_cfg.c:								apidx, pAd->ApCfg.MBSSID[apidx].WPAREKEY.ReKeyInterval));
+common/p2p_cfg.c:	POS_COOKIE 	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	PRT_WPA_REKEY	pInfo = &pAd->ApCfg.MBSSID[apidx].WPAREKEY;
+common/p2p_cfg.c:	POS_COOKIE 	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pAd->ApCfg.MBSSID[apidx].PMKCachePeriod = val * 60 * OS_HZ;
+common/p2p_cfg.c:									apidx, pAd->ApCfg.MBSSID[apidx].PMKCachePeriod));
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].DefaultKeyId = (UCHAR) (KeyIdx - 1 );
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d) Set_DefaultKeyID_Proc::(DefaultKeyID(0~3)=%d)\n", apidx, pAd->ApCfg.MBSSID[apidx].DefaultKeyId));
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pSharedKey = &pAd->SharedKey[apidx][0];
+common/p2p_cfg.c:		if (pAd->ApCfg.MBSSID[apidx].AuthMode >= Ndis802_11AuthModeWPA)
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pSharedKey = &pAd->SharedKey[apidx][1];
+common/p2p_cfg.c:		if (pAd->ApCfg.MBSSID[apidx].AuthMode >= Ndis802_11AuthModeWPA)
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pSharedKey = &pAd->SharedKey[apidx][2];
+common/p2p_cfg.c:		if (pAd->ApCfg.MBSSID[apidx].AuthMode >= Ndis802_11AuthModeWPA)
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pSharedKey = &pAd->SharedKey[apidx][3];
+common/p2p_cfg.c:		if (pAd->ApCfg.MBSSID[apidx].AuthMode >= Ndis802_11AuthModeWPA)
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:			pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Policy = 0;
+common/p2p_cfg.c:			pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Policy = 1;
+common/p2p_cfg.c:			pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Policy = 2;
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d) Set_AccessPolicy_Proc::(AccessPolicy=%ld)\n", pObj->ioctl_if, pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Policy));
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Num >= (MAX_NUM_OF_ACL_LIST - 1))
+common/p2p_cfg.c:	NdisMoveMemory(pacl, &pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList, sizeof(RT_802_11_ACL));
+common/p2p_cfg.c:	NdisZeroMemory(&pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList, sizeof(RT_802_11_ACL));
+common/p2p_cfg.c:	NdisMoveMemory(&pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList, pacl, sizeof(RT_802_11_ACL));
+common/p2p_cfg.c:		__FUNCTION__ , pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Policy, pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Num));
+common/p2p_cfg.c:	for (i=0; i<pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Num; i++)
+common/p2p_cfg.c:		   printk("%02X ", pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Entry[i].Addr[j]);
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	NdisMoveMemory(&acl, &pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList, sizeof(RT_802_11_ACL));
+common/p2p_cfg.c:	NdisZeroMemory(&pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList, sizeof(RT_802_11_ACL));
+common/p2p_cfg.c:	pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Policy = acl.Policy;
+common/p2p_cfg.c:	ASSERT(pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Num == 0);
+common/p2p_cfg.c:			NdisMoveMemory(&(pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Entry[i++]), acl.Entry[j].Addr, MAC_ADDR_LEN);
+common/p2p_cfg.c:	pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Num = i;
+common/p2p_cfg.c:	ASSERT(acl.Num >= pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Num);
+common/p2p_cfg.c:		__FUNCTION__ , pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Policy, pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Num));
+common/p2p_cfg.c:	for (i=0; i<pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Num; i++)
+common/p2p_cfg.c:		   printk("%02X ", pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Entry[i].Addr[j]);
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	NdisMoveMemory(&acl, &pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList, sizeof(RT_802_11_ACL));
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	NdisMoveMemory(pacl, &pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList, sizeof(RT_802_11_ACL));
+common/p2p_cfg.c:	NdisZeroMemory(&(pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList), sizeof(RT_802_11_ACL));
+common/p2p_cfg.c:	NdisMoveMemory(&(pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList), pacl, sizeof(RT_802_11_ACL));
+common/p2p_cfg.c:		__FUNCTION__, pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Policy, pAd->ApCfg.MBSSID[pObj->ioctl_if].AccessControlList.Num));
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pMBSSStruct = &pAd->ApCfg.MBSSID[apidx];
+common/p2p_cfg.c:		PRT_P2P_CONFIG pP2pCfg = &pAd->P2pCfg;
+common/p2p_cfg.c:		pAd->ApCfg.AutoChannelAlg = ChannelAlgApCnt;
+common/p2p_cfg.c:		pAd->ApCfg.AutoChannelAlg = ChannelAlgCCA;
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_AutoChannelSel_Proc Alg=%d \n", pAd->ApCfg.AutoChannelAlg));
+common/p2p_cfg.c:	printk("HT Operating Mode : %d\n", pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode);
+common/p2p_cfg.c:		PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[i];
+common/p2p_cfg.c:	for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/p2p_cfg.c:							pAd->ApCfg.MBSSID[apidx].AuthMode, 
+common/p2p_cfg.c:							GetAuthMode(pAd->ApCfg.MBSSID[apidx].AuthMode), 
+common/p2p_cfg.c:							pAd->ApCfg.MBSSID[apidx].WepStatus, 
+common/p2p_cfg.c:							GetEncryptType(pAd->ApCfg.MBSSID[apidx].WepStatus), 
+common/p2p_cfg.c:							pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus, 
+common/p2p_cfg.c:							GetEncryptType(pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus),
+common/p2p_cfg.c:							pAd->ApCfg.MBSSID[apidx].WpaMixPairCipher);		
+common/p2p_cfg.c:		PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[i];
+common/p2p_cfg.c:		PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[i];
+common/p2p_cfg.c:				pRecBAEntry =&pAd->BATable.BARecEntry[pEntry->BARecWcidArray[j]];
+common/p2p_cfg.c:				pOriBAEntry =&pAd->BATable.BAOriEntry[pEntry->BAOriWcidArray[j]];
+common/p2p_cfg.c:	printk("TransmittedFragmentCount = %d\n", pAd->WlanCounters.TransmittedFragmentCount.u.LowPart + pAd->WlanCounters.MulticastTransmittedFrameCount.QuadPart);
+common/p2p_cfg.c:	printk("MulticastTransmittedFrameCount = %d\n", pAd->WlanCounters.MulticastTransmittedFrameCount.u.LowPart);
+common/p2p_cfg.c:	printk("FailedCount = %d\n", pAd->WlanCounters.FailedCount.u.LowPart);
+common/p2p_cfg.c:	printk("RetryCount = %d\n", pAd->WlanCounters.RetryCount.u.LowPart);
+common/p2p_cfg.c:	printk("MultipleRetryCount = %d\n", pAd->WlanCounters.MultipleRetryCount.u.LowPart);
+common/p2p_cfg.c:	printk("RTSSuccessCount = %d\n", pAd->WlanCounters.RTSSuccessCount.u.LowPart);
+common/p2p_cfg.c:	printk("RTSFailureCount = %d\n", pAd->WlanCounters.RTSFailureCount.u.LowPart);
+common/p2p_cfg.c:	printk("ACKFailureCount = %d\n", pAd->WlanCounters.ACKFailureCount.u.LowPart);
+common/p2p_cfg.c:	printk("FrameDuplicateCount = %d\n", pAd->WlanCounters.FrameDuplicateCount.u.LowPart);
+common/p2p_cfg.c:	printk("ReceivedFragmentCount = %d\n", pAd->WlanCounters.ReceivedFragmentCount.u.LowPart);
+common/p2p_cfg.c:	printk("MulticastReceivedFrameCount = %d\n", pAd->WlanCounters.MulticastReceivedFrameCount.u.LowPart);
+common/p2p_cfg.c:	printk("RealFcsErrCount = %d\n", pAd->RalinkCounters.RealFcsErrCount.u.LowPart);
+common/p2p_cfg.c:	printk("FCSErrorCount = %d\n", pAd->WlanCounters.FCSErrorCount.u.LowPart);
+common/p2p_cfg.c:	printk("FrameDuplicateCount.LowPart = %d\n", pAd->WlanCounters.FrameDuplicateCount.u.LowPart / 100);
+common/p2p_cfg.c:	printk("TransmittedFrameCount = %d\n", pAd->WlanCounters.TransmittedFragmentCount.u.LowPart);
+common/p2p_cfg.c:	printk("WEPUndecryptableCount = %d\n", pAd->WlanCounters.WEPUndecryptableCount.u.LowPart);
+common/p2p_cfg.c:	printk("TransmittedAMSDUCount = %ld\n", (ULONG)pAd->RalinkCounters.TransmittedAMSDUCount.u.LowPart);
+common/p2p_cfg.c:	printk("TransmittedOctetsInAMSDU = %ld\n", (ULONG)pAd->RalinkCounters.TransmittedOctetsInAMSDU.QuadPart);
+common/p2p_cfg.c:	printk("ReceivedAMSDUCount = %ld\n", (ULONG)pAd->RalinkCounters.ReceivedAMSDUCount.u.LowPart);	
+common/p2p_cfg.c:	printk("ReceivedOctesInAMSDUCount = %ld\n", (ULONG)pAd->RalinkCounters.ReceivedOctesInAMSDUCount.QuadPart);	
+common/p2p_cfg.c:	printk("TransmittedAMPDUCount = %ld\n", (ULONG)pAd->RalinkCounters.TransmittedAMPDUCount.u.LowPart);
+common/p2p_cfg.c:	printk("TransmittedMPDUsInAMPDUCount = %ld\n", (ULONG)pAd->RalinkCounters.TransmittedMPDUsInAMPDUCount.u.LowPart);
+common/p2p_cfg.c:	printk("TransmittedOctetsInAMPDUCount = %ld\n", (ULONG)pAd->RalinkCounters.TransmittedOctetsInAMPDUCount.u.LowPart);
+common/p2p_cfg.c:	printk("MPDUInReceivedAMPDUCount = %ld\n", (ULONG)pAd->RalinkCounters.MPDUInReceivedAMPDUCount.u.LowPart);
+common/p2p_cfg.c:	printk("fAnyStaFortyIntolerant=%d\n", pAd->MacTab.fAnyStaFortyIntolerant);
+common/p2p_cfg.c:	for (apidx=0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/p2p_cfg.c:		printk("Packets Received = %ld\n", (ULONG)pAd->ApCfg.MBSSID[apidx].RxCount);
+common/p2p_cfg.c:		printk("Packets Sent = %ld\n", (ULONG)pAd->ApCfg.MBSSID[apidx].TxCount);
+common/p2p_cfg.c:		printk("Bytes Received = %ld\n", (ULONG)pAd->ApCfg.MBSSID[apidx].ReceivedByteCount);
+common/p2p_cfg.c:		printk("Byte Sent = %ld\n", (ULONG)pAd->ApCfg.MBSSID[apidx].TransmittedByteCount);
+common/p2p_cfg.c:		printk("Error Packets Received = %ld\n", (ULONG)pAd->ApCfg.MBSSID[apidx].RxErrorCount);
+common/p2p_cfg.c:		printk("Drop Received Packets = %ld\n", (ULONG)pAd->ApCfg.MBSSID[apidx].RxDropCount);
+common/p2p_cfg.c:		if (pAd->ApCfg.MBSSID[apidx].WscControl.WscConfMode != WSC_DISABLE)
+common/p2p_cfg.c:			pWscCtrl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p_cfg.c:		pEntry = &pAd->MacTab.Content[i];
+common/p2p_cfg.c:	printk("TransmittedFragmentCount = %d\n", pAd->WlanCounters.TransmittedFragmentCount.u.LowPart + pAd->WlanCounters.MulticastTransmittedFrameCount.QuadPart);
+common/p2p_cfg.c:	printk("MulticastTransmittedFrameCount = %d\n", pAd->WlanCounters.MulticastTransmittedFrameCount.u.LowPart);
+common/p2p_cfg.c:	printk("FailedCount = %d\n", pAd->WlanCounters.FailedCount.u.LowPart);
+common/p2p_cfg.c:	printk("RetryCount = %d\n", pAd->WlanCounters.RetryCount.u.LowPart);
+common/p2p_cfg.c:	printk("MultipleRetryCount = %d\n", pAd->WlanCounters.MultipleRetryCount.u.LowPart);
+common/p2p_cfg.c:	printk("RTSSuccessCount = %d\n", pAd->WlanCounters.RTSSuccessCount.u.LowPart);
+common/p2p_cfg.c:	printk("RTSFailureCount = %d\n", pAd->WlanCounters.RTSFailureCount.u.LowPart);
+common/p2p_cfg.c:	printk("ACKFailureCount = %d\n", pAd->WlanCounters.ACKFailureCount.u.LowPart);
+common/p2p_cfg.c:	printk("FrameDuplicateCount = %d\n", pAd->WlanCounters.FrameDuplicateCount.u.LowPart);
+common/p2p_cfg.c:	printk("ReceivedFragmentCount = %d\n", pAd->WlanCounters.ReceivedFragmentCount.u.LowPart);
+common/p2p_cfg.c:	printk("MulticastReceivedFrameCount = %d\n", pAd->WlanCounters.MulticastReceivedFrameCount.u.LowPart);
+common/p2p_cfg.c:	printk("RealFcsErrCount = %d\n", pAd->RalinkCounters.RealFcsErrCount.u.LowPart);
+common/p2p_cfg.c:	printk("FCSErrorCount = %d\n", pAd->WlanCounters.FCSErrorCount.u.LowPart);
+common/p2p_cfg.c:	printk("FrameDuplicateCount.LowPart = %d\n", pAd->WlanCounters.FrameDuplicateCount.u.LowPart / 100);
+common/p2p_cfg.c:	printk("TransmittedFrameCount = %d\n", pAd->WlanCounters.TransmittedFrameCount.u.LowPart);
+common/p2p_cfg.c:	printk("WEPUndecryptableCount = %d\n", pAd->WlanCounters.WEPUndecryptableCount.u.LowPart);
+common/p2p_cfg.c:	pAd->WlanCounters.TransmittedFragmentCount.u.LowPart = 0;
+common/p2p_cfg.c:	pAd->WlanCounters.MulticastTransmittedFrameCount.u.LowPart = 0;
+common/p2p_cfg.c:	pAd->WlanCounters.FailedCount.u.LowPart = 0;
+common/p2p_cfg.c:	pAd->WlanCounters.RetryCount.u.LowPart = 0;
+common/p2p_cfg.c:	pAd->WlanCounters.MultipleRetryCount.u.LowPart = 0;
+common/p2p_cfg.c:	pAd->WlanCounters.RTSSuccessCount.u.LowPart = 0;
+common/p2p_cfg.c:	pAd->WlanCounters.RTSFailureCount.u.LowPart = 0;
+common/p2p_cfg.c:	pAd->WlanCounters.ACKFailureCount.u.LowPart = 0;
+common/p2p_cfg.c:	pAd->WlanCounters.FrameDuplicateCount.u.LowPart = 0;
+common/p2p_cfg.c:	pAd->WlanCounters.ReceivedFragmentCount.u.LowPart = 0;
+common/p2p_cfg.c:	pAd->WlanCounters.MulticastReceivedFrameCount.u.LowPart = 0;
+common/p2p_cfg.c:	pAd->RalinkCounters.RealFcsErrCount.u.LowPart = 0;
+common/p2p_cfg.c:	pAd->WlanCounters.FCSErrorCount.u.LowPart = 0;
+common/p2p_cfg.c:	pAd->WlanCounters.FrameDuplicateCount.u.LowPart = 0;
+common/p2p_cfg.c:	pAd->WlanCounters.TransmittedFrameCount.u.LowPart = 0;
+common/p2p_cfg.c:	pAd->WlanCounters.WEPUndecryptableCount.u.LowPart = 0;
+common/p2p_cfg.c:		pEntry = &pAd->MacTab.Content[i];
+common/p2p_cfg.c:	dumpIPMacTb(&pAd->MatCfg, -1);
+common/p2p_cfg.c:	dumpSesMacTb(&pAd->MatCfg, -1);
+common/p2p_cfg.c:	dumpUidMacTb(&pAd->MatCfg, -1);
+common/p2p_cfg.c:	dumpIPv6MacTb(&pAd->MatCfg, -1);
+common/p2p_cfg.c:	pConf->mbss_num = pAd->ApCfg.BssidNum;
+common/p2p_cfg.c:	pConf->own_ip_addr = pAd->ApCfg.own_ip_addr;
+common/p2p_cfg.c:	pConf->retry_interval = pAd->ApCfg.retry_interval;
+common/p2p_cfg.c:	pConf->session_timeout_interval = pAd->ApCfg.session_timeout_interval;
+common/p2p_cfg.c:	pConf->quiet_interval = pAd->ApCfg.quiet_interval;
+common/p2p_cfg.c:	for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/p2p_cfg.c:		PMULTISSID_STRUCT 	pMbss = &pAd->ApCfg.MBSSID[apidx];
+common/p2p_cfg.c:			KeyLen = pAd->SharedKey[apidx][keyidx].KeyLen;
+common/p2p_cfg.c:				NdisMoveMemory(p1xBssInfo->key_material, pAd->SharedKey[apidx][keyidx].Key, KeyLen);
+common/p2p_cfg.c:		if (pAd->ApCfg.EAPifname_len[apidx] > 0)
+common/p2p_cfg.c:			pConf->EAPifname_len[apidx] = pAd->ApCfg.EAPifname_len[apidx];
+common/p2p_cfg.c:			NdisMoveMemory(pConf->EAPifname[apidx], pAd->ApCfg.EAPifname[apidx], pAd->ApCfg.EAPifname_len[apidx]);
+common/p2p_cfg.c:		if (pAd->ApCfg.PreAuthifname_len[apidx] > 0)
+common/p2p_cfg.c:			pConf->PreAuthifname_len[apidx] = pAd->ApCfg.PreAuthifname_len[apidx];
+common/p2p_cfg.c:			NdisMoveMemory(pConf->PreAuthifname[apidx], pAd->ApCfg.PreAuthifname[apidx], pAd->ApCfg.PreAuthifname_len[apidx]);
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	if ((pAd->ApCfg.MBSSID[pObj->ioctl_if].AuthMode == Ndis802_11AuthModeWPA) 
+common/p2p_cfg.c:    	|| (pAd->ApCfg.MBSSID[pObj->ioctl_if].AuthMode == Ndis802_11AuthModeWPA2)
+common/p2p_cfg.c:    	|| (pAd->ApCfg.MBSSID[pObj->ioctl_if].AuthMode == Ndis802_11AuthModeWPA1WPA2) 
+common/p2p_cfg.c:    	|| (pAd->ApCfg.MBSSID[pObj->ioctl_if].IEEE8021X == TRUE))
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].AuthMode >= Ndis802_11AuthModeWPA)
+common/p2p_cfg.c:				NdisMoveMemory(pAd->ApCfg.MBSSID[apidx].PMK, pKey->KeyMaterial + k_offset, 32);				
+common/p2p_cfg.c:            	pAd->ApCfg.MBSSID[apidx].PMK[0],pAd->ApCfg.MBSSID[apidx].PMK[1],pAd->ApCfg.MBSSID[apidx].PMK[2],pAd->ApCfg.MBSSID[apidx].PMK[3],
+common/p2p_cfg.c:            	pAd->ApCfg.MBSSID[apidx].PMK[4],pAd->ApCfg.MBSSID[apidx].PMK[5],pAd->ApCfg.MBSSID[apidx].PMK[6],pAd->ApCfg.MBSSID[apidx].PMK[7]));
+common/p2p_cfg.c:				pAd->ApCfg.MBSSID[apidx].DefaultKeyId = (UCHAR) KeyIdx;								
+common/p2p_cfg.c:				pAd->SharedKey[apidx][KeyIdx].KeyLen = (UCHAR) pKey->KeyLength;
+common/p2p_cfg.c:				NdisMoveMemory(pAd->SharedKey[apidx][KeyIdx].Key, &pKey->KeyMaterial, pKey->KeyLength);
+common/p2p_cfg.c:					pAd->SharedKey[apidx][KeyIdx].CipherAlg = CIPHER_WEP64;
+common/p2p_cfg.c:					pAd->SharedKey[apidx][KeyIdx].CipherAlg = CIPHER_WEP128;
+common/p2p_cfg.c:    			CipherAlg = pAd->SharedKey[apidx][KeyIdx].CipherAlg;
+common/p2p_cfg.c:    			Key = pAd->SharedKey[apidx][KeyIdx].Key;
+common/p2p_cfg.c:				AsicAddSharedKeyEntry(pAd, apidx, (UINT8)KeyIdx, &pAd->SharedKey[apidx][KeyIdx]);
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:    if (pAd->ApCfg.MBSSID[apidx].AuthMode >= Ndis802_11AuthModeWPA2)
+common/p2p_cfg.c:			NdisMoveMemory(&PMK_key[8], pAd->ApCfg.MBSSID[apidx].Bssid, MAC_ADDR_LEN);
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:            KeyIdx = pAd->ApCfg.MBSSID[apidx].DefaultKeyId;
+common/p2p_cfg.c:			if (pAd->SharedKey[apidx][KeyIdx].KeyLen == 0)
+common/p2p_cfg.c:            	pEntry->PairwiseKey.KeyLen = pAd->SharedKey[apidx][KeyIdx].KeyLen;
+common/p2p_cfg.c:            	NdisMoveMemory(pEntry->PairwiseKey.Key, pAd->SharedKey[apidx][KeyIdx].Key, pEntry->PairwiseKey.KeyLen);
+common/p2p_cfg.c:            	pEntry->PairwiseKey.CipherAlg = pAd->SharedKey[apidx][KeyIdx].CipherAlg;
+common/p2p_cfg.c:	POS_COOKIE  		pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	    sprintf(msg+strlen(msg), "Tx success                    = %ld\n", (ULONG)pAd->ate.TxDoneCount);
+common/p2p_cfg.c:	    /*sprintf(msg+strlen(msg), "Tx success without retry        = %ld\n", (ULONG)pAd->ate.TxDoneCount); */
+common/p2p_cfg.c:    sprintf(msg+strlen(msg), "Tx success                        = %ld\n", (ULONG)pAd->WlanCounters.TransmittedFragmentCount.u.LowPart);
+common/p2p_cfg.c:    /*sprintf(msg+strlen(msg), "Tx success without retry        = %ld\n", (ULONG)pAd->WlanCounters.TransmittedFragmentCount.u.LowPart - (ULONG)pAd->WlanCounters.RetryCount.u.LowPart); */
+common/p2p_cfg.c:    sprintf(msg+strlen(msg), "Tx retry count                  = %ld\n", (ULONG)pAd->WlanCounters.RetryCount.u.LowPart);
+common/p2p_cfg.c:    sprintf(msg+strlen(msg), "Tx fail to Rcv ACK after retry  = %ld\n", (ULONG)pAd->WlanCounters.FailedCount.u.LowPart);
+common/p2p_cfg.c:    sprintf(msg+strlen(msg), "RTS Success Rcv CTS             = %ld\n", (ULONG)pAd->WlanCounters.RTSSuccessCount.u.LowPart);
+common/p2p_cfg.c:    sprintf(msg+strlen(msg), "RTS Fail Rcv CTS                = %ld\n", (ULONG)pAd->WlanCounters.RTSFailureCount.u.LowPart);
+common/p2p_cfg.c:    sprintf(msg+strlen(msg), "Rx success                      = %ld\n", (ULONG)pAd->WlanCounters.ReceivedFragmentCount.QuadPart);
+common/p2p_cfg.c:    sprintf(msg+strlen(msg), "Rx with CRC                     = %ld\n", (ULONG)pAd->WlanCounters.FCSErrorCount.u.LowPart);
+common/p2p_cfg.c:    sprintf(msg+strlen(msg), "Rx drop due to out of resource  = %ld\n", (ULONG)pAd->Counters8023.RxNoBuffer);
+common/p2p_cfg.c:    sprintf(msg+strlen(msg), "Rx duplicate frame              = %ld\n", (ULONG)pAd->WlanCounters.FrameDuplicateCount.u.LowPart);
+common/p2p_cfg.c:    sprintf(msg+strlen(msg), "False CCA (one second)          = %ld\n", (ULONG)pAd->RalinkCounters.OneSecFalseCCACnt);
+common/p2p_cfg.c:		if (pAd->ate.RxAntennaSel == 0)
+common/p2p_cfg.c:    		sprintf(msg+strlen(msg), "RSSI-A                          = %ld\n", (LONG)(pAd->ate.LastRssi0 - pAd->BbpRssiToDbmDelta));
+common/p2p_cfg.c:			sprintf(msg+strlen(msg), "RSSI-B (if available)           = %ld\n", (LONG)(pAd->ate.LastRssi1 - pAd->BbpRssiToDbmDelta));
+common/p2p_cfg.c:			sprintf(msg+strlen(msg), "RSSI-C (if available)           = %ld\n\n", (LONG)(pAd->ate.LastRssi2 - pAd->BbpRssiToDbmDelta));
+common/p2p_cfg.c:    		sprintf(msg+strlen(msg), "RSSI                            = %ld\n", (LONG)(pAd->ate.LastRssi0 - pAd->BbpRssiToDbmDelta));
+common/p2p_cfg.c:    	sprintf(msg+strlen(msg), "RSSI-A                          = %ld\n", (LONG)(pAd->ApCfg.RssiSample.LastRssi0 - pAd->BbpRssiToDbmDelta));
+common/p2p_cfg.c:		sprintf(msg+strlen(msg), "RSSI-B (if available)           = %ld\n", (LONG)(pAd->ApCfg.RssiSample.LastRssi1 - pAd->BbpRssiToDbmDelta));
+common/p2p_cfg.c:		sprintf(msg+strlen(msg), "RSSI-C (if available)           = %ld\n\n", (LONG)(pAd->ApCfg.RssiSample.LastRssi2 - pAd->BbpRssiToDbmDelta));
+common/p2p_cfg.c:		if (pAd->ApCfg.ApCliTab[0].WscControl.WscEnrolleePinCodeLen == 8)
+common/p2p_cfg.c:								pAd->ApCfg.ApCliTab[0].WscControl.WscEnrolleePinCode);
+common/p2p_cfg.c:								pAd->ApCfg.ApCliTab[0].WscControl.WscEnrolleePinCode);
+common/p2p_cfg.c:								pAd->ApCfg.ApCliTab[0].WscControl.WscProfile.ProfileCnt);
+common/p2p_cfg.c:		for (idx = 0; idx < pAd->ApCfg.BssidNum; idx++)
+common/p2p_cfg.c:			if (pAd->ApCfg.MBSSID[idx].WscControl.WscEnrolleePinCodeLen == 8)
+common/p2p_cfg.c:				sprintf(msg+strlen(msg), "Enrollee PinCode(ra%d)           %08u\n", idx, pAd->ApCfg.MBSSID[idx].WscControl.WscEnrolleePinCode);
+common/p2p_cfg.c:				sprintf(msg+strlen(msg), "Enrollee PinCode(ra%d)           %04u\n", idx, pAd->ApCfg.MBSSID[idx].WscControl.WscEnrolleePinCode);
+common/p2p_cfg.c:	if (pAd->ApCfg.ApCliTab[0].WscControl.WscEnrolleePinCodeLen == 8)
+common/p2p_cfg.c:		sprintf(msg+strlen(msg), "Enrollee PinCode(ApCli0)        %08u\n", pAd->ApCfg.ApCliTab[0].WscControl.WscEnrolleePinCode);
+common/p2p_cfg.c:		sprintf(msg+strlen(msg), "Enrollee PinCode(ApCli0)        %04u\n", pAd->ApCfg.ApCliTab[0].WscControl.WscEnrolleePinCode);
+common/p2p_cfg.c:    sprintf(msg+strlen(msg), "Ap Client WPS Profile Count     = %d\n", pAd->ApCfg.ApCliTab[0].WscControl.WscProfile.ProfileCnt);
+common/p2p_cfg.c:    for (idx = 0; idx < pAd->ApCfg.ApCliTab[0].WscControl.WscProfile.ProfileCnt ; idx++)
+common/p2p_cfg.c:        PWSC_CREDENTIAL pCredential = &pAd->ApCfg.ApCliTab[0].WscControl.WscProfile.Profile[idx];
+common/p2p_cfg.c:	sprintf(msg+strlen(msg), "My Rule                         = %s\n", decodeMyRule(pAd->P2pCfg.Rule));
+common/p2p_cfg.c:	sprintf(msg+strlen(msg), "Listen Channel                  = %d\n", pAd->P2pCfg.ListenChannel);
+common/p2p_cfg.c:	sprintf(msg+strlen(msg), "WPS Config Method               = %s\n", decodeConfigMethod(pAd->P2pCfg.ConfigMethod));
+common/p2p_cfg.c:	sprintf(msg+strlen(msg), "Peer PinCode                    = %c%c%c%c%c%c%c%c\n", pAd->P2pCfg.PinCode[0], pAd->P2pCfg.PinCode[1], pAd->P2pCfg.PinCode[2], pAd->P2pCfg.PinCode[3],
+common/p2p_cfg.c:				pAd->P2pCfg.PinCode[4], pAd->P2pCfg.PinCode[5], pAd->P2pCfg.PinCode[6], pAd->P2pCfg.PinCode[7]);
+common/p2p_cfg.c:	TotalEntry = pAd->MacTab.Size;
+common/p2p_cfg.c:		PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[i];
+common/p2p_cfg.c:					BAT->BAOriEntry[index].BufSize[j] = pAd->BATable.BAOriEntry[pEntry->BAOriWcidArray[j]].BAWinSize;
+common/p2p_cfg.c:	TotalEntry = pAd->MacTab.Size;
+common/p2p_cfg.c:		PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[i];
+common/p2p_cfg.c:					BAT->BARecEntry[index].BufSize[j] = pAd->BATable.BARecEntry[pEntry->BARecWcidArray[j]].BAWinSize;
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pAd->ApCfg.ApCliTab[ifIndex].Enable = (Enable > 0) ? TRUE : FALSE;
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("I/F(apcli%d) Set_ApCli_Enable_Proc::(enable = %d)\n", ifIndex, pAd->ApCfg.ApCliTab[ifIndex].Enable));
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:		apcliEn = pAd->ApCfg.ApCliTab[ifIndex].Enable;
+common/p2p_cfg.c:			pAd->ApCfg.ApCliTab[ifIndex].Enable = FALSE;
+common/p2p_cfg.c:		NdisZeroMemory(pAd->ApCfg.ApCliTab[ifIndex].CfgSsid, MAX_LEN_OF_SSID);
+common/p2p_cfg.c:		NdisMoveMemory(pAd->ApCfg.ApCliTab[ifIndex].CfgSsid, arg, strlen(arg));
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].CfgSsidLen = (UCHAR)strlen(arg);
+common/p2p_cfg.c:		if (((pAd->ApCfg.ApCliTab[ifIndex].AuthMode == Ndis802_11AuthModeWPAPSK) ||
+common/p2p_cfg.c:				(pAd->ApCfg.ApCliTab[ifIndex].AuthMode == Ndis802_11AuthModeWPA2PSK)) && 
+common/p2p_cfg.c:					pAd->ApCfg.ApCliTab[ifIndex].PSKLen > 0)
+common/p2p_cfg.c:			RT_CfgSetWPAPSKKey(pAd, (PSTRING)pAd->ApCfg.ApCliTab[ifIndex].PSK, 
+common/p2p_cfg.c:									pAd->ApCfg.ApCliTab[ifIndex].PSKLen,
+common/p2p_cfg.c:									(PUCHAR)pAd->ApCfg.ApCliTab[ifIndex].CfgSsid, 
+common/p2p_cfg.c:									pAd->ApCfg.ApCliTab[ifIndex].CfgSsidLen, 
+common/p2p_cfg.c:									pAd->ApCfg.ApCliTab[ifIndex].PMK);
+common/p2p_cfg.c:			pAd->ApCfg.ApCliTab[ifIndex].CfgSsidLen, pAd->ApCfg.ApCliTab[ifIndex].CfgSsid));
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].Enable = apcliEn;
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	apcliEn = pAd->ApCfg.ApCliTab[ifIndex].Enable;
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].Enable = FALSE;
+common/p2p_cfg.c:	NdisZeroMemory(pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid, MAC_ADDR_LEN);
+common/p2p_cfg.c:			AtoH(value, &pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid[i], 1);
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid[0],
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid[1],
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid[2],
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid[3],
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid[4],
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid[5]));
+common/p2p_cfg.c:	pAd->ApCfg.ApCliTab[ifIndex].Enable = apcliEn;
+common/p2p_cfg.c:	POS_COOKIE 	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].AuthMode = Ndis802_11AuthModeAutoSwitch;
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].AuthMode = Ndis802_11AuthModeShared;
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].AuthMode = Ndis802_11AuthModeWPAPSK;
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].AuthMode = Ndis802_11AuthModeWPA2PSK;
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].AuthMode = Ndis802_11AuthModeOpen;
+common/p2p_cfg.c:		if (IS_ENTRY_APCLI(&pAd->MacTab.Content[i]))
+common/p2p_cfg.c:			pAd->MacTab.Content[i].PortSecured  = WPA_802_1X_PORT_NOT_SECURED;
+common/p2p_cfg.c:    RTMPMakeRSNIE(pAd, pAd->ApCfg.ApCliTab[ifIndex].AuthMode, pAd->ApCfg.ApCliTab[ifIndex].WepStatus, (ifIndex + MIN_NET_DEVICE_FOR_APCLI));
+common/p2p_cfg.c:	pAd->ApCfg.ApCliTab[ifIndex].DefaultKeyId  = 0;
+common/p2p_cfg.c:	if(pAd->ApCfg.ApCliTab[ifIndex].AuthMode >= Ndis802_11AuthModeWPA)
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].DefaultKeyId = 1;
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("IF(apcli%d) Set_ApCli_AuthMode_Proc::(AuthMode=%d)\n", ifIndex, pAd->ApCfg.ApCliTab[ifIndex].AuthMode));		
+common/p2p_cfg.c:	POS_COOKIE 	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:	POS_COOKIE 		pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:	POS_COOKIE 		pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:    POS_COOKIE 		pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	PWSC_CTRL	    pWscControl = &pAd->ApCfg.ApCliTab[ifIndex].WscControl;
+common/p2p_cfg.c:		NdisZeroMemory(pAd->ApCfg.ApCliTab[ifIndex].CfgSsid, MAX_LEN_OF_SSID);
+common/p2p_cfg.c:		NdisMoveMemory(pAd->ApCfg.ApCliTab[ifIndex].CfgSsid, arg, strlen(arg));
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].CfgSsidLen = (UCHAR)strlen(arg);
+common/p2p_cfg.c:    POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].Hostapd == TRUE)
+common/p2p_cfg.c:        pWscControl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/p2p_cfg.c:			pWscControl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/p2p_cfg.c:			pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p_cfg.c:        pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p_cfg.c:            pAd->ApCfg.MBSSID[apidx].WscIEBeacon.ValueLen = 0;
+common/p2p_cfg.c:        	pAd->ApCfg.MBSSID[apidx].WscIEProbeResp.ValueLen = 0;
+common/p2p_cfg.c:        memcpy(mac_addr, &pAd->ApCfg.ApCliTab[apidx].CurrentAddress[0], MAC_ADDR_LEN);
+common/p2p_cfg.c:        memcpy(mac_addr, &pAd->ApCfg.MBSSID[apidx].Bssid[0], MAC_ADDR_LEN);
+common/p2p_cfg.c:    POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].Hostapd == TRUE)
+common/p2p_cfg.c:	if ((pAd->ApCfg.MBSSID[apidx].WscControl.WscV2Info.bWpsEnable == FALSE) && 
+common/p2p_cfg.c:		(pAd->ApCfg.MBSSID[apidx].WscControl.WscV2Info.bEnableWpsV2))
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WscIEBeacon.ValueLen = 0;
+common/p2p_cfg.c:       	pAd->ApCfg.MBSSID[apidx].WscIEProbeResp.ValueLen = 0;
+common/p2p_cfg.c:	IsSelectedRegistrar = pAd->ApCfg.MBSSID[apidx].WscControl.WscSelReg;
+common/p2p_cfg.c:    if (pAd->ApCfg.MBSSID[apidx].WscControl.WscMode == 1)
+common/p2p_cfg.c:        pAd->ApCfg.MBSSID[apidx].WscControl.WscConfStatus = IsAPConfigured;
+common/p2p_cfg.c:        DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d) Set_WscConfStatus_Proc:: WscConfStatus is not changed (%d) \n", apidx, pAd->ApCfg.MBSSID[apidx].WscControl.WscConfStatus));
+common/p2p_cfg.c:                               pAd->ApCfg.MBSSID[apidx].Bssid[0],
+common/p2p_cfg.c:                               pAd->ApCfg.MBSSID[apidx].Bssid[1],
+common/p2p_cfg.c:                               pAd->ApCfg.MBSSID[apidx].Bssid[2],
+common/p2p_cfg.c:                               pAd->ApCfg.MBSSID[apidx].Bssid[3],
+common/p2p_cfg.c:                               pAd->ApCfg.MBSSID[apidx].Bssid[4],
+common/p2p_cfg.c:                               pAd->ApCfg.MBSSID[apidx].Bssid[5],
+common/p2p_cfg.c:                               pAd->ApCfg.MBSSID[apidx].WscControl.WscConfStatus));
+common/p2p_cfg.c:    POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].Hostapd == TRUE)
+common/p2p_cfg.c:        pWscControl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/p2p_cfg.c:			pWscControl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/p2p_cfg.c:			pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p_cfg.c:        pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p_cfg.c:        memcpy(mac_addr, pAd->ApCfg.ApCliTab[apidx].CurrentAddress, MAC_ADDR_LEN);
+common/p2p_cfg.c:        memcpy(mac_addr, pAd->ApCfg.MBSSID[apidx].Bssid, MAC_ADDR_LEN);
+common/p2p_cfg.c:    POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d) Set_WscStatus_Proc::(WscStatus=%d)\n", apidx, pAd->ApCfg.MBSSID[apidx].WscControl.WscStatus));
+common/p2p_cfg.c:    POS_COOKIE          pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	BOOLEAN 			apcliEn = pAd->ApCfg.ApCliTab[apidx].Enable;
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].Hostapd == TRUE)
+common/p2p_cfg.c:        pWscControl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/p2p_cfg.c:			pWscControl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/p2p_cfg.c:			pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p_cfg.c:        pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[apidx].Enable = FALSE;
+common/p2p_cfg.c:	                       pAd->ApCfg.ApCliTab[apidx].CurrentAddress, 
+common/p2p_cfg.c:        pAd->ApCfg.ApCliTab[apidx].Enable = apcliEn;
+common/p2p_cfg.c:		NdisMoveMemory(mac_addr, pAd->ApCfg.ApCliTab[apidx].CurrentAddress, MAC_ADDR_LEN);
+common/p2p_cfg.c:		if (pAd->P2pCfg.Dpid != DEV_PASS_ID_NOSPEC)
+common/p2p_cfg.c:			WscDpid = pAd->P2pCfg.Dpid;
+common/p2p_cfg.c:		NdisMoveMemory(mac_addr, pAd->ApCfg.MBSSID[apidx].Bssid, MAC_ADDR_LEN);
+common/p2p_cfg.c:	    							(PUCHAR)pAd->ApCfg.MBSSID[pWscControl->EntryIfIdx].Ssid, 
+common/p2p_cfg.c:	    							pAd->ApCfg.MBSSID[apidx].Bssid, 3, 0, AP_MODE);
+common/p2p_cfg.c:    POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].Hostapd == TRUE)
+common/p2p_cfg.c:        pWscControl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/p2p_cfg.c:			pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p_cfg.c:			pP2pCliWscCtrl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/p2p_cfg.c:        memcpy(mac_addr, pAd->ApCfg.ApCliTab[apidx].CurrentAddress, MAC_ADDR_LEN);
+common/p2p_cfg.c:        memcpy(mac_addr, pAd->ApCfg.MBSSID[apidx].Bssid, MAC_ADDR_LEN);
+common/p2p_cfg.c:    POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].Hostapd == TRUE)
+common/p2p_cfg.c:        snprintf(pTempSsid, 33,"RalinkInitialAP%02X%02X%02X", pAd->ApCfg.MBSSID[apidx].Bssid[3],
+common/p2p_cfg.c:                                                          pAd->ApCfg.MBSSID[apidx].Bssid[4],
+common/p2p_cfg.c:                                                          pAd->ApCfg.MBSSID[apidx].Bssid[5]);
+common/p2p_cfg.c:    POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].Hostapd == TRUE)
+common/p2p_cfg.c:        pWscControl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/p2p_cfg.c:        pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p_cfg.c:	POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].Hostapd == TRUE)
+common/p2p_cfg.c:	Profile.WscConfigured = pAd->ApCfg.MBSSID[apidx].WscControl.WscConfStatus;
+common/p2p_cfg.c:	NdisMoveMemory(Profile.WscSsid, pAd->ApCfg.MBSSID[apidx].Ssid, 
+common/p2p_cfg.c:								    pAd->ApCfg.MBSSID[apidx].SsidLen);
+common/p2p_cfg.c:	Profile.WscSsid[pAd->ApCfg.MBSSID[apidx].SsidLen] = '\0';
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK)
+common/p2p_cfg.c:		Profile.WscAuthMode = WscGetAuthType(pAd->ApCfg.MBSSID[apidx].AuthMode);
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11Encryption4Enabled)
+common/p2p_cfg.c:		Profile.WscEncrypType = WscGetEncryType(pAd->ApCfg.MBSSID[apidx].WepStatus);
+common/p2p_cfg.c:		Profile.DefaultKeyIdx = pAd->ApCfg.MBSSID[apidx].DefaultKeyId + 1;
+common/p2p_cfg.c:			for (i=0; i<pAd->SharedKey[apidx][pAd->ApCfg.MBSSID[apidx].DefaultKeyId].KeyLen; i++)
+common/p2p_cfg.c:									pAd->SharedKey[apidx][pAd->ApCfg.MBSSID[apidx].DefaultKeyId].Key[i]);
+common/p2p_cfg.c:			Profile.WscWPAKey[(pAd->SharedKey[apidx][pAd->ApCfg.MBSSID[apidx].DefaultKeyId].KeyLen)*2] = '\0';
+common/p2p_cfg.c:		NdisMoveMemory(Profile.WscWPAKey, pAd->ApCfg.MBSSID[apidx].WscControl.WpaPsk, 
+common/p2p_cfg.c:						pAd->ApCfg.MBSSID[apidx].WscControl.WpaPskLen);
+common/p2p_cfg.c:		Profile.WscWPAKey[pAd->ApCfg.MBSSID[apidx].WscControl.WpaPskLen] = '\0';
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK)
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11Encryption4Enabled)
+common/p2p_cfg.c:	POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	Profile.WscConfigured = pAd->ApCfg.MBSSID[apidx].WscControl.WscConfStatus;
+common/p2p_cfg.c:	NdisMoveMemory(Profile.WscSsid, pAd->ApCfg.MBSSID[apidx].Ssid, 
+common/p2p_cfg.c:								    pAd->ApCfg.MBSSID[apidx].SsidLen);
+common/p2p_cfg.c:	Profile.WscSsid[pAd->ApCfg.MBSSID[apidx].SsidLen] = '\0';
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK)
+common/p2p_cfg.c:		Profile.WscAuthMode = WscGetAuthType(pAd->ApCfg.MBSSID[apidx].AuthMode);
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11Encryption4Enabled)
+common/p2p_cfg.c:		Profile.WscEncrypType = WscGetEncryType(pAd->ApCfg.MBSSID[apidx].WepStatus);
+common/p2p_cfg.c:		Profile.DefaultKeyIdx = pAd->ApCfg.MBSSID[apidx].DefaultKeyId + 1;
+common/p2p_cfg.c:			for (i=0; i<pAd->SharedKey[apidx][pAd->ApCfg.MBSSID[apidx].DefaultKeyId].KeyLen; i++)
+common/p2p_cfg.c:									pAd->SharedKey[apidx][pAd->ApCfg.MBSSID[apidx].DefaultKeyId].Key[i]);
+common/p2p_cfg.c:			Profile.WscWPAKey[(pAd->SharedKey[apidx][pAd->ApCfg.MBSSID[apidx].DefaultKeyId].KeyLen)*2] = '\0';
+common/p2p_cfg.c:		NdisMoveMemory(Profile.WscWPAKey, pAd->ApCfg.MBSSID[apidx].WscControl.WpaPsk, 
+common/p2p_cfg.c:						pAd->ApCfg.MBSSID[apidx].WscControl.WpaPskLen);
+common/p2p_cfg.c:		Profile.WscWPAKey[pAd->ApCfg.MBSSID[apidx].WscControl.WpaPskLen] = '\0';
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWPA1PSKWPA2PSK)
+common/p2p_cfg.c:	if (pAd->ApCfg.MBSSID[apidx].WepStatus == Ndis802_11Encryption4Enabled)
+common/p2p_cfg.c:	POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	if(pAd->ApCfg.MBSSID[apidx].WscControl.WscEnrolleePinCode)
+common/p2p_cfg.c:		if (pAd->ApCfg.MBSSID[apidx].WscControl.WscEnrolleePinCodeLen == 8)
+common/p2p_cfg.c:			sprintf((PSTRING) tempPIN, "%08u", pAd->ApCfg.MBSSID[apidx].WscControl.WscEnrolleePinCode);
+common/p2p_cfg.c:			sprintf((PSTRING) tempPIN, "%04u", pAd->ApCfg.MBSSID[apidx].WscControl.WscEnrolleePinCode);
+common/p2p_cfg.c:	POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	sprintf(msg,"%s%d\n",msg,pAd->ApCfg.MBSSID[apidx].WscControl.WscStatus);
+common/p2p_cfg.c:/*	msg = kmalloc(sizeof(CHAR)*(pAd->ApCfg.BssidNum*(14*128)), MEM_ALLOC_FLAG); */
+common/p2p_cfg.c:	os_alloc_mem(NULL, (UCHAR **)&msg, sizeof(CHAR)*(pAd->ApCfg.BssidNum*(14*128)));
+common/p2p_cfg.c:	memset(msg, 0 ,pAd->ApCfg.BssidNum*(14*128));
+common/p2p_cfg.c:	for (apidx=0; apidx<pAd->ApCfg.BssidNum; apidx++)
+common/p2p_cfg.c:		pMbss=&pAd->ApCfg.MBSSID[apidx];
+common/p2p_cfg.c:/*	msg = kmalloc(sizeof(CHAR)*(pAd->ApCfg.BssidNum*(14*128)), MEM_ALLOC_FLAG); */
+common/p2p_cfg.c:	os_alloc_mem(NULL, (UCHAR **)&msg, sizeof(CHAR)*(pAd->ApCfg.BssidNum*(14*128)));
+common/p2p_cfg.c:	memset(msg, 0 ,pAd->ApCfg.BssidNum*(14*128));
+common/p2p_cfg.c:	for (apidx=0; apidx<pAd->ApCfg.BssidNum; apidx++)
+common/p2p_cfg.c:		pMbss=&pAd->ApCfg.MBSSID[apidx];
+common/p2p_cfg.c:    POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:        snprintf(pTempSsid, 33, "RalinkInitialAP%02X%02X%02X", pAd->ApCfg.MBSSID[apidx].Bssid[3],
+common/p2p_cfg.c:                                                          pAd->ApCfg.MBSSID[apidx].Bssid[4],
+common/p2p_cfg.c:                                                          pAd->ApCfg.MBSSID[apidx].Bssid[5]);
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;	
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WscSecurityMode = WPA2PSKAES;	
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WscSecurityMode = WPA2PSKTKIP;	
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WscSecurityMode = WPAPSKAES;	
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].WscSecurityMode = WPAPSKTKIP;	
+common/p2p_cfg.c:		apidx, pAd->ApCfg.MBSSID[apidx].WscSecurityMode ));	
+common/p2p_cfg.c:	POS_COOKIE 		pObj = (POS_COOKIE) pAd->OS_Cookie;	
+common/p2p_cfg.c:        pWpsCtrl = &pAd->ApCfg.ApCliTab[apidx].WscControl;
+common/p2p_cfg.c:        pWpsCtrl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p_cfg.c:	POS_COOKIE	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pAd->ApCfg.MBSSID[pObj->ioctl_if].WscControl.RegData.SelfInfo.Version = version;
+common/p2p_cfg.c:	POS_COOKIE	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pAd->ApCfg.MBSSID[pObj->ioctl_if].WscControl.bWscFragment = bool_flag;
+common/p2p_cfg.c:	POS_COOKIE	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[pObj->ioctl_if].WscControl.WscFragSize = WscFragSize;
+common/p2p_cfg.c:	POS_COOKIE	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	PWSC_CTRL	pWscControl = &pAd->ApCfg.MBSSID[pObj->ioctl_if].WscControl;
+common/p2p_cfg.c:								pAd->ApCfg.MBSSID[pObj->ioctl_if].WscControl.bSetupLock));
+common/p2p_cfg.c:	POS_COOKIE	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	PWSC_CTRL	pWscControl = &pAd->ApCfg.MBSSID[pObj->ioctl_if].WscControl;
+common/p2p_cfg.c:		if ((pAd->ApCfg.MBSSID[pObj->ioctl_if].WepStatus == Ndis802_11WEPEnabled) || 
+common/p2p_cfg.c:			(pAd->ApCfg.MBSSID[pObj->ioctl_if].WepStatus == Ndis802_11Encryption2Enabled) ||
+common/p2p_cfg.c:			(pAd->ApCfg.MBSSID[pObj->ioctl_if].bHideSsid))
+common/p2p_cfg.c:								pAd->ApCfg.MBSSID[pObj->ioctl_if].WscControl.WscV2Info.bEnableWpsV2));
+common/p2p_cfg.c:	POS_COOKIE	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[pObj->ioctl_if].WscControl.RegData.SelfInfo.Version2 = version;
+common/p2p_cfg.c:	POS_COOKIE	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pAd->ApCfg.MBSSID[pObj->ioctl_if].WscControl.WscV2Info.ExtraTlv.TlvTag = new_tag;
+common/p2p_cfg.c:	POS_COOKIE	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pAd->ApCfg.MBSSID[pObj->ioctl_if].WscControl.WscV2Info.ExtraTlv.TlvType = type;
+common/p2p_cfg.c:	POS_COOKIE		pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	PWSC_TLV		pWscTLV = &pAd->ApCfg.MBSSID[pObj->ioctl_if].WscControl.WscV2Info.ExtraTlv;
+common/p2p_cfg.c:	POS_COOKIE	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pEntry = pAd->MacTab.Hash[HashIdx];
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:        pAd->ApCfg.MBSSID[pObj->ioctl_if].IEEE8021X = TRUE;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[pObj->ioctl_if].IEEE8021X = FALSE;
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d) Set_IEEE8021X_Proc::(IEEE8021X=%d)\n", pObj->ioctl_if, pAd->ApCfg.MBSSID[pObj->ioctl_if].IEEE8021X));
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[pObj->ioctl_if].PreAuth = TRUE;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[pObj->ioctl_if].PreAuth = FALSE;
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d) Set_PreAuth_Proc::(PreAuth=%d)\n", pObj->ioctl_if, pAd->ApCfg.MBSSID[pObj->ioctl_if].PreAuth));
+common/p2p_cfg.c:        pAd->ApCfg.own_ip_addr = ip_addr;  
+common/p2p_cfg.c:		DBGPRINT(RT_DEBUG_TRACE, ("own_ip_addr=%s(%x)\n", arg, pAd->ApCfg.own_ip_addr));
+common/p2p_cfg.c:			pAd->ApCfg.EAPifname_len[i] = strlen(macptr); 
+common/p2p_cfg.c:			NdisMoveMemory(pAd->ApCfg.EAPifname[i], macptr, strlen(macptr));
+common/p2p_cfg.c:														pAd->ApCfg.EAPifname[i], 
+common/p2p_cfg.c:														pAd->ApCfg.EAPifname_len[i]));
+common/p2p_cfg.c:			pAd->ApCfg.PreAuthifname_len[i] = strlen(macptr); 
+common/p2p_cfg.c:			NdisMoveMemory(pAd->ApCfg.PreAuthifname[i], macptr, strlen(macptr));
+common/p2p_cfg.c:														pAd->ApCfg.PreAuthifname[i], 
+common/p2p_cfg.c:														pAd->ApCfg.PreAuthifname_len[i]));
+common/p2p_cfg.c:	POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:			PRADIUS_SRV_INFO pSrvInfo = &pAd->ApCfg.MBSSID[apidx].radius_srv_info[srv_cnt];
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].radius_srv_num = srv_cnt;
+common/p2p_cfg.c:	POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:		if (srv_cnt < pAd->ApCfg.MBSSID[apidx].radius_srv_num)
+common/p2p_cfg.c:			PRADIUS_SRV_INFO pSrvInfo = &pAd->ApCfg.MBSSID[apidx].radius_srv_info[srv_cnt];
+common/p2p_cfg.c:	POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:		if (strlen(macptr) > 0 && srv_cnt < pAd->ApCfg.MBSSID[apidx].radius_srv_num)
+common/p2p_cfg.c:			PRADIUS_SRV_INFO pSrvInfo = &pAd->ApCfg.MBSSID[apidx].radius_srv_info[srv_cnt];
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[0].UapsdInfo.bAPSDCapable = TRUE;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[0].UapsdInfo.bAPSDCapable = FALSE;
+common/p2p_cfg.c:	pAd->CommonCfg.MCastPhyMode.field.BW = pAd->CommonCfg.RegTransmitSetting.field.BW;
+common/p2p_cfg.c:			NdisMoveMemory(&pAd->CommonCfg.MCastPhyMode, &pAd->MacTab.Content[MCAST_WCID].HTPhyMode, sizeof(HTTRANSMIT_SETTING));
+common/p2p_cfg.c:			pAd->CommonCfg.MCastPhyMode.field.MODE = MODE_CCK;
+common/p2p_cfg.c:			pAd->CommonCfg.MCastPhyMode.field.BW =  BW_20;
+common/p2p_cfg.c:			pAd->CommonCfg.MCastPhyMode.field.MODE = MODE_OFDM;
+common/p2p_cfg.c:			pAd->CommonCfg.MCastPhyMode.field.MODE = MODE_HTMIX;
+common/p2p_cfg.c:	switch(pAd->CommonCfg.MCastPhyMode.field.MODE)
+common/p2p_cfg.c:				pAd->CommonCfg.MCastPhyMode.field.MCS = Mcs;
+common/p2p_cfg.c:				pAd->CommonCfg.MCastPhyMode.field.MCS = Mcs;
+common/p2p_cfg.c:			pAd->CommonCfg.MCastPhyMode.field.MCS = Mcs;
+common/p2p_cfg.c:	printk("Mcast PhyMode =%d\n", pAd->CommonCfg.MCastPhyMode.field.MODE);
+common/p2p_cfg.c:	printk("Mcast Mcs =%d\n", pAd->CommonCfg.MCastPhyMode.field.MCS);
+common/p2p_cfg.c:					pAd->CommonCfg.Dot11OBssScanPassiveDwell = ObssScanValue;	/* Unit : TU. 5~1000 */
+common/p2p_cfg.c:					pAd->CommonCfg.Dot11OBssScanActiveDwell = ObssScanValue;	/* Unit : TU. 10~1000 */
+common/p2p_cfg.c:				pAd->CommonCfg.Dot11BssWidthTriggerScanInt = ObssScanValue;	/* Unit : Second */
+common/p2p_cfg.c:					pAd->CommonCfg.Dot11OBssScanPassiveTotalPerChannel = ObssScanValue;	/* Unit : TU. 200~10000 */
+common/p2p_cfg.c:					pAd->CommonCfg.Dot11OBssScanActiveTotalPerChannel = ObssScanValue;	/* Unit : TU. 20~10000 */
+common/p2p_cfg.c:				pAd->CommonCfg.Dot11BssWidthChanTranDelayFactor = ObssScanValue;
+common/p2p_cfg.c:				pAd->CommonCfg.Dot11OBssScanActivityThre = ObssScanValue;	/* Unit : percentage */
+common/p2p_cfg.c:		pAd->CommonCfg.Dot11OBssScanPassiveDwell = dot11OBSSScanPassiveDwell;	/* Unit : TU. 5~1000 */
+common/p2p_cfg.c:		pAd->CommonCfg.Dot11OBssScanActiveDwell = dot11OBSSScanActiveDwell;	/* Unit : TU. 10~1000 */
+common/p2p_cfg.c:		pAd->CommonCfg.Dot11BssWidthTriggerScanInt = dot11BSSWidthTriggerScanInterval;	/* Unit : Second */
+common/p2p_cfg.c:		pAd->CommonCfg.Dot11OBssScanPassiveTotalPerChannel = dot11OBSSScanPassiveTotalPerChannel;	/* Unit : TU. 200~10000 */
+common/p2p_cfg.c:		pAd->CommonCfg.Dot11OBssScanActiveTotalPerChannel = dot11OBSSScanActiveTotalPerChannel;	/* Unit : TU. 20~10000 */
+common/p2p_cfg.c:		pAd->CommonCfg.Dot11BssWidthChanTranDelayFactor = dot11BSSWidthChannelTransactionDelayFactor;
+common/p2p_cfg.c:		pAd->CommonCfg.Dot11OBssScanActivityThre = dot11BSSScanActivityThreshold;	/* Unit : percentage */
+common/p2p_cfg.c:	pAd->CommonCfg.Dot11BssWidthChanTranDelay = (pAd->CommonCfg.Dot11BssWidthTriggerScanInt * pAd->CommonCfg.Dot11BssWidthChanTranDelayFactor);
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("OBSSScanParam for Dot11BssWidthChanTranDelay=%ld\n", pAd->CommonCfg.Dot11BssWidthChanTranDelay));
+common/p2p_cfg.c:		pAd->ApCfg.EntryLifeCheck = LifeCheckCnt;
+common/p2p_cfg.c:	printk("EntryLifeCheck Cnt = %ld.\n", pAd->ApCfg.EntryLifeCheck);
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeAutoSwitch;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeOpen;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeShared;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPAPSK;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPA2PSK;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPA1PSKWPA2PSK;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPA;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPA2;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPA1WPA2;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWAICERT;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWAIPSK;
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeOpen;  
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d)::AuthMode=%d\n", apidx, pAd->ApCfg.MBSSID[apidx].AuthMode));		
+common/p2p_cfg.c:	pAd->ApCfg.MBSSID[apidx].MaxStaNum = (UCHAR)simple_strtol(arg, 0, 10);
+common/p2p_cfg.c:					apidx, __FUNCTION__, pAd->ApCfg.MBSSID[apidx].MaxStaNum));
+common/p2p_cfg.c:		pAd->ApCfg.StaIdleTimeout = MAC_TABLE_MIN_AGEOUT_TIME;
+common/p2p_cfg.c:		pAd->ApCfg.StaIdleTimeout = idle_time;
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("%s : IdleTimeout=%d\n", __FUNCTION__, pAd->ApCfg.StaIdleTimeout));
+common/p2p_cfg.c:	pAd->MacTab.MsduLifeTime = simple_strtol(arg, 0, 10);
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set new life time = %d\n", pAd->MacTab.MsduLifeTime));
+common/p2p_cfg.c:	for(IdBss=0; IdBss<=pAd->ApCfg.BssidNum; IdBss++)
+common/p2p_cfg.c:			PhyMode = pAd->CommonCfg.PhyMode;
+common/p2p_cfg.c:			PhyMode = pAd->ApCfg.MBSSID[IdBss-1].PhyMode;
+common/p2p_cfg.c:		DBGPRINT(RT_DEBUG_TRACE,("ioctl SIOCSIWGENIE pAd->IoctlIF=%d\n",apidx));
+common/p2p_cfg.c:			NdisZeroMemory(pAd->ApCfg.MBSSID[apidx].RSN_IE[1], MAX_LEN_OF_RSNIE);
+common/p2p_cfg.c:			pAd->ApCfg.MBSSID[apidx].RSNIE_Len[1] = RSNIE_Len[1];
+common/p2p_cfg.c:			NdisMoveMemory(pAd->ApCfg.MBSSID[apidx].RSN_IE[1], (UCHAR *)(wrqin->u.data.pointer)+2, RSNIE_Len[1]);
+common/p2p_cfg.c:		NdisZeroMemory(pAd->ApCfg.MBSSID[apidx].RSN_IE[0], MAX_LEN_OF_RSNIE);
+common/p2p_cfg.c:		pAd->ApCfg.MBSSID[apidx].RSNIE_Len[0] = RSNIE_Len[0];
+common/p2p_cfg.c:		NdisMoveMemory(pAd->ApCfg.MBSSID[apidx].RSN_IE[0], ((UCHAR *)(wrqin->u.data.pointer))+2+offset_next_ie, RSNIE_Len[0]);
+common/p2p_cfg.c:	POS_COOKIE pObj = (POS_COOKIE)pAd->OS_Cookie;
+common/p2p_cfg.c:						DBGPRINT(RT_DEBUG_TRACE, ("Query::Get phy mode (%02X) \n", pAd->CommonCfg.PhyMode));
+common/p2p_cfg.c:						modetmp = (UINT) pAd->CommonCfg.PhyMode;
+common/p2p_cfg.c:						/**(ULONG *)pData = (ULONG)pAd->CommonCfg.PhyMode; */
+common/p2p_cfg.c:    			NdisCopyMemory((PSTRING) wrq->u.name, (PSTRING) pAd->ApCfg.MBSSID[pObj->ioctl_if].Bssid, 6);
+common/p2p_cfg.c:				if (pAd->ApCfg.ApCliTab[pObj->ioctl_if].Valid == TRUE)
+common/p2p_cfg.c:					pSSID->length = pAd->ApCfg.ApCliTab[pObj->ioctl_if].SsidLen;
+common/p2p_cfg.c:					pSSID->pSsidStr = (char *)&pAd->ApCfg.ApCliTab[pObj->ioctl_if].Ssid;
+common/p2p_cfg.c:					pSSID->length = pAd->ApCliMlmeAux.SsidLen;
+common/p2p_cfg.c:					pSSID->pSsidStr = (char *)pAd->ApCliMlmeAux.Ssid;
+common/p2p_cfg.c:					pSSID->length = pAd->ApCfg.MBSSID[pSSID->apidx].SsidLen;
+common/p2p_cfg.c:					pSSID->pSsidStr = (char *)pAd->ApCfg.MBSSID[pSSID->apidx].Ssid;
+common/p2p_cfg.c:			pAd->ApCfg.MBSSID[MAIN_MBSSID].bBcnSntReq = TRUE;
+common/p2p_cfg.c:				if (pAd->ApCfg.ApCliTab[pObj->ioctl_if].Valid == TRUE)
+common/p2p_cfg.c:					pBssidStr = (PCHAR)&APCLI_ROOT_BSSID_GET(pAd, pAd->ApCfg.ApCliTab[pObj->ioctl_if].MacTabWCID);
+common/p2p_cfg.c:				pBssidStr = (PCHAR) &pAd->ApCfg.MBSSID[pObj->ioctl_if].Bssid[0];
+common/p2p_cfg.c:				HtPhyMode = pAd->ApCfg.ApCliTab[pObj->ioctl_if].HTPhyMode;
+common/p2p_cfg.c:				HtPhyMode = pAd->ApCfg.MBSSID[pObj->ioctl_if].HTPhyMode;
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pAd->ApCfg.ApCliTab[ifIndex].Enable = (Enable > 0) ? TRUE : FALSE;
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("I/F(p2p%d) Set_P2pCli_Enable_Proc::(enable = %d)\n", ifIndex, pAd->ApCfg.ApCliTab[ifIndex].Enable));
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:		apcliEn = pAd->ApCfg.ApCliTab[ifIndex].Enable;
+common/p2p_cfg.c:			pAd->ApCfg.ApCliTab[ifIndex].Enable = FALSE;
+common/p2p_cfg.c:		NdisZeroMemory(pAd->ApCfg.ApCliTab[ifIndex].CfgSsid, MAX_LEN_OF_SSID);
+common/p2p_cfg.c:		NdisMoveMemory(pAd->ApCfg.ApCliTab[ifIndex].CfgSsid, arg, strlen(arg));
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].CfgSsidLen = (UCHAR)strlen(arg);
+common/p2p_cfg.c:		NdisZeroMemory(pAd->ApCfg.ApCliTab[ifIndex].WscControl.WscSsid.Ssid, MAX_LEN_OF_SSID);
+common/p2p_cfg.c:		NdisMoveMemory(pAd->ApCfg.ApCliTab[ifIndex].WscControl.WscSsid.Ssid, arg, strlen(arg));
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].WscControl.WscSsid.SsidLength = (UCHAR)strlen(arg);
+common/p2p_cfg.c:		if (((pAd->ApCfg.ApCliTab[ifIndex].AuthMode == Ndis802_11AuthModeWPAPSK) ||
+common/p2p_cfg.c:				(pAd->ApCfg.ApCliTab[ifIndex].AuthMode == Ndis802_11AuthModeWPA2PSK)) && 
+common/p2p_cfg.c:					pAd->ApCfg.ApCliTab[ifIndex].PSKLen > 0)
+common/p2p_cfg.c:			RT_CfgSetWPAPSKKey(pAd, (PSTRING)pAd->ApCfg.ApCliTab[ifIndex].PSK, pAd->ApCfg.ApCliTab[ifIndex].PSKLen, 
+common/p2p_cfg.c:									(PUCHAR)pAd->ApCfg.ApCliTab[ifIndex].CfgSsid, 
+common/p2p_cfg.c:									pAd->ApCfg.ApCliTab[ifIndex].CfgSsidLen, 
+common/p2p_cfg.c:									pAd->ApCfg.ApCliTab[ifIndex].PMK);
+common/p2p_cfg.c:			pAd->ApCfg.ApCliTab[ifIndex].CfgSsidLen, pAd->ApCfg.ApCliTab[ifIndex].CfgSsid));
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].Enable = apcliEn;
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	apcliEn = pAd->ApCfg.ApCliTab[ifIndex].Enable;
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].Enable = FALSE;
+common/p2p_cfg.c:	NdisZeroMemory(pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid, MAC_ADDR_LEN);
+common/p2p_cfg.c:			AtoH(value, &pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid[i], 1);
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid[0],
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid[1],
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid[2],
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid[3],
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid[4],
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid[5]));
+common/p2p_cfg.c:	pAd->ApCfg.ApCliTab[ifIndex].Enable = apcliEn;
+common/p2p_cfg.c:	POS_COOKIE 	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].AuthMode = Ndis802_11AuthModeAutoSwitch;
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].AuthMode = Ndis802_11AuthModeShared;
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].AuthMode = Ndis802_11AuthModeWPAPSK;
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].AuthMode = Ndis802_11AuthModeWPA2PSK;
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].AuthMode = Ndis802_11AuthModeOpen;
+common/p2p_cfg.c:		if (IS_ENTRY_APCLI(&pAd->MacTab.Content[i]))
+common/p2p_cfg.c:			pAd->MacTab.Content[i].PortSecured  = WPA_802_1X_PORT_NOT_SECURED;
+common/p2p_cfg.c:    RTMPMakeRSNIE(pAd, pAd->ApCfg.ApCliTab[ifIndex].AuthMode, pAd->ApCfg.ApCliTab[ifIndex].WepStatus, (ifIndex + MIN_NET_DEVICE_FOR_APCLI));
+common/p2p_cfg.c:	pAd->ApCfg.ApCliTab[ifIndex].DefaultKeyId  = 0;
+common/p2p_cfg.c:	if(pAd->ApCfg.ApCliTab[ifIndex].AuthMode >= Ndis802_11AuthModeWPA)
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].DefaultKeyId = 1;
+common/p2p_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("IF(p2p%d) Set_P2pCli_AuthMode_Proc::(AuthMode=%d)\n", ifIndex, pAd->ApCfg.ApCliTab[ifIndex].AuthMode));		
+common/p2p_cfg.c:	POS_COOKIE 	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:	POS_COOKIE 		pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:	POS_COOKIE 		pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p_cfg.c:    POS_COOKIE 		pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	PWSC_CTRL	    pWscControl = &pAd->ApCfg.ApCliTab[ifIndex].WscControl;
+common/p2p_cfg.c:		NdisZeroMemory(pAd->ApCfg.ApCliTab[ifIndex].CfgSsid, MAX_LEN_OF_SSID);
+common/p2p_cfg.c:		NdisMoveMemory(pAd->ApCfg.ApCliTab[ifIndex].CfgSsid, arg, strlen(arg));
+common/p2p_cfg.c:		pAd->ApCfg.ApCliTab[ifIndex].CfgSsidLen = (UCHAR)strlen(arg);
+common/p2p_cfg.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_cfg.c:		pP2pEntry = &pAd->P2pTable.Client[p2pindex];
+common/p2p_cfg.c:		P2P_SET_FLAG(&pAd->P2pTable.Client[p2pindex], P2PFLAG_PROVISIONED);
+common/p2p_cfg.c:		pAd->P2pCfg.P2pCounter.UserAccept = 0;
+common/p2p_cfg.c:	POS_COOKIE 		pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_cfg.c:	POS_COOKIE 		pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_cfg.c:	POS_COOKIE 		pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_cfg.c:	POS_COOKIE 		pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_cfg.c:	pP2PCtrl = &pAd->P2pCfg;
+common/igmp_snoop.c:	PMULTICAST_FILTER_TABLE pMulticastFilterTable = pAd->pMulticastFilterTable;
+common/igmp_snoop.c:	PMULTICAST_FILTER_TABLE pMulticastFilterTable = pAd->pMulticastFilterTable;
+common/igmp_snoop.c:	PMULTICAST_FILTER_TABLE pMulticastFilterTable = pAd->pMulticastFilterTable;
+common/igmp_snoop.c:	PMULTICAST_FILTER_TABLE pMulticastFilterTable = pAd->pMulticastFilterTable;
+common/igmp_snoop.c:	pAd->ApCfg.IgmpSnoopEnable = (BOOLEAN)(Enable == 0 ? FALSE : TRUE);
+common/igmp_snoop.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/igmp_snoop.c:	pDev = (ifIndex == MAIN_MBSSID) ? (pAd->net_dev) : (pAd->ApCfg.MBSSID[ifIndex].MSSIDDev);
+common/igmp_snoop.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/igmp_snoop.c:	pDev = (ifIndex == MAIN_MBSSID) ? (pAd->net_dev) : (pAd->ApCfg.MBSSID[ifIndex].MSSIDDev);
+common/igmp_snoop.c:			pAd->ApCfg.IgmpSnoopEnable = FALSE;
+common/igmp_snoop.c:			pAd->ApCfg.IgmpSnoopEnable = TRUE;
+common/igmp_snoop.c:			pAd->ApCfg.IgmpSnoopEnable = FALSE;
+common/igmp_snoop.c:		DBGPRINT(RT_DEBUG_TRACE, (" IGMP Snooping Enable=%d\n", pAd->ApCfg.IgmpSnoopEnable));
+common/igmp_snoop.c:		else if ((*ppGroupEntry = MulticastFilterTableLookup(pAd->pMulticastFilterTable, pSrcBufVA,
+common/igmp_snoop.c:		if ((*ppGroupEntry = MulticastFilterTableLookup(pAd->pMulticastFilterTable, pGroupMacAddr,
+common/igmp_snoop.c:			pMemberAddr = pAd->MacTab.Content[MacEntryIdx].Addr;
+common/igmp_snoop.c:						pMemberAddr = pAd->MacTab.Content[MacEntryIdx].Addr;
+common/igmp_snoop.c:				if (pAd->TxSwQueue[QueIdx].Number >= pAd->TxSwQMaxLen)
+common/igmp_snoop.c:					RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+common/igmp_snoop.c:					InsertTailQueueAc(pAd, pMacEntry, &pAd->TxSwQueue[QueIdx], PACKET_TO_QUEUE_ENTRY(pSkbClone));
+common/igmp_snoop.c:					RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+common/igmp_snoop.c:				pMemberAddr = pAd->MacTab.Content[MacEntryIdx].Addr;
+common/spectrum.c:	PSTRING pCountry = (PSTRING)(pAd->CommonCfg.CountryCode);
+common/spectrum.c:		RegulatoryClass = pAd->CommonCfg.RegulatoryClass[RegulatoryClassLoop];
+common/spectrum.c:	CurTxPwr = pAd->CommonCfg.DefineMaxTxPwr;
+common/spectrum.c:	if (pAd->CommonCfg.TxPowerPercentage > 90)
+common/spectrum.c:	else if (pAd->CommonCfg.TxPowerPercentage > 60)  /* reduce Pwr for 1 dB. */
+common/spectrum.c:	else if (pAd->CommonCfg.TxPowerPercentage > 30)  /* reduce Pwr for 3 dB. */
+common/spectrum.c:	else if (pAd->CommonCfg.TxPowerPercentage > 15)  /* reduce Pwr for 6 dB. */
+common/spectrum.c:	else if (pAd->CommonCfg.TxPowerPercentage > 9)   /* reduce Pwr for 9 dB. */
+common/spectrum.c:	if (pAd->CommonCfg.BBPCurrentBW == BW_40)
+common/spectrum.c:		if (pAd->CommonCfg.CentralChannel > 14)
+common/spectrum.c:			TxPwr[0] = pAd->Tx40MPwrCfgABand[0];
+common/spectrum.c:			TxPwr[1] = pAd->Tx40MPwrCfgABand[1];
+common/spectrum.c:			TxPwr[2] = pAd->Tx40MPwrCfgABand[2];
+common/spectrum.c:			TxPwr[3] = pAd->Tx40MPwrCfgABand[3];
+common/spectrum.c:			TxPwr[4] = pAd->Tx40MPwrCfgABand[4];
+common/spectrum.c:			TxPwr[0] = pAd->Tx40MPwrCfgGBand[0];
+common/spectrum.c:			TxPwr[1] = pAd->Tx40MPwrCfgGBand[1];
+common/spectrum.c:			TxPwr[2] = pAd->Tx40MPwrCfgGBand[2];
+common/spectrum.c:			TxPwr[3] = pAd->Tx40MPwrCfgGBand[3];
+common/spectrum.c:			TxPwr[4] = pAd->Tx40MPwrCfgGBand[4];
+common/spectrum.c:		if (pAd->CommonCfg.Channel > 14)
+common/spectrum.c:			TxPwr[0] = pAd->Tx20MPwrCfgABand[0];
+common/spectrum.c:			TxPwr[1] = pAd->Tx20MPwrCfgABand[1];
+common/spectrum.c:			TxPwr[2] = pAd->Tx20MPwrCfgABand[2];
+common/spectrum.c:			TxPwr[3] = pAd->Tx20MPwrCfgABand[3];
+common/spectrum.c:			TxPwr[4] = pAd->Tx20MPwrCfgABand[4];
+common/spectrum.c:			TxPwr[0] = pAd->Tx20MPwrCfgGBand[0];
+common/spectrum.c:			TxPwr[1] = pAd->Tx20MPwrCfgGBand[1];
+common/spectrum.c:			TxPwr[2] = pAd->Tx20MPwrCfgGBand[2];
+common/spectrum.c:			TxPwr[3] = pAd->Tx20MPwrCfgGBand[3];
+common/spectrum.c:			TxPwr[4] = pAd->Tx20MPwrCfgGBand[4];
+common/spectrum.c:			if (pAd->CommonCfg.TxStream == 1)
+common/spectrum.c:			else if (pAd->CommonCfg.TxStream == 2)
+common/spectrum.c:	NdisAllocateSpinLock(pAd, &pAd->CommonCfg.MeasureReqTabLock);
+common/spectrum.c:/*	pAd->CommonCfg.pMeasureReqTab = kmalloc(sizeof(MEASURE_REQ_TAB), GFP_ATOMIC);*/
+common/spectrum.c:	os_alloc_mem(pAd, (UCHAR **)&(pAd->CommonCfg.pMeasureReqTab), sizeof(MEASURE_REQ_TAB));
+common/spectrum.c:	if (pAd->CommonCfg.pMeasureReqTab)
+common/spectrum.c:		NdisZeroMemory(pAd->CommonCfg.pMeasureReqTab, sizeof(MEASURE_REQ_TAB));
+common/spectrum.c:		DBGPRINT(RT_DEBUG_ERROR, ("%s Fail to alloc memory for pAd->CommonCfg.pMeasureReqTab.\n", __FUNCTION__));
+common/spectrum.c:	NdisFreeSpinLock(&pAd->CommonCfg.MeasureReqTabLock);
+common/spectrum.c:	if (pAd->CommonCfg.pMeasureReqTab)
+common/spectrum.c:/*		kfree(pAd->CommonCfg.pMeasureReqTab);*/
+common/spectrum.c:		os_free_mem(NULL, pAd->CommonCfg.pMeasureReqTab);
+common/spectrum.c:	pAd->CommonCfg.pMeasureReqTab = NULL;
+common/spectrum.c:	PMEASURE_REQ_TAB pTab = pAd->CommonCfg.pMeasureReqTab;
+common/spectrum.c:	RTMP_SEM_LOCK(&pAd->CommonCfg.MeasureReqTabLock);
+common/spectrum.c:	RTMP_SEM_UNLOCK(&pAd->CommonCfg.MeasureReqTabLock);
+common/spectrum.c:	PMEASURE_REQ_TAB pTab = pAd->CommonCfg.pMeasureReqTab;
+common/spectrum.c:		RTMP_SEM_LOCK(&pAd->CommonCfg.MeasureReqTabLock);
+common/spectrum.c:		RTMP_SEM_UNLOCK(&pAd->CommonCfg.MeasureReqTabLock);
+common/spectrum.c:	PMEASURE_REQ_TAB pTab = pAd->CommonCfg.pMeasureReqTab;
+common/spectrum.c:		RTMP_SEM_LOCK(&pAd->CommonCfg.MeasureReqTabLock);
+common/spectrum.c:		RTMP_SEM_UNLOCK(&pAd->CommonCfg.MeasureReqTabLock);
+common/spectrum.c:	NdisAllocateSpinLock(pAd, &pAd->CommonCfg.TpcReqTabLock);
+common/spectrum.c:/*	pAd->CommonCfg.pTpcReqTab = kmalloc(sizeof(TPC_REQ_TAB), GFP_ATOMIC);*/
+common/spectrum.c:	os_alloc_mem(pAd, (UCHAR **)&(pAd->CommonCfg.pTpcReqTab), sizeof(TPC_REQ_TAB));
+common/spectrum.c:	if (pAd->CommonCfg.pTpcReqTab)
+common/spectrum.c:		NdisZeroMemory(pAd->CommonCfg.pTpcReqTab, sizeof(TPC_REQ_TAB));
+common/spectrum.c:		DBGPRINT(RT_DEBUG_ERROR, ("%s Fail to alloc memory for pAd->CommonCfg.pTpcReqTab.\n", __FUNCTION__));
+common/spectrum.c:	NdisFreeSpinLock(&pAd->CommonCfg.TpcReqTabLock);
+common/spectrum.c:	if (pAd->CommonCfg.pTpcReqTab)
+common/spectrum.c:/*		kfree(pAd->CommonCfg.pTpcReqTab);*/
+common/spectrum.c:		os_free_mem(NULL, pAd->CommonCfg.pTpcReqTab);
+common/spectrum.c:	pAd->CommonCfg.pTpcReqTab = NULL;
+common/spectrum.c:	PTPC_REQ_TAB pTab = pAd->CommonCfg.pTpcReqTab;
+common/spectrum.c:	RTMP_SEM_LOCK(&pAd->CommonCfg.TpcReqTabLock);
+common/spectrum.c:	RTMP_SEM_UNLOCK(&pAd->CommonCfg.TpcReqTabLock);
+common/spectrum.c:	PTPC_REQ_TAB pTab = pAd->CommonCfg.pTpcReqTab;
+common/spectrum.c:		RTMP_SEM_LOCK(&pAd->CommonCfg.TpcReqTabLock);
+common/spectrum.c:		RTMP_SEM_UNLOCK(&pAd->CommonCfg.TpcReqTabLock);
+common/spectrum.c:	PTPC_REQ_TAB pTab = pAd->CommonCfg.pTpcReqTab;
+common/spectrum.c:		RTMP_SEM_LOCK(&pAd->CommonCfg.TpcReqTabLock);
+common/spectrum.c:		RTMP_SEM_UNLOCK(&pAd->CommonCfg.TpcReqTabLock);
+common/spectrum.c:						pAd->CurrentAddress,
+common/spectrum.c:						pAd->CurrentAddress);
+common/spectrum.c:						pAd->CurrentAddress,
+common/spectrum.c:						pAd->CurrentAddress);
+common/spectrum.c:						pAd->CurrentAddress,
+common/spectrum.c:						pAd->CurrentAddress);
+common/spectrum.c:		if (pAd->Dot11_H.RDMode != RD_NORMAL_MODE)
+common/spectrum.c:		for (i=0; i<pAd->ChannelListNum; i++)
+common/spectrum.c:			if ((Channel == pAd->ChannelList[i].Channel)
+common/spectrum.c:				&&(pAd->ChannelList[i].RemainingTimeForUse == 0))
+common/spectrum.c:				pAd->ChannelList[i].RemainingTimeForUse = 1800;/*30 min = 1800 sec*/
+common/spectrum.c:	pAd->CommonCfg.Channel = Channel;
+common/spectrum.c:	pAd->Dot11_H.RDMode = RD_SWITCHING_MODE;
+common/spectrum.c:	pAd->Dot11_H.CSCount = 0;
+common/spectrum.c:	if ((pAd->OpMode == OPMODE_AP) &&
+common/spectrum.c:	if (pAd->OpMode == OPMODE_STA)
+common/spectrum.c:		Bssidx = BssTableSearch(&pAd->ScanTab, pFr->Hdr.Addr3, pAd->CommonCfg.Channel);
+common/spectrum.c:		DBGPRINT(RT_DEBUG_TRACE, ("\n****Bssidx is %d, Channel = %d\n", index, pAd->ScanTab.BssEntry[Bssidx].Channel));
+common/spectrum.c:		hex_dump("SSID",pAd->ScanTab.BssEntry[Bssidx].Bssid ,6);
+common/spectrum.c:		Channel = pAd->CommonCfg.Channel;
+common/spectrum.c:		if ((pAd->CommonCfg.bIEEE80211H == 1) && (NewChannel != 0) && (Channel != NewChannel))
+common/spectrum.c:			MlmeQueueInit(pAd, &pAd->Mlme.Queue);
+common/spectrum.c:			for (index = 0 ; index < pAd->ChannelListNum; index++)
+common/spectrum.c:				if (pAd->ChannelList[index].Channel == NewChannel)
+common/spectrum.c:					pAd->ScanTab.BssEntry[Bssidx].Channel = NewChannel;
+common/spectrum.c:					pAd->CommonCfg.Channel = NewChannel;
+common/spectrum.c:					AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+common/spectrum.c:					AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+common/spectrum.c:			if (index >= pAd->ChannelListNum)
+common/spectrum.c:				DBGPRINT_ERR(("&&&&&&&&&&&&&&&&&&&&&&&&&&PeerChSwAnnAction(can not find New Channel=%d in ChannelList[%d]\n", pAd->CommonCfg.Channel, pAd->ChannelListNum));
+common/spectrum.c:/*	if (pAd->CommonCfg.bIEEE80211H != TRUE)*/
+common/spectrum.c:	if (pAd->CommonCfg.bIEEE80211H != TRUE)
+common/spectrum.c:	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0, pAd->MacTab.Content[Aid].Addr,
+common/spectrum.c:						pAd->CurrentAddress,
+common/spectrum.c:						pAd->CurrentAddress);
+common/spectrum.c:	EnqueueTPCReq(pAd, pAd->MacTab.Content[Aid].Addr, TpcReqToken);
+common/spectrum.c:	MaxTxPwr = GetRegulatoryMaxTxPwr(pAd, pAd->CommonCfg.Channel) - (CHAR)Value;
+common/spectrum.c:	CurTxPwr = RTMP_GetTxPwr(pAd, pAd->MacTab.Content[0].HTPhyMode);
+common/spectrum.c:	if (pAd->CommonCfg.TxPowerPercentage > 90)
+common/spectrum.c:	else if (pAd->CommonCfg.TxPowerPercentage > 60)	/* reduce Pwr for 1 dB. */
+common/spectrum.c:	else if (pAd->CommonCfg.TxPowerPercentage > 30)	/* reduce Pwr for 3 dB. */
+common/spectrum.c:	else if (pAd->CommonCfg.TxPowerPercentage > 15)	/* reduce Pwr for 6 dB. */
+common/spectrum.c:	else if (pAd->CommonCfg.TxPowerPercentage > 9)	/* reduce Pwr for 9 dB. */
+common/spectrum.c:			pAd->CommonCfg.PwrConstraint = Value;
+common/spectrum.c:			pAd->CommonCfg.TxPowerPercentage =
+common/spectrum.c:		if (pAd->CommonCfg.RegulatoryClass[loop] == 0)
+common/spectrum.c:							(PSTRING)pAd->CommonCfg.CountryCode,
+common/spectrum.c:							pAd->CommonCfg.RegulatoryClass[loop]);
+common/cmm_tkip.c:		the MIC Value is store in pAd->PrivateInfo.MIC
+common/cmm_tkip.c:	RTMPTkipSetMICKey(&pAd->PrivateInfo.Tx, pMICKey);
+common/cmm_tkip.c:	RTMPTkipAppend(&pAd->PrivateInfo.Tx, pDA, MAC_ADDR_LEN);
+common/cmm_tkip.c:	RTMPTkipAppend(&pAd->PrivateInfo.Tx, pSA, MAC_ADDR_LEN);
+common/cmm_tkip.c:	RTMPTkipAppend(&pAd->PrivateInfo.Tx, (PUCHAR)&Priority, 4);
+common/cmm_tkip.c:	RTMPTkipSetMICKey(&pAd->PrivateInfo.Rx, pMICKey);
+common/cmm_tkip.c:	RTMPTkipAppend(&pAd->PrivateInfo.Rx, pDA, MAC_ADDR_LEN);
+common/cmm_tkip.c:	RTMPTkipAppend(&pAd->PrivateInfo.Rx, pSA, MAC_ADDR_LEN);
+common/cmm_tkip.c:	RTMPTkipAppend(&pAd->PrivateInfo.Rx, (PUCHAR)&Priority, 4);
+common/cmm_tkip.c:	RTMPTkipAppend(&pAd->PrivateInfo.Rx, pSrc, Len);
+common/cmm_tkip.c:	RTMPTkipGetMIC(&pAd->PrivateInfo.Rx);
+common/cmm_tkip.c:	if(!NdisEqualMemory(pAd->PrivateInfo.Rx.MIC, OldMic, 8))
+common/cmm_tkip.c:	if (apidx >= MIN_NET_DEVICE_FOR_APCLI && ((apidx - MIN_NET_DEVICE_FOR_APCLI) < MAX_APCLI_NUM) && (pAd->OpMode == OPMODE_AP))
+common/cmm_tkip.c:			pAd->ApCfg.ApCliTab[apidx-MIN_NET_DEVICE_FOR_APCLI].CurrentAddress,
+common/cmm_tkip.c:	if ((RTMP_GET_PACKET_WCID(pPacket) != MCAST_WCID) && (*pSrc & 0x01) && (pAd->OpMode == OPMODE_AP))
+common/cmm_tkip.c:			pAd->MacTab.Content[RTMP_GET_PACKET_WCID(pPacket)].Addr,
+common/cmm_tkip.c:		RTMPTkipAppend(&pAd->PrivateInfo.Tx, pEncap, 6);
+common/cmm_tkip.c:		RTMPTkipAppend(&pAd->PrivateInfo.Tx, pSrc + 12 + vlan_offset, 2);		
+common/cmm_tkip.c:			RTMPTkipAppend(&pAd->PrivateInfo.Tx, pSrc, SrcBufLen);
+common/cmm_tkip.c:	RTMPTkipGetMIC(&pAd->PrivateInfo.Tx);
+common/cmm_tkip.c:	RTMPTkipAppend(&pAd->PrivateInfo.Tx, plaintext_ptr, plaintext_len);
+common/cmm_tkip.c:	RTMPTkipGetMIC(&pAd->PrivateInfo.Tx);
+common/cmm_tkip.c:	NdisMoveMemory(MIC, pAd->PrivateInfo.Tx.MIC, LEN_TKIP_MIC);
+common/cmm_tkip.c:        if (pAd->StaCfg.WpaSupplicantUP) {
+common/cmm_tkip.c:                WpaSendMicFailureToWpaSupplicant(pAd->net_dev,
+common/cmm_radar.c:	if (pAd->Dot11_H.RDMode != RD_SILENCE_MODE)
+common/cmm_radar.c:	if (pAd->Dot11_H.RDCount++ > pAd->Dot11_H.ChMovingTime)
+common/cmm_radar.c:		pAd->Dot11_H.RDMode = RD_NORMAL_MODE;
+common/cmm_radar.c:	for (i=0; i<pAd->ChannelListNum; i++)
+common/cmm_radar.c:		if (Ch == pAd->ChannelList[i].Channel)
+common/cmm_radar.c:			result = pAd->ChannelList[i].DfsReq;
+common/cmm_radar.c:	if (pAd->CommonCfg.RDDurRegion != JAP)
+common/cmm_radar.c:		return pAd->CommonCfg.RDDurRegion;
+common/cmm_radar.c:		if (pAd->CommonCfg.Channel == Channel[i])
+common/cmm_radar.c:				__FUNCTION__, pAd->Dot11_H.CSCount, pAd->Dot11_H.CSPeriod));
+common/cmm_radar.c:	pAd->Dot11_H.CSCount++;
+common/cmm_radar.c:	if (pAd->Dot11_H.CSCount >= pAd->Dot11_H.CSPeriod)
+common/cmm_radar.c:		pAd->CommonCfg.RadarDetect.DFSAPRestart = 1;
+common/cmm_radar.c:	pAd->Dot11_H.CSPeriod = (USHORT) simple_strtol(arg, 0, 10);
+common/cmm_radar.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_CSPeriod_Proc::(CSPeriod=%d)\n", pAd->Dot11_H.CSPeriod));
+common/cmm_radar.c:	pAd->Dot11_H.ChMovingTime = Value;
+common/cmm_radar.c:		pAd->Dot11_H.ChMovingTime));
+common/cmm_radar.c:	for (i=0; i<pAd->ChannelListNum; i++)
+common/cmm_radar.c:		pAd->ChannelList[i].RemainingTimeForUse = 0;
+common/cmm_radar.c:	PRADAR_DETECT_STRUCT pRadarDetect = &pAd->CommonCfg.RadarDetect;
+common/cmm_radar.c:		/*printk("CeSwCheck = %d\n", pAd->CommonCfg.ce_sw_check);*/
+common/cmm_radar.c:		/*printk("CEStagCheck = %d\n", pAd->CommonCfg.ce_staggered_check);*/
+common/cmm_radar.c:		/*printk("HWDFSDisabled = %d\n", pAd->CommonCfg.hw_dfs_disabled);*/
+common/cmm_radar.c:		for (idx=0; idx < pAd->chipCap.DfsEngineNum; idx++)
+common/cmm_radar.c:		for (idx=0; idx < pAd->chipCap.DfsEngineNum; idx++)
+common/cmm_radar.c:	printk("pAd->Dot11_H.ChMovingTime = %d\n", pAd->Dot11_H.ChMovingTime);
+common/cmm_radar.c:	printk("pAd->Dot11_H.RDMode = %d\n", pAd->Dot11_H.RDMode);
+common/cmm_radar.c:	printk("pAd->CommonCfg.CarrierDetect.CD_State = %d\n", pAd->CommonCfg.CarrierDetect.CD_State);
+common/cmm_radar.c:	printk("pAd->CommonCfg.CarrierDetect.criteria = %d\n", pAd->CommonCfg.CarrierDetect.criteria);
+common/cmm_radar.c:	printk("pAd->CommonCfg.CarrierDetect.Delta = %d\n", pAd->CommonCfg.CarrierDetect.delta);
+common/cmm_radar.c:	printk("pAd->CommonCfg.CarrierDetect.DivFlag = %d\n", pAd->CommonCfg.CarrierDetect.div_flag);
+common/cmm_radar.c:	printk("pAd->CommonCfg.CarrierDetect.Threshold = %d(0x%x)\n", pAd->CommonCfg.CarrierDetect.threshold, pAd->CommonCfg.CarrierDetect.threshold);
+common/cmm_sanity.c:	if (NdisEqualMemory(pAd->MacTab.Content[pInfo->Wcid].Addr, pInfo->Addr, MAC_ADDR_LEN) == 0)
+common/cmm_sanity.c:	if (pAd->OpMode == OPMODE_STA)
+common/cmm_sanity.c:                    if (P2P_CLI_ON(pAd) && NdisEqualMemory(pBssid, pAd->ApCliMlmeAux.Bssid, MAC_ADDR_LEN))
+common/cmm_sanity.c:                        GetTimBit((PCHAR)pEid, pAd->ApCliMlmeAux.Aid, &TimLen, pBcastFlag, pDtimCount, pDtimPeriod, pMessageToMe);
+common/cmm_sanity.c:					if (INFRA_ON(pAd) && NdisEqualMemory(pBssid, pAd->CommonCfg.Bssid, MAC_ADDR_LEN))
+common/cmm_sanity.c:                        GetTimBit((PCHAR)pEid, pAd->StaActive.Aid, &TimLen, pBcastFlag, pDtimCount, pDtimPeriod, pMessageToMe);
+common/cmm_sanity.c:                else if ((*pHtCapabilityLen == 0) && NdisEqualMemory(pEid->Octet, PRE_N_HT_OUI, 3) && (pEid->Len >= 4) && (pAd->OpMode == OPMODE_STA))
+common/cmm_sanity.c:		if ((pAd->LatchRfRegs.Channel > 14) && ((Sanity & 0x4) == 0))
+common/cmm_sanity.c:			if ((pAd->StaCfg.BssType == BSS_ADHOC) &&
+common/cmm_sanity.c:												&pAd->StaCfg.WscControl.WscPeerMAC[0], 
+common/cmm_sanity.c:						NdisMoveMemory(&pAd->StaCfg.WscControl.WscPeerMAC[0], pAddr2, MAC_ADDR_LEN);
+common/cmm_sanity.c:					NdisMoveMemory(&pAd->StaCfg.WscControl.EntryAddr[0], 
+common/cmm_sanity.c:							&pAd->StaCfg.WscControl.WscPeerMAC[0], 
+common/cmm_sanity.c:					hex_dump("PeerBeaconAndProbeRspSanity - WscPeerMAC", &pAd->StaCfg.WscControl.WscPeerMAC[0], MAC_ADDR_LEN);
+common/cmm_sanity.c:		if (bFoundIWscIe && (pAd->StaCfg.BssType == BSS_ADHOC))
+common/cmm_sanity.c:			PWSC_CTRL pWscCtrl = &pAd->StaCfg.WscControl;
+common/cmm_sanity.c:				if (P2P_CLI_ON(pAd) && NdisEqualMemory(&ie_list->Bssid[0], pAd->ApCliMlmeAux.Bssid, MAC_ADDR_LEN))
+common/cmm_sanity.c:					GetTimBit((PCHAR)pEid, pAd->ApCliMlmeAux.Aid, &TimLen,
+common/cmm_sanity.c:				if (INFRA_ON(pAd) && NdisEqualMemory(&ie_list->Bssid[0], pAd->CommonCfg.Bssid, MAC_ADDR_LEN))
+common/cmm_sanity.c:					GetTimBit((PCHAR)pEid, pAd->StaActive.Aid, &TimLen, &ie_list->BcastFlag,
+common/cmm_sanity.c:			else if ((ie_list->HtCapabilityLen == 0) && NdisEqualMemory(pEid->Octet, PRE_N_HT_OUI, 3) && (pEid->Len >= 4) && (pAd->OpMode == OPMODE_STA))
+common/cmm_sanity.c:	if ((pAd->LatchRfRegs.Channel > 14) && ((Sanity & 0x4) == 0))
+common/cmm_sanity.c:		if ((pAd->StaCfg.BssType == BSS_ADHOC) &&
+common/cmm_sanity.c:											&pAd->StaCfg.WscControl.WscPeerMAC[0], 
+common/cmm_sanity.c:					NdisMoveMemory(&pAd->StaCfg.WscControl.WscPeerMAC[0], ie_list->Addr2, MAC_ADDR_LEN);
+common/cmm_sanity.c:				NdisMoveMemory(&pAd->StaCfg.WscControl.EntryAddr[0], 
+common/cmm_sanity.c:						&pAd->StaCfg.WscControl.WscPeerMAC[0], 
+common/cmm_sanity.c:				hex_dump("PeerBeaconAndProbeRspSanity - WscPeerMAC", &pAd->StaCfg.WscControl.WscPeerMAC[0], MAC_ADDR_LEN);
+common/cmm_sanity.c:		if (bFoundIWscIe && (pAd->StaCfg.BssType == BSS_ADHOC))
+common/cmm_sanity.c:			PWSC_CTRL pWscCtrl = &pAd->StaCfg.WscControl;
+common/cmm_sanity.c:    for (i = 0; i < pAd->ChannelListNum; i ++)
+common/cmm_sanity.c:        if (channel == pAd->ChannelList[i].Channel)
+common/cmm_sanity.c:		if (pAd->StaCfg.WscControl.bWscTrigger && (pAd->StaCfg.WscControl.WscConfMode != WSC_DISABLE))
+common/cmm_sanity.c:					if (pAd->StaCfg.BssType == BSS_ADHOC)
+common/cmm_sanity.c:		for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/cmm_sanity.c:			if (NdisEqualMemory(Addr1, pAd->ApCfg.MBSSID[apidx].Bssid, MAC_ADDR_LEN))
+common/cmm_sanity.c:		if (apidx >= pAd->ApCfg.BssidNum)
+common/cmm_sanity.c:		if ((pAd->ApCfg.MBSSID[apidx].WscControl.WscConfMode & WSC_PROXY) != WSC_DISABLE)
+common/action.c:		Idx = pAd->MacTab.Content[pInfo->Wcid].BAOriWcidArray[pInfo->TID];
+common/action.c:			pBAEntry =&pAd->BATable.BAOriEntry[Idx];
+common/action.c:			pEntry = &pAd->MacTab.Content[pInfo->Wcid];
+common/action.c:					|| (IS_ENTRY_DLS(&pAd->MacTab.Content[pInfo->Wcid]))
+common/action.c:					|| (IS_ENTRY_TDLS(&pAd->MacTab.Content[pInfo->Wcid]))
+common/action.c:					ActHeaderInit(pAd, &Frame.Hdr, pInfo->pAddr, pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+common/action.c:			if (IS_ENTRY_APCLI(&pAd->MacTab.Content[pInfo->Wcid]))
+common/action.c:				apidx = pAd->MacTab.Content[pInfo->Wcid].MatchAPCLITabIdx;
+common/action.c:				ActHeaderInit(pAd, &Frame.Hdr, pInfo->pAddr, pAd->ApCfg.ApCliTab[apidx].CurrentAddress, pInfo->pAddr);		
+common/action.c:				apidx = pAd->MacTab.Content[pInfo->Wcid].apidx;
+common/action.c:				ActHeaderInit(pAd, &Frame.Hdr, pInfo->pAddr, pAd->ApCfg.MBSSID[apidx].Bssid, pAd->ApCfg.MBSSID[apidx].Bssid);
+common/action.c:				|| (IS_ENTRY_DLS(&pAd->MacTab.Content[pInfo->Wcid]))
+common/action.c:				|| (IS_ENTRY_TDLS(&pAd->MacTab.Content[pInfo->Wcid]))
+common/action.c:				ActHeaderInit(pAd, &Frame.Hdr, pInfo->pAddr, pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+common/action.c:				ActHeaderInit(pAd, &Frame.Hdr, pAd->CommonCfg.Bssid, pAd->CurrentAddress, pInfo->pAddr);
+common/action.c:		Frame.BaStartSeq.field.StartSeq = pAd->MacTab.Content[pInfo->Wcid].TxSeq[pInfo->TID];
+common/action.c:		Idx = pAd->MacTab.Content[pInfo->Wcid].BAOriWcidArray[pInfo->TID];
+common/action.c:			pEntry = &pAd->MacTab.Content[pInfo->Wcid];
+common/action.c:				BarHeaderInit(pAd, &FrameBar, pAd->MacTab.Content[pInfo->Wcid].Addr, pEntry->HdrAddr2);
+common/action.c:			if (IS_ENTRY_APCLI(&pAd->MacTab.Content[pInfo->Wcid]))
+common/action.c:				apidx = pAd->MacTab.Content[pInfo->Wcid].MatchAPCLITabIdx;
+common/action.c:				BarHeaderInit(pAd, &FrameBar, pAd->MacTab.Content[pInfo->Wcid].Addr, pAd->ApCfg.ApCliTab[apidx].CurrentAddress);
+common/action.c:				apidx = pAd->MacTab.Content[pInfo->Wcid].apidx;
+common/action.c:				BarHeaderInit(pAd, &FrameBar, pAd->MacTab.Content[pInfo->Wcid].Addr, pAd->ApCfg.MBSSID[apidx].Bssid);
+common/action.c:			BarHeaderInit(pAd, &FrameBar, pAd->MacTab.Content[pInfo->Wcid].Addr, pAd->CurrentAddress);
+common/action.c:		FrameBar.StartingSeq.field.StartSeq = pAd->MacTab.Content[pInfo->Wcid].TxSeq[pInfo->TID]; /* make sure sequence not clear in DEL funciton.*/
+common/action.c:			pEntry = &pAd->MacTab.Content[pInfo->Wcid];
+common/action.c:					|| (IS_ENTRY_DLS(&pAd->MacTab.Content[pInfo->Wcid]))
+common/action.c:					|| (IS_ENTRY_TDLS(&pAd->MacTab.Content[pInfo->Wcid]))
+common/action.c:					ActHeaderInit(pAd, &Frame.Hdr, pAd->MacTab.Content[pInfo->Wcid].Addr, pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+common/action.c:					ActHeaderInit(pAd, &Frame.Hdr, pAd->MacTab.Content[pInfo->Wcid].Addr, pEntry->HdrAddr2, pEntry->HdrAddr3);
+common/action.c:			if (IS_ENTRY_APCLI(&pAd->MacTab.Content[pInfo->Wcid]))
+common/action.c:				apidx = pAd->MacTab.Content[pInfo->Wcid].MatchAPCLITabIdx;
+common/action.c:				ActHeaderInit(pAd, &Frame.Hdr, pAd->MacTab.Content[pInfo->Wcid].Addr, pAd->ApCfg.ApCliTab[apidx].CurrentAddress, pAd->MacTab.Content[pInfo->Wcid].Addr);		
+common/action.c:				apidx = pAd->MacTab.Content[pInfo->Wcid].apidx;
+common/action.c:				ActHeaderInit(pAd, &Frame.Hdr,  pAd->MacTab.Content[pInfo->Wcid].Addr, pAd->ApCfg.MBSSID[apidx].Bssid, pAd->ApCfg.MBSSID[apidx].Bssid);
+common/action.c:				|| (IS_ENTRY_DLS(&pAd->MacTab.Content[pInfo->Wcid]))
+common/action.c:				|| (IS_ENTRY_TDLS(&pAd->MacTab.Content[pInfo->Wcid]))
+common/action.c:				ActHeaderInit(pAd, &Frame.Hdr, pAd->MacTab.Content[pInfo->Wcid].Addr, pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+common/action.c:				ActHeaderInit(pAd, &Frame.Hdr,  pAd->CommonCfg.Bssid, pAd->CurrentAddress, pAd->MacTab.Content[pInfo->Wcid].Addr);
+common/action.c:	BssCoexistInfo.BssCoexistIe.word = pAd->CommonCfg.LastBSSCoexist2040.word;
+common/action.c:		pAddr1 = pAd->MacTab.Content[Wcid].Addr;
+common/action.c:	ActHeaderInit(pAd, &Frame.Hdr, pAddr1, pAd->ApCfg.MBSSID[apidx].Bssid, pAd->ApCfg.MBSSID[apidx].Bssid);
+common/action.c:		pAd->CommonCfg.BSSCoexist2040.field.InfoReq = 1;
+common/action.c:		pAd->CommonCfg.BSSCoexist2040.field.Intolerant40 = 0;
+common/action.c:		pAd->CommonCfg.BSSCoexist2040.field.BSS20WidthReq = 0;
+common/action.c:		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+common/action.c:		for ( i = 0;i < pAd->CommonCfg.TriggerEventTab.EventANo;i++)
+common/action.c:			if (pAd->CommonCfg.TriggerEventTab.EventA[i].bValid == TRUE)
+common/action.c:				if (pAd->CommonCfg.TriggerEventTab.EventA[i].RegClass == TmpRegClass)
+common/action.c:						if (ChannelList[j] == (UCHAR)pAd->CommonCfg.TriggerEventTab.EventA[i].Channel)
+common/action.c:						ChannelList[idx] = (UCHAR)pAd->CommonCfg.TriggerEventTab.EventA[i].Channel;
+common/action.c:					pAd->CommonCfg.TriggerEventTab.EventA[i].bValid = FALSE;
+common/action.c:	DBGPRINT(RT_DEBUG_ERROR,("ACT - Update2040CoexistFrameAndNotify. BSSCoexist2040 = %x. EventANo = %d. \n", pAd->CommonCfg.BSSCoexist2040.word, pAd->CommonCfg.TriggerEventTab.EventANo));
+common/action.c:	OldValue.word = pAd->CommonCfg.BSSCoexist2040.word;
+common/action.c:	pAd->CommonCfg.BSSCoexist2040.word = 0;
+common/action.c:	if (pAd->CommonCfg.TriggerEventTab.EventBCountDown > 0)
+common/action.c:		pAd->CommonCfg.BSSCoexist2040.field.BSS20WidthReq = 1;
+common/action.c:	/*if (OldValue.field.BSS20WidthReq != pAd->CommonCfg.BSSCoexist2040.field.BSS20WidthReq)*/
+common/action.c:	ActHeaderInit(pAd, &Frame.Hdr, pAd->MacTab.Content[Wcid].Addr, pAd->CurrentAddress, pAd->CommonCfg.Bssid);	
+common/action.c:				  1,                                &pAd->CommonCfg.BSSCoexist2040.word,
+common/action.c:								IntolerantChaRepLen, pAd->CommonCfg.BSSCoexist2040.word));
+common/action.c:	if (!((IntolerantChaRepLen == 0) && (pAd->CommonCfg.BSSCoexist2040.word == 0)))
+common/action.c:	DBGPRINT(RT_DEBUG_TRACE,("ACT - Send2040CoexistAction( BSSCoexist2040 = 0x%x )  \n", pAd->CommonCfg.BSSCoexist2040.word));
+common/action.c:	pAd->CommonCfg.Dot11BssWidthChanTranDelayFactor = le2cpu16(APBssScan.DelayFactor); /*APBssScan.DelayFactor[1] * 256 + APBssScan.DelayFactor[0];*/
+common/action.c:	if ((pAd->CommonCfg.Dot11BssWidthChanTranDelayFactor <5) || (pAd->CommonCfg.Dot11BssWidthChanTranDelayFactor > 100))
+common/action.c:		pAd->CommonCfg.Dot11BssWidthChanTranDelayFactor = 5;
+common/action.c:	pAd->CommonCfg.Dot11BssWidthTriggerScanInt = le2cpu16(APBssScan.TriggerScanInt); /*APBssScan.TriggerScanInt[1] * 256 + APBssScan.TriggerScanInt[0];*/
+common/action.c:	if ((pAd->CommonCfg.Dot11BssWidthTriggerScanInt < 10) ||(pAd->CommonCfg.Dot11BssWidthTriggerScanInt > 900))
+common/action.c:		pAd->CommonCfg.Dot11BssWidthTriggerScanInt = 900;
+common/action.c:	pAd->CommonCfg.Dot11OBssScanPassiveDwell = le2cpu16(APBssScan.ScanPassiveDwell); /*APBssScan.ScanPassiveDwell[1] * 256 + APBssScan.ScanPassiveDwell[0];*/
+common/action.c:	if ((pAd->CommonCfg.Dot11OBssScanPassiveDwell < 5) ||(pAd->CommonCfg.Dot11OBssScanPassiveDwell > 1000))
+common/action.c:		pAd->CommonCfg.Dot11OBssScanPassiveDwell = 20;
+common/action.c:	pAd->CommonCfg.Dot11OBssScanActiveDwell = le2cpu16(APBssScan.ScanActiveDwell); /*APBssScan.ScanActiveDwell[1] * 256 + APBssScan.ScanActiveDwell[0];*/
+common/action.c:	if ((pAd->CommonCfg.Dot11OBssScanActiveDwell < 10) ||(pAd->CommonCfg.Dot11OBssScanActiveDwell > 1000))
+common/action.c:		pAd->CommonCfg.Dot11OBssScanActiveDwell = 10;
+common/action.c:	pAd->CommonCfg.Dot11OBssScanPassiveTotalPerChannel = le2cpu16(APBssScan.PassiveTalPerChannel); /*APBssScan.PassiveTalPerChannel[1] * 256 + APBssScan.PassiveTalPerChannel[0];*/
+common/action.c:	if ((pAd->CommonCfg.Dot11OBssScanPassiveTotalPerChannel < 200) ||(pAd->CommonCfg.Dot11OBssScanPassiveTotalPerChannel > 10000))
+common/action.c:		pAd->CommonCfg.Dot11OBssScanPassiveTotalPerChannel = 200;
+common/action.c:	pAd->CommonCfg.Dot11OBssScanActiveTotalPerChannel = le2cpu16(APBssScan.ActiveTalPerChannel); /*APBssScan.ActiveTalPerChannel[1] * 256 + APBssScan.ActiveTalPerChannel[0];*/
+common/action.c:	if ((pAd->CommonCfg.Dot11OBssScanActiveTotalPerChannel < 20) ||(pAd->CommonCfg.Dot11OBssScanActiveTotalPerChannel > 10000))
+common/action.c:		pAd->CommonCfg.Dot11OBssScanActiveTotalPerChannel = 20;
+common/action.c:	pAd->CommonCfg.Dot11OBssScanActivityThre = le2cpu16(APBssScan.ScanActThre); /*APBssScan.ScanActThre[1] * 256 + APBssScan.ScanActThre[0];*/
+common/action.c:	if (pAd->CommonCfg.Dot11OBssScanActivityThre > 100)
+common/action.c:		pAd->CommonCfg.Dot11OBssScanActivityThre = 25;
+common/action.c:	pAd->CommonCfg.Dot11BssWidthChanTranDelay = (pAd->CommonCfg.Dot11BssWidthTriggerScanInt * pAd->CommonCfg.Dot11BssWidthChanTranDelayFactor);
+common/action.c:	/*DBGPRINT(RT_DEBUG_LOUD,("ACT - UpdateBssScanParm( Dot11BssWidthTriggerScanInt = %d )  \n", pAd->CommonCfg.Dot11BssWidthTriggerScanInt));*/
+common/action.c:	for (i = 0;i < pAd->ChannelListNum;i++)
+common/action.c:		if (pAd->ChannelList[i].Channel == NewChannel)
+common/action.c:	if (i == pAd->ChannelListNum)
+common/action.c:	pAd->CommonCfg.Channel = NewChannel;
+common/action.c:		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
+common/action.c:		pAd->MacTab.Content[Wcid].HTPhyMode.field.BW = 0;
+common/action.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 0;
+common/action.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = 0;		
+common/action.c:		rf_channel = pAd->CommonCfg.Channel;
+common/action.c:			(pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth == 1)
+common/action.c:		if (pAd->ApCfg.bGreenAPActive == 1)
+common/action.c:			pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
+common/action.c:			pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel + 2;
+common/action.c:			pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel - 2;
+common/action.c:		rf_channel = pAd->CommonCfg.CentralChannel;
+common/action.c:		pAd->MacTab.Content[Wcid].HTPhyMode.field.BW = 1;
+common/action.c:					pAd->CommonCfg.Channel, 
+common/action.c:					pAd->CommonCfg.CentralChannel));
+common/action.c:				if(pAd->CommonCfg.bBssCoexEnable == FALSE || (pAd->CommonCfg.bForty_Mhz_Intolerant == TRUE))
+common/action.c:												pAd->CommonCfg.bBssCoexEnable,
+common/action.c:												pAd->CommonCfg.bForty_Mhz_Intolerant));
+common/action.c:	if ((Elem->OpMode == OPMODE_AP) || (pAd->OpMode == OPMODE_AP))
+common/action.c:													pAd->ChannelList[coexChRange.effectChStart].Channel,
+common/action.c:													pAd->ChannelList[coexChRange.effectChEnd].Channel));
+common/action.c:								if (chEntry >= pAd->ChannelList[coexChRange.effectChStart].Channel && 
+common/action.c:									chEntry <= pAd->ChannelList[coexChRange.effectChEnd].Channel)
+common/action.c:						NdisMoveMemory((PUCHAR)&pAd->CommonCfg.LastBSSCoexist2040, (PUCHAR)pBssCoexistIe, sizeof(BSS_2040_COEXIST_IE));
+common/action.c:						pAd->CommonCfg.Bss2040CoexistFlag |= BSS_2040_COEXIST_INFO_SYNC;
+common/action.c:						if (!(pAd->CommonCfg.Bss2040CoexistFlag & BSS_2040_COEXIST_TIMER_FIRED))
+common/action.c:									pAd->CommonCfg.Dot11BssWidthChanTranDelay));
+common/action.c:							pAd->CommonCfg.Bss2040CoexistFlag |= BSS_2040_COEXIST_TIMER_FIRED;
+common/action.c:							RTMPSetTimer(&pAd->CommonCfg.Bss2040CoexistTimer,  (pAd->CommonCfg.Dot11BssWidthChanTranDelay + 5) * 1000);
+common/action.c:							RTMPModTimer(&pAd->CommonCfg.Bss2040CoexistTimer, (pAd->CommonCfg.Dot11BssWidthChanTranDelay + 5) * 1000);
+common/action.c:						apidx = pAd->MacTab.Content[Elem->Wcid].apidx;
+common/action.c:						for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/action.c:	if ((Elem->OpMode == OPMODE_STA) || (pAd->OpMode == OPMODE_STA))
+common/action.c:			if ((pAd->StaCfg.BssType == BSS_ADHOC) &&
+common/action.c:				pAd->P2pCfg.bPeriodicListen = FALSE;
+common/action.c:				if (pAd->P2pCfg.P2pCounter.bStartScan)
+common/action.c:					pAd->P2pCfg.P2pCounter.bStartScan = FALSE;
+common/action.c:					pAd->P2pCfg.P2pCounter.bListen = FALSE;
+common/action.c:					pAd->P2pCfg.P2pCounter.bNextScan = FALSE;
+common/action.c:						pAd->P2pCfg.bPeriodicListen = TRUE;
+common/action.c:		pEntry = &pAd->MacTab.Content[Elem->Wcid];
+common/action.c:		if (IS_ENTRY_APCLI(&pAd->MacTab.Content[Elem->Wcid]))
+common/action.c:			apidx = pAd->MacTab.Content[Elem->Wcid].MatchAPCLITabIdx;
+common/action.c:			ActHeaderInit(pAd, &HTINFOframe.Hdr, pAddr, pAd->ApCfg.ApCliTab[apidx].CurrentAddress, pAddr);		
+common/action.c:			apidx = pAd->MacTab.Content[Elem->Wcid].apidx;
+common/action.c:			ActHeaderInit(pAd, &HTINFOframe.Hdr, pAddr, pAd->ApCfg.MBSSID[apidx].Bssid, pAd->ApCfg.MBSSID[apidx].Bssid);
+common/action.c:			ActHeaderInit(pAd, &HTINFOframe.Hdr, pAddr, pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+common/action.c:		ActHeaderInit(pAd, &HTINFOframe.Hdr, pAd->CommonCfg.Bssid, pAd->CurrentAddress, pAddr);
+common/action.c:	HTINFOframe.HT_Info.Forty_MHz_Intolerant = pAd->CommonCfg.HtCapability.HtCapInfo.Forty_Mhz_Intolerant;
+common/action.c:	HTINFOframe.HT_Info.STA_Channel_Width	 = pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth;	
+common/action.c:		pAddr1 = pAd->MacTab.Content[Wcid].Addr;
+common/action.c:	ActHeaderInit(pAd, &Frame.Hdr, pAddr1, pAd->ApCfg.MBSSID[apidx].Bssid, pAd->ApCfg.MBSSID[apidx].Bssid);
+common/action.c:	*(pOutBuffer + FrameLen) = pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth;
+common/action.c:	DBGPRINT(RT_DEBUG_TRACE,("ACT - SendNotifyBWAction(NotifyBW= %d)!\n", pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth));
+common/action.c:	pEntry = &pAd->MacTab.Content[Elem->Wcid];
+common/action.c:			if(pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE)
+common/action.c:											pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth;
+common/action.c:	total = pAd->MacTab.Size * NUM_OF_TID;
+common/action.c:		if  (pAd->BATable.BAOriEntry[i].ORI_BA_Status == Originator_Done)
+common/action.c:			pEntry = &pAd->MacTab.Content[pAd->BATable.BAOriEntry[i].Wcid];
+common/action.c:			TID = pAd->BATable.BAOriEntry[i].TID;
+common/action.c:			ASSERT(pAd->BATable.BAOriEntry[i].Wcid < MAX_LEN_OF_MAC_TABLE);
+common/action.c:		pBAEntry = &pAd->BATable.BAOriEntry[idx];
+common/action.c:					BarHeaderInit(pAd, &FrameBar, pEntry->Addr, pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx].CurrentAddress);			
+common/action.c:					BarHeaderInit(pAd, &FrameBar, pEntry->Addr, pAd->ApCfg.MBSSID[pEntry->apidx].Bssid);					
+common/action.c:				BarHeaderInit(pAd, &FrameBar, pEntry->Addr, pAd->CurrentAddress);
+Binary file common/p2p_packet.o matches
+common/eeprom.c:	RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
+common/eeprom.c:	if(pAd->bUseEfuse)
+common/eeprom.c:				pAd->chipCap.EFUSE_USAGE_MAP_SIZE,
+common/eeprom.c:				pAd->chipCap.EFUSE_USAGE_MAP_START,
+common/eeprom.c:				pAd->chipCap.EFUSE_USAGE_MAP_END));
+common/eeprom.c:		pAd->bFroceEEPROMBuffer = FALSE;
+common/netif_block.c:		initList(&pAd->blockQueueTab[i].NetIfList);
+common/netif_block.c:		NetDev = pAd->ApCfg.MBSSID[IfIdx].MSSIDDev;
+common/netif_block.c:		NetDev = pAd->ApCfg.ApCliTab[IfIdx].dev;
+common/netif_block.c:		if (pAd->OpMode == OPMODE_AP)
+common/netif_block.c:			NetDev = pAd->ApCfg.MBSSID[IfIdx].MSSIDDev;
+common/netif_block.c:			NetDev = pAd->net_dev;
+common/netif_block.c:		NetDev = pAd->net_dev;
+common/netif_block.c:		valid = (pAd->ApCfg.MBSSID[IfIdx].bWmmCapable == TRUE) ? FALSE : TRUE;
+common/netif_block.c:			valid = (pAd->ApCfg.MBSSID[IfIdx].bWmmCapable == TRUE) ? FALSE : TRUE;
+common/netif_block.c:		valid = (pAd->CommonCfg.bWmmCapable == TRUE) ? FALSE : TRUE;
+common/netif_block.c:		blockNetIf(&pAd->blockQueueTab[QueIdx], NetDev);
+Binary file common/cmm_cfg.o matches
+Binary file common/ba_action.o matches
+Binary file common/spectrum.o matches
+Binary file common/cmm_data.o matches
+common/rtmp_timer.c:	pTask = &pAd->timerTask;
+common/rtmp_timer.c:		if (pAd->TimerQ.status == RTMP_TASK_STAT_STOPED)
+common/rtmp_timer.c:		while(pAd->TimerQ.pQHead)
+common/rtmp_timer.c:			RTMP_INT_LOCK(&pAd->TimerQLock, irqFlag);
+common/rtmp_timer.c:			pEntry = pAd->TimerQ.pQHead;
+common/rtmp_timer.c:				pAd->TimerQ.pQHead = pEntry->pNext;
+common/rtmp_timer.c:				if (pEntry == pAd->TimerQ.pQTail)
+common/rtmp_timer.c:					pAd->TimerQ.pQTail = NULL;
+common/rtmp_timer.c:				pEntry->pNext = pAd->TimerQ.pQPollFreeList;
+common/rtmp_timer.c:				pAd->TimerQ.pQPollFreeList = pEntry;
+common/rtmp_timer.c:			RTMP_INT_UNLOCK(&pAd->TimerQLock, irqFlag);
+common/rtmp_timer.c:				if ((pTimer->handle != NULL) && (!pAd->PM_FlgSuspend))
+common/rtmp_timer.c:			pAd->TimerQ.status = RTMP_TASK_STAT_STOPED;
+common/rtmp_timer.c:	RTMP_OS_TASK	*pTask = &pAd->timerTask;
+common/rtmp_timer.c:	RTMP_INT_LOCK(&pAd->TimerQLock, irqFlags);
+common/rtmp_timer.c:	if (pAd->TimerQ.status & RTMP_TASK_CAN_DO_INSERT)
+common/rtmp_timer.c:		if(pAd->TimerQ.pQPollFreeList)
+common/rtmp_timer.c:			pQNode = pAd->TimerQ.pQPollFreeList;
+common/rtmp_timer.c:			pAd->TimerQ.pQPollFreeList = pQNode->pNext;
+common/rtmp_timer.c:			pQTail = pAd->TimerQ.pQTail;
+common/rtmp_timer.c:			if (pAd->TimerQ.pQTail != NULL)
+common/rtmp_timer.c:			pAd->TimerQ.pQTail = pQNode;
+common/rtmp_timer.c:			if (pAd->TimerQ.pQHead == NULL)
+common/rtmp_timer.c:				pAd->TimerQ.pQHead = pQNode;
+common/rtmp_timer.c:	RTMP_INT_UNLOCK(&pAd->TimerQLock, irqFlags);
+common/rtmp_timer.c:	RTMP_INT_LOCK(&pAd->TimerQLock, irqFlags);
+common/rtmp_timer.c:	if (pAd->TimerQ.status >= RTMP_TASK_STAT_INITED)
+common/rtmp_timer.c:		pNode = pAd->TimerQ.pQHead;
+common/rtmp_timer.c:			if (pNode == pAd->TimerQ.pQHead)
+common/rtmp_timer.c:				pAd->TimerQ.pQHead = pNode->pNext;
+common/rtmp_timer.c:			if (pNode == pAd->TimerQ.pQTail)
+common/rtmp_timer.c:				pAd->TimerQ.pQTail = pPrev;
+common/rtmp_timer.c:			pNode->pNext = pAd->TimerQ.pQPollFreeList;
+common/rtmp_timer.c:			pAd->TimerQ.pQPollFreeList = pNode;
+common/rtmp_timer.c:	RTMP_INT_UNLOCK(&pAd->TimerQLock, irqFlags);
+common/rtmp_timer.c:	RTMP_INT_LOCK(&pAd->TimerQLock, irqFlags);
+common/rtmp_timer.c:	while (pAd->TimerQ.pQHead)
+common/rtmp_timer.c:		pTimerQ = pAd->TimerQ.pQHead;
+common/rtmp_timer.c:		pAd->TimerQ.pQHead = pTimerQ->pNext;
+common/rtmp_timer.c:	pAd->TimerQ.pQPollFreeList = NULL;
+common/rtmp_timer.c:	os_free_mem(pAd, pAd->TimerQ.pTimerQPoll);
+common/rtmp_timer.c:	pAd->TimerQ.pQTail = NULL;
+common/rtmp_timer.c:	pAd->TimerQ.pQHead = NULL;
+common/rtmp_timer.c:	pAd->TimerQ.status = RTMP_TASK_STAT_STOPED;
+common/rtmp_timer.c:	RTMP_INT_UNLOCK(&pAd->TimerQLock, irqFlags);
+common/rtmp_timer.c:/*	NdisFreeSpinLock(&pAd->TimerQLock); */
+common/rtmp_timer.c:	NdisAllocateSpinLock(pAd, &pAd->TimerQLock);
+common/rtmp_timer.c:	NdisZeroMemory(&pAd->TimerQ, sizeof(pAd->TimerQ));
+common/rtmp_timer.c:	os_alloc_mem(pAd, &pAd->TimerQ.pTimerQPoll, sizeof(RTMP_TIMER_TASK_ENTRY) * TIMER_QUEUE_SIZE_MAX);
+common/rtmp_timer.c:	if (pAd->TimerQ.pTimerQPoll)
+common/rtmp_timer.c:		pQNode = (RTMP_TIMER_TASK_ENTRY *)pAd->TimerQ.pTimerQPoll;
+common/rtmp_timer.c:		NdisZeroMemory(pAd->TimerQ.pTimerQPoll, sizeof(RTMP_TIMER_TASK_ENTRY) * TIMER_QUEUE_SIZE_MAX);
+common/rtmp_timer.c:		RTMP_INT_LOCK(&pAd->TimerQLock, irqFlags);
+common/rtmp_timer.c:		pAd->TimerQ.pQPollFreeList = pEntry;
+common/rtmp_timer.c:		pAd->TimerQ.pQHead = NULL;
+common/rtmp_timer.c:		pAd->TimerQ.pQTail = NULL;
+common/rtmp_timer.c:		pAd->TimerQ.status = RTMP_TASK_STAT_INITED;
+common/rtmp_timer.c:		RTMP_INT_UNLOCK(&pAd->TimerQLock, irqFlags);
+common/cmm_asic.c:	if (!(pAd->CommonCfg.bHTProtect) && (OperationMode != 8))
+common/cmm_asic.c:	if (pAd->BATable.numDoneOriginator)
+common/cmm_asic.c:			(pAd->CommonCfg.BACapability.field.AmsduEnable) || 
+common/cmm_asic.c:			(pAd->CommonCfg.bAggregationCapable == TRUE))
+common/cmm_asic.c:            && pAd->CommonCfg.RtsThreshold == MAX_RTS_THRESHOLD)
+common/cmm_asic.c:			MacReg |= (pAd->CommonCfg.RtsThreshold << 8);
+common/cmm_asic.c:	if (pAd->OpMode == OPMODE_AP)
+common/cmm_asic.c:		if (pAd->CommonCfg.Channel > 14)
+common/cmm_asic.c:		ProtCfg.field.ProtectRate |= pAd->CommonCfg.RtsRate;	
+common/cmm_asic.c:	else if (pAd->OpMode == OPMODE_STA)
+common/cmm_asic.c:		if (pAd->CommonCfg.Channel > 14)
+common/cmm_asic.c:			if (pAd->CommonCfg.MinTxRate > RATE_11)
+common/cmm_asic.c:		/*ProtCfg.field.ProtectRate = pAd->CommonCfg.RtsRate;*/
+common/cmm_asic.c:		pAd->FlgCtsEnabled = 0; /* CTS-self is not used */
+common/cmm_asic.c:		/*ProtCfg.field.ProtectRate = pAd->CommonCfg.RtsRate;*/
+common/cmm_asic.c:		pAd->FlgCtsEnabled = 1; /* CTS-self is used */
+common/cmm_asic.c:				pAd->CommonCfg.IOTestParm.bRTSLongProtOn = FALSE;
+common/cmm_asic.c:				pAd->CommonCfg.IOTestParm.bRTSLongProtOn = TRUE;
+common/cmm_asic.c:				pAd->CommonCfg.IOTestParm.bRTSLongProtOn = FALSE;
+common/cmm_asic.c:				pAd->CommonCfg.IOTestParm.bRTSLongProtOn = TRUE;
+common/cmm_asic.c:				pAd->CommonCfg.IOTestParm.bRTSLongProtOn = TRUE;
+common/cmm_asic.c:	if (pAd->chipOps.ChipBBPAdjust != NULL)
+common/cmm_asic.c:		pAd->chipOps.ChipBBPAdjust(pAd);
+common/cmm_asic.c:	POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_asic.c:	if (pAd->chipOps.ChipSwitchChannel)
+common/cmm_asic.c:		pAd->chipOps.ChipSwitchChannel(pAd, Channel, bScan);
+common/cmm_asic.c:		RTMPSetAGCInitValue(pAd, pAd->CommonCfg.BBPCurrentBW);
+common/cmm_asic.c:	pAd->TxPowerCtrl.TssiGain[IEEE80211_BAND_2G] = (WordStruct.field.Byte0 & 0x0F);
+common/cmm_asic.c:	pAd->TxPowerCtrl.RefTemp[IEEE80211_BAND_2G] = (CHAR)WordStruct.field.Byte1;
+common/cmm_asic.c:	DBGPRINT(RT_DEBUG_TRACE, ("[temp. compensation 2.4G] tssi gain/step = %u\n", pAd->TxPowerCtrl.TssiGain[IEEE80211_BAND_2G]));
+common/cmm_asic.c:	DBGPRINT(RT_DEBUG_TRACE, ("[temp. compensation 2.4] RefTemp_2G = %d\n", pAd->TxPowerCtrl.RefTemp[IEEE80211_BAND_2G]));
+common/cmm_asic.c:		pAd->TxPowerCtrl.TssiGain[IEEE80211_BAND_5G] = (WordStruct.field.Byte0 & 0x0F);
+common/cmm_asic.c:		pAd->TxPowerCtrl.RefTemp[IEEE80211_BAND_5G] = (CHAR)WordStruct.field.Byte1;
+common/cmm_asic.c:		DBGPRINT(RT_DEBUG_TRACE, ("[temp. compensation 5G] tssi gain/step = %u\n", pAd->TxPowerCtrl.TssiGain[IEEE80211_BAND_5G]));
+common/cmm_asic.c:		DBGPRINT(RT_DEBUG_TRACE, ("[temp. compensation 5G] RefTemp_2G = %d\n", pAd->TxPowerCtrl.RefTemp[IEEE80211_BAND_5G]));
+common/cmm_asic.c:		pAd->TxPowerCtrl.LookupTable[band][1 + Offset] = Step[band] / 2;
+common/cmm_asic.c:		pAd->TxPowerCtrl.LookupTable[band][0 + Offset] = pAd->TxPowerCtrl.LookupTable[band][1 + Offset] - Step[band];
+common/cmm_asic.c:					pAd->TxPowerCtrl.LookupTable[band][Idx + Offset] = pAd->TxPowerCtrl.LookupTable[band][Idx - 1 + Offset] + (Step[band] - (i+1) + 1);
+common/cmm_asic.c:					pAd->TxPowerCtrl.LookupTable[band][Idx + Offset] = pAd->TxPowerCtrl.LookupTable[band][Idx - 1 + Offset] + (Step[band] - (i+1) + 1);
+common/cmm_asic.c:					pAd->TxPowerCtrl.LookupTable[band][-Idx + Offset] = pAd->TxPowerCtrl.LookupTable[band][-Idx + 1 + Offset] - (Step[band] + (i+1) - 1);
+common/cmm_asic.c:					pAd->TxPowerCtrl.LookupTable[band][-Idx + Offset] = pAd->TxPowerCtrl.LookupTable[band][-Idx + 1 + Offset] - (Step[band] + (i+1) - 1);
+common/cmm_asic.c:			DBGPRINT(RT_DEBUG_TRACE, ("[temp. compensation band(%d)] %d, %d\n", band, Idx - Offset, pAd->TxPowerCtrl.LookupTable[band][Idx]));
+common/cmm_asic.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+common/cmm_asic.c:	INT	LookupTableIndex = pAd->TxPowerCtrl.LookupTableIndex + TEMPERATURE_COMPENSATION_LOOKUP_TABLE_OFFSET;
+common/cmm_asic.c:	if (pAd->CommonCfg.Channel > 14)
+common/cmm_asic.c:		bAutoTxAgc = pAd->bAutoTxAgcA;
+common/cmm_asic.c:		pTxAgcCompensate = &pAd->TxAgcCompensateA;
+common/cmm_asic.c:		RefTemp = pAd->TxPowerCtrl.RefTemp[IEEE80211_BAND_5G];
+common/cmm_asic.c:		LookupTable = &pAd->TxPowerCtrl.LookupTable[IEEE80211_BAND_5G][0];
+common/cmm_asic.c:		bAutoTxAgc = pAd->bAutoTxAgcG;
+common/cmm_asic.c:		pTxAgcCompensate = &pAd->TxAgcCompensateG;
+common/cmm_asic.c:		RefTemp = pAd->TxPowerCtrl.RefTemp[IEEE80211_BAND_2G];
+common/cmm_asic.c:		LookupTable = &pAd->TxPowerCtrl.LookupTable[IEEE80211_BAND_2G][0];
+common/cmm_asic.c:		DBGPRINT(RT_DEBUG_INFO, ("[temp. compensation] index = %d\n", pAd->TxPowerCtrl.LookupTableIndex));
+common/cmm_asic.c:		DBGPRINT(RT_DEBUG_INFO, ("[temp. compensation] f(%d)= %d\n", pAd->TxPowerCtrl.LookupTableIndex - 1, LookupTable[LookupTableIndex - 1]));
+common/cmm_asic.c:		DBGPRINT(RT_DEBUG_INFO, ("[temp. compensation] f(%d)= %d\n", pAd->TxPowerCtrl.LookupTableIndex, LookupTable[LookupTableIndex]));
+common/cmm_asic.c:		DBGPRINT(RT_DEBUG_INFO, ("[temp. compensation] f(%d)= %d\n", pAd->TxPowerCtrl.LookupTableIndex + 1, LookupTable[LookupTableIndex + 1]));
+common/cmm_asic.c:			pAd->TxPowerCtrl.LookupTableIndex++;
+common/cmm_asic.c:			pAd->TxPowerCtrl.LookupTableIndex--;
+common/cmm_asic.c:			pAd->TxPowerCtrl.idxTxPowerTable + pAd->TxPowerCtrl.LookupTableIndex,
+common/cmm_asic.c:			pAd->TxPowerCtrl.idxTxPowerTable2 + pAd->TxPowerCtrl.LookupTableIndex,
+common/cmm_asic.c:		TuningTableIndex0 = pAd->TxPowerCtrl.idxTxPowerTable 
+common/cmm_asic.c:									+ pAd->TxPowerCtrl.LookupTableIndex 
+common/cmm_asic.c:									+ pAd->TxPower[pAd->CommonCfg.CentralChannel-1].Power;
+common/cmm_asic.c:									+ pAd->TxPower[pAd->CommonCfg.Channel-1].Power;
+common/cmm_asic.c:		TuningTableIndex1 = pAd->TxPowerCtrl.idxTxPowerTable2 
+common/cmm_asic.c:									+ pAd->TxPowerCtrl.LookupTableIndex 
+common/cmm_asic.c:									+ pAd->TxPower[pAd->CommonCfg.CentralChannel-1].Power2;
+common/cmm_asic.c:									+ pAd->TxPower[pAd->CommonCfg.Channel-1].Power2;
+common/cmm_asic.c:	if ( (pAd->CurrentAddress[5] & 0x01 ) == 0x01 )
+common/cmm_asic.c:		PUCHAR pP2PBssid = &pAd->CurrentAddress[0];
+common/cmm_asic.c:		if (pAd->chipCap.MBSSIDMode == MBSSID_MODE0)
+common/cmm_asic.c:			if ((pAd->CurrentAddress[5] % 2 != 0)
+common/cmm_asic.c:	MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[MCAST_WCID];
+common/cmm_asic.c:	pEntry->CurrTxRate = pAd->CommonCfg.MlmeRate; 
+common/cmm_asic.c:	/*if ( pAd->CommonCfg.bEnableTxBurst )	*/
+common/cmm_asic.c:		&& (pAd->MacTab.fAnyStationMIMOPSDynamic == FALSE)
+common/cmm_asic.c:		if (pAd->CommonCfg.bEnableTxBurst)
+common/cmm_asic.c:	pAd->TbttTickCount = 0;
+common/cmm_asic.c:		csr.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4; /* ASIC register in units of 1/16 TU*/
+common/cmm_asic.c:		csr.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4; /* ASIC register in units of 1/16 TU*/
+common/cmm_asic.c:	USHORT			beaconLen = (USHORT) pAd->BeaconTxWI.TxWIMPDUByteCnt;
+common/cmm_asic.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/cmm_asic.c:	NdisMoveMemory((PUCHAR)&localTxWI, (PUCHAR)&pAd->BeaconTxWI, TXWISize);
+common/cmm_asic.c:	DBGPRINT(RT_DEBUG_TRACE, ("--->AsicEnableIbssSync(TxWIMPDUByteCnt=%d, beaconLen=%d)\n", pAd->BeaconTxWI.TxWIMPDUByteCnt, beaconLen));
+common/cmm_asic.c:	DBGPRINT(RT_DEBUG_TRACE, ("--->AsicEnableIbssSync(ADHOC mode. TxWIMPDUByteCnt = %d)\n", pAd->BeaconTxWI.TxWIMPDUByteCnt));
+common/cmm_asic.c:	ptr = (PUCHAR)&pAd->BeaconTxWI;
+common/cmm_asic.c:	ptr = pAd->BeaconBuf;
+common/cmm_asic.c:	/*for (i=0; i< pAd->BeaconTxWI.TxWIMPDUByteCnt; i+=2)*/
+common/cmm_asic.c:	csr9.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4; /* ASIC register in units of 1/16 TU*/
+common/cmm_asic.c:			if (IS_ENTRY_CLIENT(&pAd->MacTab.Content[i]) || IS_ENTRY_APCLI(&pAd->MacTab.Content[i]))
+common/cmm_asic.c:				CLIENT_STATUS_CLEAR_FLAG(&pAd->MacTab.Content[i], fCLIENT_STATUS_WMM_CAPABLE);
+common/cmm_asic.c:		if( pAd->CommonCfg.bEnableTxBurst )		
+common/cmm_asic.c:		if (WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_B))
+common/cmm_asic.c:		if (WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_B))
+common/cmm_asic.c:		NdisZeroMemory(&pAd->CommonCfg.APEdcaParm, sizeof(EDCA_PARM));
+common/cmm_asic.c:			if (pAd->CommonCfg.bWiFiTest && 
+common/cmm_asic.c:		if (pAd->CommonCfg.bWiFiTest)
+common/cmm_asic.c:			if(pAd->Antenna.field.TxPath == 1)
+common/cmm_asic.c:			if (pAd->CommonCfg.bWiFiTest &&
+common/cmm_asic.c:				CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[BSSID_WCID], fCLIENT_STATUS_WMM_CAPABLE);
+common/cmm_asic.c:		NdisMoveMemory(&pAd->CommonCfg.APEdcaParm, pEdcaParm, sizeof(EDCA_PARM));
+common/cmm_asic.c:	pAd->CommonCfg.RestoreBurstMode = Ac0Cfg.word;
+common/cmm_asic.c:	if (pAd->CommonCfg.Channel > 14)
+common/cmm_asic.c:		if (((pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE) && (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED)))
+common/cmm_asic.c:			|| ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE) && (pAd->CommonCfg.BACapability.field.Policy == BA_NOTUSE))
+common/cmm_asic.c:		else if (pAd->CommonCfg.bEnableTxBurst)
+common/cmm_asic.c:		if (pAd->StaCfg.BssType == BSS_ADHOC)	
+common/cmm_asic.c:	if (pAd->chipOps.sendCommandToMcu)
+common/cmm_asic.c:		return pAd->chipOps.sendCommandToMcu(pAd, Command, Token, Arg0, Arg1, in_atomic);
+common/cmm_asic.c:	if (pAd->chipOps.sendCommandToMcu)
+common/cmm_asic.c:		return pAd->chipOps.sendCommandToMcu(pAd, Command, Token, Arg0, Arg1, FlgIsNeedLocked);
+common/cmm_asic.c:	if (pAd->chipOps.SetRxAnt)
+common/cmm_asic.c:		pAd->chipOps.SetRxAnt(pAd, Ant);
+common/cmm_asic.c:	if (pAd->chipOps.AsicRfTurnOff)
+common/cmm_asic.c:		pAd->chipOps.AsicRfTurnOff(pAd);
+common/cmm_asic.c:		switch (pAd->RfIcType)
+common/cmm_asic.c:						/*if (pAd->StaCfg.bRadio == FALSE)*/
+common/cmm_asic.c:								Channel, pAd->RfIcType, R2, R3));
+common/cmm_asic.c:								Channel, pAd->RfIcType, R2));
+common/cmm_asic.c:											Channel, pAd->RfIcType));
+common/cmm_asic.c:	UINT8 mode = pAd->chipCap.FlgIsVcoReCalMode;
+common/cmm_asic.c:	if (pAd->CommonCfg.Channel <= 14)
+common/cmm_asic.c:		if (pAd->Antenna.field.TxPath == 1)
+common/cmm_asic.c:		else if (pAd->Antenna.field.TxPath == 2)
+common/cmm_asic.c:		else if (pAd->Antenna.field.TxPath == 3)
+common/cmm_asic.c:		if (pAd->Antenna.field.TxPath == 1)
+common/cmm_asic.c:		else if (pAd->Antenna.field.TxPath == 2)
+common/cmm_asic.c:		else if (pAd->Antenna.field.TxPath == 3)
+common/cmm_asic.c:		if (pAd->CommonCfg.RegTransmitSetting.field.ITxBfEn
+common/cmm_asic.c:			&& (pAd->CommonCfg.DebugFlags & DBF_DISABLE_CAL)==0
+common/cmm_asic.c:		if (pAd->CommonCfg.ETxBfEnCond)
+common/cmm_asic.c:				pEntry = &pAd->MacTab.Content[idx];
+common/cmm_asic.c:	switch (pAd->CommonCfg.StreamMode)
+common/cmm_asic.c:	if (!pAd->chipCap.FlgHwStreamMode)
+common/cmm_asic.c:	if (pAd->chipCap.FlgHwStreamMode == FALSE)
+common/cmm_asic.c:		pMacAddr = &pAd->CommonCfg.StreamModeMac[chainIdx][0];
+common/cmm_asic.c:	pAd->CommonCfg.RestoreBurstMode = Data;
+common/cmm_asic.c:	Data = pAd->CommonCfg.RestoreBurstMode;
+common/cmm_asic.c:		&& (pAd->MacTab.fAnyStationMIMOPSDynamic == FALSE)
+common/cmm_asic.c:		else if (pAd->CommonCfg.bEnableTxBurst)
+common/cmm_asic.c:		pAd->WOW_Cfg.bWOWFirmware = TRUE;
+common/cmm_asic.c:		pAd->WOW_Cfg.bWOWFirmware = FALSE;
+common/cmm_asic.c:	UINT32 cipher = pAd->StaCfg.GroupCipher;
+common/cmm_asic.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/cmm_asic.c:	TxWI = (TXWI_STRUC *)&pAd->NullContext.TransferBuffer->field.WirelessPacket[TXINFO_SIZE];
+common/cmm_asic.c:	NullFrame = (PUCHAR)&pAd->NullFrame;
+common/cmm_asic.c:	DBGPRINT(RT_DEBUG_OFF, ("Write GroupCipher Mode: %d\n", pAd->StaCfg.GroupCipher));
+common/rtusb_bulk.c:		if (pAd->TxContext[i].CurWritePosition>=pAd->TxContext[i].ENextBulkOutPosition)
+common/rtusb_bulk.c:			PacketsInQueueSize=pAd->TxContext[i].CurWritePosition-pAd->TxContext[i].ENextBulkOutPosition;
+common/rtusb_bulk.c:			PacketsInQueueSize=MAX_TXBULK_SIZE-pAd->TxContext[i].ENextBulkOutPosition+pAd->TxContext[i].CurWritePosition;
+common/rtusb_bulk.c:		if (pAd->BulkOutDataSizeCount[i]>20480 || PacketsInQueueSize>6144)
+common/rtusb_bulk.c:			pAd->BulkOutDataFlag[i]=TRUE;
+common/rtusb_bulk.c:			pAd->BulkOutDataFlag[i]=FALSE;
+common/rtusb_bulk.c:		pAd->BulkOutDataSizeCount[i]=0;
+common/rtusb_bulk.c:	if (RunningQueueNo>pAd->LastRunningQueueNo)
+common/rtusb_bulk.c:		DBGPRINT(RT_DEBUG_INFO,("SoftwareFlowControl  reset %d > %d \n",RunningQueueNo,pAd->LastRunningQueueNo));
+common/rtusb_bulk.c:		 pAd->RunningQueueNoCount=0;
+common/rtusb_bulk.c:		 pAd->LastRunningQueueNo=RunningQueueNo;
+common/rtusb_bulk.c:	else if (RunningQueueNo==pAd->LastRunningQueueNo)
+common/rtusb_bulk.c:pAd->RunningQueueNoCount=0;
+common/rtusb_bulk.c:	else if (RunningQueueNo<pAd->LastRunningQueueNo)
+common/rtusb_bulk.c:		DBGPRINT(RT_DEBUG_INFO,("SoftwareFlowControl  reset %d < %d \n",RunningQueueNo,pAd->LastRunningQueueNo));
+common/rtusb_bulk.c:		pAd->RunningQueueNoCount++;
+common/rtusb_bulk.c:		if (pAd->RunningQueueNoCount>=6)
+common/rtusb_bulk.c:			pAd->RunningQueueNoCount=0;
+common/rtusb_bulk.c:			pAd->LastRunningQueueNo=RunningQueueNo;
+common/rtusb_bulk.c:				if (pAd->BulkOutDataFlag[i]==TRUE && Priority[i]>Priority[QueIdx])
+common/rtusb_bulk.c:			pAd->BulkOutDataSizeLimit[QueIdx]=MaxBulkOutsSizeLimit[RunningQueueNo][HighWorkingAcCount];
+common/rtusb_bulk.c:			DBGPRINT(RT_DEBUG_TRACE, ("Reset bulkout size AC0(BE):%7d AC1(BK):%7d AC2(VI):%7d AC3(VO):%7d %d\n",pAd->BulkOutDataSizeLimit[0]
+common/rtusb_bulk.c:			,pAd->BulkOutDataSizeLimit[1]
+common/rtusb_bulk.c:			,pAd->BulkOutDataSizeLimit[2]
+common/rtusb_bulk.c:			,pAd->BulkOutDataSizeLimit[3]
+common/rtusb_bulk.c:	POS_COOKIE			pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/rtusb_bulk.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+common/rtusb_bulk.c:	POS_COOKIE			pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/rtusb_bulk.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+common/rtusb_bulk.c:	POS_COOKIE			pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/rtusb_bulk.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+common/rtusb_bulk.c:	if ( pAd->BulkInMaxPacketSize == 64)
+common/rtusb_bulk.c:					&(pRxContext->TransferBuffer[pAd->NextRxBulkInPosition]),
+common/rtusb_bulk.c:					RX_bulk_size - (pAd->NextRxBulkInPosition),
+common/rtusb_bulk.c:					(pRxContext->data_dma + pAd->NextRxBulkInPosition));
+common/rtusb_bulk.c:	POS_COOKIE pObj = (POS_COOKIE)pAd->OS_Cookie;
+common/rtusb_bulk.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+common/rtusb_bulk.c:	//printk("%s, Bulk In add = 0x%x\n", __FUNCTION__, pAd->BulkInEpAddr[1]);
+common/rtusb_bulk.c:	BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+common/rtusb_bulk.c:	if ((pAd->BulkOutPending[BulkOutPipeId] == TRUE) || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX)
+common/rtusb_bulk.c:		BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+common/rtusb_bulk.c:	pAd->BulkOutPending[BulkOutPipeId] = TRUE;
+common/rtusb_bulk.c:		pAd->BulkOutPending[BulkOutPipeId] = FALSE;
+common/rtusb_bulk.c:		BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+common/rtusb_bulk.c:	BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+common/rtusb_bulk.c:	pHTTXContext = &(pAd->TxContext[BulkOutPipeId]);
+common/rtusb_bulk.c:	BULK_OUT_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags2);
+common/rtusb_bulk.c:		BULK_OUT_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags2);
+common/rtusb_bulk.c:		BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+common/rtusb_bulk.c:		pAd->BulkOutPending[BulkOutPipeId] = FALSE;
+common/rtusb_bulk.c:		BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+common/rtusb_bulk.c:		if (pAd->bForcePrintTX == TRUE)
+common/rtusb_bulk.c:		if (pAd->bForcePrintTX == TRUE)
+common/rtusb_bulk.c:				else if (((ThisBulkSize&0xffff8000) != 0) || ((ThisBulkSize&pAd->BulkOutDataSizeLimit[BulkOutPipeId]) == pAd->BulkOutDataSizeLimit[BulkOutPipeId]))
+common/rtusb_bulk.c:			/*DBGPRINT(RT_DEBUG_TRACE,("b mode BulkOutPipeId %d  pAd->BulkOutDataSizeLimit[BulkOutPipeId] %d  \n",BulkOutPipeId,pAd->BulkOutDataSizeLimit[BulkOutPipeId]));*/
+common/rtusb_bulk.c:			else if (((pAd->BulkOutMaxPacketSize < 512) && ((ThisBulkSize&0xfffff800) != 0) ) /*|| ( (ThisBulkSize != 0)  && (pTxWI->AMPDU == 0))*/)
+common/rtusb_bulk.c:			else if (((pAd->BulkOutMaxPacketSize < 512) && (((ThisBulkSize&0xffff8000) != 0) || ((ThisBulkSize&BULKOUT_SIZE) == BULKOUT_SIZE)) ))
+common/rtusb_bulk.c:		else if (((ThisBulkSize&0xffff8000) != 0) || ((ThisBulkSize&pAd->BulkOutDataSizeLimit[BulkOutPipeId]) == pAd->BulkOutDataSizeLimit[BulkOutPipeId]))
+common/rtusb_bulk.c:		else if (((pAd->BulkOutMaxPacketSize < 512) && ((ThisBulkSize&0xfffff800) != 0) ) /*|| ( (ThisBulkSize != 0)  && (pTxWI->AMPDU == 0))*/)
+common/rtusb_bulk.c:			else if (((pAd->BulkOutMaxPacketSize < 512) && (((ThisBulkSize&0xffff8000) != 0) || ((ThisBulkSize&BULKOUT_SIZE) == BULKOUT_SIZE)) ))
+common/rtusb_bulk.c:			BULK_OUT_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags2);
+common/rtusb_bulk.c:			pAd->bForcePrintTX = TRUE;
+common/rtusb_bulk.c:			BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+common/rtusb_bulk.c:			pAd->BulkOutPending[BulkOutPipeId] = FALSE;
+common/rtusb_bulk.c:			BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+common/rtusb_bulk.c:		pAd->RalinkCounters.OneSecTransmittedByteCount +=  pTxWI->TxWIMPDUByteCnt;
+common/rtusb_bulk.c:		pAd->RalinkCounters.TransmittedByteCount +=  pTxWI->TxWIMPDUByteCnt;
+common/rtusb_bulk.c:	if (pAd->bForcePrintTX == TRUE)
+common/rtusb_bulk.c:	pAd->watchDogTxPendingCnt[BulkOutPipeId] = 1;
+common/rtusb_bulk.c:	BULK_OUT_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags2);
+common/rtusb_bulk.c:		BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+common/rtusb_bulk.c:		pAd->BulkOutPending[BulkOutPipeId] = FALSE;
+common/rtusb_bulk.c:		pAd->watchDogTxPendingCnt[BulkOutPipeId] = 0;
+common/rtusb_bulk.c:		BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+common/rtusb_bulk.c:	BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+common/rtusb_bulk.c:	BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+common/rtusb_bulk.c:	pAd->BulkOutReq++;
+common/rtusb_bulk.c:	pObj 			= (POS_COOKIE) pAd->OS_Cookie;
+common/rtusb_bulk.c:	pAd->BulkOutDataOneSecCount++;
+common/rtusb_bulk.c:	PTX_CONTEXT		pNullContext = &(pAd->NullContext);
+common/rtusb_bulk.c:	RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], IrqFlags);
+common/rtusb_bulk.c:	if ((pAd->BulkOutPending[0] == TRUE) || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX))
+common/rtusb_bulk.c:		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
+common/rtusb_bulk.c:	pAd->BulkOutPending[0] = TRUE;
+common/rtusb_bulk.c:	pAd->watchDogTxPendingCnt[0] = 1;
+common/rtusb_bulk.c:	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
+common/rtusb_bulk.c:	pAd->RalinkCounters.TransmittedByteCount +=  pNullContext->BulkOutSize;
+common/rtusb_bulk.c:		RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], IrqFlags);
+common/rtusb_bulk.c:		pAd->BulkOutPending[0] = FALSE;
+common/rtusb_bulk.c:		pAd->watchDogTxPendingCnt[0] = 0;
+common/rtusb_bulk.c:		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
+common/rtusb_bulk.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/rtusb_bulk.c:	pMLMEContext = (PTX_CONTEXT)pAd->MgmtRing.Cell[pAd->MgmtRing.TxDmaIdx].AllocVa;
+common/rtusb_bulk.c:	if ((pAd->MgmtRing.TxSwFreeIdx >= MGMT_RING_SIZE) ||
+common/rtusb_bulk.c:	RTMP_IRQ_LOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
+common/rtusb_bulk.c:	if ((pAd->BulkOutPending[MGMTPIPEIDX] == TRUE) || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX))
+common/rtusb_bulk.c:		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
+common/rtusb_bulk.c:	pAd->BulkOutPending[MGMTPIPEIDX] = TRUE;
+common/rtusb_bulk.c:	pAd->watchDogTxPendingCnt[MGMTPIPEIDX] = 1;
+common/rtusb_bulk.c:	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
+common/rtusb_bulk.c:	pAd->RalinkCounters.TransmittedByteCount +=  pMLMEContext->BulkOutSize;
+common/rtusb_bulk.c:		RTMP_IRQ_LOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
+common/rtusb_bulk.c:		pAd->BulkOutPending[MGMTPIPEIDX] = FALSE;
+common/rtusb_bulk.c:		pAd->watchDogTxPendingCnt[MGMTPIPEIDX] = 0;
+common/rtusb_bulk.c:		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
+common/rtusb_bulk.c:	pObj 			= (POS_COOKIE)pAd->OS_Cookie;
+common/rtusb_bulk.c:	PTX_CONTEXT		pPsPollContext = &(pAd->PsPollContext);
+common/rtusb_bulk.c:	RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], IrqFlags);
+common/rtusb_bulk.c:	if ((pAd->BulkOutPending[0] == TRUE) || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NEED_STOP_TX))
+common/rtusb_bulk.c:		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
+common/rtusb_bulk.c:	pAd->BulkOutPending[0] = TRUE;
+common/rtusb_bulk.c:	pAd->watchDogTxPendingCnt[0] = 1;
+common/rtusb_bulk.c:	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
+common/rtusb_bulk.c:		RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], IrqFlags);
+common/rtusb_bulk.c:		pAd->BulkOutPending[0] = FALSE;
+common/rtusb_bulk.c:		pAd->watchDogTxPendingCnt[0] = 0;
+common/rtusb_bulk.c:		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], IrqFlags);
+common/rtusb_bulk.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/rtusb_bulk.c:	RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
+common/rtusb_bulk.c:	pRxContext = &(pAd->RxContext[pAd->NextRxBulkInIndex]);
+common/rtusb_bulk.c:	if ((pAd->PendingRx > 0) || (pRxContext->Readable == TRUE) || (pRxContext->InUse == TRUE))
+common/rtusb_bulk.c:		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
+common/rtusb_bulk.c:	pAd->PendingRx++;
+common/rtusb_bulk.c:	pAd->BulkInReq++;
+common/rtusb_bulk.c:	RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
+common/rtusb_bulk.c:		RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
+common/rtusb_bulk.c:		pAd->PendingRx--;
+common/rtusb_bulk.c:		pAd->BulkInReq--;
+common/rtusb_bulk.c:		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
+common/rtusb_bulk.c:	PCMD_RSP_CONTEXT pCmdRspEventContext = &pAd->CmdRspEventContext;
+common/rtusb_bulk.c:	RTMP_IRQ_LOCK(&pAd->CmdRspLock, IrqFlags);
+common/rtusb_bulk.c:		RTMP_IRQ_UNLOCK(&pAd->CmdRspLock, IrqFlags);
+common/rtusb_bulk.c:	RTMP_IRQ_UNLOCK(&pAd->CmdRspLock, IrqFlags);
+common/rtusb_bulk.c:		RTMP_IRQ_LOCK(&pAd->CmdRspLock, IrqFlags);
+common/rtusb_bulk.c:		RTMP_IRQ_UNLOCK(&pAd->CmdRspLock, IrqFlags);
+common/rtusb_bulk.c:		RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
+common/rtusb_bulk.c:		pRxContext = &(pAd->RxContext[pAd->NextRxBulkInReadIndex]);
+common/rtusb_bulk.c:			RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
+common/rtusb_bulk.c:			RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
+common/rtusb_bulk.c:			pAd->ReadPosition = 0;
+common/rtusb_bulk.c:			pAd->TransferBufferLength = 0;
+common/rtusb_bulk.c:			INC_RING_INDEX(pAd->NextRxBulkInReadIndex, RX_RING_SIZE);
+common/rtusb_bulk.c:			RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
+common/rtusb_bulk.c:			RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
+common/rtusb_bulk.c:	PCMD_RSP_CONTEXT pCmdRspEventContext = &pAd->CmdRspEventContext;
+common/rtusb_bulk.c:	RTMP_IRQ_LOCK(&pAd->CmdRspLock, IrqFlags);
+common/rtusb_bulk.c:		RTMP_IRQ_UNLOCK(&pAd->CmdRspLock, IrqFlags);
+common/rtusb_bulk.c:		RTMP_IRQ_LOCK(&pAd->CmdRspLock, IrqFlags);
+common/rtusb_bulk.c:		RTMP_IRQ_UNLOCK(&pAd->CmdRspLock, IrqFlags);
+common/rtusb_bulk.c:		RTMP_IRQ_UNLOCK(&pAd->CmdRspLock, IrqFlags);
+common/rtusb_bulk.c:	pObj 		= (POS_COOKIE) pAd->OS_Cookie;
+common/rtusb_bulk.c:	pObj = (POS_COOKIE)pAd->OS_Cookie;
+common/rtusb_bulk.c:				 (pAd->MgmtRing.TxSwFreeIdx < MGMT_RING_SIZE))
+common/rtusb_bulk.c:			RTUSBBulkOutMLMEPacket(pAd, pAd->MgmtRing.TxDmaIdx);
+common/rtusb_bulk.c:				RTUSBBulkOutDataPacket(pAd, EDCA_AC0_PIPE, pAd->NextBulkOutIndex[EDCA_AC0_PIPE]);
+common/rtusb_bulk.c:				RTUSBBulkOutDataPacket(pAd, EDCA_AC1_PIPE, pAd->NextBulkOutIndex[EDCA_AC1_PIPE]);
+common/rtusb_bulk.c:				RTUSBBulkOutDataPacket(pAd, EDCA_AC2_PIPE, pAd->NextBulkOutIndex[EDCA_AC2_PIPE]);
+common/rtusb_bulk.c:				RTUSBBulkOutDataPacket(pAd, EDCA_AC3_PIPE, pAd->NextBulkOutIndex[EDCA_AC3_PIPE]);
+common/rtusb_bulk.c:		pTxContext = &pAd->TxContext[Idx];
+common/rtusb_bulk.c:		NdisAcquireSpinLock(&pAd->BulkOutLock[Idx]);
+common/rtusb_bulk.c:		pAd->BulkOutPending[Idx] = FALSE;
+common/rtusb_bulk.c:		NdisReleaseSpinLock(&pAd->BulkOutLock[Idx]);
+common/rtusb_bulk.c:	PCMD_RSP_CONTEXT pCmdRspEventContext = &pAd->CmdRspEventContext;
+common/rtusb_bulk.c:		pRxContext = &(pAd->RxContext[i]);
+common/rtusb_bulk.c:			/*NdisInterlockedDecrement(&pAd->PendingRx);*/
+common/rtusb_bulk.c:			/*pAd->PendingRx--;*/
+common/rtusb_bulk.c:/*	pLock = &pAd->BulkOutLock[MGMTPIPEIDX];*/
+common/rtusb_bulk.c:/*	pPending = &pAd->BulkOutPending[MGMTPIPEIDX];*/
+common/rtusb_bulk.c:		pHTTXContext = &(pAd->TxContext[Idx]);
+common/rtusb_bulk.c:		pAd->BulkOutPending[Idx] = FALSE;
+common/rtusb_bulk.c:		pMLMEContext = (PTX_CONTEXT)pAd->MgmtRing.Cell[i].AllocVa;
+common/rtusb_bulk.c:	pAd->BulkOutPending[MGMTPIPEIDX] = FALSE;
+common/rtusb_bulk.c:	pNullContext = &(pAd->NullContext);
+common/rtusb_bulk.c:	pPsPollContext = &(pAd->PsPollContext);
+common/rtusb_bulk.c:		NdisAcquireSpinLock(&pAd->BulkOutLock[Idx]);
+common/rtusb_bulk.c:		pAd->BulkOutPending[Idx] = FALSE;
+common/rtusb_bulk.c:		NdisReleaseSpinLock(&pAd->BulkOutLock[Idx]);
+common/p2p.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	RTMPZeroMemory(pAd->P2pCfg.SSID, MAX_LEN_OF_SSID);
+common/p2p.c:	RTMPMoveMemory(pAd->P2pCfg.SSID, WILDP2PSSID, WILDP2PSSIDLEN);
+common/p2p.c:	/*RTMPMoveMemory(pAd->P2pCfg.Bssid, pAd->P2pCfg.CurrentAddress, MAC_ADDR_LEN); */
+common/p2p.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	if ((pP2PCtrl->P2pCounter.bStartScan == TRUE) && (pAd->P2pCfg.P2pCounter.CounterAftrScanButton == 0))
+common/p2p.c:	if (pAd->P2pCfg.P2pCounter.UserAccept > 0)
+common/p2p.c:		pAd->P2pCfg.P2pCounter.UserAccept--;
+common/p2p.c:			PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:		else if ((pAd->P2pCfg.P2PConnectState == P2P_DO_GO_SCAN_DONE) 
+common/p2p.c:			|| (pAd->P2pCfg.P2PConnectState == P2P_DO_GO_SCAN_OP_DONE))
+common/p2p.c:				/* BssIdx = BssTableSearch(pAd, &pAd->ScanTab, pAd->P2pCfg.Bssid, pAd->StaCfg.WscControl.WscAPChannel); */
+common/p2p.c:				BssIdx = BssTableSearch(&pAd->ScanTab, pAd->P2pCfg.Bssid, pAd->MlmeAux.Channel);
+common/p2p.c:				DBGPRINT(RT_DEBUG_ERROR, ("CNTL - Nr= %d. Channel = %d. BSSID not found.  %02x:%02x:%02x:%02x:%02x:%02x.\n", pAd->ScanTab.BssNr, pAd->MlmeAux.Channel /*pAd->StaCfg.WscControl.WscAPChannel*/, PRINT_MAC(pP2PCtrl->Bssid)));
+common/p2p.c:			else if (pAd->ScanTab.BssEntry[BssIdx].SsidLen < 9)
+common/p2p.c:				DBGPRINT(RT_DEBUG_ERROR, ("CNTL -Nr= %d. Channel = %d.	SSID is  %c%c%c%c%c%c \n", pAd->ScanTab.BssNr, pAd->MlmeAux.Channel /*pAd->StaCfg.WscControl.WscAPChannel*/, pAd->P2pCfg.SSID[0], pAd->P2pCfg.Bssid[1],pAd->P2pCfg.SSID[2],pAd->P2pCfg.SSID[3],pAd->P2pCfg.SSID[4],pAd->P2pCfg.SSID[5]));
+common/p2p.c:				DBGPRINT(RT_DEBUG_ERROR, ("CNTL -	Goback to %s  \n", decodeP2PState(pAd->P2pCfg.P2PConnectState)));
+common/p2p.c: 			RTMPMoveMemory(pP2PCtrl->PortCfg.Ssid, pAd->ScanTab.BssEntry[BssIdx].Ssid,32);
+common/p2p.c:			pP2PCtrl->PortCfg.SsidLen = pAd->ScanTab.BssEntry[BssIdx].SsidLen;
+common/p2p.c:			RTMPSetTimer(&pAd->P2pCfg.P2pSwNoATimer, GPDiff);
+common/p2p.c:			pAd->P2pCfg.GONoASchedule.SwTimerTickCounter++;
+common/p2p.c:			if (pAd->P2pCfg.GONoASchedule.bInAwake == FALSE)
+common/p2p.c:					RTMPSetTimer(&pAd->P2pCfg.P2pPreAbsenTimer, (GPDiff - 10));
+common/p2p.c:		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &Cancelled);
+common/p2p.c:		pAd->MlmeAux.Channel = 0;
+common/p2p.c:	RTMPZeroMemory(&pAd->P2pCfg.ConnectingMAC[0], MAC_ADDR_LEN);
+common/p2p.c:	DBGPRINT(RT_DEBUG_INFO, ("<---- P2P - P2pStopScan @channel = %d.\n", pAd->MlmeAux.Channel));
+common/p2p.c:		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &Cancelled);
+common/p2p.c:		pAd->MlmeAux.Channel = 0;
+common/p2p.c:	DBGPRINT(RT_DEBUG_INFO, ("----> P2P - P2pStopScan @channel = %d.\n", pAd->MlmeAux.Channel));
+common/p2p.c:	/* pAd->P2pCfg.P2PDiscoProvState = P2P_ENABLE_LISTEN_ONLY; */
+common/p2p.c:	pAd->P2pCfg.P2pCounter.Counter100ms = 0;
+common/p2p.c:	/* pAd->P2pCfg.P2pCounter.NextScanRound = (RandomByte(pAd) % P2P_RANDOM_BASE) + P2P_RANDOM_BIAS; */
+common/p2p.c:	pAd->P2pCfg.CtrlCurrentState = P2P_CTRL_IDLE;
+common/p2p.c:	pAd->P2pCfg.DiscCurrentState = P2P_DISC_IDLE;
+common/p2p.c:	pAd->P2pCfg.GoFormCurrentState = P2P_GO_FORM_IDLE;
+common/p2p.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	pAd->P2pCfg.P2pCounter.Counter100ms = 0;
+common/p2p.c:	pAd->P2pCfg.P2pCounter.NextScanRound = 5;
+common/p2p.c:	pAd->P2pCfg.GONoASchedule.Token++;
+common/p2p.c:	pAd->P2pCfg.GONoASchedule.bValid = TRUE;
+common/p2p.c:	RTMP_IO_READ32(pAd, TSF_TIMER_DW1, &pAd->P2pCfg.GONoASchedule.TsfHighByte);
+common/p2p.c:	DBGPRINT(RT_DEBUG_TRACE,("P2pGOStartNoA parameter.!!!!HighByte = %lx \n", pAd->P2pCfg.GONoASchedule.TsfHighByte));
+common/p2p.c:	pAd->P2pCfg.GONoASchedule.StartTime = Value + TimeTillTbtt*64 + 512000 + 25600;
+common/p2p.c:	pAd->P2pCfg.GONoASchedule.NextTargetTimePoint = Value + TimeTillTbtt*64 + 512000 + 25600 + pAd->P2pCfg.GONoASchedule.Duration;
+common/p2p.c:	pAd->P2pCfg.GONoASchedule.ThreToWrapAround = pAd->P2pCfg.GONoASchedule.StartTime + 0x7fffffff;
+common/p2p.c:	DBGPRINT(RT_DEBUG_TRACE,("   .!!!!Expect Starttime= %ld. ThreToWrapAround = %ld. \n", temp, pAd->P2pCfg.GONoASchedule.ThreToWrapAround));
+common/p2p.c:	pAd->P2pCfg.GONoASchedule.bInAwake = TRUE;
+common/p2p.c:	RTMPCancelTimer(&pAd->P2pCfg.P2pPreAbsenTimer, &Cancelled);
+common/p2p.c:	pAd->P2pCfg.bKeepSlient = FALSE;
+common/p2p.c:	pAd->P2pCfg.bPreKeepSlient = FALSE;
+common/p2p.c:	RTMPCancelTimer(&pAd->P2pCfg.P2pSwNoATimer, &Cancelled);
+common/p2p.c:	pAd->P2pCfg.GONoASchedule.bValid = FALSE;
+common/p2p.c:	pAd->P2pCfg.GONoASchedule.bInAwake = TRUE;
+common/p2p.c:	pAd->P2pCfg.GONoASchedule.bWMMPSInAbsent = FALSE; /* Set to FALSE if changes state to Awake */
+common/p2p.c:	if (pAd->P2pCfg.GONoASchedule.bNeedResumeNoA == FALSE)
+common/p2p.c:		pAd->P2pCfg.GONoASchedule.Count = 1;
+common/p2p.c:		pAd->P2pCfg.GONoASchedule.Duration = 0xc800;
+common/p2p.c:		pAd->P2pCfg.GONoASchedule.Interval = 0x19000;
+common/p2p.c:	pAd->P2pCfg.GONoASchedule.SwTimerTickCounter = 0;
+common/p2p.c:	pAd->P2pCfg.bPreKeepSlient = FALSE;
+common/p2p.c:	if (pAd->P2pCfg.GONoASchedule.bValid == TRUE)
+common/p2p.c:	pAd->P2pCfg.CTWindows = 0x8a;
+common/p2p.c:	pAd->P2pCfg.bKeepSlient = FALSE;
+common/p2p.c:	if (pAd->P2pCfg.GONoASchedule.bValid == FALSE)
+common/p2p.c:		pAd->P2pCfg.bKeepSlient = FALSE;
+common/p2p.c:	if (P2P_TEST_BIT(pAd->P2pCfg.CTWindows, P2P_OPPS_BIT))
+common/p2p.c:		pAd->P2pCfg.bFirstTimeCancelOpps = TRUE;
+common/p2p.c:	pAd->P2pCfg.CTWindows = 0;
+common/p2p.c:	pAd->P2pCfg.bPreKeepSlient = TRUE;
+common/p2p.c:	PRT_P2P_CONFIG 	pP2pCtrl = &pAd->P2pCfg;
+common/p2p.c:		PWSC_CTRL			pWscControl = &pAd->ApCfg.MBSSID[0].WscControl;
+common/p2p.c:			pEntry = &pAd->MacTab.Content[i];
+common/p2p.c:		DBGPRINT(RT_DEBUG_ERROR, ("P2pWscTimeOut - Total= %d. p2pEntry = %d.\n", pAd->MacTab.Size, p2pEntryCnt));
+common/p2p.c:		if ((p2pEntryCnt == 0) && (pAd->flg_p2p_OpStatusFlags == P2P_GO_UP))
+common/p2p.c:	PRT_P2P_CONFIG	pP2pCtrl = &pAd->P2pCfg;
+common/p2p.c:		pP2pEntry = &pAd->P2pTable.Client[p2pindex];
+common/p2p.c:						pAd->P2pCfg.P2pCounter.UserAccept = 0;
+common/p2p.c:	PRT_P2P_CONFIG	pP2pCtrl = &pAd->P2pCfg;
+common/p2p.c:			pAd->P2pCfg.CTWindows = *(pData+4); 
+common/p2p.c:		pAd->P2pCfg.CTWindows = *(pData+4); 
+common/p2p.c:		Value = pAd->P2pCfg.GONoASchedule.LastBeaconTimeStamp;
+common/p2p.c:		pAd->P2pCfg.GONoASchedule.CurrentTargetTimePoint = pMacClient->P2pInfo.NoADesc[0].StartTime;
+common/p2p.c:			pAd->P2pCfg.GONoASchedule.OngoingAwakeTime = pMacClient->P2pInfo.NoADesc[0].NextTargetTimePoint;
+common/p2p.c:			pAd->P2pCfg.GONoASchedule.NextTimePointForWMMPSCounting = pMacClient->P2pInfo.NoADesc[0].StartTime;
+common/p2p.c:			pAd->P2pCfg.GONoASchedule.LastBeaconTimeStamp += GPDiff;
+common/p2p.c:					pAd->P2pCfg.GONoASchedule.OngoingAwakeTime = pMacClient->P2pInfo.NoADesc[0].NextTargetTimePoint;
+common/p2p.c:					pAd->P2pCfg.GONoASchedule.LastBeaconTimeStamp += GPDiff;
+common/p2p.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:			P2pStopNoA(pAd, &pAd->MacTab.Content[pP2PCtrl->MyGOwcid]);
+common/p2p.c:			pAd->MacTab.Content[pP2PCtrl->MyGOwcid].P2pInfo.NoADesc[0].Token--;
+common/p2p.c:			P2pHandleNoAAttri(pAd, &pAd->MacTab.Content[pP2PCtrl->MyGOwcid], &FakeNoAAttribute[0]);
+common/p2p.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:			Value = pAd->P2pCfg.GONoASchedule.LastBeaconTimeStamp;
+common/p2p.c:				DBGPRINT(RT_DEBUG_INFO,(" NextTargetTimePoint = %ld. \n", pAd->P2pCfg.GONoASchedule.NextTargetTimePoint));
+common/p2p.c:						/*DBGPRINT(RT_DEBUG_TRACE,("SwBasedNoA : Dequeue here. %d\n", pAd->TxSwNoAMgmtQueue.Number));*/
+common/p2p.c:		pEntry = &pAd->MacTab.Content[pP2PCtrl->NoAIndex];
+common/p2p.c:			MacValue = pAd->P2pCfg.GONoASchedule.LastBeaconTimeStamp;
+common/p2p.c:				pAd->P2pCfg.GONoASchedule.NextTimePointForWMMPSCounting = pEntry->P2pInfo.NoADesc[0].NextTargetTimePoint;
+common/p2p.c:						/*DBGPRINT(RT_DEBUG_TRACE,("SwBasedNoA : Dequeue here. %d\n", pAd->TxSwNoAMgmtQueue.Number));*/
+common/p2p.c:				DBGPRINT(RT_DEBUG_TRACE,("Enter Awake now ======= %d\n", pAd->P2pCfg.bKeepSlient));
+common/p2p.c:	DBGPRINT(RT_DEBUG_TRACE, ("--->P2pPauseBssSync  %s\n", decodeP2PState(pAd->P2pCfg.P2PConnectState)));
+common/p2p.c:	DBGPRINT(RT_DEBUG_TRACE, ("--->P2pResumeBssSync  %s\n", decodeP2PState(pAd->P2pCfg.P2PConnectState)));
+common/p2p.c:	PRT_P2P_CONFIG pP2pCtrl = &pAd->P2pCfg;
+common/p2p.c:		Before reinvoke a persistent group, copy persistent parameter to pAd->P2pCfg.. 
+common/p2p.c:	NdisMoveMemory((pSSID + 9), pAd->P2pCfg.DeviceName, pAd->P2pCfg.DeviceNameLen);
+common/p2p.c:	(*pSSIDLen) = 9 + pAd->P2pCfg.DeviceNameLen;
+common/p2p.c:	pAd->P2pCfg.P2pCounter.ListenIntervalBias = Bias;
+common/p2p.c:		pAd->P2pCfg.P2pCounter.ListenIntervalBias = 1;
+common/p2p.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	PRT_P2P_CLIENT_ENTRY pP2pEntry = &pAd->P2pTable.Client[Index];
+common/p2p.c:		pAd->P2pTable.Client[p2pindex].GeneralToken++;
+common/p2p.c:		pAd->P2pTable.Client[p2pindex].P2pClientState = P2PSTATE_PROVISION_COMMAND;
+common/p2p.c:		Channel = pAd->P2pTable.Client[p2pindex].ListenChannel;
+common/p2p.c:		pAd->P2pCfg.DiscCurrentState = P2P_DISC_SEARCH;
+common/p2p.c:		COPY_MAC_ADDR(pAd->P2pCfg.ConnectingMAC, pAd->P2pTable.Client[p2pindex].addr);
+common/p2p.c:	p2pIdx = P2pGroupTabSearch(pAd, pAd->P2pCfg.ConnectingMAC);
+common/p2p.c:	Channel = pAd->P2pTable.Client[p2pIdx].ListenChannel;
+common/p2p.c:	pAd->P2pCfg.DiscCurrentState = P2P_DISC_SEARCH;
+common/p2p.c:	DBGPRINT(RT_DEBUG_ERROR, ("Addr = %02x:%02x:%02x:%02x:%02x:%02x.  \n",  PRINT_MAC(pAd->P2pCfg.ConnectingMAC)));
+common/p2p.c:		pAd->P2pCfg.bConfirmByUI = TRUE;
+common/p2p.c:		pAd->P2pCfg.bPeriodicListen = FALSE;
+common/p2p.c:		if ((pAd->P2pTable.Client[p2pindex].P2pClientState == P2PSTATE_DISCOVERY_GO))
+common/p2p.c:			Channel = pAd->P2pTable.Client[p2pindex].OpChannel;
+common/p2p.c:			Channel = pAd->P2pTable.Client[p2pindex].ListenChannel;
+common/p2p.c:			if (pAd->CommonCfg.BBPCurrentBW == BW_40)
+common/p2p.c:		pAd->P2pCfg.ConnectingIndex = 0;
+common/p2p.c:		COPY_MAC_ADDR(pAd->P2pCfg.ConnectingMAC, pAd->P2pTable.Client[p2pindex].addr);
+common/p2p.c:		pAd->P2pTable.Client[p2pindex].StateCount = 0;
+common/p2p.c:		pAd->P2pTable.Client[p2pindex].bValid = TRUE;
+common/p2p.c:		if ((pAd->P2pTable.Client[p2pindex].P2pClientState == P2PSTATE_DISCOVERY_GO))
+common/p2p.c:			COPY_MAC_ADDR(pAd->P2pCfg.ConnectingMAC, pAd->P2pTable.Client[p2pindex].bssid);
+common/p2p.c:			pAd->P2pTable.Client[p2pindex].P2pClientState = P2PSTATE_PROVISION_COMMAND;
+common/p2p.c:			pAd->P2pTable.Client[p2pindex].P2pClientState = ConnType;
+common/p2p.c:		pAd->P2pCfg.DiscCurrentState = P2P_DISC_SEARCH;
+common/p2p.c:		pAd->P2pCfg.GoFormCurrentState = P2P_GO_FORM_IDLE;
+common/p2p.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	DBGPRINT(RT_DEBUG_ERROR, (" P2pConnectAfterScan   %d. %s \n", pAd->P2pTable.Client[idx].P2pClientState, decodeP2PClientState(pAd->P2pTable.Client[idx].P2pClientState)));
+common/p2p.c:	if (pAd->P2pTable.Client[GrpIndex].P2pClientState == P2PSTATE_DISCOVERY)
+common/p2p.c:			pAd->P2pTable.Client[GrpIndex].P2pClientState = P2PSTATE_INVITE_COMMAND;
+common/p2p.c:			index = P2pPerstTabSearch(pAd, pAd->P2pTable.Client[GrpIndex].addr, 
+common/p2p.c:										pAd->P2pTable.Client[GrpIndex].bssid, 
+common/p2p.c:										pAd->P2pTable.Client[GrpIndex].InterfaceAddr);
+common/p2p.c:				pAd->P2pTable.Client[GrpIndex].P2pClientState = P2PSTATE_INVITE_COMMAND;
+common/p2p.c:				pAd->P2pTable.Client[idx].P2pClientState = P2PSTATE_CONNECT_COMMAND;
+common/p2p.c:	else if ((pAd->P2pTable.Client[GrpIndex].P2pClientState == P2PSTATE_DISCOVERY_GO))
+common/p2p.c:	else if ((pAd->P2pTable.Client[GrpIndex].P2pClientState == P2PSTATE_DISCOVERY_CLIENT))
+common/p2p.c:				decodeP2PClientState(pAd->P2pTable.Client[GrpIndex].P2pClientState)));
+common/p2p.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	DBGPRINT(RT_DEBUG_ERROR, (" P2pConnectAction   %d. %s \n", pAd->P2pTable.Client[index].P2pClientState, decodeP2PClientState(pAd->P2pTable.Client[index].P2pClientState)));
+common/p2p.c:		if (pAd->P2pTable.Client[index].P2pClientState == P2PSTATE_CONNECT_COMMAND
+common/p2p.c:			||(pAd->P2pTable.Client[index].P2pClientState == P2PSTATE_INVITE_COMMAND))
+common/p2p.c:			P2pGoNegoDone(pAd, &pAd->P2pTable.Client[index]);
+common/p2p.c:		else if (pAd->P2pTable.Client[index].P2pClientState == P2PSTATE_GO_DISCO_COMMAND)
+common/p2p.c:			bresult = P2pClientDiscovery(pAd, pAd->P2pTable.Client[index].addr, index);
+common/p2p.c:		if ((pAd->P2pTable.Client[index].P2pClientState == P2PSTATE_CONNECT_COMMAND)
+common/p2p.c:			|| (pAd->P2pTable.Client[index].P2pClientState == P2PSTATE_INVITE_COMMAND))
+common/p2p.c:				bresult = P2pInvite(pAd, pAd->P2pTable.Client[index].addr, MAX_P2P_TABLE_SIZE, index);
+common/p2p.c:			else if (pAd->P2pTable.Client[index].Rule == P2P_IS_GO)
+common/p2p.c:				P2pGoNegoDone(pAd, &pAd->P2pTable.Client[index]);
+common/p2p.c:				UCHAR ClientState = pAd->P2pTable.Client[index].P2pClientState;
+common/p2p.c:				perstindex = P2pPerstTabSearch(pAd, pAd->P2pTable.Client[index].addr, 
+common/p2p.c:												pAd->P2pTable.Client[index].bssid, 
+common/p2p.c:												pAd->P2pTable.Client[index].InterfaceAddr);
+common/p2p.c:					Channel = pAd->P2pTable.Client[index].ListenChannel;
+common/p2p.c:					pAd->P2pCfg.P2PConnectState = P2P_CONNECT_IDLE;
+common/p2p.c:				COPY_MAC_ADDR(&P2pCmd.Addr[0], pAd->P2pTable.Client[index].addr);
+common/p2p.c:		GoP2pIndex = pAd->P2pTable.Client[GrpIndex].MyGOIndex;
+common/p2p.c:		if ((pAd->P2pTable.Client[GrpIndex].DevCapability & DEVCAP_CLIENT_DISCOVER) == 0)
+common/p2p.c:			DBGPRINT(RT_DEBUG_TRACE, ("P2P Client Not support Discoverability  %x \n", pAd->P2pTable.Client[GrpIndex].DevCapability));
+common/p2p.c:			DBGPRINT(RT_DEBUG_TRACE, ("P2P Client CAN Support Discoverability  %x \n", pAd->P2pTable.Client[GrpIndex].DevCapability));
+common/p2p.c:		DBGPRINT(RT_DEBUG_TRACE, ("P2P Client DevCapability  %x. GoP2pIndex = %d. \n", pAd->P2pTable.Client[GrpIndex].DevCapability, GoP2pIndex));
+common/p2p.c:		if ((GoP2pIndex < MAX_P2P_GROUP_SIZE) && (pAd->P2pTable.Client[GoP2pIndex].P2pClientState == P2PSTATE_DISCOVERY_GO))
+common/p2p.c:			pAd->P2pTable.Client[GrpIndex].P2pClientState = P2PSTATE_CLIENT_DISCO_COMMAND;
+common/p2p.c:			pAd->P2pTable.Client[GoP2pIndex].P2pClientState = P2PSTATE_GO_DISCO_COMMAND;
+common/p2p.c:		DBGPRINT(RT_DEBUG_TRACE, (" P2pConnectIdle - peer device's state %s \n", decodeP2PClientState(pAd->P2pTable.Client[GrpIndex].P2pClientState)));
+common/p2p.c:		pAd->P2pCfg.P2pCounter.CounterAftrScanButton = 0;
+common/p2p.c:	DBGPRINT(RT_DEBUG_TRACE, ("P2pConnectP2pGo.  %s\n", decodeP2PState(pAd->P2pCfg.P2PConnectState)));
+common/p2p.c:	DBGPRINT(RT_DEBUG_TRACE, ("pAd->P2pCfg.Dpid = %d \n", pAd->P2pCfg.Dpid));
+common/p2p.c:	if (pAd->P2pCfg.P2PConnectState == P2P_CONNECT_IDLE)
+common/p2p.c:		pAd->P2pTable.Client[idx].P2pClientState = P2PSTATE_PROVISION_COMMAND;
+common/p2p.c:		DBGPRINT(RT_DEBUG_TRACE,("P2p : Use Provision first before connecting to GO with Bssid   %x.  %x. %x.  %x. %x.  %x. \n", pAd->P2pTable.Client[idx].bssid[0], pAd->P2pTable.Client[idx].bssid[1],pAd->P2pTable.Client[idx].bssid[2],pAd->P2pTable.Client[idx].bssid[3],pAd->P2pTable.Client[idx].bssid[4],pAd->P2pTable.Client[idx].bssid[5]));
+common/p2p.c:		DBGPRINT(RT_DEBUG_TRACE,("P2p : its GroupCapability= %x.  DevCapability= %x. \n", pAd->P2pTable.Client[idx].GroupCapability, pAd->P2pTable.Client[idx].DevCapability));
+common/p2p.c:		DBGPRINT(RT_DEBUG_ERROR, ("invalid P2pConnectP2pGo command when %s \n", decodeP2PState(pAd->P2pCfg.P2PConnectState)));
+common/p2p.c:		if (pAd->P2pTable.Client[i].P2pClientState == P2PSTATE_CLIENT_DISCO_COMMAND)
+common/p2p.c:	P2PSendDevDisReq(pAd, pAd->P2pTable.Client[GoP2pTabIdx].addr, pAd->P2pTable.Client[GoP2pTabIdx].addr, pAd->P2pTable.Client[ClientP2PIndex].addr, &TotalFrameLen);
+common/p2p.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	pClient = &pAd->P2pTable.Client[P2pTabIdx];
+common/p2p.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:		pEntry = &pAd->P2pTable.PerstEntry[PersistentTabIdx];
+common/p2p.c:			pAd->P2pCfg.PhraseKeyLen = (UCHAR)pEntry->Profile.KeyLength;
+common/p2p.c:			RTMPMoveMemory(pAd->P2pCfg.PhraseKey, pEntry->Profile.Key, pEntry->Profile.KeyLength);
+common/p2p.c:			pClient = &pAd->P2pTable.Client[P2pTabIdx];
+common/p2p.c:			RTMPMoveMemory(pAd->P2pCfg.SSID, pEntry->Profile.SSID.Ssid, 32);
+common/p2p.c:				RTMPMoveMemory(pAd->P2pCfg.Bssid, pEntry->Addr, MAC_ADDR_LEN);
+common/p2p.c:				RTMPMoveMemory(pAd->P2pCfg.Bssid, pAd->CurrentAddress, MAC_ADDR_LEN);
+common/p2p.c:		if ((pAd->P2pTable.Client[P2pTabIdx].DevCapability & DEVCAP_INVITE) == DEVCAP_INVITE)
+common/p2p.c:			DBGPRINT(RT_DEBUG_TRACE, ("Peer doesn't support Invite. DevCapability = %x \n", pAd->P2pTable.Client[P2pTabIdx].DevCapability));
+common/p2p.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:		if ((pAd->P2pTable.Client[idx].P2pClientState == P2PSTATE_CONNECT_COMMAND)|| 
+common/p2p.c:		(pAd->P2pTable.Client[idx].P2pClientState == P2PSTATE_DISCOVERY) || 
+common/p2p.c:		(pAd->P2pTable.Client[idx].P2pClientState == P2PSTATE_SENT_GO_NEG_REQ))
+common/p2p.c:			pAd->P2pCfg.P2pCounter.Counter100ms = 0;
+common/p2p.c:				pAd->P2pCfg.ExtListenInterval = P2P_EXT_LISTEN_INTERVAL;
+common/p2p.c:				pAd->P2pCfg.ExtListenPeriod = P2P_EXT_LISTEN_PERIOD;
+common/p2p.c:				pAd->P2pTable.Client[idx].P2pClientState = P2PSTATE_SENT_GO_NEG_REQ;
+common/p2p.c:				pAd->P2pTable.Client[idx].StateCount = 0;
+common/p2p.c:				pAd->P2pTable.Client[idx].bValid = FALSE;
+common/p2p.c:	ptr = &pAd->P2pCfg.ConnectingMAC[0];
+common/p2p.c:	if (NdisEqualMemory(pAd->P2pCfg.ConnectingMAC, ZERO_MAC_ADDR, 6))
+common/p2p.c:	DBGPRINT(RT_DEBUG_ERROR, ("P2p : P2PDevice Not Match from %02x:%02x:%02x:%02x:%02x:%02x.. = %s \n", PRINT_MAC(Addr), decodeP2PState(pAd->P2pCfg.P2PConnectState)));
+common/p2p.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p.c:		PWSC_CTRL pWscControl = &pAd->ApCfg.MBSSID[0].WscControl;
+common/p2p.c:		DBGPRINT(RT_DEBUG_ERROR, ("(%d, %d)\n", pAd->LatchRfRegs.Channel != pP2PCtrl->GroupChannel));
+common/p2p.c:		if (pAd->LatchRfRegs.Channel != pP2PCtrl->GroupChannel)
+common/p2p.c:			pApCliEntry = &pAd->ApCfg.ApCliTab[BSS0];
+common/p2p.c:					if ((pAd->CommonCfg.BBPCurrentBW == BW_40) && (pAd->LatchRfRegs.Channel != pAd->CommonCfg.CentralChannel))
+common/p2p.c:				pAd->CommonCfg.Channel = pP2PCtrl->GroupOpChannel;
+common/p2p.c:				if (WMODE_CAP_N(pAd->CommonCfg.PhyMode)
+common/p2p.c:					&& pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)
+common/p2p.c:					N_SetCenCh(pAd, pAd->CommonCfg.Channel);
+common/p2p.c:				rf_channel = pAd->CommonCfg.CentralChannel;
+common/p2p.c:				if ((pAd->CommonCfg.Channel != pAd->CommonCfg.CentralChannel) && (pAd->CommonCfg.BBPCurrentBW == BW_40))
+common/p2p.c:					rf_channel = pAd->CommonCfg.CentralChannel;
+common/p2p.c:					rf_channel = pAd->CommonCfg.Channel;
+common/p2p.c:			if (rf_channel != pAd->CommonCfg.Channel)
+common/p2p.c:					__FUNCTION__, decodeMyRule(pP2PCtrl->Rule), pAd->CommonCfg.Channel, pAd->CommonCfg.CentralChannel));
+common/p2p.c:				if (pP2PCtrl->bSigmaEnabled == TRUE || pAd->P2pCfg.bConfirmByUI == TRUE) {
+common/p2p.c:				if ((!(pAd->flg_p2p_OpStatusFlags & P2P_FIXED_MODE)) ||
+common/p2p.c:			if (pAd->P2pCfg.bConfirmByUI == TRUE) {
+common/p2p.c:		RTMPSetTimer(&pAd->P2pCfg.P2pWscTimer, P2P_WSC_TIMER);
+common/p2p.c:		pAd->CommonCfg.Channel = pP2PCtrl->GroupOpChannel;
+common/p2p.c:		AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+common/p2p.c:		AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+common/p2p.c:					__FUNCTION__, decodeMyRule(pP2PCtrl->Rule), pAd->CommonCfg.Channel, pAd->CommonCfg.CentralChannel));
+common/p2p.c:				if (pP2PCtrl->bSigmaEnabled == TRUE || pAd->P2pCfg.bConfirmByUI == TRUE) {
+common/p2p.c:			/*COPY_MAC_ADDR(pAd->ApCfg.ApCliTab[0].CfgApCliBssid, pP2PCtrl->Bssid);*/
+common/p2p.c:			if (pAd->P2pCfg.bConfirmByUI == TRUE) {
+common/p2p.c:		RTMPSetTimer(&pAd->P2pCfg.P2pWscTimer, P2P_WSC_TIMER);
+common/p2p.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:		pAd->flg_p2p_OpStatusFlags |= P2P_GO_UP;
+common/p2p.c:		DBGPRINT(RT_DEBUG_ERROR, ("pAd->P2pCfg.Dpid = %s \n", decodeDpid(pP2PCtrl->Dpid)));
+common/p2p.c:		pAd->flg_p2p_OpStatusFlags = P2P_CLI_UP;
+common/p2p.c:			/*pAd->StaCfg.WscControl.WscAPChannel = pP2PCtrl->GroupOpChannel; */
+common/p2p.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	POS_COOKIE			pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p.c:		PWSC_CTRL			pWscControl = &pAd->ApCfg.MBSSID[0].WscControl;
+common/p2p.c:	pAd->ApCfg.ApCliTab[0].WscControl.WscConfStatus = WSC_SCSTATE_UNCONFIGURED;
+common/p2p.c:	pAd->ApCfg.MBSSID[0].WscControl.WscConfStatus = WSC_SCSTATE_UNCONFIGURED;
+common/p2p.c:	P2pGetRandomSSID(pAd, pAd->ApCfg.MBSSID[MAIN_MBSSID].Ssid, &(pAd->ApCfg.MBSSID[MAIN_MBSSID].SsidLen));
+common/p2p.c:	pAd->P2pCfg.SSIDLen = pAd->ApCfg.MBSSID[MAIN_MBSSID].SsidLen;
+common/p2p.c:	NdisMoveMemory(pAd->P2pCfg.SSID, pAd->ApCfg.MBSSID[MAIN_MBSSID].Ssid, pAd->P2pCfg.SSIDLen);
+common/p2p.c:	if ((INFRA_ON(pAd)) && (pAd->StaActive.SupportedHtPhy.ChannelWidth == BW_40))
+common/p2p.c:			pAd->CommonCfg.Channel = pP2PCtrl->ListenChannel;
+common/p2p.c:			pAd->MlmeAux.AutoReconnectSsidLen = pAd->CommonCfg.SsidLen;
+common/p2p.c:			NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen);
+common/p2p.c:		if (pAd->CommonCfg.BBPCurrentBW == BW_20)
+common/p2p.c:			pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
+common/p2p.c:		AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
+common/p2p.c:		AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
+common/p2p.c:		COPY_MAC_ADDR(pAd->P2pCfg.ConnectingMAC, pAd->P2pTable.PerstEntry[0].Addr);
+common/p2p.c:					PRINT_MAC(pAd->P2pCfg.ConnectingMAC)));
+common/p2p.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:		pAd->P2pCfg.P2pCapability[1] |= GRPCAP_PERSISTENT;
+common/p2p.c:		pAd->P2pCfg.P2pCapability[1] |= GRPCAP_PERSISTENT_RECONNECT;
+common/p2p.c:		pAd->P2pCfg.P2pCapability[0] |= DEVCAP_INVITE;
+common/p2p.c:		pAd->P2pCfg.ExtListenInterval = P2P_EXT_LISTEN_INTERVAL;
+common/p2p.c:		pAd->P2pCfg.ExtListenPeriod = P2P_EXT_LISTEN_PERIOD;
+common/p2p.c:		pAd->P2pCfg.ExtListenInterval = 0;
+common/p2p.c:		pAd->P2pCfg.ExtListenPeriod = 0;
+common/p2p.c:		pAd->StaCfg.WscControl.RegData.SelfInfo.ConfigMethods = 0x188;
+common/p2p.c:		pAd->StaCfg.WscControl.RegData.SelfInfo.DevPwdId = 0x188;
+common/p2p.c:	pAd->P2pCfg.CTWindows = 0;
+common/p2p.c:		PUCHAR pP2PBssid = &pAd->CurrentAddress[0];
+common/p2p.c:		if ((pAd->CurrentAddress[5] % 2 != 0)
+common/p2p.c:		if (pAd->chipCap.MBSSIDMode == MBSSID_MODE1)
+common/p2p.c:	DBGPRINT(RT_DEBUG_ERROR, ("!4 OpStatusFlags = %lx. CentralChannel = %d. Channel	= %d. !!! \n", pAd->CommonCfg.OpStatusFlags,pAd->CommonCfg.CentralChannel,pAd->CommonCfg.Channel));
+common/p2p.c:	pAd->P2pCfg.P2pProprietary.ListenChanel[0] = 1;
+common/p2p.c:	pAd->P2pCfg.P2pProprietary.ListenChanel[1] = 6;
+common/p2p.c:	pAd->P2pCfg.P2pProprietary.ListenChanel[2] = 11;
+common/p2p.c:	pAd->P2pCfg.P2pProprietary.ListenChanelIndex = 0;
+common/p2p.c:	pAd->P2pCfg.P2pProprietary.ListenChanelCount = 3;
+common/p2p.c:		__FUNCTION__, pAd->P2pCfg.P2pProprietary.ListenChanelCount, pAd->P2pCfg.P2pProprietary.ListenChanel[0], pAd->P2pCfg.P2pProprietary.ListenChanel[1], pAd->P2pCfg.P2pProprietary.ListenChanel[2]));
+common/p2p.c:		FALSE - None of channel in ChannelList Match any channel in pAd->ChannelList[] array
+common/p2p.c:		for (i = 0;i < pAd->ChannelListNum;i++)
+common/p2p.c:			if (pAd->ChannelList[i].Channel == *(pChannelList + k))
+common/p2p.c:		if ( i == pAd->ChannelListNum)
+common/p2p.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:		NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen);
+common/p2p.c:		pAd->MlmeAux.AutoReconnectSsidLen = (UCHAR)pAd->CommonCfg.SsidLen;
+common/p2p.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:	PRT_P2P_CLIENT_ENTRY pP2pEntry = &pAd->P2pTable.Client[index];
+common/p2p.c:		pAd->ApCfg.MBSSID[0].WscControl.WscEnrolleePinCode = pAd->ApCfg.ApCliTab[0].WscControl.WscEnrolleePinCode;
+common/p2p.c:		pAd->ApCfg.MBSSID[0].WscControl.WscEnrolleePinCodeLen = pAd->ApCfg.ApCliTab[0].WscControl.WscEnrolleePinCodeLen;
+common/p2p.c:		DBGPRINT(RT_DEBUG_TRACE, ("    *       PIN Code = %08u                     *\n", pAd->ApCfg.ApCliTab[0].WscControl.WscEnrolleePinCode));
+common/p2p.c:					RtmpOSWrielessEventSendExt(pAd->net_dev, RT_WLAN_EVENT_SHOWPIN, -1, pP2pEntry->addr,
+common/p2p.c:					RtmpOSWrielessEventSendExt(pAd->net_dev, RT_WLAN_EVENT_PIN, -1, pP2pEntry->addr,
+common/p2p.c:	pEntry = &pAd->MacTab.Content[macindex];
+common/p2p.c:	pClient = &pAd->P2pTable.Client[p2pindex];
+common/p2p.c:	DBGPRINT(RT_DEBUG_TRACE, ("DeviceName[%ld] = %s\n", pClient->DeviceNameLen, pAd->P2pTable.Client[p2pindex].DeviceName));
+common/p2p.c:	pClient = &pAd->P2pTable.PerstEntry[p2pindex];
+common/p2p.c:	/*RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &Cancelled); */
+common/p2p.c:	/*pAd->MlmeAux.Channel = 0; */
+common/p2p.c:	pAd->P2pCfg.P2pCapability[1] |= GRPCAP_OWNER;
+common/p2p.c:	pAd->StaCfg.bAutoReconnect = FALSE;
+common/p2p.c:	pAd->ApCfg.MBSSID[0].UapsdInfo.bAPSDCapable = TRUE;
+common/p2p.c:	pAd->P2pCfg.bSentProbeRSP = TRUE;
+common/p2p.c:	/*pAd->P2pCfg.DiscCurrentState = P2P_DISC_LISTEN;*/
+common/p2p.c:	RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &Cancelled);
+common/p2p.c:	pAd->MlmeAux.Channel = 0;
+common/p2p.c:	pAd->ApCfg.BssidNum = 1;
+common/p2p.c:	pAd->MacTab.MsduLifeTime = 20; /* default 5 seconds */
+common/p2p.c:	pAd->ApCfg.MBSSID[MAIN_MBSSID].bBcnSntReq = TRUE;
+common/p2p.c:	pAd->ApCfg.MBSSID[MAIN_MBSSID].StationKeepAliveTime = 3;
+common/p2p.c:	pAd->flg_p2p_OpStatusFlags |= P2P_GO_UP;
+common/p2p.c:	pAd->P2pCfg.GroupOpChannel = pAd->P2pCfg.GroupChannel;
+common/p2p.c:		pAd->CommonCfg.Channel = pAd->P2pCfg.GroupChannel;
+common/p2p.c:	pAd->P2pCfg.Rule = P2P_IS_GO;
+common/p2p.c:		pAd->BulkOutDataSizeLimit[i]=24576;
+common/p2p.c:	if (WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+common/p2p.c:		if (pAd->CommonCfg.Channel > 14)
+common/p2p.c:			pAd->ApCfg.MBSSID[MAIN_MBSSID].PhyMode = (WMODE_A | WMODE_AN);
+common/p2p.c:			pAd->ApCfg.MBSSID[MAIN_MBSSID].PhyMode = (WMODE_B | WMODE_G | WMODE_GN);
+common/p2p.c:		if (pAd->CommonCfg.Channel > 14)
+common/p2p.c:			pAd->ApCfg.MBSSID[MAIN_MBSSID].PhyMode = WMODE_A;
+common/p2p.c:			pAd->ApCfg.MBSSID[MAIN_MBSSID].PhyMode = (WMODE_B | WMODE_G);
+common/p2p.c:	TxPreamble = (pAd->CommonCfg.TxPreamble == Rt802_11PreambleLong ? 0 : 1);
+common/p2p.c:		PMULTISSID_STRUCT	pMbss = &pAd->ApCfg.MBSSID[MAIN_MBSSID];
+common/p2p.c:			CAP_GENERATE(1, 0, (pMbss->WepStatus != Ndis802_11EncryptionDisabled), TxPreamble, pAd->CommonCfg.bUseShortSlotTime, SpectrumMgmt);
+common/p2p.c:		if (pAd->ApCfg.MBSSID[0].UapsdInfo.bAPSDCapable == TRUE)
+common/p2p.c:	if (INFRA_ON(pAd) && (pAd->StaActive.SupportedHtPhy.ChannelWidth == BW_40) && 
+common/p2p.c:		(pAd->CommonCfg.RegTransmitSetting.field.EXTCHA != pAd->StaActive.SupportedHtPhy.ExtChanOffset))
+common/p2p.c:		pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = pAd->StaActive.SupportedHtPhy.ExtChanOffset;
+common/p2p.c:	RTMPSetPhyMode(pAd,  pAd->CommonCfg.PhyMode);
+common/p2p.c:		if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) && (pAd->Antenna.field.TxPath == 2))
+common/p2p.c:	rtmp_bbp_set_rxpath(pAd, pAd->Antenna.field.RxPath);
+common/p2p.c:	if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) || bWmmCapable)
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.bValid = TRUE;
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.Aifsn[0] = 3;
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.Aifsn[1] = 7;
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.Aifsn[2] = 1;
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.Aifsn[3] = 1;
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.Cwmin[0] = 4;
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.Cwmin[1] = 4;
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.Cwmin[2] = 3;
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.Cwmin[3] = 2;
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.Cwmax[0] = 6;
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.Cwmax[1] = 10;
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.Cwmax[2] = 4;
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.Cwmax[3] = 3;
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.Txop[0]  = 0;
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.Txop[1]  = 0;
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.Txop[2]  = 94;	/*96; */
+common/p2p.c:			pAd->CommonCfg.APEdcaParm.Txop[3]  = 47;	/*48; */
+common/p2p.c:		AsicSetEdcaParm(pAd, &pAd->CommonCfg.APEdcaParm);
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.bValid = TRUE;
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.Aifsn[0] = 3;
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.Aifsn[1] = 7;
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.Aifsn[2] = 2;
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.Aifsn[3] = 2;
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.Cwmin[0] = 4;
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.Cwmin[1] = 4;
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.Cwmin[2] = 3;
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.Cwmin[3] = 2;
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.Cwmax[0] = 10;
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.Cwmax[1] = 10;
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.Cwmax[2] = 4;
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.Cwmax[3] = 3;
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.Txop[0]  = 0;
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.Txop[1]  = 0;
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.Txop[2]  = 94;	/*96; */
+common/p2p.c:			pAd->ApCfg.BssEdcaParm.Txop[3]  = 47;	/*48; */
+common/p2p.c:	if (!WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+common/p2p.c:		pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth = BW_20;
+common/p2p.c:	if (pAd->CommonCfg.bRdg)
+common/p2p.c:	AsicSetBssid(pAd, pAd->CurrentAddress); 
+common/p2p.c:	pAd->MacTab.Content[0].Addr[0] = 0x01;
+common/p2p.c:	pAd->MacTab.Content[0].HTPhyMode.field.MODE = MODE_OFDM;
+common/p2p.c:	pAd->MacTab.Content[0].HTPhyMode.field.MCS = 3;
+common/p2p.c:	/*pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;*/
+common/p2p.c:	pAd->P2PChannel = pAd->CommonCfg.Channel;
+common/p2p.c:	if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) &&
+common/p2p.c:		pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40)
+common/p2p.c:		N_SetCenCh(pAd, pAd->CommonCfg.Channel);
+common/p2p.c:	AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
+common/p2p.c:	AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
+common/p2p.c:	MlmeSetTxPreamble(pAd, (USHORT)pAd->CommonCfg.TxPreamble);	
+common/p2p.c:	if (WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+common/p2p.c:		pAd->MacTab.Content[idx].PortSecured  = WPA_802_1X_PORT_NOT_SECURED;
+common/p2p.c:		PMULTISSID_STRUCT	pMbss = &pAd->ApCfg.MBSSID[MAIN_MBSSID];
+common/p2p.c:				CipherAlg = pAd->SharedKey[MAIN_MBSSID + 1][idx].CipherAlg;
+common/p2p.c:				if (pAd->SharedKey[MAIN_MBSSID + 1][idx].KeyLen > 0)
+common/p2p.c:    					AsicAddSharedKeyEntry(pAd, MAIN_MBSSID + 1, idx, &pAd->SharedKey[MAIN_MBSSID + 1][idx]);	
+common/p2p.c:							pAd->SharedKey[MAIN_MBSSID + 1][idx].TxTsc[idx_len] = RandomByte(pAd);   
+common/p2p.c:	RTMPSetPiggyBack(pAd, pAd->CommonCfg.bPiggyBackCapable);
+common/p2p.c:	ApLogEvent(pAd, pAd->CurrentAddress, EVENT_RESET_ACCESS_POINT);
+common/p2p.c:			pWscControl = &pAd->ApCfg.MBSSID[MAIN_MBSSID].WscControl;
+common/p2p.c:	/*pAd->Dot11_H.RDMode = RD_NORMAL_MODE;*/
+common/p2p.c:		pAd->Dot11_H.RDMode = RD_NORMAL_MODE;
+common/p2p.c:		if (pAd->CommonCfg.Channel > 14)
+common/p2p.c:			if ((pAd->CommonCfg.CarrierDetect.Enable == 0)
+common/p2p.c:				&& ((pAd->CommonCfg.RDDurRegion == JAP)
+common/p2p.c:					|| (pAd->CommonCfg.RDDurRegion == JAP_W53)
+common/p2p.c:					|| (pAd->CommonCfg.RDDurRegion == JAP_W56)))
+common/p2p.c:				pAd->CommonCfg.CarrierDetect.Enable = 1;
+common/p2p.c:			if (pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40)
+common/p2p.c:				if ((pAd->CommonCfg.CarrierDetect.Enable == 0)
+common/p2p.c:						&& ((pAd->CommonCfg.RDDurRegion == JAP)
+common/p2p.c:							|| (pAd->CommonCfg.RDDurRegion == JAP_W53)
+common/p2p.c:							|| (pAd->CommonCfg.RDDurRegion == JAP_W56)))
+common/p2p.c:					pAd->CommonCfg.CarrierDetect.Enable = 1;
+common/p2p.c:		if (pAd->CommonCfg.CarrierDetect.Enable == TRUE)
+common/p2p.c:	if (pAd->ApCfg.IdsEnable)
+common/p2p.c:		if (pAd->CommonCfg.bWirelessEvent == FALSE)
+common/p2p.c:	  * the value on pAd->CommonCfg.NumOfBulkInIRP may be large than 1.
+common/p2p.c:		for(num_idx=0; num_idx < pAd->CommonCfg.NumOfBulkInIRP; num_idx++)
+common/p2p.c:	pAd->P2pCfg.bStopAuthRsp = FALSE;
+common/p2p.c:	pAd->P2pCfg.P2pCapability[1] &= ~(GRPCAP_OWNER);
+common/p2p.c:	pAd->flg_p2p_OpStatusFlags &= P2P_FIXED_MODE;
+common/p2p.c:	pAd->P2pCfg.Rule = P2P_IS_DEVICE;
+common/p2p.c:	pAd->ApCfg.MBSSID[MAIN_MBSSID].bBcnSntReq = FALSE;
+common/p2p.c:		if (pAd->ApCfg.MBSSID[apidx].REKEYTimerRunning == TRUE)
+common/p2p.c:			RTMPCancelTimer(&pAd->ApCfg.MBSSID[apidx].REKEYTimer, &Cancelled);
+common/p2p.c:			pAd->ApCfg.MBSSID[apidx].REKEYTimerRunning = FALSE;
+common/p2p.c:	if (pAd->ApCfg.CMTimerRunning == TRUE)
+common/p2p.c:		RTMPCancelTimer(&pAd->ApCfg.CounterMeasureTimer, &Cancelled);
+common/p2p.c:		pAd->ApCfg.CMTimerRunning = FALSE;
+common/p2p.c:	if (pAd->flg_apcli_init != TRUE)
+common/p2p.c:	pAd->P2pCfg.P2pCapability[1] &= ~(GRPCAP_OWNER);
+common/p2p.c:	pAd->flg_p2p_OpStatusFlags = P2P_CLI_UP;
+common/p2p.c:	pAd->P2pCfg.Rule = P2P_IS_CLIENT;
+common/p2p.c:	pAd->StaCfg.bAutoReconnect = FALSE;
+common/p2p.c:	AsicSetBssid(pAd, pAd->CurrentAddress); 
+common/p2p.c:		pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+common/p2p.c:		if (pAd->CommonCfg.Channel != 0)
+common/p2p.c:			pAd->P2PChannel = pAd->CommonCfg.Channel;
+common/p2p.c:			pAd->P2PChannel  = FirstChannel(pAd);
+common/p2p.c:	pAd->flg_p2p_OpStatusFlags = P2P_DISABLE;
+common/p2p.c:	pAd->P2pCfg.Rule = P2P_IS_DEVICE;
+common/p2p.c:		if (pAd->ApCfg.ApCliTab[ifIndex].Enable)
+common/p2p.c:	ULONG MinimumAMPDUSize = pAd->CommonCfg.DesiredHtPhy.MaxRAmpduFactor; /*Default set minimum AMPDU Size to 2, i.e. 32K */
+common/p2p.c:	pMacTable = &pAd->MacTab;
+common/p2p.c:				if (pAd->CommonCfg.IOTestParm.bRTSLongProtOn == FALSE)
+common/p2p.c:		if ((pAd->ApCfg.MBSSID[pEntry->apidx].StationKeepAliveTime > 0) &&
+common/p2p.c:			(pEntry->NoDataIdleCount >= pAd->ApCfg.MBSSID[pEntry->apidx].StationKeepAliveTime))
+common/p2p.c:			MULTISSID_STRUCT *pMbss = &pAd->ApCfg.MBSSID[pEntry->apidx];
+common/p2p.c:				if (pAd->P2pCfg.bSigmaEnabled == FALSE)
+common/p2p.c:		else if (pEntry->ContinueTxFailCnt >= pAd->ApCfg.EntryLifeCheck)
+common/p2p.c:					/*NdisReleaseSpinLock(&pAd->MacTabLock); */
+common/p2p.c:									pAd->ApCfg.MBSSID[pEntry->apidx].Bssid,
+common/p2p.c:									pAd->ApCfg.MBSSID[pEntry->apidx].Bssid);				
+common/p2p.c:				NdisAcquireSpinLock(&pAd->irq_lock);
+common/p2p.c:				NdisReleaseSpinLock(&pAd->irq_lock);
+common/p2p.c:			&& (pAd->CommonCfg.Bss2040CoexistFlag & BSS_2040_COEXIST_INFO_NOTIFY)
+common/p2p.c:			&& (pAd->CommonCfg.bBssCoexEnable == TRUE)
+common/p2p.c:			pAd->ApCfg.MBSSID[bss_index].PortSecured = WPA_802_1X_PORT_SECURED;
+common/p2p.c:			pAd->ApCfg.MBSSID[bss_index].PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+common/p2p.c:	if (pAd->CommonCfg.Bss2040CoexistFlag & BSS_2040_COEXIST_INFO_NOTIFY)
+common/p2p.c:		pAd->CommonCfg.Bss2040CoexistFlag &= (~BSS_2040_COEXIST_INFO_NOTIFY);
+common/p2p.c:	if (pAd->CommonCfg.bRdg && pMacTable->fAllStationAsRalink)
+common/p2p.c:	if (WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+common/p2p.c:		if(pAd->MacTab.fAnyStationIsHT==FALSE
+common/p2p.c:			&& pAd->ApCfg.bGreenAPEnable == TRUE)
+common/p2p.c:				if (pAd->ApCfg.GreenAPLevel!=GREENAP_ONLY_11BG_STAS)
+common/p2p.c:					pAd->ApCfg.GreenAPLevel=GREENAP_ONLY_11BG_STAS;
+common/p2p.c:			if (pAd->ApCfg.GreenAPLevel!=GREENAP_11BGN_STAS)
+common/p2p.c:				pAd->ApCfg.GreenAPLevel=GREENAP_11BGN_STAS;
+common/p2p.c:		if ((pMacTable->fAnyStationBadAtheros == FALSE) && (pAd->CommonCfg.IOTestParm.bRTSLongProtOn == TRUE))
+common/p2p.c:			AsicUpdateProtect(pAd, pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode, ALLN_SETPROTECT, FALSE, pMacTable->fAnyStationNonGF);
+common/p2p.c:	 *	4. garbage collect pAd->MacTab.McastPsQueue if backlogged MCAST/BCAST frames
+common/p2p.c:			/*NdisAcquireSpinLock(&pAd->MacTabLock); */
+common/p2p.c:			/*NdisReleaseSpinLock(&pAd->MacTabLock); */
+common/p2p.c:			if (pAd->ApCfg.BssidNum > MAX_MBSSID_NUM(pAd))
+common/p2p.c:				pAd->ApCfg.BssidNum = MAX_MBSSID_NUM(pAd);
+common/p2p.c:			for(bss_index=BSS0; bss_index<pAd->ApCfg.BssidNum; bss_index++)
+common/p2p.c:	csr.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4; /* ASIC register in units of 1/16 TU */
+common/p2p.c:	/*NdisAcquireSpinLock(&pAd->MacTabLock); */
+common/p2p.c:		pEntry = &pAd->MacTab.Content[i];
+common/p2p.c:			/*MacTableDeleteEntry(pAd, i, pAd->MacTab.Content[i].Addr); */
+common/p2p.c:			if ((pAd->OpMode == OPMODE_AP) || IS_P2P_GO_ENTRY(pEntry))
+common/p2p.c:						/*NdisReleaseSpinLock(&pAd->MacTabLock); */
+common/p2p.c:												Reason, PRINT_MAC(pAd->MacTab.Content[i].Addr)));
+common/p2p.c:		for (apidx = MAIN_MBSSID; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/p2p.c:			PWSC_CTRL   pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
+common/p2p.c:			pAd->ApCfg.MBSSID[apidx].StaCount = 0; 
+common/p2p.c:		DBGPRINT(RT_DEBUG_TRACE, ("McastPsQueue.Number %ld...\n",pAd->MacTab.McastPsQueue.Number));
+common/p2p.c:		if (pAd->MacTab.McastPsQueue.Number > 0)
+common/p2p.c:			APCleanupPsQueue(pAd, &pAd->MacTab.McastPsQueue);
+common/p2p.c:		DBGPRINT(RT_DEBUG_TRACE, ("2McastPsQueue.Number %ld...\n",pAd->MacTab.McastPsQueue.Number));
+common/p2p.c:		/*NdisZeroMemory(&pAd->MacTab, sizeof(MAC_TABLE)); */
+common/p2p.c:		InitializeQueueHeader(&pAd->MacTab.McastPsQueue);
+common/p2p.c:		HtInfo = pAd->CommonCfg.AddHTInfo.AddHtInfo;
+common/p2p.c:		RootApHtInfo = pAd->ApCliMlmeAux.AddHtInfo.AddHtInfo;
+common/p2p.c:		if ((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40) &&
+common/p2p.c:			AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+common/p2p.c:			AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+common/p2p.c:	pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeOpen;
+common/p2p.c:	pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11EncryptionDisabled;
+common/p2p.c:	pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus = Ndis802_11EncryptionDisabled;
+common/p2p.c:	pAd->ApCfg.MBSSID[apidx].DefaultKeyId = 0;
+common/p2p.c:	pAd->ApCfg.MBSSID[apidx].WpaMixPairCipher = MIX_CIPHER_NOTUSE;
+common/p2p.c:	pAd->ApCfg.MBSSID[apidx].IEEE8021X = FALSE;
+common/p2p.c:	pAd->ApCfg.MBSSID[apidx].PreAuth = FALSE;
+common/p2p.c:	pAd->ApCfg.MBSSID[apidx].PMKCachePeriod = (10 * 60 * OS_HZ); /* unit : tick(default: 10 minute) */
+common/p2p.c:	NdisZeroMemory(&pAd->ApCfg.MBSSID[apidx].PMKIDCache, sizeof(NDIS_AP_802_11_PMKID));
+common/p2p.c:	pAd->ApCfg.MBSSID[apidx].radius_srv_num = 0;
+common/p2p.c:	pAd->ApCfg.MBSSID[apidx].NasIdLen = 0;
+common/p2p.c:	pAd->ApCfg.MBSSID[apidx].VLAN_VID = 0;
+common/p2p.c:	pAd->ApCfg.MBSSID[apidx].bAutoTxRateSwitch = TRUE;
+common/p2p.c:	pAd->ApCfg.MBSSID[apidx].DesiredTransmitSetting.field.MCS = MCS_AUTO;
+common/p2p.c:	pAd->ApCfg.MBSSID[apidx].MaxStaNum = 0;
+common/p2p.c:	pAd->ApCfg.MBSSID[apidx].StaCount = 0;
+common/p2p.c:		pAd->ApCfg.ApCliTab[apcliIdx].AuthMode = Ndis802_11AuthModeOpen;
+common/p2p.c:		pAd->ApCfg.ApCliTab[apcliIdx].WepStatus = Ndis802_11WEPDisabled;
+common/p2p.c:		pAd->ApCfg.MBSSID[apidx].TimBitmaps[apcliIdx] = 0;
+common/p2p.c:	pAd->ApCfg.RssiSample.AvgRssi0 = -127;
+common/p2p.c:	pAd->ApCfg.RssiSample.AvgRssi1 = -127;
+common/p2p.c:	pAd->ApCfg.RssiSample.AvgRssi2 = -127;
+common/p2p.c:	pAd->CommonCfg.CentralChannel = pAd->ApCliMlmeAux.CentralChannel;
+common/p2p.c:	pAd->CommonCfg.Channel = pAd->ApCliMlmeAux.Channel;
+common/p2p.c:			pAd->CommonCfg.CentralChannel, pAd->CommonCfg.Channel,
+common/p2p.c:			pAd->ApCliMlmeAux.HtCapability.HtCapInfo.ChannelWidth));
+common/p2p.c:	if ( (pAd->CommonCfg.CentralChannel > pAd->CommonCfg.Channel) &&
+common/p2p.c:		(pAd->ApCliMlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40))
+common/p2p.c:		rf_channel = pAd->CommonCfg.CentralChannel;
+common/p2p.c:	else if ( (pAd->CommonCfg.CentralChannel < pAd->CommonCfg.Channel) &&
+common/p2p.c:			(pAd->ApCliMlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40))
+common/p2p.c:		rf_channel = pAd->CommonCfg.CentralChannel;
+common/p2p.c:		rf_channel = pAd->CommonCfg.Channel;
+common/p2p.c:				pAd->CommonCfg.Channel,
+common/p2p.c:				pAd->CommonCfg.CentralChannel));
+common/p2p.c:	rtmp_bbp_get_agc(pAd, &pAd->BbpTuning.R66CurrentValue, RX_CHAIN_0);
+common/p2p.c:	switch (pAd->CommonCfg.PhyMode) 
+common/p2p.c:			if ((pAd->ApCliMlmeAux.SupRateLen == 4) &&
+common/p2p.c:				(pAd->ApCliMlmeAux.ExtRateLen == 0))
+common/p2p.c:			if (pAd->ApCliMlmeAux.Channel <= 14)
+common/p2p.c:			if (pAd->ApCliMlmeAux.Channel <= 14)
+common/p2p.c:	for (i = 0; i < pAd->ApCliMlmeAux.SupRateLen; i++)
+common/p2p.c:			if ((pAd->ApCliMlmeAux.SupRate[i] & 0x7f) == RateIdTo500Kbps[j])
+common/p2p.c:		for (i = 0; i < pAd->ApCliMlmeAux.ExtRateLen; i++)
+common/p2p.c:				if ((pAd->ApCliMlmeAux.ExtRate[i] & 0x7f) == RateIdTo500Kbps[j])
+common/p2p.c:		pAd->CommonCfg.MlmeRate = MinimumRate;
+common/p2p.c:		pAd->CommonCfg.RtsRate = ProperMlmeRate;
+common/p2p.c:		if (pAd->CommonCfg.MlmeRate >= RATE_6)
+common/p2p.c:			pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
+common/p2p.c:			pAd->CommonCfg.MlmeTransmit.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
+common/p2p.c:			pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MODE = MODE_OFDM;
+common/p2p.c:			pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
+common/p2p.c:			pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
+common/p2p.c:			pAd->CommonCfg.MlmeTransmit.field.MCS = pAd->CommonCfg.MlmeRate;
+common/p2p.c:			pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MODE = MODE_CCK;
+common/p2p.c:			pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MCS = pAd->CommonCfg.MlmeRate;
+common/p2p.c:	DBGPRINT(RT_DEBUG_TRACE, ("RTMPUpdateMlmeRate ==>   MlmeTransmit = 0x%x  \n" , pAd->CommonCfg.MlmeTransmit.word));
+common/p2p.c:	MultiCastFilterTableReset(&pAd->pMulticastFilterTable);
+common/p2p.c:	NdisFreeSpinLock(&pAd->MacTabLock);
+common/p2p.c:	pAd->ApCfg.BssidNum = MAX_MBSSID_NUM(pAd);
+common/p2p.c:	for(j = BSS0; j < pAd->ApCfg.BssidNum; j++)
+common/p2p.c:		pAd->ApCfg.MBSSID[j].AuthMode = Ndis802_11AuthModeOpen;
+common/p2p.c:		pAd->ApCfg.MBSSID[j].WepStatus = Ndis802_11EncryptionDisabled;
+common/p2p.c:		pAd->ApCfg.MBSSID[j].GroupKeyWepStatus = Ndis802_11EncryptionDisabled;
+common/p2p.c:		pAd->ApCfg.MBSSID[j].DefaultKeyId = 0;
+common/p2p.c:		pAd->ApCfg.MBSSID[j].WpaMixPairCipher = MIX_CIPHER_NOTUSE;
+common/p2p.c:		pAd->ApCfg.MBSSID[j].IEEE8021X = FALSE;
+common/p2p.c:		pAd->ApCfg.MBSSID[j].PreAuth = FALSE;
+common/p2p.c:		pAd->ApCfg.MBSSID[j].PMKCachePeriod = (10 * 60 * OS_HZ); /* unit : tick(default: 10 minute) */
+common/p2p.c:		NdisZeroMemory(&pAd->ApCfg.MBSSID[j].PMKIDCache, sizeof(NDIS_AP_802_11_PMKID));
+common/p2p.c:		pAd->ApCfg.MBSSID[j].radius_srv_num = 0;
+common/p2p.c:		pAd->ApCfg.MBSSID[j].NasIdLen = 0;
+common/p2p.c:		pAd->ApCfg.MBSSID[j].VLAN_VID = 0;
+common/p2p.c:		pAd->ApCfg.MBSSID[j].bAutoTxRateSwitch = TRUE;
+common/p2p.c:		pAd->ApCfg.MBSSID[j].DesiredTransmitSetting.field.MCS = MCS_AUTO;
+common/p2p.c:		pAd->ApCfg.MBSSID[j].MaxStaNum = 0;
+common/p2p.c:		pAd->ApCfg.MBSSID[j].StaCount = 0;
+common/p2p.c:			pWscControl = &pAd->ApCfg.MBSSID[j].WscControl;
+common/p2p.c:			NdisZeroMemory(&pAd->CommonCfg.WscStaPbcProbeInfo, sizeof(WSC_STA_PBC_PROBE_INFO));
+common/p2p.c:			pAd->CommonCfg.WscPBCOverlap = FALSE;
+common/p2p.c:			pAd->ApCfg.MBSSID[j].TimBitmaps[i] = 0;
+common/p2p.c:	pAd->ApCfg.DtimCount  = 0;
+common/p2p.c:	pAd->ApCfg.DtimPeriod = DEFAULT_DTIM_PERIOD;
+common/p2p.c:	pAd->ApCfg.ErpIeContent = 0;
+common/p2p.c:	pAd->ApCfg.StaIdleTimeout = MAC_TABLE_AGEOUT_TIME;
+common/p2p.c:	pAd->ApCfg.IdsEnable = FALSE;
+common/p2p.c:	pAd->ApCfg.AuthFloodThreshold = 0;
+common/p2p.c:	pAd->ApCfg.AssocReqFloodThreshold = 0;
+common/p2p.c:	pAd->ApCfg.ReassocReqFloodThreshold = 0;
+common/p2p.c:	pAd->ApCfg.ProbeReqFloodThreshold = 0;
+common/p2p.c:	pAd->ApCfg.DisassocFloodThreshold = 0;
+common/p2p.c:	pAd->ApCfg.DeauthFloodThreshold = 0;
+common/p2p.c:	pAd->ApCfg.EapReqFloodThreshold = 0;
+common/p2p.c:	pAd->WriteWscCfgToDatFile = 0xFF;
+common/p2p.c:	pAd->WriteWscCfgToAr9DatFile = FALSE;
+common/p2p.c:	pAd->bWscDriverAutoUpdateCfg = TRUE;
+common/p2p.c:		pAd->ApCfg.ApCliTab[j].AuthMode = Ndis802_11AuthModeOpen;
+common/p2p.c:		pAd->ApCfg.ApCliTab[j].WepStatus = Ndis802_11WEPDisabled;
+common/p2p.c:		pAd->ApCfg.ApCliTab[j].bAutoTxRateSwitch = TRUE;
+common/p2p.c:		pAd->ApCfg.ApCliTab[j].DesiredTransmitSetting.field.MCS = MCS_AUTO;
+common/p2p.c:		PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p.c:		RTMPMoveMemory(pAd->P2pCfg.SSID, WILDP2PSSID, WILDP2PSSIDLEN);
+common/p2p.c:/*		RTMPMoveMemory(pAd->P2pCfg.Bssid, pAd->P2pCfg.CurrentAddress, MAC_ADDR_LEN); */
+common/p2p.c:	if (pAd->flg_p2p_init != FALSE)
+common/p2p.c:	pAd->ApCfg.MBSSID[MAIN_MBSSID].MSSIDDev = NULL;
+common/p2p.c:	pAd->ApCfg.ApCliTab[MAIN_MBSSID].dev = NULL;
+common/p2p.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[MAIN_MBSSID];
+common/p2p.c:		COPY_MAC_ADDR(pAd->P2PCurrentAddress, pAd->CurrentAddress);
+common/p2p.c:		if (pAd->chipCap.MBSSIDMode == MBSSID_MODE1)
+common/p2p.c:		pAd->P2PCurrentAddress[0] += 2; 
+common/p2p.c:			if (pAd->P2PCurrentAddress[5] & 0x01 == 0x01)
+common/p2p.c:				pAd->P2PCurrentAddress[5] -= 1;
+common/p2p.c:		pAd->P2PCurrentAddress[5] += FIRST_MBSSID;
+common/p2p.c:		NdisMoveMemory(&pNetDevOps->devAddr[0], &pAd->P2PCurrentAddress[0], MAC_ADDR_LEN);
+common/p2p.c:		pAd->ApCfg.MBSSID[MAIN_MBSSID].MSSIDDev = new_dev_p;
+common/p2p.c:		COPY_MAC_ADDR(pAd->ApCfg.MBSSID[MAIN_MBSSID].Bssid, pAd->P2PCurrentAddress);
+common/p2p.c:		COPY_MAC_ADDR(pApCliEntry->CurrentAddress, pAd->P2PCurrentAddress);
+common/p2p.c:		COPY_MAC_ADDR(pAd->P2pCfg.CurrentAddress, pAd->P2PCurrentAddress);
+common/p2p.c:		pAd->p2p_dev = new_dev_p;
+common/p2p.c:		RtmpOSNetDevAttach(pAd->OpMode, new_dev_p, pNetDevOps);
+common/p2p.c:	pAd->CommonCfg.BeaconPeriod = 100;
+common/p2p.c:	pAd->ApCfg.DtimPeriod = 1;
+common/p2p.c:	pAd->CommonCfg.DisableOLBCDetect = 0;
+common/p2p.c:	P2pGetRandomSSID(pAd, pAd->ApCfg.MBSSID[MAIN_MBSSID].Ssid, &(pAd->ApCfg.MBSSID[MAIN_MBSSID].SsidLen));
+common/p2p.c:	pAd->ApCfg.MBSSID[MAIN_MBSSID].AuthMode = Ndis802_11AuthModeOpen;
+common/p2p.c:	pAd->ApCfg.MBSSID[MAIN_MBSSID].WepStatus = Ndis802_11EncryptionDisabled;
+common/p2p.c:	pAd->ApCfg.MBSSID[MAIN_MBSSID].DesiredTransmitSetting.field.MCS = pAd->StaCfg.DesiredTransmitSetting.field.MCS;
+common/p2p.c:	if ((pAd->CommonCfg.bWmmCapable) || WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+common/p2p.c:		pAd->ApCfg.MBSSID[MAIN_MBSSID].bWmmCapable = TRUE;
+common/p2p.c:	pAd->flg_p2p_init = TRUE;
+common/p2p.c:	pAd->ApCfg.ApCliTab[MAIN_MBSSID].AuthMode = Ndis802_11AuthModeOpen;
+common/p2p.c:	pAd->ApCfg.ApCliTab[MAIN_MBSSID].WepStatus = Ndis802_11WEPDisabled;
+common/p2p.c:	pAd->ApCfg.ApCliTab[MAIN_MBSSID].DesiredTransmitSetting.field.MCS = pAd->StaCfg.DesiredTransmitSetting.field.MCS;
+common/p2p.c:	pAd->flg_apcli_init = TRUE;
+common/p2p.c:	pAd->flg_p2p_OpStatusFlags = P2P_DISABLE;
+common/p2p.c:	WscGenerateUUID(pAd, &pAd->P2pCfg.Wsc_Uuid_E[0], &pAd->P2pCfg.Wsc_Uuid_Str[0], 0, FALSE);
+common/p2p.c:	NdisMoveMemory(&pAd->P2pCfg.DevInfo.Uuid[0], &pAd->P2pCfg.Wsc_Uuid_E[0], UUID_LEN_HEX);
+common/p2p.c:	pAd->ApCfg.MBSSID[MAIN_MBSSID].bBcnSntReq = FALSE;
+common/p2p.c:	pMbss = &pAd->ApCfg.MBSSID[MAIN_MBSSID];
+common/p2p.c:	COPY_MAC_ADDR(pMbss->Bssid, pAd->CurrentAddress);
+common/p2p.c:	if (pAd->chipCap.MBSSIDMode == MBSSID_MODE1)
+common/p2p.c:	NdisAllocateSpinLock(pAd, &pAd->P2pTableSemLock);
+common/p2p.c:	RTMPInitTimer(pAd, &pAd->CommonCfg.BeaconUpdateTimer, GET_TIMER_FUNCTION(BeaconUpdateExec), pAd, TRUE);
+common/p2p.c:	NdisFreeSpinLock(&pAd->P2pTableSemLock);
+common/p2p.c:	if (pAd->p2p_dev)
+common/p2p.c:		RtmpOSNetDevDetach(pAd->p2p_dev);
+common/p2p.c:		RtmpOSNetDevFree(pAd->p2p_dev);
+common/p2p.c:		pAd->p2p_dev = NULL;
+common/p2p.c:		pAd->flg_p2p_init = FALSE;
+common/p2p.c:		pMbss = &pAd->ApCfg.MBSSID[MAIN_MBSSID];
+common/p2p.c:		pAd->ApCfg.ApCliTab[MAIN_MBSSID].dev = NULL;
+common/p2p.c:		pAd->flg_apcli_init = FALSE;
+common/p2p.c:			pApCli = (PAPCLI_STRUCT)&pAd->ApCfg.ApCliTab;
+common/p2p.c:				pAd->RalinkCounters.PendingNdisPacketCount ++;
+common/p2p.c:				SET_OS_PKT_NETDEV(pPktSrc, pAd->net_dev);
+common/p2p.c:			if (pAd->ApCfg.MBSSID[MAIN_MBSSID].MSSIDDev == pDev)
+common/p2p.c:				pAd->RalinkCounters.PendingNdisPacketCount ++;
+common/p2p.c:				SET_OS_PKT_NETDEV(pPktSrc, pAd->net_dev);
+common/p2p.c:	if (!WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+common/p2p.c:	SetHT.PhyMode = (RT_802_11_PHY_MODE)pAd->CommonCfg.PhyMode;
+common/p2p.c:	SetHT.TransmitNo = ((UCHAR)pAd->Antenna.field.TxPath);
+common/p2p.c:	SetHT.HtMode = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.HTMODE;
+common/p2p.c:	SetHT.ExtOffset = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.EXTCHA;
+common/p2p.c:	SetHT.BW = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.BW;
+common/p2p.c:	SetHT.STBC = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.STBC;
+common/p2p.c:	SetHT.SHORTGI = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.ShortGI; 
+common/p2p.c:		if (pAd->StaActive.SupportedHtPhy.ChannelWidth == BW_40)
+common/p2p.c:			SetHT.ExtOffset = (UCHAR)pAd->StaActive.SupportedHtPhy.ExtChanOffset;
+common/p2p.c:			pEntry = &pAd->MacTab.Content[i];
+common/wapi.c:			cipher_mode = pAd->ApCfg.MBSSID[apidx].WepStatus;
+common/wapi.c:		cipher_mode = pAd->StaCfg.WepStatus;
+common/wapi.c:	PCOMMON_WAPI_INFO pInfo = &pAd->CommonCfg.comm_wapi_info;
+common/wapi.c:			pAd->CommonCfg.wapi_usk_rekey_method = REKEY_METHOD_TIME;
+common/wapi.c:			pAd->CommonCfg.wapi_usk_rekey_method = REKEY_METHOD_PKT;
+common/wapi.c:			pAd->CommonCfg.wapi_usk_rekey_method = REKEY_METHOD_DISABLE;
+common/wapi.c:		DBGPRINT(RT_DEBUG_TRACE, ("WapiUskRekeyMethod=%d\n", pAd->CommonCfg.wapi_usk_rekey_method));			   
+common/wapi.c:		pAd->CommonCfg.wapi_usk_rekey_threshold = simple_strtol(tmpbuf, 0, 10); 
+common/wapi.c:		DBGPRINT(RT_DEBUG_TRACE, ("WapiUskRekeyThreshold=%d\n", pAd->CommonCfg.wapi_usk_rekey_threshold));			   
+common/wapi.c:			pAd->CommonCfg.wapi_msk_rekey_method = REKEY_METHOD_TIME;
+common/wapi.c:			pAd->CommonCfg.wapi_msk_rekey_method = REKEY_METHOD_PKT;
+common/wapi.c:			pAd->CommonCfg.wapi_msk_rekey_method = REKEY_METHOD_DISABLE;
+common/wapi.c:		DBGPRINT(RT_DEBUG_TRACE, ("WapiMskRekeyMethod=%d\n", pAd->CommonCfg.wapi_msk_rekey_method));			   
+common/wapi.c:		pAd->CommonCfg.wapi_msk_rekey_threshold = simple_strtol(tmpbuf, 0, 10); 
+common/wapi.c:		DBGPRINT(RT_DEBUG_TRACE, ("WapiMskRekeyThreshold=%d\n", pAd->CommonCfg.wapi_msk_rekey_threshold));			   
+common/wapi.c:		for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/wapi.c:			NdisZeroMemory(pAd->ApCfg.MBSSID[apidx].WAPIPassPhrase, 64);
+common/wapi.c:			pAd->ApCfg.MBSSID[apidx].WAPIPassPhraseLen = 0;
+common/wapi.c:			        NdisMoveMemory(pAd->ApCfg.MBSSID[apidx].WAPIPassPhrase, tmpbuf, strlen(tmpbuf));
+common/wapi.c:			        pAd->ApCfg.MBSSID[apidx].WAPIPassPhraseLen = strlen(tmpbuf);
+common/wapi.c:					if (pAd->ApCfg.MBSSID[apidx].AuthMode == Ndis802_11AuthModeWAIPSK)
+common/wapi.c:						pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeOpen;
+common/wapi.c:						pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11EncryptionDisabled;
+common/wapi.c:		    NdisZeroMemory(pAd->StaCfg.WAPIPassPhrase, 64);
+common/wapi.c:		    pAd->StaCfg.WAPIPassPhraseLen = 0;
+common/wapi.c:		        NdisMoveMemory(pAd->StaCfg.WAPIPassPhrase, tmpbuf, strlen(tmpbuf));
+common/wapi.c:		        pAd->StaCfg.WAPIPassPhraseLen = strlen(tmpbuf);
+common/wapi.c:				if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAIPSK)
+common/wapi.c:					pAd->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
+common/wapi.c:					pAd->StaCfg.WepStatus = Ndis802_11EncryptionDisabled;
+common/wapi.c:				if (apidx >= pAd->ApCfg.BssidNum)
+common/wapi.c:					pAd->ApCfg.MBSSID[apidx].WapiPskType = HEX_MODE;
+common/wapi.c:					if (pAd->ApCfg.MBSSID[apidx].WAPIPassPhraseLen % 2 != 0)
+common/wapi.c:					pAd->ApCfg.MBSSID[apidx].WapiPskType = ASCII_MODE;
+common/wapi.c:					pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeOpen;
+common/wapi.c:					pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11EncryptionDisabled;
+common/wapi.c:					DBGPRINT(RT_DEBUG_TRACE, ("I/F(ra%d) WapiPskType=%s\n", apidx, (pAd->ApCfg.MBSSID[apidx].WapiPskType == HEX_MODE) ? "HEX" : "ASCII"));
+common/wapi.c:				pAd->StaCfg.WapiPskType = HEX_MODE;
+common/wapi.c:				if (pAd->StaCfg.WAPIPassPhraseLen % 2 != 0)
+common/wapi.c:				pAd->StaCfg.WapiPskType = ASCII_MODE;
+common/wapi.c:				pAd->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
+common/wapi.c:				pAd->StaCfg.WepStatus = Ndis802_11EncryptionDisabled;
+common/wapi.c:				DBGPRINT(RT_DEBUG_TRACE, ("WapiPskType=%s\n", (pAd->StaCfg.WapiPskType == HEX_MODE) ? "HEX" : "ASCII"));
+common/wapi.c:	if (pAd->CommonCfg.wapi_usk_rekey_method == REKEY_METHOD_DISABLE || 
+common/wapi.c:		pAd->CommonCfg.wapi_usk_rekey_threshold == 0)
+common/wapi.c:		pAd->CommonCfg.wapi_usk_rekey_method = REKEY_METHOD_DISABLE;
+common/wapi.c:		pAd->CommonCfg.wapi_usk_rekey_threshold = 0;
+common/wapi.c:	if (pAd->CommonCfg.wapi_msk_rekey_method == REKEY_METHOD_DISABLE || 
+common/wapi.c:		pAd->CommonCfg.wapi_msk_rekey_threshold == 0)
+common/wapi.c:		pAd->CommonCfg.wapi_msk_rekey_method = REKEY_METHOD_DISABLE;
+common/wapi.c:		pAd->CommonCfg.wapi_msk_rekey_threshold = 0;
+common/wapi.c:		PMULTISSID_STRUCT pMbss = &pAd->ApCfg.MBSSID[apidx];
+common/wapi.c:		NdisMoveMemory(pConf->ifname, pAd->StaCfg.dev_name, strlen((PSTRING) pAd->StaCfg.dev_name));
+common/wapi.c:		pConf->ifname_len = strlen((PSTRING) pAd->StaCfg.dev_name);
+common/wapi.c:		if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAICERT)
+common/wapi.c:		else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAIPSK)
+common/wapi.c:		if (pAd->StaCfg.WAPIPassPhraseLen > 0)
+common/wapi.c:			if (pAd->StaCfg.WapiPskType == HEX_MODE)
+common/wapi.c:				pConf->psk_len = pAd->StaCfg.WAPIPassPhraseLen / 2;
+common/wapi.c:				AtoH((PSTRING) pAd->StaCfg.WAPIPassPhrase, (PUCHAR) pConf->psk, pConf->psk_len);
+common/wapi.c:				pConf->psk_len = pAd->StaCfg.WAPIPassPhraseLen; 
+common/wapi.c:				NdisMoveMemory(pConf->psk, pAd->StaCfg.WAPIPassPhrase, pConf->psk_len);
+common/wapi.c:		RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus, BSS0);
+common/wapi.c:		if (pAd->StaCfg.RSNIE_Len > 0)
+common/wapi.c:			pConf->wie_len = pAd->StaCfg.RSNIE_Len + 2; 
+common/wapi.c:			pConf->wie[1] = pAd->StaCfg.RSNIE_Len;
+common/wapi.c:			NdisMoveMemory(&pConf->wie[2], pAd->StaCfg.RSN_IE, pAd->StaCfg.RSNIE_Len);
+common/wapi.c:		pConf->mbss_num = pAd->ApCfg.BssidNum;		
+common/wapi.c:	NdisMoveMemory(&pConf->comm_wapi_info, &pAd->CommonCfg.comm_wapi_info, sizeof(COMMON_WAPI_INFO));
+common/wapi.c:    if (pAd->CommonCfg.wapi_usk_rekey_method == REKEY_METHOD_TIME)
+common/wapi.c:	else if (pAd->CommonCfg.wapi_usk_rekey_method == REKEY_METHOD_PKT)
+common/wapi.c:	if (tmp_cnt > pAd->CommonCfg.wapi_usk_rekey_threshold)
+common/wapi.c:	if (pAd->MacTab.fAnyWapiStation == FALSE)
+common/wapi.c:    if (pAd->CommonCfg.wapi_msk_rekey_method == REKEY_METHOD_TIME)
+common/wapi.c:		tmp_cnt = (++pAd->CommonCfg.wapi_msk_rekey_cnt);
+common/wapi.c:	else if (pAd->CommonCfg.wapi_msk_rekey_method == REKEY_METHOD_PKT)
+common/wapi.c:		tmp_cnt = pAd->CommonCfg.wapi_msk_rekey_cnt/1000;
+common/wapi.c:	if (tmp_cnt > pAd->CommonCfg.wapi_msk_rekey_threshold)
+common/wapi.c:		pAd->CommonCfg.wapi_msk_rekey_cnt = 0;
+common/wapi.c:			for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+common/wapi.c:				pAd->ApCfg.MBSSID[apidx].DefaultKeyId = pAd->ApCfg.MBSSID[apidx].DefaultKeyId == 0 ? 1 : 0;
+common/wapi.c:				inc_iv_byte(pAd->ApCfg.MBSSID[apidx].key_announce_flag, LEN_WAPI_TSC, 1);
+common/wapi.c:					pAd->ApCfg.MBSSID[apidx].NMK[cnt] = RandomByte(pAd);
+common/wapi.c:				RTMPDeriveWapiGTK(pAd->ApCfg.MBSSID[apidx].NMK, pAd->ApCfg.MBSSID[apidx].GTK);				
+common/wapi.c:									 pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus, 
+common/wapi.c:									 pAd->ApCfg.MBSSID[apidx].DefaultKeyId, 
+common/wapi.c:									 pAd->ApCfg.MBSSID[apidx].GTK);
+common/wapi.c:			pEntry = &pAd->MacTab.Content[i];
+common/wapi.c:		RTMPInitTimer(pAd, &pAd->CommonCfg.WapiMskRekeyTimer, GET_TIMER_FUNCTION(RTMPWapiMskRekeyPeriodicExec), pAd, TRUE);
+common/wapi.c:		pAd->CommonCfg.WapiMskRekeyTimerRunning = FALSE;
+common/wapi.c:		if ((pAd->CommonCfg.wapi_usk_rekey_method != REKEY_METHOD_DISABLE) && 
+common/wapi.c:			(pAd->CommonCfg.wapi_usk_rekey_threshold > 0))
+common/wapi.c:				DBGPRINT(RT_DEBUG_TRACE, (" RTMPStartWapiRekeyTimerAction : WAPI USK rekey timer is started (%d) \n", pAd->CommonCfg.wapi_usk_rekey_threshold));
+common/wapi.c:		if ((pAd->CommonCfg.wapi_msk_rekey_method != REKEY_METHOD_DISABLE) && 
+common/wapi.c:			(pAd->CommonCfg.wapi_msk_rekey_threshold > 0))
+common/wapi.c:			if (pAd->CommonCfg.WapiMskRekeyTimerRunning == FALSE)
+common/wapi.c:				RTMPSetTimer(&pAd->CommonCfg.WapiMskRekeyTimer, WAPI_KEY_UPDATE_EXEC_INTV);
+common/wapi.c:				pAd->CommonCfg.WapiMskRekeyTimerRunning = TRUE;
+common/wapi.c:				pAd->CommonCfg.wapi_msk_rekey_cnt = 0;
+common/wapi.c:		if (pAd->CommonCfg.WapiMskRekeyTimerRunning == TRUE)
+common/wapi.c:			RTMPCancelTimer(&pAd->CommonCfg.WapiMskRekeyTimer, &Cancelled);
+common/wapi.c:			pAd->CommonCfg.wapi_msk_rekey_cnt = 0;
+common/wapi.c:			pAd->CommonCfg.WapiMskRekeyTimerRunning = FALSE;
+common/wapi.c:			MAKE_802_3_HEADER(FrameBuf, pAd->ApCfg.MBSSID[apidx].Bssid, pAddr, WAPI_IE); 
+common/wapi.c:			MAKE_802_3_HEADER(FrameBuf, pAd->CurrentAddress, pAddr, WAPI_IE); 
+common/wapi.c:	pSharedKey = &pAd->SharedKey[BssIdx][KeyIdx];
+common/uapsd.c:	NdisAllocateSpinLock(pAd, &pAd->UAPSDEOSPLock);
+common/uapsd.c:    NdisFreeSpinLock(&pAd->UAPSDEOSPLock);
+common/uapsd.c:		RTMP_SEM_LOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:		RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:	RTMP_SEM_LOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:	RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:	RTMP_SEM_LOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:		UAPSD_INSERT_QUEUE_AC(pAd, pEntry, &pAd->TxSwQueue[QueId],
+common/uapsd.c:			UAPSD_INSERT_QUEUE_AC(pAd, pEntry, &pAd->TxSwQueue[QueId], pQueEntry);
+common/uapsd.c:	RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:		RTMP_SEM_LOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:		RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:	RTMP_SEM_LOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:		RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+common/uapsd.c:		if (pEntry->UAPSDQIdleCount > pAd->MacTab.MsduLifeTime)
+common/uapsd.c:		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+common/uapsd.c:	RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:		RTMP_SEM_LOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:			RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:					UAPSD_INSERT_QUEUE_AC(pAd, pEntry, &pAd->TxSwQueue[QueId],
+common/uapsd.c:			RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:				pCookie = (POS_COOKIE) pAd->OS_Cookie;
+common/uapsd.c:			if (pAd->bAPSDFlagSPSuspend == 1)
+common/uapsd.c:				(pAd->bAPSDFlagSPSuspend == 0))
+common/uapsd.c:		RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:	if (pAd->MacTab.fAnyStationInPsm == FALSE)
+common/uapsd.c:		MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[IdEntry];
+common/uapsd.c:		RTMP_SEM_LOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:		RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:	RTMP_SEM_LOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:		RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:		RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:			pAcSwQue = &pAd->TxSwQueue[QueId];
+common/uapsd.c:	RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:	RTMP_SEM_LOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:	RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:	RTMP_SEM_LOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:			RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:			RTMP_SEM_LOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:			RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:		RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:		RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:		pAcSwQue = &pAd->TxSwQueue[QueId];
+common/uapsd.c:	RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:	pEntry = &pAd->MacTab.Content[Wcid];
+common/uapsd.c:	RTMP_SEM_LOCK(&pAd->UAPSDEOSPLock);
+common/uapsd.c:		pEntry = &pAd->MacTab.Content[IdEntry];
+common/uapsd.c:										&pAd->TxSwQueue[QueId],
+common/uapsd.c:	RTMP_SEM_UNLOCK(&pAd->UAPSDEOSPLock);
+Binary file common/rtusb_io.o matches
+common/rtmp_init_inf.c:	if (pAd->WlanFunCtrl.field.WLAN_EN == 0)
+common/rtmp_init_inf.c:	if (IS_MT7601(pAd) && (pAd->WlanFunCtrl.field.WLAN_EN == 0))
+common/rtmp_init_inf.c:	DBGPRINT(RT_DEBUG_OFF, ("MACVersion=0x%x\n", pAd->MACVersion));
+common/rtmp_init_inf.c:		pAd->CmbCtrl.word = cmbCtrl.word;
+common/rtmp_init_inf.c:	DBGPRINT(RT_DEBUG_TRACE, ("MAC[Ver:Rev=0x%08x]\n", pAd->MACVersion));
+common/rtmp_init_inf.c:    skb_queue_head_init(&pAd->rx0_recycle);
+common/rtmp_init_inf.c:	/* Initialize pAd->StaCfg, pAd->ApCfg, pAd->CommonCfg to manufacture default*/
+common/rtmp_init_inf.c:	pAd->RfIcType = RFIC_UNKNOWN;
+common/rtmp_init_inf.c:	DBGPRINT(RT_DEBUG_OFF, ("1. Phy Mode = %d\n", pAd->CommonCfg.PhyMode));
+common/rtmp_init_inf.c:	pAd->CommonCfg.bMultipleIRP = FALSE;
+common/rtmp_init_inf.c:	if (pAd->CommonCfg.bMultipleIRP)
+common/rtmp_init_inf.c:		pAd->CommonCfg.NumOfBulkInIRP = RX_RING_SIZE;
+common/rtmp_init_inf.c:		pAd->CommonCfg.NumOfBulkInIRP = 1;
+common/rtmp_init_inf.c:	pAd->CommonCfg.DesiredHtPhy.MpduDensity = (UCHAR)pAd->CommonCfg.BACapability.field.MpduDensity;
+common/rtmp_init_inf.c:	pAd->CommonCfg.DesiredHtPhy.AmsduEnable = (USHORT)pAd->CommonCfg.BACapability.field.AmsduEnable;
+common/rtmp_init_inf.c:	pAd->CommonCfg.DesiredHtPhy.AmsduSize = (USHORT)pAd->CommonCfg.BACapability.field.AmsduSize;
+common/rtmp_init_inf.c:	pAd->CommonCfg.DesiredHtPhy.MimoPs = (USHORT)pAd->CommonCfg.BACapability.field.MMPSmode;
+common/rtmp_init_inf.c:	pAd->CommonCfg.HtCapability.HtCapInfo.MimoPs = (USHORT)pAd->CommonCfg.BACapability.field.MMPSmode;
+common/rtmp_init_inf.c:	pAd->CommonCfg.HtCapability.HtCapInfo.AMsduSize = (USHORT)pAd->CommonCfg.BACapability.field.AmsduSize;
+common/rtmp_init_inf.c:	pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity = (UCHAR)pAd->CommonCfg.BACapability.field.MpduDensity;
+common/rtmp_init_inf.c:	DBGPRINT(RT_DEBUG_OFF, ("2. Phy Mode = %d\n", pAd->CommonCfg.PhyMode));
+common/rtmp_init_inf.c:	DBGPRINT(RT_DEBUG_OFF, ("3. Phy Mode = %d\n", pAd->CommonCfg.PhyMode));
+common/rtmp_init_inf.c:	if (pAd->chipCap.FreqCalibrationSupport)
+common/rtmp_init_inf.c:	DBGPRINT(RT_DEBUG_OFF, ("bAutoTxAgcG = %d\n", pAd->bAutoTxAgcG));
+common/rtmp_init_inf.c:	if (pAd->chipCap.bTempCompTxALC && pAd->bAutoTxAgcG)
+common/rtmp_init_inf.c:	if (pAd->chipCap.FreqCalibrationSupport)
+common/rtmp_init_inf.c:	RTMPSetPhyMode(pAd, pAd->CommonCfg.PhyMode);
+common/rtmp_init_inf.c:	if (pAd->ChannelListNum == 0)
+common/rtmp_init_inf.c:	DBGPRINT(RT_DEBUG_OFF, ("MCS Set = %02x %02x %02x %02x %02x\n", pAd->CommonCfg.HtCapability.MCSSet[0],
+common/rtmp_init_inf.c:           pAd->CommonCfg.HtCapability.MCSSet[1], pAd->CommonCfg.HtCapability.MCSSet[2],
+common/rtmp_init_inf.c:           pAd->CommonCfg.HtCapability.MCSSet[3], pAd->CommonCfg.HtCapability.MCSSet[4]));
+common/rtmp_init_inf.c:	VR_IKANOS_FP_Init(pAd->ApCfg.BssidNum, pAd->PermanentAddress);
+common/rtmp_init_inf.c:	if (pAd->OpMode == OPMODE_AP)
+common/rtmp_init_inf.c:		AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+common/rtmp_init_inf.c:		AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+common/rtmp_init_inf.c:			if (pAd->ApCfg.bAutoChannelAtBootup || (pAd->CommonCfg.Channel == 0))
+common/rtmp_init_inf.c:				/* the value on pAd->CommonCfg.NumOfBulkInIRP may be large than 1.*/
+common/rtmp_init_inf.c:				for(index=0; index<pAd->CommonCfg.NumOfBulkInIRP; index++)
+common/rtmp_init_inf.c:				pAd->CommonCfg.Channel = AP_AUTO_CH_SEL(pAd, pAd->ApCfg.AutoChannelAlg);
+common/rtmp_init_inf.c:				pAd->ApCfg.bAutoChannelAtBootup = FALSE;
+common/rtmp_init_inf.c:			if (pAd->CommonCfg.bForty_Mhz_Intolerant == TRUE)
+common/rtmp_init_inf.c:											pAd->CommonCfg.bBssCoexEnable, 
+common/rtmp_init_inf.c:											pAd->CommonCfg.bForty_Mhz_Intolerant));
+common/rtmp_init_inf.c:			else if(pAd->CommonCfg.bBssCoexEnable == TRUE)
+common/rtmp_init_inf.c:							pAd->CommonCfg.bBssCoexEnable));
+common/rtmp_init_inf.c:/*			RTMPInitTimer(pAd, &pAd->CommonCfg.Bss2040CoexistTimer, GET_TIMER_FUNCTION(Bss2040CoexistTimeOut), pAd, FALSE);*/
+common/rtmp_init_inf.c:									PRINT_MAC(pAd->ApCfg.MBSSID[BSS0].Bssid)));
+common/rtmp_init_inf.c:		/* the value on pAd->CommonCfg.NumOfBulkInIRP may be large than 1.*/
+common/rtmp_init_inf.c:		for(index=0; index<pAd->CommonCfg.NumOfBulkInIRP; index++)
+common/rtmp_init_inf.c:	RtmpOSNetDevAddrSet(pAd->OpMode, pAd->net_dev, &pAd->CurrentAddress[0], NULL);
+common/rtmp_init_inf.c:	RtmpOSNetDevAddrSet(pAd->OpMode, pAd->net_dev, &pAd->CurrentAddress[0], (PUCHAR)(pAd->StaCfg.dev_name));
+common/rtmp_init_inf.c:/*		RT28xx_MBSS_Init(pAd, pAd->net_dev);  os abl move to rt_main_dev.c*/
+common/rtmp_init_inf.c:/*		RT28xx_ApCli_Init(pAd, pAd->net_dev);*/
+common/rtmp_init_inf.c:/*		RTMP_P2P_Init(pAd, pAd->net_dev); */
+common/rtmp_init_inf.c:		RtmpOSWrielessEventSend(pAd->net_dev, RT_WLAN_EVENT_CUSTOM, RT_INTERFACE_UP, NULL, NULL, 0);
+common/rtmp_init_inf.c:	if (pAd->CommonCfg.TxStream >= 3)
+common/rtmp_init_inf.c:	if (pAd->CommonCfg.ITxBfTimeout)
+common/rtmp_init_inf.c:		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R182, pAd->CommonCfg.ITxBfTimeout & 0xFF);
+common/rtmp_init_inf.c:		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R182, (pAd->CommonCfg.ITxBfTimeout>>8) & 0xFF);
+common/rtmp_init_inf.c:	if (pAd->CommonCfg.ETxBfTimeout)
+common/rtmp_init_inf.c:		RTMP_IO_WRITE32(pAd, TX_TXBF_CFG_3, pAd->CommonCfg.ETxBfTimeout);
+common/rtmp_init_inf.c:	MultiCastFilterTableReset(&pAd->pMulticastFilterTable);
+common/rtmp_init_inf.c:	NdisFreeSpinLock(&pAd->TimerQLock);
+common/rtmp_init_inf.c:	if(pAd->mpdu_blk_pool.mem)
+common/rtmp_init_inf.c:		os_free_mem(pAd, pAd->mpdu_blk_pool.mem); /* free BA pool*/
+common/rtmp_init_inf.c:	if (pAd->OpMode == OPMODE_STA)
+common/rtmp_init_inf.c:	if ((pAd->OpMode == OPMODE_AP)
+common/rtmp_init_inf.c:		for (index = 0; index < pAd->ApCfg.BssidNum; index++)
+common/rtmp_init_inf.c:			if (pAd->ApCfg.MBSSID[index].Hostapd == TRUE)
+common/rtmp_init_inf.c:				pWscControl = &pAd->ApCfg.MBSSID[index].WscControl;
+common/rtmp_init_inf.c:			PWSC_CTRL pWpsCtrl = &pAd->ApCfg.ApCliTab[index].WscControl;
+common/rtmp_init_inf.c:			RTMP_AP_IoctlHandle(pAd, NULL, CMD_RTPRIV_IOCTL_WSC_INIT, 0, (VOID *)&pAd->ApCfg.ApCliTab[index], index);
+common/rtmp_init_inf.c:		PWSC_CTRL pWscControl = &pAd->StaCfg.WscControl;
+common/rtmp_init_inf.c:		WscInitRegistrarPair(pAd, &pAd->StaCfg.WscControl, BSS0);
+common/rtmp_init_inf.c:		if (pAd->IndicateMediaState == NdisMediaStateConnected)
+common/rtmp_init_inf.c:			RTMP_SEM_LOCK(&pAd->StaCtIf.Lock);
+common/rtmp_init_inf.c:			pAd->StaCtIf.Changeable = FALSE;
+common/rtmp_init_inf.c:			RTMP_SEM_UNLOCK(&pAd->StaCtIf.Lock);
+common/rtmp_init_inf.c:	if (pAd->CommonCfg.pChDesp != NULL)
+common/rtmp_init_inf.c:		os_free_mem(NULL, pAd->CommonCfg.pChDesp);
+common/rtmp_init_inf.c:	pAd->CommonCfg.pChDesp = NULL;
+common/rtmp_init_inf.c:	pAd->CommonCfg.DfsType = MAX_RD_REGION;
+common/rtmp_init_inf.c:	pAd->CommonCfg.bCountryFlag = 0;
+common/rtmp_init_inf.c:		while (pAd->DeQueueRunning[i] == TRUE)
+common/rtmp_init_inf.c:	RtmpOsUsbEmptyUrbCheck(&pAd->wait, &pAd->BulkInLock, &pAd->PendingRx);
+common/rtmp_init_inf.c:		RTMPCancelTimer(&pAd->CommonCfg.BeaconUpdateTimer, &Cancelled);
+common/rtmp_init_inf.c:		if (pAd->CommonCfg.Bss2040CoexistFlag & BSS_2040_COEXIST_TIMER_FIRED)
+common/rtmp_init_inf.c:			RTMPCancelTimer(&pAd->CommonCfg.Bss2040CoexistTimer, &Cancelled);
+common/rtmp_init_inf.c:			pAd->CommonCfg.Bss2040CoexistFlag  = 0;
+common/rtmp_init_inf.c:		/*RTMPCancelTimer(&pAd->PeriodicTimer,	&Cancelled);*/
+common/rtmp_init_inf.c:		/* must after RtmpMgmtTaskExit(); Or pAd->pChannelInfo will be NULL */
+common/rtmp_init_inf.c:		DlListForEachSafe(ch, ch_temp, &pAd->SingleSkuPwrList, CH_POWER, List)
+common/rtmp_init_inf.c:	skb_queue_purge(&pAd->rx0_recycle);
+common/rtmp_init_inf.c:		TDLS_ClearEntryList(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerList);
+common/rtmp_init_inf.c:		NdisFreeSpinLock(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+common/rtmp_init_inf.c:		TDLS_ClearEntryList(&pAd->StaCfg.TdlsInfo.TdlsBlackList);
+common/rtmp_init_inf.c:		NdisFreeSpinLock(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+common/rtmp_init_inf.c:	NdisZeroMemory(&pAd->MacTab, sizeof(MAC_TABLE));
+common/rtmp_init_inf.c:	NdisFreeSpinLock(&pAd->TimerQLock);
+common/rtmp_init_inf.c:	pAd->ApCfg.MBSSID[MAIN_MBSSID].bBcnSntReq = FALSE;
+common/rtmp_init_inf.c:		if (pAd->CommonCfg.bDLSCapable)
+common/rtmp_init_inf.c:				if (pAd->StaCfg.DLSEntry[i].Valid && (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH))
+common/rtmp_init_inf.c:					RTMPSendDLSTearDownFrame(pAd, pAd->StaCfg.DLSEntry[i].MacAddr);
+common/rtmp_init_inf.c:					pAd->StaCfg.DLSEntry[i].Status	= DLS_NONE;
+common/rtmp_init_inf.c:					pAd->StaCfg.DLSEntry[i].Valid	= FALSE;
+common/rtmp_init_inf.c:				if (pAd->StaCfg.DLSEntry[i].Valid && (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH))
+common/rtmp_init_inf.c:					RTMPSendDLSTearDownFrame(pAd, pAd->StaCfg.DLSEntry[i].MacAddr);
+common/rtmp_init_inf.c:					pAd->StaCfg.DLSEntry[i].Status = DLS_NONE;
+common/rtmp_init_inf.c:					pAd->StaCfg.DLSEntry[i].Valid	= FALSE;
+common/rtmp_init_inf.c:			COPY_MAC_ADDR(DisReq.Addr, pAd->CommonCfg.Bssid);
+common/rtmp_init_inf.c:			pAd->MlmeAux.AutoReconnectSsidLen= 32;
+common/rtmp_init_inf.c:			NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen);
+common/rtmp_init_inf.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_DISASSOC;
+common/rtmp_init_inf.c:		RtmpOSWrielessEventSend(pAd->net_dev, RT_WLAN_EVENT_CUSTOM, RT_INTERFACE_DOWN, NULL, NULL, 0);
+common/rtmp_init_inf.c:		if (pAd->StaCfg.pWpsProbeReqIe)
+common/rtmp_init_inf.c:/*			kfree(pAd->StaCfg.pWpsProbeReqIe);*/
+common/rtmp_init_inf.c:			os_free_mem(NULL, pAd->StaCfg.pWpsProbeReqIe);
+common/rtmp_init_inf.c:			pAd->StaCfg.pWpsProbeReqIe = NULL;
+common/rtmp_init_inf.c:			pAd->StaCfg.WpsProbeReqIeLen = 0;
+common/rtmp_init_inf.c:		if (pAd->StaCfg.pWpaAssocIe)
+common/rtmp_init_inf.c:/*			kfree(pAd->StaCfg.pWpaAssocIe);*/
+common/rtmp_init_inf.c:			os_free_mem(NULL, pAd->StaCfg.pWpaAssocIe);
+common/rtmp_init_inf.c:			pAd->StaCfg.pWpaAssocIe = NULL;
+common/rtmp_init_inf.c:			pAd->StaCfg.WpaAssocIeLen = 0;
+common/rtmp_init_inf.c:	MC_RowID = pAd->MC_RowID;
+common/rtmp_init_inf.c:	IoctlIF = pAd->IoctlIF;
+common/rtmp_init_inf.c:	pAd->IoctlIF = IoctlIF;
+common/rtmp_init_inf.c:					NdisMoveMemory(pTempStr + 5, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen);
+common/rtmp_init_inf.c:					if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeOpen)
+common/rtmp_init_inf.c:					else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeShared)
+common/rtmp_init_inf.c:					else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeAutoSwitch)
+common/rtmp_init_inf.c:					else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK)
+common/rtmp_init_inf.c:					else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+common/rtmp_init_inf.c:					else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA)
+common/rtmp_init_inf.c:					else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
+common/rtmp_init_inf.c:					else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
+common/rtmp_init_inf.c:					if (pAd->StaCfg.WepStatus == Ndis802_11WEPDisabled)
+common/rtmp_init_inf.c:					else if (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled)
+common/rtmp_init_inf.c:					else if (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled)
+common/rtmp_init_inf.c:					else if (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled)
+common/rtmp_init_inf.c:	if (pAd->bWriteDat == FALSE)
+common/rtmp_init_inf.c:	pTask = &pAd->WriteDatTask;
+common/rtmp_init_inf.c:	status = RtmpOSTaskAttach(pTask, write_dat_file_thread, (ULONG)&pAd->WriteDatTask);
+common/p2p_action.c:	pAd->P2pCfg.ActionState = P2P_IDLE_STATE;
+common/p2p_action.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p_action.c:		if ((pAd->MacTab.Content[p2pindex].P2pInfo.NoADesc[0].Count > 2) || (pAd->MacTab.Content[p2pindex].P2pInfo.NoADesc[0].Count == 0))
+common/p2p_action.c:			MlmeP2pCommonAction(pAd, P2PACT_PERSENCE_RSP, pAd->MacTab.Content[p2pindex].P2pInfo.NoAToken, &NoAAttribute[0], 3+6, Elem);
+common/p2p_action.c:			pAd->P2pCfg.GONoASchedule.Duration = pAd->MacTab.Content[p2pindex].P2pInfo.NoADesc[0].Duration;
+common/p2p_action.c:			pAd->P2pCfg.GONoASchedule.Interval = pAd->MacTab.Content[p2pindex].P2pInfo.NoADesc[0].Interval;
+common/p2p_action.c:			pAd->P2pCfg.GONoASchedule.Count = 255;
+common/p2p_action.c:			NoAAttribute[Index+7] = pAd->MacTab.Content[p2pindex].P2pInfo.NoAToken; /* NoAToken should save the token from client's presence request. */
+common/p2p_action.c:			NoAAttribute[Index+8] = pAd->P2pCfg.CTWindows;	/* CTWindows */
+common/p2p_action.c:			NoAAttribute[Index+9] = pAd->P2pCfg.GONoASchedule.Count;	/* Count */
+common/p2p_action.c:			RTMPMoveMemory(&NoAAttribute[Index+10], &pAd->P2pCfg.GONoASchedule.Duration, 4);
+common/p2p_action.c:			RTMPMoveMemory(&NoAAttribute[Index+14], &pAd->P2pCfg.GONoASchedule.Interval, 4);
+common/p2p_action.c:			RTMPMoveMemory(&NoAAttribute[Index+18], &pAd->P2pCfg.GONoASchedule.StartTime, 4);
+common/p2p_action.c:			MlmeP2pCommonAction(pAd, P2PACT_PERSENCE_RSP, pAd->MacTab.Content[p2pindex].P2pInfo.NoAToken, &NoAAttribute[0], 22+6, Elem);
+common/p2p_action.c:			pAd->P2pCfg.GONoASchedule.bValid = TRUE;
+common/p2p_action.c:		pAd->P2pTable.Client[pGoReq->TabIndex].P2pClientState = P2PSTATE_WAIT_GO_DISCO_ACK;
+common/p2p_action.c:		DBGPRINT(RT_DEBUG_TRACE, ("P2P- Client State %s  \n", decodeP2PClientState(pAd->P2pTable.Client[pGoReq->TabIndex].P2pClientState)));
+common/p2p_action.c:	DBGPRINT(RT_DEBUG_TRACE,("PeerP2pNoaAction  %s. \n", decodeP2PState(pAd->P2pCfg.P2PConnectState)));
+common/p2p_action.c:		DBGPRINT(RT_DEBUG_TRACE,("PeerP2pNoaAction return %s. \n", decodeP2PState(pAd->P2pCfg.P2PConnectState)));
+common/p2p_action.c:	pClient = &pAd->MacTab.Content[Elem->Wcid];
+common/p2p_action.c:	pAd->P2pCfg.NoAIndex = Elem->Wcid;
+common/p2p_action.c:	pEntry = &pAd->MacTab.Content[Elem->Wcid];
+common/p2p_action.c:	DBGPRINT(RT_DEBUG_TRACE,("bKeepSlient = %d.\n", pAd->P2pCfg.bKeepSlient));
+common/cmm_mac_usb.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_mac_usb.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_mac_usb.c:	PTX_CONTEXT pNullContext   = &pAd->NullContext;
+common/cmm_mac_usb.c:	PTX_CONTEXT pPsPollContext = &pAd->PsPollContext;
+common/cmm_mac_usb.c:	PCMD_RSP_CONTEXT pCmdRspEventContext = &pAd->CmdRspEventContext;
+common/cmm_mac_usb.c:		RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+common/cmm_mac_usb.c:		pQueue = &pAd->TxSwQueue[index];
+common/cmm_mac_usb.c:		 RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+common/cmm_mac_usb.c:		PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
+common/cmm_mac_usb.c:		PTX_CONTEXT pMLMEContext = (PTX_CONTEXT)pAd->MgmtRing.Cell[i].AllocVa;
+common/cmm_mac_usb.c:		if (NULL != pAd->MgmtRing.Cell[i].pNdisPacket) 
+common/cmm_mac_usb.c:			RELEASE_NDIS_PACKET(pAd, pAd->MgmtRing.Cell[i].pNdisPacket, NDIS_STATUS_FAILURE);
+common/cmm_mac_usb.c:			pAd->MgmtRing.Cell[i].pNdisPacket = NULL;
+common/cmm_mac_usb.c:		PHT_TX_CONTEXT pHTTXContext = &(pAd->TxContext[acidx]);
+common/cmm_mac_usb.c:		NdisFreeSpinLock(&pAd->BulkOutLock[i]);
+common/cmm_mac_usb.c:	NdisFreeSpinLock(&pAd->BulkInLock);
+common/cmm_mac_usb.c:	NdisFreeSpinLock(&pAd->CmdRspLock);
+common/cmm_mac_usb.c:	NdisFreeSpinLock(&pAd->MLMEBulkOutLock);
+common/cmm_mac_usb.c:	NdisFreeSpinLock(&pAd->CmdQLock);
+common/cmm_mac_usb.c:	NdisFreeSpinLock(&pAd->GenericLock);
+common/cmm_mac_usb.c:		NdisFreeSpinLock(&pAd->TxContextQueueLock[i]);
+common/cmm_mac_usb.c:	NdisFreeSpinLock(&pAd->MacTabLock);
+common/cmm_mac_usb.c:		NdisFreeSpinLock(&pAd->BATable.BARecEntry[i].RxReRingLock);
+common/cmm_mac_usb.c:	PTX_CONTEXT			pNullContext   = &pAd->NullContext;
+common/cmm_mac_usb.c:	PTX_CONTEXT			pPsPollContext = &pAd->PsPollContext;
+common/cmm_mac_usb.c:	PCMD_RSP_CONTEXT	pCmdRspEventContext = &pAd->CmdRspEventContext;
+common/cmm_mac_usb.c:		PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
+common/cmm_mac_usb.c:		PTX_CONTEXT pMLMEContext = (PTX_CONTEXT)pAd->MgmtRing.Cell[i].AllocVa;
+common/cmm_mac_usb.c:		if (NULL != pAd->MgmtRing.Cell[i].pNdisPacket) 
+common/cmm_mac_usb.c:			RELEASE_NDIS_PACKET(pAd, pAd->MgmtRing.Cell[i].pNdisPacket, NDIS_STATUS_FAILURE);
+common/cmm_mac_usb.c:			pAd->MgmtRing.Cell[i].pNdisPacket = NULL;
+common/cmm_mac_usb.c:	if (pAd->MgmtDescRing.AllocVa)
+common/cmm_mac_usb.c:		os_free_mem(pAd, pAd->MgmtDescRing.AllocVa);
+common/cmm_mac_usb.c:		PHT_TX_CONTEXT pHTTXContext = &(pAd->TxContext[acidx]);
+common/cmm_mac_usb.c:	if (pAd->FragFrame.pFragPacket)
+common/cmm_mac_usb.c:		RELEASE_NDIS_PACKET(pAd, pAd->FragFrame.pFragPacket, NDIS_STATUS_SUCCESS);
+common/cmm_mac_usb.c:	PCMD_RSP_CONTEXT pCmdRspEventContext = &pAd->CmdRspEventContext;
+common/cmm_mac_usb.c:	pAd->PendingRx = 0;
+common/cmm_mac_usb.c:	pAd->NextRxBulkInReadIndex 	= 0;	/* Next Rx Read index*/
+common/cmm_mac_usb.c:	pAd->NextRxBulkInIndex		= 0 ; /*RX_RING_SIZE -1;  Rx Bulk pointer*/
+common/cmm_mac_usb.c:	pAd->NextRxBulkInPosition 	= 0;
+common/cmm_mac_usb.c:		PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
+common/cmm_mac_usb.c:	PTX_CONTEXT		pNullContext   = &(pAd->NullContext);
+common/cmm_mac_usb.c:	PTX_CONTEXT		pPsPollContext = &(pAd->PsPollContext);
+common/cmm_mac_usb.c:		InitializeQueueHeader(&pAd->TxSwQueue[acidx]);
+common/cmm_mac_usb.c:		pAd->NextBulkOutIndex[acidx] = acidx;
+common/cmm_mac_usb.c:		pAd->BulkOutPending[acidx] = FALSE; /* Buck Out control flag	*/
+common/cmm_mac_usb.c:			PHT_TX_CONTEXT	pHTTXContext = &(pAd->TxContext[acidx]);
+common/cmm_mac_usb.c:			pAd->BulkOutPending[acidx] = FALSE;
+common/cmm_mac_usb.c:		NdisZeroMemory(pAd->MgmtDescRing.AllocVa, pAd->MgmtDescRing.AllocSize);
+common/cmm_mac_usb.c:		RingBaseVa = pAd->MgmtDescRing.AllocVa;
+common/cmm_mac_usb.c:		pMgmtRing = &pAd->MgmtRing;
+common/cmm_mac_usb.c:			pMLMEContext = (PTX_CONTEXT) pAd->MgmtRing.Cell[i].AllocVa;
+common/cmm_mac_usb.c:		/*pAd->MgmtRing.TxSwFreeIdx = (MGMT_RING_SIZE - 1);*/
+common/cmm_mac_usb.c:		pAd->MgmtRing.TxSwFreeIdx = MGMT_RING_SIZE;
+common/cmm_mac_usb.c:		pAd->MgmtRing.TxCpuIdx = 0;
+common/cmm_mac_usb.c:		pAd->MgmtRing.TxDmaIdx = 0;
+common/cmm_mac_usb.c:	if (pAd->MgmtDescRing.AllocVa)
+common/cmm_mac_usb.c:		pMgmtRing = &pAd->MgmtRing;
+common/cmm_mac_usb.c:			pMLMEContext = (PTX_CONTEXT) pAd->MgmtRing.Cell[i].AllocVa;
+common/cmm_mac_usb.c:		os_free_mem(pAd, pAd->MgmtDescRing.AllocVa);
+common/cmm_mac_usb.c:		pAd->MgmtDescRing.AllocVa = NULL;
+common/cmm_mac_usb.c:	PTX_CONTEXT pNullContext   = &(pAd->NullContext);
+common/cmm_mac_usb.c:	PTX_CONTEXT pPsPollContext = &(pAd->PsPollContext);
+common/cmm_mac_usb.c:	PCMD_RSP_CONTEXT pCmdRspEventContext = &(pAd->CmdRspEventContext);
+common/cmm_mac_usb.c:			PHT_TX_CONTEXT	pHTTXContext = &(pAd->TxContext[acidx]);
+common/cmm_mac_usb.c:		pAd->MgmtDescRing.AllocSize = MGMT_RING_SIZE * sizeof(TX_CONTEXT);
+common/cmm_mac_usb.c:		os_alloc_mem(pAd, (PUCHAR *)(&pAd->MgmtDescRing.AllocVa), pAd->MgmtDescRing.AllocSize);
+common/cmm_mac_usb.c:		if (pAd->MgmtDescRing.AllocVa == NULL)
+common/cmm_mac_usb.c:			PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
+common/cmm_mac_usb.c:		NdisZeroMemory(&pAd->FragFrame, sizeof(FRAGMENT_FRAME));
+common/cmm_mac_usb.c:		pAd->FragFrame.pFragPacket =  RTMP_AllocateFragPacketBuffer(pAd, RX_BUFFER_NORMSIZE);
+common/cmm_mac_usb.c:		if (pAd->FragFrame.pFragPacket == NULL)
+common/cmm_mac_usb.c:	NdisAllocateSpinLock(pAd, &pAd->CmdQLock);	
+common/cmm_mac_usb.c:	NdisAcquireSpinLock(&pAd->CmdQLock);
+common/cmm_mac_usb.c:	RTInitializeCmdQ(&pAd->CmdQ);
+common/cmm_mac_usb.c:	NdisReleaseSpinLock(&pAd->CmdQLock);
+common/cmm_mac_usb.c:	NdisAllocateSpinLock(pAd, &pAd->MLMEBulkOutLock);
+common/cmm_mac_usb.c:	NdisAllocateSpinLock(pAd, &pAd->BulkInLock);
+common/cmm_mac_usb.c:	NdisAllocateSpinLock(pAd, &pAd->CmdRspLock);
+common/cmm_mac_usb.c:		NdisAllocateSpinLock(pAd, &pAd->BulkOutLock[num]);
+common/cmm_mac_usb.c:		NdisAllocateSpinLock(pAd, &pAd->TxContextQueueLock[num]);
+common/cmm_mac_usb.c:	NdisAllocateSpinLock(pAd, &pAd->GenericLock);
+common/cmm_mac_usb.c:	POS_COOKIE			pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_mac_usb.c:	PCMD_RSP_CONTEXT pCmdRspEventContext = &pAd->CmdRspEventContext;
+common/cmm_mac_usb.c:	/*InterlockedExchange(&pAd->PendingRx, 0);*/
+common/cmm_mac_usb.c:	pAd->PendingRx = 0;
+common/cmm_mac_usb.c:	pAd->NextRxBulkInReadIndex 	= 0;	/* Next Rx Read index*/
+common/cmm_mac_usb.c:	pAd->NextRxBulkInIndex		= 0 ; /*RX_RING_SIZE -1;  Rx Bulk pointer*/
+common/cmm_mac_usb.c:	pAd->NextRxBulkInPosition 	= 0;
+common/cmm_mac_usb.c:		PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
+common/cmm_mac_usb.c:		PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
+common/cmm_mac_usb.c:	PTX_CONTEXT		pNullContext   = &(pAd->NullContext);
+common/cmm_mac_usb.c:	PTX_CONTEXT		pPsPollContext = &(pAd->PsPollContext);
+common/cmm_mac_usb.c:	POS_COOKIE		pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_mac_usb.c:		InitializeQueueHeader(&pAd->TxSwQueue[acidx]);
+common/cmm_mac_usb.c:		pAd->NextBulkOutIndex[acidx] = acidx;
+common/cmm_mac_usb.c:		pAd->BulkOutPending[acidx] = FALSE; /* Buck Out control flag	*/
+common/cmm_mac_usb.c:			PHT_TX_CONTEXT	pHTTXContext = &(pAd->TxContext[acidx]);
+common/cmm_mac_usb.c:			pAd->BulkOutPending[acidx] = FALSE;
+common/cmm_mac_usb.c:		pAd->MgmtDescRing.AllocSize = MGMT_RING_SIZE * sizeof(TX_CONTEXT);
+common/cmm_mac_usb.c:		os_alloc_mem(pAd, (PUCHAR *)(&pAd->MgmtDescRing.AllocVa), pAd->MgmtDescRing.AllocSize);
+common/cmm_mac_usb.c:		if (pAd->MgmtDescRing.AllocVa == NULL)
+common/cmm_mac_usb.c:		NdisZeroMemory(pAd->MgmtDescRing.AllocVa, pAd->MgmtDescRing.AllocSize);
+common/cmm_mac_usb.c:		RingBaseVa     = pAd->MgmtDescRing.AllocVa;
+common/cmm_mac_usb.c:		pMgmtRing = &pAd->MgmtRing;
+common/cmm_mac_usb.c:			pMLMEContext = (PTX_CONTEXT) pAd->MgmtRing.Cell[i].AllocVa;
+common/cmm_mac_usb.c:		/*pAd->MgmtRing.TxSwFreeIdx = (MGMT_RING_SIZE - 1);*/
+common/cmm_mac_usb.c:		pAd->MgmtRing.TxSwFreeIdx = MGMT_RING_SIZE;
+common/cmm_mac_usb.c:		pAd->MgmtRing.TxCpuIdx = 0;
+common/cmm_mac_usb.c:		pAd->MgmtRing.TxDmaIdx = 0;
+common/cmm_mac_usb.c:	if (pAd->MgmtDescRing.AllocVa)
+common/cmm_mac_usb.c:		pMgmtRing = &pAd->MgmtRing;
+common/cmm_mac_usb.c:			pMLMEContext = (PTX_CONTEXT) pAd->MgmtRing.Cell[i].AllocVa;
+common/cmm_mac_usb.c:		os_free_mem(pAd, pAd->MgmtDescRing.AllocVa);
+common/cmm_mac_usb.c:		pAd->MgmtDescRing.AllocVa = NULL;
+common/cmm_mac_usb.c:		PHT_TX_CONTEXT pHTTxContext = &(pAd->TxContext[acidx]);
+common/cmm_mac_usb.c:/*	COUNTER_802_11	pCounter = &pAd->WlanCounters;*/
+common/cmm_mac_usb.c:		NdisAllocateSpinLock(pAd, &pAd->CmdQLock);	
+common/cmm_mac_usb.c:		NdisAcquireSpinLock(&pAd->CmdQLock);
+common/cmm_mac_usb.c:		RTInitializeCmdQ(&pAd->CmdQ);
+common/cmm_mac_usb.c:		NdisReleaseSpinLock(&pAd->CmdQLock);
+common/cmm_mac_usb.c:		NdisAllocateSpinLock(pAd, &pAd->MLMEBulkOutLock);
+common/cmm_mac_usb.c:		NdisAllocateSpinLock(pAd, &pAd->BulkInLock);
+common/cmm_mac_usb.c:		NdisAllocateSpinLock(pAd, &pAd->CmdRspLock);
+common/cmm_mac_usb.c:			NdisAllocateSpinLock(pAd, &pAd->BulkOutLock[num]);
+common/cmm_mac_usb.c:			NdisAllocateSpinLock(pAd, &pAd->TxContextQueueLock[num]);
+common/cmm_mac_usb.c:		NdisAllocateSpinLock(pAd, &pAd->GenericLock);
+common/cmm_mac_usb.c:		NdisZeroMemory(&pAd->FragFrame, sizeof(FRAGMENT_FRAME));
+common/cmm_mac_usb.c:		pAd->FragFrame.pFragPacket =  RTMP_AllocateFragPacketBuffer(pAd, RX_BUFFER_NORMSIZE);
+common/cmm_mac_usb.c:		if (pAd->FragFrame.pFragPacket == NULL)
+common/cmm_mac_usb.c:	PTX_CONTEXT			pNullContext   = &pAd->NullContext;
+common/cmm_mac_usb.c:	PTX_CONTEXT			pPsPollContext = &pAd->PsPollContext;
+common/cmm_mac_usb.c:		PRX_CONTEXT  pRxContext = &(pAd->RxContext[i]);
+common/cmm_mac_usb.c:		PTX_CONTEXT pMLMEContext = (PTX_CONTEXT)pAd->MgmtRing.Cell[i].AllocVa;
+common/cmm_mac_usb.c:		if (NULL != pAd->MgmtRing.Cell[i].pNdisPacket) 
+common/cmm_mac_usb.c:			RELEASE_NDIS_PACKET(pAd, pAd->MgmtRing.Cell[i].pNdisPacket, NDIS_STATUS_FAILURE);
+common/cmm_mac_usb.c:			pAd->MgmtRing.Cell[i].pNdisPacket = NULL;
+common/cmm_mac_usb.c:	if (pAd->MgmtDescRing.AllocVa)
+common/cmm_mac_usb.c:		os_free_mem(pAd, pAd->MgmtDescRing.AllocVa);
+common/cmm_mac_usb.c:		PHT_TX_CONTEXT pHTTXContext = &(pAd->TxContext[acidx]);
+common/cmm_mac_usb.c:	if (pAd->FragFrame.pFragPacket)
+common/cmm_mac_usb.c:		RELEASE_NDIS_PACKET(pAd, pAd->FragFrame.pFragPacket, NDIS_STATUS_SUCCESS);
+common/cmm_mac_usb.c:		NdisFreeSpinLock(&pAd->BulkOutLock[i]);
+common/cmm_mac_usb.c:	NdisFreeSpinLock(&pAd->BulkInLock);
+common/cmm_mac_usb.c:	NdisFreeSpinLock(&pAd->CmdRspLock);
+common/cmm_mac_usb.c:	NdisFreeSpinLock(&pAd->MLMEBulkOutLock);
+common/cmm_mac_usb.c:	NdisFreeSpinLock(&pAd->CmdQLock);
+common/cmm_mac_usb.c:	NdisFreeSpinLock(&pAd->GenericLock);
+common/cmm_mac_usb.c:		NdisFreeSpinLock(&pAd->TxContextQueueLock[i]);
+common/cmm_mac_usb.c:	StaMacReg0.field.Byte0 = pAd->CurrentAddress[0];
+common/cmm_mac_usb.c:	StaMacReg0.field.Byte1 = pAd->CurrentAddress[1];
+common/cmm_mac_usb.c:	StaMacReg0.field.Byte2 = pAd->CurrentAddress[2];
+common/cmm_mac_usb.c:	StaMacReg0.field.Byte3 = pAd->CurrentAddress[3];
+common/cmm_mac_usb.c:	StaMacReg1.field.Byte4 = pAd->CurrentAddress[4];
+common/cmm_mac_usb.c:	StaMacReg1.field.Byte5 = pAd->CurrentAddress[5];
+common/cmm_mac_usb.c:			pAd->CurrentAddress[0], pAd->CurrentAddress[1], pAd->CurrentAddress[2],
+common/cmm_mac_usb.c:			pAd->CurrentAddress[3], pAd->CurrentAddress[4], pAd->CurrentAddress[5]));
+common/cmm_mac_usb.c:	BEACON_SYNC_STRUCT	*pBeaconSync = pAd->CommonCfg.pBeaconSync;
+common/cmm_mac_usb.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/cmm_mac_usb.c:	if ((apidx < pAd->ApCfg.BssidNum) && (apidx < MAX_MBSSID_NUM(pAd)))
+common/cmm_mac_usb.c:		bcn_idx = pAd->ApCfg.MBSSID[apidx].BcnBufIdx;
+common/cmm_mac_usb.c:		pBeaconFrame = (PUCHAR) pAd->ApCfg.MBSSID[apidx].BeaconBuf;
+common/cmm_mac_usb.c:		bBcnReq = BeaconTransmitRequired(pAd, apidx, &pAd->ApCfg.MBSSID[apidx]);
+common/cmm_mac_usb.c:			RTMP_CHIP_UPDATE_BEACON(pAd, pAd->BeaconOffset[bcn_idx] + i, 0x00, 4);
+common/cmm_mac_usb.c:		ptr = (PUCHAR)&pAd->BeaconTxWI;
+common/cmm_mac_usb.c:		if (NdisEqualMemory(pBeaconSync->BeaconTxWI[bcn_idx], &pAd->BeaconTxWI, TXWISize) == FALSE)
+common/cmm_mac_usb.c:			NdisMoveMemory(pBeaconSync->BeaconTxWI[bcn_idx], &pAd->BeaconTxWI, TXWISize);
+common/cmm_mac_usb.c:				RTMP_CHIP_UPDATE_BEACON(pAd, pAd->BeaconOffset[bcn_idx] + i, longValue, 4);
+common/cmm_mac_usb.c:				RTMP_CHIP_UPDATE_BEACON(pAd, pAd->BeaconOffset[bcn_idx] + TXWISize + i, longValue, 2);
+common/cmm_mac_usb.c:			ptr = (PUCHAR) (pAd->ApCfg.MBSSID[apidx].BeaconBuf + pAd->ApCfg.MBSSID[apidx].TimIELocationInBeacon);
+common/cmm_mac_usb.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/cmm_mac_usb.c:	pBeaconSync = pAd->CommonCfg.pBeaconSync;
+common/cmm_mac_usb.c:			NumOfBcn = pAd->ApCfg.BssidNum + MAX_MESH_NUM;
+common/cmm_mac_usb.c:		RTMPCancelTimer(&pAd->CommonCfg.BeaconUpdateTimer, &Cancelled);
+common/cmm_mac_usb.c:				RTMP_CHIP_UPDATE_BEACON(pAd, pAd->BeaconOffset[i] + offset, 0x00, 4);
+common/cmm_mac_usb.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/cmm_mac_usb.c:	pBeaconSync = pAd->CommonCfg.pBeaconSync;
+common/cmm_mac_usb.c:			NumOfBcn = pAd->ApCfg.BssidNum + MAX_MESH_NUM;
+common/cmm_mac_usb.c:					CapabilityInfoLocationInBeacon = pAd->ApCfg.MBSSID[apidx].CapabilityInfoLocationInBeacon;
+common/cmm_mac_usb.c:					TimIELocationInBeacon = pAd->ApCfg.MBSSID[apidx].TimIELocationInBeacon;
+common/cmm_mac_usb.c:					CapabilityInfoLocationInBeacon = pAd->ApCfg.MBSSID[apidx].CapabilityInfoLocationInBeacon;
+common/cmm_mac_usb.c:					TimIELocationInBeacon = pAd->ApCfg.MBSSID[apidx].TimIELocationInBeacon;
+common/cmm_mac_usb.c:		pAd->CommonCfg.BeaconUpdateTimer.Repeat = TRUE;
+common/cmm_mac_usb.c:		pAd->CommonCfg.BeaconAdjust = 0;
+common/cmm_mac_usb.c:		pAd->CommonCfg.BeaconFactor = 0xffffffff / (pAd->CommonCfg.BeaconPeriod << 10);
+common/cmm_mac_usb.c:		pAd->CommonCfg.BeaconRemain = (0xffffffff % (pAd->CommonCfg.BeaconPeriod << 10)) + 1;
+common/cmm_mac_usb.c:									pAd->CommonCfg.BeaconFactor, pAd->CommonCfg.BeaconRemain));
+common/cmm_mac_usb.c:		RTMPSetTimer(&pAd->CommonCfg.BeaconUpdateTimer, 10 /*pAd->CommonCfg.BeaconPeriod*/);
+common/cmm_mac_usb.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+common/cmm_mac_usb.c:	os_alloc_mem(pAd, (PUCHAR *)(&pAd->CommonCfg.pBeaconSync), sizeof(BEACON_SYNC_STRUCT));
+common/cmm_mac_usb.c:	if (pAd->CommonCfg.pBeaconSync)
+common/cmm_mac_usb.c:		pBeaconSync = pAd->CommonCfg.pBeaconSync;
+common/cmm_mac_usb.c:		/*RTMPInitTimer(pAd, &pAd->CommonCfg.BeaconUpdateTimer, GET_TIMER_FUNCTION(BeaconUpdateExec), pAd, TRUE);*/
+common/cmm_mac_usb.c:	os_free_mem(pAd, pAd->CommonCfg.pBeaconSync);
+common/cmm_mac_usb.c:	if (pAd->CommonCfg.pBeaconSync)
+common/cmm_mac_usb.c:		pBeaconSync = pAd->CommonCfg.pBeaconSync;
+common/cmm_mac_usb.c:		RTMPCancelTimer(&pAd->CommonCfg.BeaconUpdateTimer, &Cancelled);
+common/cmm_mac_usb.c:		os_free_mem(pAd, pAd->CommonCfg.pBeaconSync);
+common/cmm_mac_usb.c:		pAd->CommonCfg.pBeaconSync = NULL;
+common/cmm_mac_usb.c:	if (pAd->CommonCfg.IsUpdateBeacon==TRUE)
+common/cmm_mac_usb.c:			|| (pAd->VifNextMode == RT_CMD_80211_IFTYPE_AP)	
+common/cmm_mac_usb.c:			BEACON_SYNC_STRUCT *pBeaconSync = pAd->CommonCfg.pBeaconSync;
+common/cmm_mac_usb.c:			if (pAd->ApCfg.DtimCount == 0 && pBeaconSync->DtimBitOn)
+common/cmm_mac_usb.c:				pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_mac_usb.c:		BeaconRemain = (0xffffffff % (pAd->CommonCfg.BeaconPeriod << 10)) + 1;
+common/cmm_mac_usb.c:	period2US = (pAd->CommonCfg.BeaconPeriod << 10);
+common/cmm_mac_usb.c:	remain_high = pAd->CommonCfg.BeaconRemain * tsfTime_a.u.HighPart;
+common/cmm_mac_usb.c:	remain_low = tsfTime_a.u.LowPart % (pAd->CommonCfg.BeaconPeriod << 10);
+common/cmm_mac_usb.c:	remain = (remain_high + remain_low)%(pAd->CommonCfg.BeaconPeriod << 10);
+common/cmm_mac_usb.c:	delta = (pAd->CommonCfg.BeaconPeriod << 10) - remain;
+common/cmm_mac_usb.c:		pAd->CommonCfg.BeaconUpdateTimer.TimerValue = 100;
+common/cmm_mac_usb.c:		pAd->CommonCfg.IsUpdateBeacon=FALSE;
+common/cmm_mac_usb.c:		pAd->CommonCfg.BeaconUpdateTimer.TimerValue = delta2MS + 10;
+common/cmm_mac_usb.c:		pAd->CommonCfg.IsUpdateBeacon=TRUE;
+common/cmm_mac_usb.c:		if ((pAd->CommonCfg.Channel > 14)
+common/cmm_mac_usb.c:			&& (pAd->CommonCfg.bIEEE80211H == 1)
+common/cmm_mac_usb.c:			&& (pAd->Dot11_H.RDMode == RD_SWITCHING_MODE))
+common/cmm_mac_usb.c:	pAd->StaCfg.SavedPMKNum = 0;
+common/cmm_mac_usb.c:	RTMPZeroMemory(pAd->StaCfg.SavedPMK, (PMKID_NO * sizeof(BSSID_INFO)));
+common/cmm_mac_usb.c:				COPY_MAC_ADDR(&DisReq.Addr, pAd->CommonCfg.Bssid);
+common/cmm_mac_usb.c:		BssTableInit(&pAd->ScanTab);
+common/cmm_mac_usb.c:	if (pAd->CommonCfg.CentralChannel)
+common/cmm_mac_usb.c:		AsicTurnOffRFClk(pAd, pAd->CommonCfg.CentralChannel);
+common/cmm_mac_usb.c:		AsicTurnOffRFClk(pAd, pAd->CommonCfg.Channel);
+common/cmm_mac_usb.c:	if((pAd->PendingRx > 0) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)))
+common/cmm_mac_usb.c:		pAd->PendingRx = 0;
+common/cmm_mac_usb.c:	RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
+common/cmm_mac_usb.c:	POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_mac_usb.c:		//pAd->hw_cfg.cent_ch = pAd->CommonCfg.CentralChannel;
+common/cmm_mac_usb.c:		//AsicSwitchChannel(pAd, pAd->hw_cfg.cent_ch, FALSE);
+common/cmm_mac_usb.c:		//AsicLockChannel(pAd, pAd->hw_cfg.cent_ch);
+common/cmm_mac_usb.c:		if (pAd->StaCfg.PSPXlink)
+common/cmm_mac_usb.c:		RTMP_SEM_EVENT_WAIT(&pAd->reg_atomic, ret);
+common/cmm_mac_usb.c:		RTMP_SEM_EVENT_UP(&pAd->reg_atomic);
+common/cmm_mac_usb.c:	AsicWOWSendNullFrame(pAd, pAd->CommonCfg.TxRate, (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) ? TRUE:FALSE));
+common/cmm_mac_usb.c:	AsicSendCommandToMcu(pAd, 0x33, 0xff, pAd->WOW_Cfg.nSelectedGPIO, pAd->WOW_Cfg.nDelay, FALSE);   
+common/cmm_mac_usb.c:	Value |= (pAd->WOW_Cfg.nHoldTime << 24);
+common/cmm_mac_usb.c:	DBGPRINT(RT_DEBUG_OFF, ("Send WOW enable cmd (%d/%d/%d)\n", pAd->WOW_Cfg.nDelay, pAd->WOW_Cfg.nSelectedGPIO, pAd->WOW_Cfg.nHoldTime));
+common/cmm_mac_usb.c:    DBGPRINT(RT_DEBUG_OFF, ("MCU back to normal mode (%d/%d)\n", pAd->WOW_Cfg.nDelay, pAd->WOW_Cfg.nSelectedGPIO));
+common/rt_os_util.c:	    DBGPRINT(RT_DEBUG_TRACE, ("pAd->StaCfg.ReqVarIELen > MAX_CUSTOM_LEN\n"));
+common/rt_os_util.c:		DBGPRINT(RT_DEBUG_TRACE, ("pAd->StaCfg.ReqVarIELen + 17 > MAX_CUSTOM_LEN\n"));
+common/cmm_cfg.c:	        NdisMoveMemory(&macAddr[0], pAd->ApCfg.ApCliTab[apidx].CurrentAddress, MAC_ADDR_LEN);
+common/cmm_cfg.c:		NdisMoveMemory(&macAddr[0], pAd->ApCfg.MBSSID[apidx].Bssid, MAC_ADDR_LEN);
+common/cmm_cfg.c:		NdisMoveMemory(&macAddr[0], pAd->CurrentAddress, MAC_ADDR_LEN);
+common/cmm_cfg.c:		NdisMoveMemory(&macAddr[0], pAd->P2PCurrentAddress, MAC_ADDR_LEN);
+common/cmm_cfg.c:		NdisMoveMemory(&macAddr[0], pAd->ApCfg.ApCliTab[apidx].CurrentAddress, MAC_ADDR_LEN);
+common/cmm_cfg.c:        Set Country Region to pAd->CommonCfg.CountryRegion.
+common/cmm_cfg.c:		pCountryRegion = &pAd->CommonCfg.CountryRegion;
+common/cmm_cfg.c:		pCountryRegion = &pAd->CommonCfg.CountryRegionForABand;
+common/cmm_cfg.c:	if ((WMODE_CAP_5G(wmode) && (!PHY_CAP_5G(pAd->chipCap.phy_caps))) ||
+common/cmm_cfg.c:		(WMODE_CAP_2G(wmode) && (!PHY_CAP_2G(pAd->chipCap.phy_caps))) ||
+common/cmm_cfg.c:				BAND_STR[pAd->chipCap.phy_caps & 0x3]));
+common/cmm_cfg.c:	if (wmode_band_equal(pAd->CommonCfg.PhyMode, wmode) == TRUE)
+common/cmm_cfg.c:	pAd->CommonCfg.PhyMode = wmode;
+common/cmm_cfg.c:	pAd->CommonCfg.cfg_wmode = wmode;
+common/cmm_cfg.c:	for(idx = 0; idx < pAd->ApCfg.BssidNum; idx++) {
+common/cmm_cfg.c:		wdev = &pAd->ApCfg.MBSSID[idx];
+common/cmm_cfg.c:				BAND_STR[pAd->chipCap.phy_caps & 0x3]));
+common/cmm_cfg.c:	if (pAd->ApCfg.BssidNum > 1)
+common/cmm_cfg.c:		/* pAd->CommonCfg.PhyMode = maximum capability of all MBSS */
+common/cmm_cfg.c:		if (wmode_band_equal(pAd->CommonCfg.PhyMode, wmode) == TRUE)
+common/cmm_cfg.c:			for(IdBss=0; IdBss<pAd->ApCfg.BssidNum; IdBss++)
+common/cmm_cfg.c:				pAd->ApCfg.MBSSID[IdBss].PhyMode = wmode;
+common/cmm_cfg.c:	pAd->CommonCfg.PhyMode = wmode;
+common/cmm_cfg.c:	pAd->CommonCfg.cfg_wmode = wmode;
+common/cmm_cfg.c:		pAd->CommonCfg.bUseShortSlotTime = TRUE;
+common/cmm_cfg.c:		pAd->CommonCfg.bUseShortSlotTime = FALSE;
+common/cmm_cfg.c:		AtoH(arg, &pAd->CurrentAddress[i], 1);
+common/cmm_cfg.c:	pAd->bLocalAdminMAC = TRUE;
+common/cmm_cfg.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_cfg.c:	POS_COOKIE pObj = (POS_COOKIE)pAd->OS_Cookie;
+common/cmm_cfg.c:			*ppNetDev = (VOID *)(pAd->net_dev);
+common/cmm_cfg.c:			pAd->net_dev = pData;
+common/cmm_cfg.c:			pAd->ApCfg.MBSSID[MAIN_MBSSID].MSSIDDev = pData;
+common/cmm_cfg.c:			*(ULONG *)pData = pAd->OpMode;
+common/cmm_cfg.c:			pList->pMlmeTask = &pAd->mlmeTask;
+common/cmm_cfg.c:			pList->pTimerTask = &pAd->timerTask;
+common/cmm_cfg.c:			pList->pCmdQTask = &pAd->cmdQTask;
+common/cmm_cfg.c:			pList->pWscTask = &pAd->wscTask;
+common/cmm_cfg.c:			RTMP_OS_IRQ_RELEASE(pAd, pAd->net_dev);
+common/cmm_cfg.c:					COPY_MAC_ADDR(DisReq.Addr, pAd->CommonCfg.Bssid);
+common/cmm_cfg.c:					pAd->MlmeAux.AutoReconnectSsidLen= 32;
+common/cmm_cfg.c:					NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen);
+common/cmm_cfg.c:					pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_DISASSOC;
+common/cmm_cfg.c:				RtmpOSWrielessEventSend(pAd->net_dev, RT_WLAN_EVENT_CGIWAP, -1, NULL, NULL, 0);
+common/cmm_cfg.c:			*(UCHAR *)pData = (UCHAR)pAd->WOW_Cfg.bEnable;
+common/cmm_cfg.c:			if (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED)
+common/cmm_cfg.c:				NdisCopyMemory(pData, pAd->MlmeAux.Bssid, 6);
+common/cmm_cfg.c:			*(ULONG *)pData = pAd->CommonCfg.Channel;
+common/cmm_cfg.c:			*(ULONG *)pData = pAd->Antenna.field.RxPath;
+common/cmm_cfg.c:			*(ULONG *)pData = pAd->ChannelListNum;
+common/cmm_cfg.c:			for (i = 1; i <= pAd->ChannelListNum; i++)
+common/cmm_cfg.c:				*pChannel = pAd->ChannelList[i-1].Channel;
+common/cmm_cfg.c:			for (i = 1; i <= pAd->ChannelListNum; i++)
+common/cmm_cfg.c:				MAP_CHANNEL_ID_TO_KHZ(pAd->ChannelList[i-1].Channel, m);
+common/cmm_cfg.c:           pAd->CommonCfg.DfsType = MAX_RD_REGION;
+common/cmm_cfg.c:			pAd->NumberOfPipes = pConfig->NumberOfPipes;
+common/cmm_cfg.c:			pAd->BulkInMaxPacketSize = pConfig->BulkInMaxPacketSize;
+common/cmm_cfg.c:			pAd->BulkOutMaxPacketSize = pConfig->BulkOutMaxPacketSize;
+common/cmm_cfg.c:				pAd->BulkOutEpAddr[i] = pConfig->BulkOutEpAddr[i];
+common/cmm_cfg.c:				DBGPRINT(RT_DEBUG_OFF, ("%s():pAd->BulkOutEpAddr=0x%x\n", __FUNCTION__, pAd->BulkOutEpAddr[i]));
+common/cmm_cfg.c:				pAd->BulkInEpAddr[i] = pConfig->BulkInEpAddr[i];
+common/cmm_cfg.c:			pAd->config = pConfig->pConfig;
+common/cmm_cfg.c:			pAd->PM_FlgSuspend = 1;
+common/cmm_cfg.c:			pAd->PM_FlgSuspend = 0;
+common/cmm_cfg.c:			os_alloc_mem(NULL, (UCHAR **)&(pAd->pDirectpathCb), sizeof(PPA_DIRECTPATH_CB));
+common/cmm_cfg.c:			if (ppa_hook_directpath_register_dev_fn && pAd->PPAEnable==TRUE) 
+common/cmm_cfg.c:				status=ppa_hook_directpath_register_dev_fn(&pAd->g_if_id, pAd->net_dev, NULL, 0);
+common/cmm_cfg.c:				DBGPRINT(RT_DEBUG_TRACE, ("unregister PPA:g_if_id=%d status=%d\n",pAd->g_if_id,status));
+common/cmm_cfg.c:			os_free_mem(NULL, pAd->pDirectpathCb);
+common/cmm_cfg.c:				if (pInfConf->rt28xx_open(pAd->net_dev) != 0)
+common/cmm_cfg.c:				pAd->ApCfg.BssidNum = 1;
+common/cmm_cfg.c:				pAd->MacTab.MsduLifeTime = 20; /* default 5 seconds */
+common/cmm_cfg.c:				pAd->ApCfg.MBSSID[MAIN_MBSSID].bBcnSntReq = TRUE;
+common/cmm_cfg.c:				pInfConf->rt28xx_close(pAd->net_dev);
+common/cmm_cfg.c:			*(ULONG *)pData = pAd->infType;
+common/cmm_cfg.c:				pStats->pStats = pAd->stats;
+common/cmm_cfg.c:				if(pAd->OpMode == OPMODE_STA)
+common/cmm_cfg.c:					pStats->rx_packets = pAd->WlanCounters.ReceivedFragmentCount.QuadPart;
+common/cmm_cfg.c:					pStats->tx_packets = pAd->WlanCounters.TransmittedFragmentCount.QuadPart;
+common/cmm_cfg.c:					pStats->rx_bytes = pAd->RalinkCounters.ReceivedByteCount;
+common/cmm_cfg.c:					pStats->tx_bytes = pAd->RalinkCounters.TransmittedByteCount;
+common/cmm_cfg.c:					pStats->rx_errors = pAd->Counters8023.RxErrors;
+common/cmm_cfg.c:					pStats->tx_errors = pAd->Counters8023.TxErrors;
+common/cmm_cfg.c:					pStats->multicast = pAd->WlanCounters.MulticastReceivedFrameCount.QuadPart;   /* multicast packets received*/
+common/cmm_cfg.c:					pStats->collisions = pAd->Counters8023.OneCollision + pAd->Counters8023.MoreCollisions;  /* Collision packets*/
+common/cmm_cfg.c:					pStats->rx_over_errors = pAd->Counters8023.RxNoBuffer;                   /* receiver ring buff overflow*/
+common/cmm_cfg.c:					pStats->rx_crc_errors = 0;/*pAd->WlanCounters.FCSErrorCount;      recved pkt with crc error*/
+common/cmm_cfg.c:					pStats->rx_frame_errors = pAd->Counters8023.RcvAlignmentErrors;          /* recv'd frame alignment error*/
+common/cmm_cfg.c:					pStats->rx_fifo_errors = pAd->Counters8023.RxNoBuffer;                   /* recv'r fifo overrun*/
+common/cmm_cfg.c:				else if(pAd->OpMode == OPMODE_AP)
+common/cmm_cfg.c:						if (pAd->ApCfg.MBSSID[index].MSSIDDev == (PNET_DEV)(pStats->pNetDev))
+common/cmm_cfg.c:					pStats->rx_packets = pAd->ApCfg.MBSSID[index].RxCount;
+common/cmm_cfg.c:					pStats->tx_packets = pAd->ApCfg.MBSSID[index].TxCount;
+common/cmm_cfg.c:					pStats->rx_bytes = pAd->ApCfg.MBSSID[index].ReceivedByteCount;
+common/cmm_cfg.c:					pStats->tx_bytes = pAd->ApCfg.MBSSID[index].TransmittedByteCount;
+common/cmm_cfg.c:					pStats->rx_errors = pAd->ApCfg.MBSSID[index].RxErrorCount;
+common/cmm_cfg.c:					pStats->tx_errors = pAd->ApCfg.MBSSID[index].TxErrorCount;
+common/cmm_cfg.c:					pStats->multicast = pAd->ApCfg.MBSSID[index].mcPktsRx; /* multicast packets received */
+common/cmm_cfg.c:			pStats->pStats = pAd->iw_stats;
+common/cmm_cfg.c:			if (pAd->OpMode == OPMODE_STA)
+common/cmm_cfg.c:					if ((ApCliIdx >= 0) && VALID_WCID(pAd->ApCfg.ApCliTab[ApCliIdx].MacTabWCID))
+common/cmm_cfg.c:						pMacEntry = &pAd->MacTab.Content[pAd->ApCfg.ApCliTab[ApCliIdx].MacTabWCID];
+common/cmm_cfg.c:				pStats->qual = ((pAd->Mlme.ChannelQuality * 12)/10 + 10);
+common/cmm_cfg.c:					pStats->qual = ((pAd->Mlme.ChannelQuality * 12)/10 + 10);
+common/cmm_cfg.c:					RTMPMaxRssi(pAd, pAd->StaCfg.RssiSample.AvgRssi0,
+common/cmm_cfg.c:									pAd->StaCfg.RssiSample.AvgRssi1,
+common/cmm_cfg.c:									pAd->StaCfg.RssiSample.AvgRssi2);
+common/cmm_cfg.c:						RTMPMaxRssi(pAd, pAd->StaCfg.RssiSample.AvgRssi0,
+common/cmm_cfg.c:										pAd->StaCfg.RssiSample.AvgRssi1,
+common/cmm_cfg.c:										pAd->StaCfg.RssiSample.AvgRssi2);
+common/cmm_cfg.c:			pStats->noise = RTMPMaxRssi(pAd, pAd->ApCfg.RssiSample.AvgRssi0,
+common/cmm_cfg.c:										pAd->ApCfg.RssiSample.AvgRssi1,
+common/cmm_cfg.c:										pAd->ApCfg.RssiSample.AvgRssi2) -
+common/cmm_cfg.c:										RTMPMinSnr(pAd, pAd->ApCfg.RssiSample.AvgSnr0,
+common/cmm_cfg.c:										pAd->ApCfg.RssiSample.AvgSnr1);
+common/cmm_cfg.c:			pStats->noise = RTMPMaxRssi(pAd, pAd->StaCfg.RssiSample.AvgRssi0,
+common/cmm_cfg.c:										pAd->StaCfg.RssiSample.AvgRssi1,
+common/cmm_cfg.c:										pAd->StaCfg.RssiSample.AvgRssi2) - 
+common/cmm_cfg.c:										RTMPMinSnr(pAd, pAd->StaCfg.RssiSample.AvgSnr0, 
+common/cmm_cfg.c:										pAd->StaCfg.RssiSample.AvgSnr1);
+common/cmm_cfg.c:				HtPhyMode = pAd->ApCfg.ApCliTab[pObj->ioctl_if].HTPhyMode;
+common/cmm_cfg.c:				HtPhyMode = pAd->ApCfg.MBSSID[pObj->ioctl_if].HTPhyMode;
+common/cmm_cfg.c:			pOS_cookie = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_cfg.c:                        pOS_cookie = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_cfg.c:			*ppOS_cookie = (VOID *)(pAd->OS_Cookie);
+common/cmm_cfg.c:			*(UCHAR *)pData = (pAd->MoreFlags & fASIC_CAP_CSO) ? 1:0;
+common/cmm_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/cmm_cfg.c:		pAd->StaCfg.bSkipAutoScanConn = TRUE;
+common/cmm_cfg.c:					pAd->RxAnt.Pair1PrimaryRxAnt, pAd->RxAnt.Pair1SecondaryRxAnt));
+common/cmm_cfg.c:							__FUNCTION__, pAd->RxAnt.Pair1PrimaryRxAnt, pAd->RxAnt.Pair1SecondaryRxAnt));
+common/cmm_cfg.c:					pAd->RxAnt.Pair1PrimaryRxAnt, pAd->RxAnt.Pair1SecondaryRxAnt));
+common/ee_efuse.c:	if( (pAd->chipCap.EFUSE_USAGE_MAP_END % 2) != 0)
+common/ee_efuse.c:		StartBlock = pAd->chipCap.EFUSE_USAGE_MAP_END-1; 
+common/ee_efuse.c:		StartBlock = pAd->chipCap.EFUSE_USAGE_MAP_END; 
+common/ee_efuse.c:	if( (pAd->chipCap.EFUSE_USAGE_MAP_START % 2) != 0)
+common/ee_efuse.c:		EndBlock = pAd->chipCap.EFUSE_USAGE_MAP_START-1; 
+common/ee_efuse.c:		EndBlock = pAd->chipCap.EFUSE_USAGE_MAP_START; 
+common/ee_efuse.c:				if (i != pAd->chipCap.EFUSE_USAGE_MAP_END)
+common/ee_efuse.c:					BlkNum = i-pAd->chipCap.EFUSE_USAGE_MAP_START+1;	
+common/ee_efuse.c:				if (i != (pAd->chipCap.EFUSE_USAGE_MAP_START-1))
+common/ee_efuse.c:					BlkNum = i-pAd->chipCap.EFUSE_USAGE_MAP_START;
+common/ee_efuse.c:		addr = pAd->chipCap.EFUSE_USAGE_MAP_START+BlkNum;
+common/ee_efuse.c:			addr = pAd->chipCap.EFUSE_USAGE_MAP_START+BlkNum;			
+common/ee_efuse.c:					if(i != pAd->chipCap.EFUSE_USAGE_MAP_END)
+common/ee_efuse.c:						BlkNum = i+1-pAd->chipCap.EFUSE_USAGE_MAP_START;
+common/ee_efuse.c:					if(i != (pAd->chipCap.EFUSE_USAGE_MAP_START-1))
+common/ee_efuse.c:						BlkNum = i-pAd->chipCap.EFUSE_USAGE_MAP_START;
+common/ee_efuse.c:	if (pAd->bUseEfuse == FALSE && pAd->bFroceEEPROMBuffer == FALSE)
+common/ee_efuse.c:	if (pAd->bUseEfuse == FALSE && pAd->bFroceEEPROMBuffer == FALSE)
+common/ee_efuse.c:	for(i =0; i<pAd->chipCap.EFUSE_USAGE_MAP_END/2; i++)
+common/ee_efuse.c:	if( (pAd->chipCap.EFUSE_USAGE_MAP_END % 2) != 0)
+common/ee_efuse.c:		StartBlock = pAd->chipCap.EFUSE_USAGE_MAP_END-1; 
+common/ee_efuse.c:		StartBlock = pAd->chipCap.EFUSE_USAGE_MAP_END; 
+common/ee_efuse.c:	if( (pAd->chipCap.EFUSE_USAGE_MAP_START % 2) != 0)
+common/ee_efuse.c:		EndBlock = pAd->chipCap.EFUSE_USAGE_MAP_START-1; 
+common/ee_efuse.c:		EndBlock = pAd->chipCap.EFUSE_USAGE_MAP_START; 
+common/ee_efuse.c:				if(i != pAd->chipCap.EFUSE_USAGE_MAP_END)
+common/ee_efuse.c:					BlkNum = i+1-pAd->chipCap.EFUSE_USAGE_MAP_START;
+common/ee_efuse.c:				if(i != (pAd->chipCap.EFUSE_USAGE_MAP_START-1))
+common/ee_efuse.c:					BlkNum = i-pAd->chipCap.EFUSE_USAGE_MAP_START;
+common/ee_efuse.c:		addr = pAd->chipCap.EFUSE_USAGE_MAP_START+BlkNum;
+common/ee_efuse.c:			addr = pAd->chipCap.EFUSE_USAGE_MAP_START+BlkNum;			
+common/ee_efuse.c:					if(i !=pAd->chipCap.EFUSE_USAGE_MAP_END)
+common/ee_efuse.c:						BlkNum = i+1-pAd->chipCap.EFUSE_USAGE_MAP_START;
+common/ee_efuse.c:					if(i != (pAd->chipCap.EFUSE_USAGE_MAP_START-1))
+common/ee_efuse.c:						BlkNum = i-pAd->chipCap.EFUSE_USAGE_MAP_START;
+common/ee_efuse.c:	if (pAd->bFroceEEPROMBuffer
+common/ee_efuse.c:			||pAd->bEEPROMFile
+common/ee_efuse.c:	    NdisMoveMemory(pValue, &(pAd->EEPROMImage[Offset]), 2);
+common/ee_efuse.c:    if (pAd->bFroceEEPROMBuffer
+common/ee_efuse.c:			||pAd->bEEPROMFile
+common/ee_efuse.c:        NdisMoveMemory(&(pAd->EEPROMImage[Offset]), &data, 2);
+common/ee_efuse.c:		pAd->EFuseTag = (value & 0xff);
+common/ee_efuse.c:				memset(pAd->EEPROMImage, 0x00, MAX_EEPROM_BIN_FILE_SIZE);
+common/ee_efuse.c:			retval =RtmpOSFileRead(srcf, (PSTRING)pAd->EEPROMImage, MAX_EEPROM_BIN_FILE_SIZE);
+common/ee_efuse.c:			RtmpOSFileWrite(srcf, (PSTRING)pAd->EEPROMImage,MAX_EEPROM_BIN_FILE_SIZE);
+common/ee_efuse.c:	if(!pAd->bUseEfuse)
+common/ee_efuse.c:	if( (pAd->chipCap.EFUSE_USAGE_MAP_START % 2) != 0)
+common/ee_efuse.c:		StartBlock = pAd->chipCap.EFUSE_USAGE_MAP_START-1; 
+common/ee_efuse.c:		StartBlock = pAd->chipCap.EFUSE_USAGE_MAP_START; 
+common/ee_efuse.c:	if( (pAd->chipCap.EFUSE_USAGE_MAP_END % 2) != 0)
+common/ee_efuse.c:		EndBlock = pAd->chipCap.EFUSE_USAGE_MAP_END-1; 
+common/ee_efuse.c:		EndBlock = pAd->chipCap.EFUSE_USAGE_MAP_END; 
+common/ee_efuse.c:			if(i != (pAd->chipCap.EFUSE_USAGE_MAP_START-1))
+common/ee_efuse.c:			if(i != pAd->chipCap.EFUSE_USAGE_MAP_END)
+common/ee_efuse.c:			if(i != pAd->chipCap.EFUSE_USAGE_MAP_END)
+common/ee_efuse.c:			if(i != (pAd->chipCap.EFUSE_USAGE_MAP_START-1))
+common/ee_efuse.c:	DBGPRINT(RT_DEBUG_ERROR, ("NVM is Efuse and its size =%x[%x-%x] \n",pAd->chipCap.EFUSE_USAGE_MAP_SIZE,pAd->chipCap.EFUSE_USAGE_MAP_START,pAd->chipCap.EFUSE_USAGE_MAP_END));
+common/ee_efuse.c:	if(EfuseFreeBlock > (pAd->chipCap.EFUSE_USAGE_MAP_SIZE-5))
+common/ee_efuse.c:		pAd->bFroceEEPROMBuffer = TRUE;
+common/ee_efuse.c:			if ( pAd->chipCap.EFUSE_DEFAULT_BIN != NULL )
+common/ee_efuse.c:				NdisMoveMemory(pAd->EEPROMImage, pAd->chipCap.EFUSE_DEFAULT_BIN, pAd->chipCap.EFUSE_DEFAULT_BIN_SIZE);
+common/ee_efuse.c:                                                pAd->EEPROMImage[EEPROM_FREQ_OFFSET] = (UCHAR)(FrequencyOffset & 0xFF);
+common/ee_efuse.c:                                                *(UINT16 *)(&pAd->EEPROMImage[EEPROM_TX0_TSSI_SLOPE]) = EfuseValue;
+common/ee_efuse.c:                                                *(UINT16 *)(&pAd->EEPROMImage[EEPROM_TX0_TSSI_OFFSET_GROUP1]) = EfuseValue;
+common/ee_efuse.c:                                                pAd->EEPROMImage[EEPROM_TX0_TSSI_OFFSET] = (UCHAR)(EfuseValue & 0xFF);;
+common/ee_efuse.c:                                                pAd->EEPROMImage[EEPROM_G_TARGET_POWER + 1] = (UCHAR)(EfuseValue >> 8);
+common/ee_efuse.c:		pAd->bFroceEEPROMBuffer = FALSE;
+common/ee_efuse.c:	DBGPRINT(RT_DEBUG_TRACE, ("NVM is Efuse and force to use EEPROM Buffer Mode=%x\n",pAd->bFroceEEPROMBuffer));
+common/ee_efuse.c:	//pAd->bFroceEEPROMBuffer = TRUE;
+common/ee_efuse.c:	pAd->bUseEfuse=FALSE;
+common/ee_efuse.c:	//pAd->bUseEfuse = ( (eFuseCtrl & 0x80000000) == 0x80000000) ? 1 : 0;
+common/ee_efuse.c:	pAd->bUseEfuse = TRUE;
+common/ps.c:			RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+common/ps.c:			RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+common/ps.c:	pMacEntry = &pAd->MacTab.Content[Aid];
+common/ps.c:		/*NdisAcquireSpinLock(&pAd->MacTabLock); */
+common/ps.c:		/*NdisAcquireSpinLock(&pAd->TxSwQueueLock); */
+common/ps.c:		RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+common/ps.c:				NumOfOldPsPkt = pAd->TxSwQueue[QID_AC_BE].Number;
+common/ps.c:				InsertTailQueueAc(pAd, pMacEntry, &pAd->TxSwQueue[QID_AC_BE], pEntry);
+common/ps.c:				if (NumOfOldPsPkt != pAd->TxSwQueue[QID_AC_BE].Number)
+common/ps.c:/*				if (pAd->TxSwQueue[QID_AC_BE].Number <= */
+common/ps.c:/*                    (pAd->PortCfg.TxQueueSize + (MAX_PACKETS_IN_PS_QUEUE>>1))) */
+common/ps.c:					InsertTailQueueAc(pAd, pMacEntry, &pAd->TxSwQueue[QID_AC_BE], pEntry);
+common/ps.c:		/*NdisReleaseSpinLock(&pAd->TxSwQueueLock); */
+common/ps.c:		/*NdisReleaseSpinLock(&pAd->MacTabLock); */
+common/ps.c:		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+common/ps.c:	pEntry = &pAd->MacTab.Content[Wcid];
+common/ps.c:	if (pAd->StaCfg.TdlsInfo.TdlsFlgIsKeepingActiveCountDown == TRUE)
+common/ps.c:		return (pAd->StaCfg.Psm == PWR_SAVE);
+common/ps.c:	if (pAd->StaCfg.TdlsInfo.TdlsPowerSaveActiveCountDown > 0)
+common/ps.c:		pAd->StaCfg.TdlsInfo.TdlsPowerSaveActiveCountDown --;
+common/ps.c:		if (pAd->StaCfg.TdlsInfo.TdlsPowerSaveActiveCountDown == 0)
+common/ps.c:	if (pAd->StaCfg.BssType == BSS_INFRA)
+common/ps.c:			if (pAd->StaCfg.bWindowsACCAMEnable == FALSE)
+common/ps.c:				pAd->StaCfg.WindowsPowerMode = Ndis802_11PowerModeMAX_PSP;
+common/ps.c:			pAd->StaCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeMAX_PSP;
+common/ps.c:			pAd->StaCfg.DefaultListenCount = 5;
+common/ps.c:			if (pAd->StaCfg.bWindowsACCAMEnable == FALSE)
+common/ps.c:				pAd->StaCfg.WindowsPowerMode = Ndis802_11PowerModeFast_PSP;
+common/ps.c:			pAd->StaCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeFast_PSP;
+common/ps.c:			pAd->StaCfg.DefaultListenCount = 3;
+common/ps.c:			if (pAd->StaCfg.bWindowsACCAMEnable == FALSE)
+common/ps.c:				pAd->StaCfg.WindowsPowerMode = Ndis802_11PowerModeLegacy_PSP;
+common/ps.c:			pAd->StaCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeLegacy_PSP;
+common/ps.c:			pAd->StaCfg.DefaultListenCount = 1;
+common/ps.c:			pAd->StaCfg.DefaultListenCount = 3;
+common/ps.c:			if (pAd->StaCfg.bWindowsACCAMEnable == FALSE)
+common/ps.c:				pAd->StaCfg.WindowsPowerMode = Ndis802_11PowerModeCAM;
+common/ps.c:			pAd->StaCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeCAM;
+common/ps.c:		RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE, FALSE);
+common/ps.c:		DBGPRINT(RT_DEBUG_TRACE, ("PSMode=%ld\n", pAd->StaCfg.WindowsPowerMode));
+common/p2p_packet.c:	*(pDest+3) = pAd->P2pCfg.GONoASchedule.Token;
+common/p2p_packet.c:	*(pDest+5) = pAd->P2pCfg.GONoASchedule.Count;
+common/p2p_packet.c:	RTMPMoveMemory((pDest+6), &pAd->P2pCfg.GONoASchedule.Duration, 4);
+common/p2p_packet.c:	RTMPMoveMemory((pDest+10), &pAd->P2pCfg.GONoASchedule.Interval, 4);
+common/p2p_packet.c:		pClient = &pAd->P2pTable.Client[i];
+common/p2p_packet.c:		PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:				/*RTMPMoveMemory(pDest + 7, pAd->CurrentAddress, 8); */
+common/p2p_packet.c:				*(pDest + 2) = pAd->CommonCfg.CountryCode[0];
+common/p2p_packet.c:				*(pDest + 3) = pAd->CommonCfg.CountryCode[1];
+common/p2p_packet.c:				*(pDest + 2) = pAd->CommonCfg.CountryCode[0];
+common/p2p_packet.c:				*(pDest + 3) = pAd->CommonCfg.CountryCode[1];
+common/p2p_packet.c:	for (i = 0; i < pAd->ChannelListNum; i++)
+common/p2p_packet.c:		CurRegClass = ChannelToClass(pAd->ChannelList[i].Channel, 1);
+common/p2p_packet.c:		*(pDest + pos) = pAd->ChannelList[i].Channel;
+common/p2p_packet.c:		if (i == pAd->ChannelListNum -1)
+common/p2p_packet.c:								&& (pAd->P2pTable.Client[idx].P2pClientState != P2PSTATE_DISCOVERY_CLIENT)
+common/p2p_packet.c:								&& (pAd->P2pTable.Client[idx].P2pClientState != P2PSTATE_CLIENT_DISCO_COMMAND))
+common/p2p_packet.c:								DBGPRINT(RT_DEBUG_TRACE, ("!P2P topology changed[P2pClientState = %d] when parsing P2P IE group info attribute. Delete from index : %d\n", pAd->P2pTable.Client[idx].P2pClientState, SmallerP2Pidx ));
+common/p2p_packet.c:									if ((pAd->P2pTable.Client[i].P2pClientState == P2PSTATE_PROVISION_COMMAND)
+common/p2p_packet.c:										|| (pAd->P2pTable.Client[i].P2pClientState == P2PSTATE_CONNECT_COMMAND)
+common/p2p_packet.c:										|| (pAd->P2pTable.Client[i].P2pClientState > P2PSTATE_DISCOVERY_CLIENT))
+common/p2p_packet.c:										P2pGroupTabDelete(pAd, i, pAd->P2pTable.Client[i].addr);
+common/p2p_packet.c:									if (pAd->P2pTable.ClientNumber == SmallerP2Pidx)
+common/p2p_packet.c:							if ((idx == P2P_NOT_FOUND) && ( pAd->P2pTable.ClientNumber < (MAX_P2P_GROUP_SIZE - 1))
+common/p2p_packet.c:								&& (!RTMPEqualMemory(pClient->DevAddr, pAd->P2pCfg.CurrentAddress, MAC_ADDR_LEN)))
+common/p2p_packet.c:								pAd->P2pTable.Client[idx].DevCapability = pClient->Capability;
+common/p2p_packet.c:								if (pAd->P2pTable.Client[idx].P2pClientState != P2PSTATE_CLIENT_DISCO_COMMAND)
+common/p2p_packet.c:									pAd->P2pTable.Client[idx].P2pClientState = P2PSTATE_DISCOVERY_CLIENT;
+common/p2p_packet.c:								pAd->P2pTable.Client[idx].ConfigMethod = *((PUSHORT) pClient->ConfigMethod);
+common/p2p_packet.c:								pAd->P2pTable.Client[idx].ConfigMethod = be2cpu16(pAd->P2pTable.Client[idx].ConfigMethod);
+common/p2p_packet.c:								RTMPMoveMemory(pAd->P2pTable.Client[idx].PrimaryDevType, pClient->PrimaryDevType, P2P_DEVICE_TYPE_LEN);
+common/p2p_packet.c:								pAd->P2pTable.Client[idx].NumSecondaryType = pClient->NumSecondaryType;
+common/p2p_packet.c:								RTMPMoveMemory(&pAd->P2pTable.Client[idx].DeviceName[0], &pClient->Octet[4+(pClient->NumSecondaryType*P2P_DEVICE_TYPE_LEN)], 32);
+common/p2p_packet.c:									pAd->P2pTable.Client[idx].DeviceNameLen = WscLen;
+common/p2p_packet.c:								pAd->P2pTable.Client[idx].MyGOIndex = P2pindex;
+common/p2p_packet.c:								pAd->P2pTable.Client[idx].DeviceName[pAd->P2pTable.Client[idx].DeviceNameLen] = 0x0;
+common/p2p_packet.c:									P2pSendWirelessEvent(pAd, RT_P2P_DEVICE_FIND, &pAd->P2pTable.Client[idx], NULL);
+common/p2p_packet.c:								if (pAd->P2pCfg.ConnectingIndex < MAX_P2P_GROUP_SIZE)
+common/p2p_packet.c:									if (RTMPEqualMemory(pAd->P2pTable.Client[idx].addr, &pAd->P2pCfg.ConnectingMAC[0], MAC_ADDR_LEN))
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:							brc = P2pHandleNoAAttri(pAd, &pAd->MacTab.Content[wcidindex], pPtrEid);
+common/p2p_packet.c:		if (P2P_TEST_BIT(pAd->P2pCfg.CTWindows, P2P_OPPS_BIT))
+common/p2p_packet.c:		if ((pAd->MacTab.Content[wcidindex].P2pInfo.NoADesc[0].bValid == TRUE))
+common/p2p_packet.c:			P2pStopNoA(pAd, &pAd->MacTab.Content[wcidindex]);
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:		if ((pP2PCtrl->P2PConnectState == P2P_ANY_IN_FORMATION_AS_GO) && (pAd->P2pTable.Client[index].P2pClientState != P2PSTATE_WAIT_GO_COMFIRM))
+common/p2p_packet.c:			DBGPRINT(RT_DEBUG_ERROR, (" P2P - Existing peer stay in another state. = %d. return.\n", pAd->P2pTable.Client[index].P2pClientState));
+common/p2p_packet.c:		PRT_P2P_CLIENT_ENTRY pP2pEntry = &pAd->P2pTable.Client[index];
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:			pAd->P2pTable.Client[index].ReTransmitCnt = 0;
+common/p2p_packet.c:			/*pAd->P2pTable.Client[index].P2pClientState = P2PSTATE_DISCOVERY; */
+common/p2p_packet.c:			pAd->P2pTable.Client[index].P2pClientState = P2PSTATE_DISCOVERY_CLIENT;
+common/p2p_packet.c:			DBGPRINT(RT_DEBUG_ERROR, (" P2P -  = %s \n", decodeP2PState(pAd->P2pCfg.P2PConnectState)));
+common/p2p_packet.c:		Channel = pAd->P2pCfg.ListenChannel;
+common/p2p_packet.c:		pP2pEntry = &pAd->P2pTable.Client[index];
+common/p2p_packet.c:		if ((pP2PCtrl->P2PConnectState == P2P_ANY_IN_FORMATION_AS_GO) && (pAd->P2pTable.Client[index].P2pClientState != P2PSTATE_SENT_GO_NEG_REQ))
+common/p2p_packet.c:			DBGPRINT(RT_DEBUG_ERROR, (" P2P -  Existing peer stay in another state. = %d. \n", pAd->P2pTable.Client[index].P2pClientState));
+common/p2p_packet.c:		PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:			pAd->P2pTable.Client[index].ReTransmitCnt = 0;
+common/p2p_packet.c:				RTMPMoveMemory(pAd->P2pTable.Client[index].DeviceName, DeviceName, 32);
+common/p2p_packet.c:				pAd->P2pTable.Client[index].DeviceNameLen = DeviceNameLen;
+common/p2p_packet.c:				pAd->P2pTable.Client[index].DeviceName[pAd->P2pTable.Client[index].DeviceNameLen] = 0x0;
+common/p2p_packet.c:				pP2pEntry = &pAd->P2pTable.Client[index];
+common/p2p_packet.c:				|| (pAd->P2pCfg.bSigmaEnabled == TRUE))
+common/p2p_packet.c:			pP2pEntry = &pAd->P2pTable.Client[index];
+common/p2p_packet.c:			P2pSendWirelessEvent(pAd, RT_P2P_DEVICE_FIND, &pAd->P2pTable.Client[index], pFrame->p80211Header.Addr2);
+common/p2p_packet.c:		P2pSendWirelessEvent(pAd, RT_P2P_RECV_GO_NEGO_REQ, &pAd->P2pTable.Client[index], pFrame->p80211Header.Addr2);
+common/p2p_packet.c:			/*UCHAR ClientState = pAd->P2pTable.Client[index].P2pClientState;*/
+common/p2p_packet.c:			COPY_MAC_ADDR(&P2pCmd.Addr[0], pAd->P2pTable.Client[index].addr);
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:		AsicSwitchChannel(pAd, pAd->P2pCfg.ListenChannel, FALSE);
+common/p2p_packet.c:		AsicLockChannel(pAd, pAd->P2pCfg.ListenChannel);
+common/p2p_packet.c:		pEntry = &pAd->P2pTable.Client[p2pClientIndex];
+common/p2p_packet.c:		RTMPMoveMemory(&pAd->P2pCfg.LatestP2pPublicFrame, pFrame, sizeof(P2P_SAVED_PUBLIC_FRAME));
+common/p2p_packet.c:		P2PSendDevDisRsp(pAd, P2PSTATUS_SUCCESS, pAd->P2pCfg.LatestP2pPublicFrame.Token, pAd->P2pCfg.LatestP2pPublicFrame.p80211Header.Addr2, &TotalFrameLen);
+common/p2p_packet.c:	pP2pEntry = &pAd->P2pTable.Client[index];
+common/p2p_packet.c:			if (pAd->P2pTable.Client[i].P2pClientState == P2PSTATE_CLIENT_DISCO_COMMAND)
+common/p2p_packet.c:		pAd->P2pTable.Client[ClientP2PIndex].P2pClientState = P2PSTATE_CONNECT_COMMAND;
+common/p2p_packet.c:		P2pStartGroupForm(pAd, pAd->P2pTable.Client[ClientP2PIndex].addr, ClientP2PIndex);
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:		P2pCheckInviteReq(pAd, (pAd->P2pTable.PerstEntry[index].MyRule == P2P_IS_GO), index, ChannelList, BssidAddr, OpChannel, Ssid, SsidLen, &RspStatus);
+common/p2p_packet.c:			if (pAd->P2pTable.PerstEntry[index].MyRule == P2P_IS_GO)
+common/p2p_packet.c:				/* pAd->StaCfg.WscControl.WscAPChannel = OpChannel; */
+common/p2p_packet.c:					pAd->P2pTable.Client[p2pindex].P2pClientState = P2PSTATE_WAIT_REVOKEINVITE_RSP_ACK;
+common/p2p_packet.c:				/*P2pGoNegoDone(pAd, pAd->PortList[pAd->P2pCfg.PortNumber], &pAd->P2pTable.Client[index]); */
+common/p2p_packet.c:				COPY_MAC_ADDR(pAd->ApCfg.ApCliTab[0].CfgApCliBssid, pP2PCtrl->Bssid);
+common/p2p_packet.c:		pAd->P2pTable.Client[p2pindex].Rule = P2P_IS_DEVICE;
+common/p2p_packet.c:		pAd->P2pTable.Client[p2pindex].P2pClientState = P2PSTATE_DISCOVERY;
+common/p2p_packet.c:		else if (IS_P2P_CONNECT_IDLE(pAd) || (pAd->P2pCfg.P2PConnectState == P2P_INVITE))
+common/p2p_packet.c:				RTMPZeroMemory(pAd->P2pTable.Client[p2pindex].Ssid, MAX_LEN_OF_SSID);
+common/p2p_packet.c:				RTMPMoveMemory(pAd->P2pTable.Client[p2pindex].Ssid, Ssid, SsidLen);
+common/p2p_packet.c:				pAd->P2pTable.Client[p2pindex].SsidLen = SsidLen;
+common/p2p_packet.c:				COPY_MAC_ADDR(pAd->P2pTable.Client[p2pindex].bssid, BssidAddr);
+common/p2p_packet.c:				COPY_MAC_ADDR(pAd->P2pTable.Client[p2pindex].InterfaceAddr, BssidAddr);
+common/p2p_packet.c:				pAd->P2pTable.Client[p2pindex].OpChannel = OpChannel;
+common/p2p_packet.c:				pAd->P2pTable.Client[p2pindex].ConfigMethod = ConfigMethod;
+common/p2p_packet.c:	P2pSendWirelessEvent(pAd, RT_P2P_RECV_INVITE_REQ, &pAd->P2pTable.Client[p2pindex], pFrame->p80211Header.Addr2);
+common/p2p_packet.c:			POS_COOKIE	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_packet.c:			pWscControl = &pAd->ApCfg.ApCliTab[0].WscControl;
+common/p2p_packet.c:			NdisMoveMemory(pP2PCtrl->Bssid, pAd->P2pTable.PerstEntry[index].Addr, MAC_ADDR_LEN);
+common/p2p_packet.c:							&pAd->P2pTable.PerstEntry[index].Profile,
+common/p2p_packet.c:			if ((pAd->CommonCfg.Channel != OpChannel) && (!INFRA_ON(pAd)))
+common/p2p_packet.c:				pAd->CommonCfg.Channel = OpChannel;
+common/p2p_packet.c:				AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+common/p2p_packet.c:				AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+common/p2p_packet.c:				pWscControl = &pAd->ApCfg.MBSSID[0].WscControl;
+common/p2p_packet.c:								  &pAd->P2pTable.PerstEntry[index].Profile,
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:			if (pAd->P2pTable.PerstEntry[index].MyRule == P2P_IS_GO)
+common/p2p_packet.c:				pP2pEntry = &pAd->P2pTable.Client[index];
+common/p2p_packet.c:				pWscControl = &pAd->ApCfg.MBSSID[0].WscControl;
+common/p2p_packet.c:								  &pAd->P2pTable.PerstEntry[index].Profile,
+common/p2p_packet.c:				POS_COOKIE	pObj = (POS_COOKIE) pAd->OS_Cookie;
+common/p2p_packet.c:				pWscControl = &pAd->ApCfg.ApCliTab[0].WscControl;
+common/p2p_packet.c:								&pAd->P2pTable.PerstEntry[index].Profile,
+common/p2p_packet.c:					pP2pEntry = &pAd->P2pTable.Client[index];
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:				RTMPZeroMemory(pAd->P2pTable.Client[p2pindex].Ssid, MAX_LEN_OF_SSID);
+common/p2p_packet.c:				RTMPMoveMemory(pAd->P2pTable.Client[p2pindex].Ssid, Ssid, SsidLen);
+common/p2p_packet.c:				COPY_MAC_ADDR(pAd->P2pTable.Client[p2pindex].bssid, DevAddr);
+common/p2p_packet.c:				COPY_MAC_ADDR(pAd->P2pTable.Client[p2pindex].InterfaceAddr, DevAddr);
+common/p2p_packet.c:				pAd->P2pTable.Client[p2pindex].SsidLen = SsidLen;
+common/p2p_packet.c:			pP2pEntry = &pAd->P2pTable.Client[p2pindex];
+common/p2p_packet.c:				RTMPMoveMemory(&pAd->P2pTable.Client[p2pindex].DeviceName[0], DeviceName, 32);
+common/p2p_packet.c:				pAd->P2pTable.Client[p2pindex].DeviceNameLen = DeviceNameLen;
+common/p2p_packet.c:				pAd->P2pTable.Client[p2pindex].DeviceName[pAd->P2pTable.Client[p2pindex].DeviceNameLen] = 0x0;
+common/p2p_packet.c:				P2pSendWirelessEvent(pAd, RT_P2P_RECV_PROV_REQ, &pAd->P2pTable.Client[p2pindex], pFrame->p80211Header.Addr2);
+common/p2p_packet.c:				P2P_SET_FLAG(&pAd->P2pTable.Client[p2pindex], P2PFLAG_PROVISIONED);
+common/p2p_packet.c:					RTMPMoveMemory(pP2PCtrl->Bssid, pAd->P2pTable.Client[p2pindex].bssid, MAC_ADDR_LEN);
+common/p2p_packet.c:					RTMPMoveMemory(pAd->P2pCfg.Bssid, pP2pEntry->bssid, MAC_ADDR_LEN);
+common/p2p_packet.c:					COPY_MAC_ADDR(pAd->P2pCfg.ConnectingMAC, pP2pEntry->addr);
+common/p2p_packet.c:					P2pSendWirelessEvent(pAd, RT_P2P_RECV_PROV_REQ, &pAd->P2pTable.Client[p2pindex], pFrame->p80211Header.Addr2);
+common/p2p_packet.c:					COPY_MAC_ADDR(pAd->P2pCfg.ConnectingMAC, pP2pEntry->addr);
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:		pAd->P2pTable.Client[p2pindex].ReTransmitCnt = 0;
+common/p2p_packet.c:	if (pAd->P2pCfg.GoFormCurrentState == P2P_WAIT_GO_FORM_PROV_RSP)
+common/p2p_packet.c:		pAd->P2pCfg.GoFormCurrentState = P2P_GO_FORM_IDLE;
+common/p2p_packet.c:	pP2pEntry = &pAd->P2pTable.Client[p2pindex];
+common/p2p_packet.c:	DBGPRINT(RT_DEBUG_ERROR, ("pAd->P2pCfg.Dpid = %d. %s.\n", pAd->P2pCfg.Dpid, decodeDpid(pAd->P2pCfg.Dpid)));
+common/p2p_packet.c:		P2P_SET_FLAG(&pAd->P2pTable.Client[p2pindex], P2PFLAG_PROVISIONED);
+common/p2p_packet.c:			DBGPRINT(RT_DEBUG_TRACE, ("Need setting first. Pop up setting windows. %d\n", pAd->P2pCfg.PopUpIndex));
+common/p2p_packet.c:			DBGPRINT(RT_DEBUG_TRACE, ("Decide to Join P2p group? when I am %s \n", decodeP2PState(pAd->P2pCfg.P2PConnectState)));
+common/p2p_packet.c:			if (pAd->P2pCfg.P2PConnectState == P2P_CONNECT_IDLE)
+common/p2p_packet.c:				DBGPRINT(RT_DEBUG_TRACE, ("P2p :connecting to GO with Bssid   %02x:%02x:%02x:%02x:%02x:%02x. \n", PRINT_MAC(pAd->P2pTable.Client[p2pindex].bssid)));
+common/p2p_packet.c:				DBGPRINT(RT_DEBUG_TRACE, ("P2p : its GroupCapability= %x.  DevCapability= %x. \n", pAd->P2pTable.Client[p2pindex].GroupCapability, pAd->P2pTable.Client[p2pindex].DevCapability));
+common/p2p_packet.c:				RTMPMoveMemory(pP2PCtrl->Bssid, pAd->P2pTable.Client[p2pindex].bssid, MAC_ADDR_LEN);
+common/p2p_packet.c:				RTMPMoveMemory(pAd->P2pCfg.Bssid, pP2pEntry->bssid, MAC_ADDR_LEN);
+common/p2p_packet.c:					pAddr = &pAd->P2pTable.Client[p2pindex].addr;
+common/p2p_packet.c:		P2pSendWirelessEvent(pAd, RT_P2P_RECV_PROV_RSP, &pAd->P2pTable.Client[p2pindex], pFrame->p80211Header.Addr2);
+common/p2p_packet.c:		P2pSendWirelessEvent(pAd, RT_P2P_RECV_PROV_RSP, &pAd->P2pTable.Client[p2pindex], pFrame->p80211Header.Addr2);
+common/p2p_packet.c:		PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:		pP2pEntry = &pAd->P2pTable.Client[idx];
+common/p2p_packet.c:				Channel = pAd->CommonCfg.Channel;
+common/p2p_packet.c:			RTMPMoveMemory(pP2PCtrl->SSID, &pAd->ApCfg.MBSSID[MAIN_MBSSID].Ssid, pAd->ApCfg.MBSSID[MAIN_MBSSID].SsidLen);
+common/p2p_packet.c:			pP2PCtrl->SSIDLen = pAd->ApCfg.MBSSID[MAIN_MBSSID].SsidLen;
+common/p2p_packet.c:				tmpGroupID[0] = 6 + pAd->ApCfg.MBSSID[MAIN_MBSSID].SsidLen;
+common/p2p_packet.c:				RTMPMoveMemory(&tmpGroupID[8], &pAd->ApCfg.MBSSID[MAIN_MBSSID].Ssid, pAd->ApCfg.MBSSID[MAIN_MBSSID].SsidLen);
+common/p2p_packet.c:			pAd->flg_p2p_OpStatusFlags = P2P_GO_UP;			
+common/p2p_packet.c:			pAd->flg_p2p_OpStatusFlags = P2P_CLI_UP;
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:		pP2pEntry = &pAd->P2pTable.Client[index];
+common/p2p_packet.c:			tmpGroupID[0] = 6 + pAd->ApCfg.MBSSID[MAIN_MBSSID].SsidLen;
+common/p2p_packet.c:			RTMPMoveMemory(&tmpGroupID[8], &pAd->ApCfg.MBSSID[MAIN_MBSSID].Ssid, pAd->ApCfg.MBSSID[MAIN_MBSSID].SsidLen);
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:	PRT_P2P_CONFIG pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:		Length = InsertP2PSubelmtTlv(pAd, SUBID_P2P_OP_CHANNEL, &pAd->CommonCfg.Channel, pDest);
+common/p2p_packet.c:		tmpGroupID[0] = 6 + pAd->ApCfg.MBSSID[MAIN_MBSSID].SsidLen;
+common/p2p_packet.c:		RTMPMoveMemory(&tmpGroupID[8], &pAd->ApCfg.MBSSID[MAIN_MBSSID].Ssid, pAd->ApCfg.MBSSID[MAIN_MBSSID].SsidLen);
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:		Length = InsertP2PSubelmtTlv(pAd, SUBID_P2P_OP_CHANNEL, &pAd->CommonCfg.Channel, pDest);
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:			Length = InsertP2PSubelmtTlv(pAd, SUBID_P2P_OP_CHANNEL, &pAd->CommonCfg.Channel, pDest);
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:			Length = InsertP2PSubelmtTlv(pAd, SUBID_P2P_OP_CHANNEL, &pAd->CommonCfg.Channel, pDest);
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:	/*PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;*/
+common/p2p_packet.c:		RTMPMoveMemory(pAd->P2pCfg.P2pManagedParm.ManageAPBSsid, Bssid, MAC_ADDR_LEN);
+common/p2p_packet.c:		pAd->P2pCfg.P2pManagedParm.APP2pMinorReason = 0;
+common/p2p_packet.c:		pAd->P2pCfg.P2pManagedParm.APUsageChannel = Channel ;
+common/p2p_packet.c:		pAd->P2pCfg.P2pManagedParm.APP2pManageability = P2pManageability;
+common/p2p_packet.c:	pAd->P2pCfg.P2pManagedParm.TotalNumOfP2pAttribute = TotalNumOfP2pAttribute;
+common/p2p_packet.c:		PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:	/*	if ((INFRA_ON(pAd) || ADHOC_ON(pAd)) && (pAd->OpMode == OPMODE_STA))
+common/p2p_packet.c:			SavedP2PTableNum = pAd->P2pTable.ClientNumber;
+common/p2p_packet.c:				pP2pEntry = &pAd->P2pTable.Client[index];
+common/p2p_packet.c:				DBGPRINT(RT_DEBUG_INFO, ("%s:: got ProbeResp.index = %d. statue = %s\n", __FUNCTION__, index, decodeP2PClientState(pAd->P2pTable.Client[index].P2pClientState)));
+common/p2p_packet.c:						if ((pAd->P2pTable.ClientNumber < 10)
+common/p2p_packet.c:							|| (((pAd->P2pTable.ClientNumber%4) == 3)&&(pAd->P2pTable.ClientNumber >= 10)))
+common/p2p_packet.c:					if ((pAd->P2pTable.ClientNumber < 10)
+common/p2p_packet.c:						|| (((pAd->P2pTable.ClientNumber % 4) == 3) && (pAd->P2pTable.ClientNumber >= 10)))
+common/p2p_packet.c:						/*P2pCmd.ConfigMethod = pAd->P2pTable.Client[index].ConfigMethod; */
+common/p2p_packet.c:					if (pAd->P2pCfg.ConnectingIndex < MAX_P2P_GROUP_SIZE)
+common/p2p_packet.c:						if (MAC_ADDR_EQUAL(pAd->P2pTable.Client[index].addr, &pAd->P2pCfg.ConnectingMAC[0]))
+common/p2p_packet.c:							DBGPRINT(RT_DEBUG_INFO, ("    ConenctIdx = %d, Addr : %02x:%02x:%02x:%02x:%02x:%02x\n", pAd->P2pCfg.ConnectingIndex, PRINT_MAC(pAd->P2pCfg.ConnectingMAC)));
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:	pMacEntry = &pAd->MacTab.Content[Elem->Wcid];
+common/p2p_packet.c:		if (P2P_TEST_BIT(pAd->P2pCfg.CTWindows, P2P_OPPS_BIT))
+common/p2p_packet.c:			pAd->P2pCfg.bKeepSlient = FALSE;
+common/p2p_packet.c:			if (((pAd->P2pCfg.CTWindows&0x7f) > 0) && ((pAd->P2pCfg.CTWindows&0x7f) < 80))
+common/p2p_packet.c:				RTMPSetTimer(&pAd->P2pCfg.P2pCTWindowTimer, (pAd->P2pCfg.CTWindows&0x7f));
+common/p2p_packet.c:		PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:		if (Channel != pAd->P2pCfg.ListenChannel)
+common/p2p_packet.c:			if (P2P_GO_ON(pAd) && (Channel == pAd->P2pCfg.GroupOpChannel))
+common/p2p_packet.c:					decodeP2PClientState(pAd->P2pTable.Client[index].P2pClientState), decodeP2PState(pAd->P2pCfg.P2PConnectState)));
+common/p2p_packet.c:				if ((pAd->P2pTable.Client[index].P2pClientState > P2PSTATE_DISCOVERY_UNKNOWN) || 
+common/p2p_packet.c:					(pAd->P2pCfg.P2PConnectState != P2P_CONNECT_IDLE))
+common/p2p_packet.c:					FALSE, NULL, &GroupCap, &DeviceCap, NULL, NULL, DevAddr, NULL, NULL, &SsidLen, Ssid, NULL, NULL, pAd->P2pTable.Client[index].PrimaryDevType, &pAd->P2pTable.Client[index].ListenChannel, &pAd->P2pTable.Client[index].OpChannel, NULL, &pAd->P2pTable.Client[index].GoIntent, &StatusCode, NULL, NULL);
+common/p2p_packet.c:				if (pAd->P2pTable.Client[index].P2pClientState == P2PSTATE_CONNECT_COMMAND)
+common/p2p_packet.c:					UCHAR ClientState = pAd->P2pTable.Client[index].P2pClientState;
+common/p2p_packet.c:					COPY_MAC_ADDR(&P2pCmd.Addr[0], pAd->P2pTable.Client[index].addr);
+common/p2p_packet.c:					/*P2pStartGroupForm(pAd, pAd->P2pTable.Client[index].addr, index); */
+common/p2p_packet.c:				else if (pAd->P2pTable.Client[index].P2pClientState == P2PSTATE_INVITE_COMMAND)
+common/p2p_packet.c:						perstindex = P2pPerstTabSearch(pAd, pAd->P2pTable.Client[index].addr, pAd->P2pTable.Client[index].bssid, pAd->P2pTable.Client[index].InterfaceAddr);
+common/p2p_packet.c:						bresult = P2pInvite(pAd, pAd->P2pTable.Client[index].addr, perstindex, index);
+common/p2p_packet.c:						bresult = P2pInvite(pAd, pAd->P2pTable.Client[index].addr, MAX_P2P_TABLE_SIZE, index);
+common/p2p_packet.c:						bresult = P2pInvite(pAd, pAd->P2pTable.Client[index].addr, MAX_P2P_TABLE_SIZE, index);
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:	*(pData + 4) = (pAd->P2pCfg.bConfiguredAP ? WSC_SCSTATE_CONFIGURED : WSC_SCSTATE_UNCONFIGURED);
+common/p2p_packet.c:	templen = AppendWSCTLV(WSC_ID_MANUFACTURER, pData, pAd->P2pCfg.Manufacturer, pAd->P2pCfg.ManufacturerLen);
+common/p2p_packet.c:	templen = AppendWSCTLV(WSC_ID_MODEL_NAME, pData, pAd->P2pCfg.ModelName, pAd->P2pCfg.ModelNameLen);
+common/p2p_packet.c:	templen = AppendWSCTLV(WSC_ID_MODEL_NUMBER, pData, pAd->P2pCfg.ModelNumber, pAd->P2pCfg.ModelNumberLen);
+common/p2p_packet.c:	templen = AppendWSCTLV(WSC_ID_SERIAL_NUM, pData, pAd->P2pCfg.SerialNumber, pAd->P2pCfg.SerialNumberLen);
+common/p2p_packet.c:	*((PUSHORT) (pData + 2)) = cpu2be16(pAd->P2pCfg.DeviceNameLen); 
+common/p2p_packet.c:	NdisMoveMemory((pData + 4), pAd->P2pCfg.DeviceName, pAd->P2pCfg.DeviceNameLen);
+common/p2p_packet.c:	pData += pAd->P2pCfg.DeviceNameLen + 4;
+common/p2p_packet.c:	Len   += pAd->P2pCfg.DeviceNameLen + 4;
+common/p2p_packet.c:		if (pAd->P2pCfg.Dpid  != DEV_PASS_ID_NOSPEC)
+common/p2p_packet.c:			*((PUSHORT) (pData + 4)) = cpu2be16(pAd->P2pCfg.Dpid);
+common/p2p_packet.c:		if ((pAd->ApCfg.MBSSID[BSS0].WscControl.WscSelReg) && (pAd->P2pCfg.Dpid == DEV_PASS_ID_PBC))
+common/p2p_packet.c:				*(pData + 4) = pAd->ApCfg.MBSSID[BSS0].WscControl.WscSelReg; /* AP */
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:	pReg = (PWSC_REG_DATA) &pAd->StaCfg.WscControl.RegData;
+common/p2p_packet.c:	*(pData + 4) = ((pAd->StaCfg.WscControl.WscConfMode == WSC_REGISTRAR) ? WSC_MSGTYPE_AP_WLAN_MGR : WSC_MSGTYPE_ENROLLEE_OPEN_8021X );
+common/p2p_packet.c:	*((PUSHORT) pData) = ((pAd->StaCfg.WscControl.WscConfMode == WSC_REGISTRAR) ? cpu2be16(WSC_ID_UUID_R) : cpu2be16(WSC_ID_UUID_E));
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:	NdisMoveMemory(tmpSupRate,pAd->CommonCfg.SupRate,pAd->CommonCfg.SupRateLen);
+common/p2p_packet.c:	tmpExtRateLen = pAd->CommonCfg.ExtRateLen;
+common/p2p_packet.c:	tmpExtRateLen = pAd->CommonCfg.ExtRateLen;
+common/p2p_packet.c:						  2,                          &pAd->CommonCfg.BeaconPeriod,
+common/p2p_packet.c:							1,								&pAd->StaCfg.RSNIE_Len,
+common/p2p_packet.c:							pAd->StaCfg.RSNIE_Len,			pAd->StaCfg.RSN_IE,
+common/p2p_packet.c:		if (pAd->CommonCfg.bAggregationCapable)
+common/p2p_packet.c:			if ((pAd->CommonCfg.bPiggyBackCapable))
+common/p2p_packet.c:			NdisMoveMemory(&HtCapability, &pAd->ApCfg.HtCapability, sizeof(HT_CAPABILITY_IE));
+common/p2p_packet.c:			if (pAd->Antenna.field.RxPath > 1)
+common/p2p_packet.c:			HtLen = sizeof(pAd->ApCfg.HtCapability);
+common/p2p_packet.c:			AddHtLen = sizeof(pAd->ApCfg.AddHTInfoIe);
+common/p2p_packet.c:			NdisMoveMemory(&AddHTInfo, &pAd->ApCfg.AddHTInfoIe, sizeof(ADD_HT_INFO_IE));
+common/p2p_packet.c:							 sizeof(NEW_EXT_CHAN_IE),          	&pAd->CommonCfg.NewExtChanOffset, 
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:	P2pCapability[0] = pAd->P2pCfg.P2pCapability[0];
+common/p2p_packet.c:	P2pCapability[1] = pAd->P2pCfg.P2pCapability[1];
+common/p2p_packet.c:			&& RTMPEqualMemory(pP2PCtrl->Bssid, pAd->P2pCfg.P2pManagedParm.ManageAPBSsid, MAC_ADDR_LEN))
+common/p2p_packet.c:			DBGPRINT(RT_DEBUG_TRACE, ("pAd->P2pCfg.P2pManagedParm.APP2pManageability = %x \n",	pAd->P2pCfg.P2pManagedParm.APP2pManageability));
+common/p2p_packet.c:			if ((pAd->P2pCfg.P2pManagedParm.APP2pManageability != 0xff)
+common/p2p_packet.c:				&& (P2P_TEST_BIT(pAd->P2pCfg.P2pManagedParm.APP2pManageability, P2PMANAGED_ENABLE_BIT))
+common/p2p_packet.c:				&& (!P2P_TEST_BIT(pAd->P2pCfg.P2pManagedParm.APP2pManageability, P2PMANAGED_ICS_ENABLE_BIT)))
+common/p2p_packet.c:			pBuf = &pAd->CommonCfg.Channel;
+common/p2p_packet.c:				pBuf = &pAd->CommonCfg.Channel;
+common/p2p_packet.c:		DBGPRINT(RT_DEBUG_INFO, ("	P2pMakeP2pIE (PacketType = %d)	insert SUBID_P2P_DEVICE_INFO. DeviceNameLen = %ld.\n", PacketType, pAd->P2pCfg.DeviceNameLen));
+common/p2p_packet.c:	if (P2P_GO_ON(pAd) && (pAd->P2pCfg.GONoASchedule.bValid == TRUE))
+common/p2p_packet.c:	else if (P2P_GO_ON(pAd) && (P2P_TEST_BIT(pAd->P2pCfg.CTWindows, P2P_OPPS_BIT)))
+common/p2p_packet.c:	PRT_P2P_CONFIG	pP2PCtrl = &pAd->P2pCfg;
+common/p2p_packet.c:		/*pDest = &pAd->BeaconBuf[StartPosition];*/
+common/p2p_packet.c:		/*PUCHAR        pDest = (PUCHAR)pAd->ApCfg.MBSSID[apidx].BeaconBuf;*/
+common/p2p_packet.c:		pAd->GOBeaconBufNoALen = 24; 
+common/p2p_packet.c:	return pAd->GOBeaconBufNoALen;
+common/p2p_packet.c:	if (pAd->P2pCfg.GONoASchedule.bValid == TRUE)
+common/p2p_packet.c:		*(pDest+9) = pAd->P2pCfg.GONoASchedule.Token;
+common/p2p_packet.c:		*(pDest+11) = pAd->P2pCfg.GONoASchedule.Count;
+common/p2p_packet.c:		RTMPMoveMemory((pDest+12), &pAd->P2pCfg.GONoASchedule.Duration, 4);
+common/p2p_packet.c:		RTMPMoveMemory((pDest+16), &pAd->P2pCfg.GONoASchedule.Interval, 4);
+common/p2p_packet.c:		RTMPMoveMemory((pDest+20), &pAd->P2pCfg.GONoASchedule.StartTime, 4);
+common/p2p_packet.c:	else if (P2P_TEST_BIT(pAd->P2pCfg.CTWindows, P2P_OPPS_BIT))
+common/p2p_packet.c:		*(pDest+9) = pAd->P2pCfg.GONoASchedule.Token;
+common/p2p_packet.c:		*(pDest+10) = pAd->P2pCfg.CTWindows;
+common/p2p_packet.c:		FALSE - None of channel in ChannelList Match any channel in pAd->ChannelList[] array
+common/p2p_packet.c:	if (!RTMPEqualMemory(BssidAddr, pAd->P2pTable.PerstEntry[index].Addr, MAC_ADDR_LEN)
+common/p2p_packet.c:		for (i = 0;i < pAd->ChannelListNum;i++)
+common/p2p_packet.c:			if (pAd->ChannelList[i].Channel == OpChannel)
+common/p2p_packet.c:		if ( i == pAd->ChannelListNum)
+common/p2p_packet.c:	if ((SsidLen > 0) && (!RTMPEqualMemory(pAd->P2pTable.PerstEntry[index].Profile.SSID.Ssid, Ssid, SsidLen)))
+common/p2p_packet.c:		DBGPRINT(RT_DEBUG_ERROR, ("Ssid2[%d] = %s.  \n",  pAd->P2pTable.PerstEntry[index].Profile.SSID.SsidLength, pAd->P2pTable.PerstEntry[index].Profile.SSID.Ssid));
+common/p2p_packet.c:		FALSE - None of channel in ChannelList Match any channel in pAd->ChannelList[] array
+common/p2p_packet.c:		for (i = 0;i < pAd->ChannelListNum;i++)
+common/p2p_packet.c:			if (pAd->ChannelList[i].Channel == OpChannel)
+common/p2p_packet.c:		if ( i == pAd->ChannelListNum)
+History.txt:		init_waitqueue_head(&pAd->cmdQTask.kthread_q); for KTHREAD_SUPPORT
+include/rt_led.h:#define LED_MODE_DEFAULT            	0	/* value domain of pAd->LedCntl.LedMode and E2PROM */
+include/frq_cal.h:	__pAd->FreqCalibrationCtrl.bEnableFrequencyCalibration = FALSE;
+include/radar.h:	_pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40 ? 						\
+include/radar.h:	((_pAd->CommonCfg.Channel >= 116) && (_pAd->CommonCfg.Channel <= 128)) :	\
+include/radar.h:	((_pAd->CommonCfg.Channel >= 120) && (_pAd->CommonCfg.Channel <= 128))
+include/uapsd.h:	__pAd->StaCfg.FlgPsmCanNotSleep = FALSE;
+include/uapsd.h:	__pAd->StaCfg.FlgPsmCanNotSleep = TRUE;
+include/rtmp.h:	_pAd->StaActive.SupportedHtPhy.ChannelWidth = _pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth;      \
+include/rtmp.h:	_pAd->StaActive.SupportedHtPhy.MimoPs = _pAd->MlmeAux.HtCapability.HtCapInfo.MimoPs;      \
+include/rtmp.h:	_pAd->StaActive.SupportedHtPhy.GF = _pAd->MlmeAux.HtCapability.HtCapInfo.GF;      \
+include/rtmp.h:	_pAd->StaActive.SupportedHtPhy.ShortGIfor20 = _pAd->MlmeAux.HtCapability.HtCapInfo.ShortGIfor20;      \
+include/rtmp.h:	_pAd->StaActive.SupportedHtPhy.ShortGIfor40 = _pAd->MlmeAux.HtCapability.HtCapInfo.ShortGIfor40;      \
+include/rtmp.h:	_pAd->StaActive.SupportedHtPhy.TxSTBC = _pAd->MlmeAux.HtCapability.HtCapInfo.TxSTBC;      \
+include/rtmp.h:	_pAd->StaActive.SupportedHtPhy.RxSTBC = _pAd->MlmeAux.HtCapability.HtCapInfo.RxSTBC;      \
+include/rtmp.h:	_pAd->StaActive.SupportedHtPhy.ExtChanOffset = _pAd->MlmeAux.AddHtInfo.AddHtInfo.ExtChanOffset;      \
+include/rtmp.h:	_pAd->StaActive.SupportedHtPhy.RecomWidth = _pAd->MlmeAux.AddHtInfo.AddHtInfo.RecomWidth;      \
+include/rtmp.h:	_pAd->StaActive.SupportedHtPhy.OperaionMode = _pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode;      \
+include/rtmp.h:	_pAd->StaActive.SupportedHtPhy.NonGfPresent = _pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent;      \
+include/rtmp.h:	_pAd->MacTab.Content[BSSID_WCID].AMsduSize = (UCHAR)(_pHtCapability->HtCapInfo.AMsduSize);	\
+include/rtmp.h:	_pAd->MacTab.Content[BSSID_WCID].MmpsMode= (UCHAR)(_pHtCapability->HtCapInfo.MimoPs);	\
+include/rtmp.h:	_pAd->MacTab.Content[BSSID_WCID].MaxRAmpduFactor = (UCHAR)(_pHtCapability->HtCapParm.MaxRAmpduFactor);	\
+include/rtmp.h:#define GET_LNA_GAIN(_pAd)	((_pAd->LatchRfRegs.Channel <= 14) ? (_pAd->BLNAGain) : ((_pAd->LatchRfRegs.Channel <= 64) ? (_pAd->ALNAGain0) : ((_pAd->LatchRfRegs.Channel <= 128) ? (_pAd->ALNAGain1) : (_pAd->ALNAGain2))))
+include/rtmp.h:	pAd->ApCfg.MBSSID[apidx].TimBitmaps[WLAN_CT_TIM_BCMC_OFFSET] &= ~NUM_BIT8[0];
+include/rtmp.h:	pAd->ApCfg.MBSSID[apidx].TimBitmaps[WLAN_CT_TIM_BCMC_OFFSET] |= NUM_BIT8[0];
+include/rtmp.h:	/*CIPHER_KEY SharedKey[SHARE_KEY_NUM]; // ref pAd->SharedKey[BSS][4] */
+include/rtmp.h:	UINT MatchDlsEntryIdx;	/* indicate the index in pAd->StaCfg.DLSEntry */
+include/rtmp.h:	UCHAR			MatchTdlsEntryIdx; // indicate the index in pAd->StaCfg.DLSEntry
+include/rtmp.h:	/* used only when pAd->OpMode == OPMODE_AP */
+include/rtmp.h:	/* used only when pAd->OpMode == OPMODE_STA */
+include/rtmp.h:#define QLOAD_DOES_ALARM_OCCUR(pAd)	(pAd->FlgQloadAlarmIsSuspended == TRUE)
+include/rtmp.h:#define QLOAD_ALARM_EVER_OCCUR(pAd) (pAd->QloadAlarmNumber > 0)
+include/rtmp.h:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+include/rtmp.h:	UINT8 RXWISize = pAd->chipCap.RXWISize;
+include/tdls_cmm.h:		RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE, FALSE);				\
+include/tdls_cmm.h:	RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE, FALSE);					\
+include/mac_ral/mac_pci.h:		(((freeNum != (TX_RING_SIZE-1)) && (pAd->TxSwQueue[QueIdx].Number == 0)) || (freeNum<3))
+include/mac_ral/mac_pci.h:		/*(((freeNum) != (TX_RING_SIZE-1)) && (pAd->TxSwQueue[QueIdx].Number == 1)) */
+include/mac_ral/mac_pci.h:	(_pAd->TxRing[_QueIdx].TxSwFreeIdx > _pAd->TxRing[_QueIdx].TxCpuIdx)	? \
+include/mac_ral/mac_pci.h:			(_pAd->TxRing[_QueIdx].TxSwFreeIdx - _pAd->TxRing[_QueIdx].TxCpuIdx - 1) \
+include/mac_ral/mac_pci.h:			(_pAd->TxRing[_QueIdx].TxSwFreeIdx + TX_RING_SIZE - _pAd->TxRing[_QueIdx].TxCpuIdx - 1);
+include/mac_ral/mac_pci.h:	(_pAd->MgmtRing.TxSwFreeIdx > _pAd->MgmtRing.TxCpuIdx)	? \
+include/mac_ral/mac_pci.h:			(_pAd->MgmtRing.TxSwFreeIdx - _pAd->MgmtRing.TxCpuIdx - 1) \
+include/mac_ral/mac_pci.h:			(_pAd->MgmtRing.TxSwFreeIdx + MGMT_RING_SIZE - _pAd->MgmtRing.TxCpuIdx - 1);
+include/mac_ral/mac_pci.h:		RTMP_INT_LOCK(&pAd->irq_lock, _irqFlags);\
+include/mac_ral/mac_pci.h:		pAd->int_enable_reg = ((DELAYINTMASK) |(RxINT|TxDataInt|TxMgmtInt));\
+include/mac_ral/mac_pci.h:		pAd->int_disable_mask = 0;\
+include/mac_ral/mac_pci.h:		pAd->int_pending = 0;\
+include/mac_ral/mac_pci.h:		RTMP_INT_UNLOCK(&pAd->irq_lock, _irqFlags);\
+include/mac_ral/mac_pci.h:		RTMP_INT_LOCK(&pAd->irq_lock, _irqFlags);\
+include/mac_ral/mac_pci.h:		pAd->int_enable_reg = ((DELAYINTMASK) |		\
+include/mac_ral/mac_pci.h:		pAd->int_disable_mask = 0;						\
+include/mac_ral/mac_pci.h:		pAd->int_pending = 0; \
+include/mac_ral/mac_pci.h:		RTMP_INT_UNLOCK(&pAd->irq_lock, _irqFlags);\
+include/mac_ral/mac_pci.h:		RTMP_INT_LOCK(&pAd->irq_lock, _irqFlags);\
+include/mac_ral/mac_pci.h:		RTMP_INT_UNLOCK(&pAd->irq_lock, _irqFlags);\
+include/mac_ral/mac_pci.h:	POS_COOKIE pObj = (POS_COOKIE)(_pAd->OS_Cookie);						\
+include/mac_ral/mac_pci.h:	RtmpOSIRQRelease(_NetDev, pAd->infType, pObj->pci_dev, &_pAd->HaveMsi);	\
+include/mac_ral/mac_pci.h:	POS_COOKIE pObj = (POS_COOKIE)(_pAd->OS_Cookie);						\
+include/mac_ral/mac_pci.h:	RtmpOSIRQRelease(_NetDev, pAd->infType, pObj->pci_dev, NULL);			\
+include/mac_ral/mac_usb.h:				RTMP_IRQ_LOCK(&pAd->DeQueueLock[QueIdx], irqFlags);		\
+include/mac_ral/mac_usb.h:				if (pAd->DeQueueRunning[QueIdx])						\
+include/mac_ral/mac_usb.h:					RTMP_IRQ_UNLOCK(&pAd->DeQueueLock[QueIdx], irqFlags);\
+include/mac_ral/mac_usb.h:					pAd->DeQueueRunning[QueIdx] = TRUE;					\
+include/mac_ral/mac_usb.h:					RTMP_IRQ_UNLOCK(&pAd->DeQueueLock[QueIdx], irqFlags);\
+include/mac_ral/mac_usb.h:				RTMP_IRQ_LOCK(&pAd->DeQueueLock[QueIdx], irqFlags);		\
+include/mac_ral/mac_usb.h:				pAd->DeQueueRunning[QueIdx] = FALSE;					\
+include/mac_ral/mac_usb.h:				RTMP_IRQ_UNLOCK(&pAd->DeQueueLock[QueIdx], irqFlags);	\
+include/mac_ral/mac_usb.h:#define GET_TXRING_FREENO(_pAd, _QueIdx)	(_QueIdx) /*(_pAd->TxRing[_QueIdx].TxSwFreeIdx) */
+include/mac_ral/mac_usb.h:#define GET_MGMTRING_FREENO(_pAd)			(_pAd->MgmtRing.TxSwFreeIdx)
+include/mac_ral/mac_usb.h:#define RTMP_MLME_HANDLER(pAd)			RTUSBMlmeUp(&(pAd->mlmeTask))
+include/mac_ral/mac_usb.h:	{	if ((pAd->StaCfg.bHardwareRadio == TRUE) && 					\
+include/mac_ral/mac_usb.h:		        RTUSBMlmeUp(&(pAd->mlmeTask));
+include/mac_ral/mac_usb.h:		RTUSBMlmeUp(&(_pAd->mlmeTask));									\
+include/dfs.h:		!(((_DfsEvent).EngineId >= _pAd->chipCap.DfsEngineNum) ||	\
+include/dfs.h:		!((_pAd->Dot11_H.RDMode == RD_SWITCHING_MODE) ||		\
+include/p2p_cmm.h:	(_pAd->P2pCfg.DiscCurrentState == P2P_DISC_LISTEN)
+include/p2p_cmm.h:	(_pAd->P2pCfg.DiscCurrentState == P2P_DISC_SEARCH)
+include/p2p_cmm.h:	(_pAd->P2pCfg.DiscCurrentState == P2P_DISC_SCAN)
+include/p2p_cmm.h:	(_pAd->P2pCfg.CtrlCurrentState == P2P_CTRL_DISCOVERY)
+include/p2p_cmm.h:		_pAd->P2pCfg.WscMode = WSC_PIN_MODE;	\
+include/p2p_cmm.h:		_pAd->P2pCfg.ConfigMethod = 0x188;	\
+include/p2p_cmm.h:		_pAd->P2pCfg.Dpid = DEV_PASS_ID_NOSPEC;
+include/rtmp_cmd.h:	OUT VOID *pStats;	/* point to pAd->stats */
+include/rtmp_cmd.h:	VOID *pStats;		/* point to pAd->iw_stats */
+include/iface/iface_util.h:	{     POS_COOKIE _pObj = (POS_COOKIE)(_pAd->OS_Cookie); \
+include/ap.h:	if ((__FromWhichBSSID < __pAd->ApCfg.BssidNum) &&					\
+include/ap.h:		(__pAd->ApCfg.MBSSID[__FromWhichBSSID].VLAN_VID != 0))			\
+include/ap.h:		__VLAN_VID = __pAd->ApCfg.MBSSID[__FromWhichBSSID].VLAN_VID;	\
+include/ap.h:		__VLAN_Priority = __pAd->ApCfg.MBSSID[__FromWhichBSSID].VLAN_Priority; \
+include/rtmp_chip.h:#define IS_RT3052(_pAd)		(((_pAd)->MACVersion == 0x28720200) && (_pAd->Antenna.field.TxPath == 2))
+include/rtmp_chip.h:	(_pAd->DeviceID == NIC3090_PCIe_DEVICE_ID) || \
+include/rtmp_chip.h:	(_pAd->DeviceID == NIC3091_PCIe_DEVICE_ID) || \
+include/rtmp_chip.h:	(_pAd->DeviceID == NIC3092_PCIe_DEVICE_ID) || \
+include/rtmp_chip.h:	(_pAd->DeviceID == NIC3592_PCIe_DEVICE_ID) || \
+include/rtmp_chip.h:	((_pAd->DeviceID == NIC3593_PCI_OR_PCIe_DEVICE_ID) && (RT3593OverPCIe(_pAd))) \
+include/rtmp_chip.h:#define IS_RT5392(_pAd)   ((_pAd->MACVersion & 0xFFFF0000) == 0x53920000) /* Include RT5392, RT5372 and RT5362 */
+include/rtmp_chip.h:#define IS_RT5390H(_pAd)   (((_pAd->MACVersion & 0xFFFF0000) == 0x53910000) && (((_pAd)->MACVersion & 0x0000FFFF) >= 0x1500))
+include/rtmp_chip.h:#define IS_DUAL_BAND_NIC(_pAd) (((_pAd->RfIcType == RFIC_2850) || (_pAd->RfIcType == RFIC_2750) || (_pAd->RfIcType == RFIC_3052)		\
+include/rtmp_chip.h:								|| (_pAd->RfIcType == RFIC_3053) || (_pAd->RfIcType == RFIC_2853) || (_pAd->RfIcType == RFIC_3853) 	\
+include/rtmp_chip.h:#define RT3593OverPCIe(_pAd) (IS_RT3593(_pAd) && (_pAd->CommonCfg.bPCIeBus == TRUE))
+include/rtmp_chip.h:#define RT3593OverPCI(_pAd) (IS_RT3593(_pAd) && (_pAd->CommonCfg.bPCIeBus == FALSE))
+include/rtmp_chip.h:#define SNR_FORMULA1		0	/* ((0xeb     - pAd->StaCfg.LastSNR0) * 3) / 16; */
+include/rtmp_chip.h:#define SNR_FORMULA2		1	/* (pAd->StaCfg.LastSNR0 * 3 + 8) >> 4; */
+include/rtmp_chip.h:#define SNR_FORMULA3		2	/* (pAd->StaCfg.LastSNR0) * 3) / 16; */
+include/rtmp_chip.h:		if (__pAd->chipOps.EnableAPMIMOPS != NULL)							\
+include/rtmp_chip.h:			__pAd->chipOps.EnableAPMIMOPS(__pAd, __ReduceCorePower)
+include/rtmp_chip.h:		if (__pAd->chipOps.DisableAPMIMOPS != NULL)							\
+include/rtmp_chip.h:			__pAd->chipOps.DisableAPMIMOPS(__pAd)
+include/rtmp_chip.h:		if (__pAd->chipOps.PwrSavingOP != NULL)	\
+include/rtmp_chip.h:			__pAd->chipOps.PwrSavingOP(__pAd, __PwrOP, __PwrLevel,	\
+include/rtmp_chip.h:		if (__pAd->chipOps.RxSensitivityTuning != NULL)						\
+include/rtmp_chip.h:			__pAd->chipOps.RxSensitivityTuning(__pAd)
+include/rtmp_chip.h:		if (__pAd->chipOps.ChipAGCAdjust != NULL)						\
+include/rtmp_chip.h:			__R66 = __pAd->chipOps.ChipAGCAdjust(__pAd, __Rssi, __R66)
+include/rtmp_chip.h:		if (__pAd->chipOps.InitDesiredTSSITable != NULL)					\
+include/rtmp_chip.h:			__pAd->chipOps.InitDesiredTSSITable(__pAd)
+include/rtmp_chip.h:		if (__pAd->chipOps.ATETssiCalibration != NULL)					\
+include/rtmp_chip.h:			__pAd->chipOps.ATETssiCalibration(__pAd, __pData)
+include/rtmp_chip.h:		if (__pAd->chipOps.ATETssiCalibrationExtend != NULL)				\
+include/rtmp_chip.h:			__pAd->chipOps.ATETssiCalibrationExtend(__pAd, __pData)	
+include/rtmp_chip.h:		if (__pAd->chipOps.ATEReadExternalTSSI != NULL)					\
+include/rtmp_chip.h:			__pAd->chipOps.ATEReadExternalTSSI(__pAd, __pData)	
+include/rtmp_chip.h:		if (__pAd->chipOps.AsicGetTxPowerOffset != NULL)					\
+include/rtmp_chip.h:			__pAd->chipOps.AsicGetTxPowerOffset(__pAd, __pCfgOfTxPwrCtrlOverMAC)	
+include/rtmp_chip.h:		if (__pAd->chipOps.AsicTxAlcGetAutoAgcOffset != NULL)				\
+include/rtmp_chip.h:			__pAd->chipOps.AsicTxAlcGetAutoAgcOffset(						\
+include/rtmp_chip.h:		if (__pAd->chipOps.AsicExtraPowerOverMAC != NULL)					\
+include/rtmp_chip.h:			__pAd->chipOps.AsicExtraPowerOverMAC(__pAd)
+include/rtmp_chip.h:			__pAd->chipOps.TSSIRatio(__DeltaPwr)
+include/rtmp_chip.h:		if (__pAd->chipOps.AsicFreqCalStop != NULL)							\
+include/rtmp_chip.h:			__pAd->chipOps.AsicFreqCalStop(__pAd)
+include/rtmp_chip.h:		if (__pAd->chipOps.ChipIQCalibration != NULL)								\
+include/rtmp_chip.h:			 __pAd->chipOps.ChipIQCalibration(__pAd, __pChannel)
+include/rtmp_chip.h:		if (__pAd->chipOps.HighPowerTuning != NULL)							\
+include/rtmp_chip.h:			__pAd->chipOps.HighPowerTuning(__pAd, __pRssi)
+include/rtmp_chip.h:		if (__pAd->chipOps.AsicAntennaDefaultReset != NULL)					\
+include/rtmp_chip.h:			__pAd->chipOps.AsicAntennaDefaultReset(__pAd, __pAntenna)
+include/rtmp_chip.h:		if (__pAd->chipOps.NetDevNickNameInit != NULL)						\
+include/rtmp_chip.h:			__pAd->chipOps.NetDevNickNameInit(__pAd)
+include/rtmp_chip.h:		if (__pAd->chipOps.NICInitAsicFromEEPROM != NULL)					\
+include/rtmp_chip.h:			__pAd->chipOps.NICInitAsicFromEEPROM(__pAd)
+include/rtmp_chip.h:		if (__pAd->chipOps.InitTemperCompensation != NULL)					\
+include/rtmp_chip.h:			__pAd->chipOps.InitTemperCompensation(__pAd)
+include/rtmp_chip.h:		if (__pAd->chipOps.TemperCompensation != NULL)					\
+include/rtmp_chip.h:			__pAd->chipOps.TemperCompensation(__pAd)
+include/rtmp_chip.h:			if (__pAd->chipOps.ChipSpecFunc[__FuncId] != NULL)					\
+include/rtmp_chip.h:				__pAd->chipOps.ChipSpecFunc[__FuncId](__pAd, __pData, __Data);	\
+include/rtmp_chip.h:		if (__pAd->chipOps.AsicResetBbpAgent != NULL)				\
+include/rtmp_chip.h:			__pAd->chipOps.AsicResetBbpAgent(__pAd)
+include/rtmp_chip.h:		if (__pAd->chipOps.BeaconUpdate != NULL)					\
+include/rtmp_chip.h:			__pAd->chipOps.BeaconUpdate(__pAd, Offset, Value, Unit)
+include/rtmp_chip.h:		if(__pAd->chipOps.ToneRadarProgram != NULL)					\
+include/rtmp_chip.h:			__pAd->chipOps.ToneRadarProgram(__pAd, threshold)
+include/rtmp_chip.h:		if(__pAd->chipOps.CckMrcStatusCtrl != NULL)				\
+include/rtmp_chip.h:			__pAd->chipOps.CckMrcStatusCtrl(__pAd)
+include/rtmp_chip.h:					if(__pAd->chipOps.RadarGLRTCompensate != NULL)				\
+include/rtmp_chip.h:						__pAd->chipOps.RadarGLRTCompensate(__pAd)
+include/rtmp_chip.h:	if(__pAd->chipOps.Calibration != NULL) \
+include/rtmp_chip.h:		__pAd->chipOps.Calibration(__pAd, __CalibrationID, __parameter); \
+include/rtmp_chip.h:		if (_pAd->chipOps.BurstWrite != NULL)		\
+include/rtmp_chip.h:			_pAd->chipOps.BurstWrite(_pAd, _Offset, _pData, _Cnt);\
+include/rtmp_chip.h:		if (_pAd->chipOps.BurstRead != NULL)	\
+include/rtmp_chip.h:			_pAd->chipOps.BurstRead(_pAd, _Offset, _Cnt, _pData);	\
+include/rtmp_chip.h:		if (_pAd->chipOps.RandomRead != NULL)	\
+include/rtmp_chip.h:			_pAd->chipOps.RandomRead(_pAd, _RegPair, _Num);	\
+include/rtmp_chip.h:		if (_pAd->chipOps.RFRandomRead != NULL)	\
+include/rtmp_chip.h:			_pAd->chipOps.RFRandomRead(_pAd, _RegPair, _Num); \
+include/rtmp_chip.h:		if (_pAd->chipOps.ReadModifyWrite != NULL)	\
+include/rtmp_chip.h:			_pAd->chipOps.ReadModifyWrite(_pAd, _RegPair, _Num);	\
+include/rtmp_chip.h:		if (_pAd->chipOps.RFReadModifyWrite != NULL)	\
+include/rtmp_chip.h:			_pAd->chipOps.RFReadModifyWrite(_pAd, _RegPair, _Num);	\
+include/rtmp_chip.h:		if (_pAd->chipOps.RandomWrite != NULL)	\
+include/rtmp_chip.h:			_pAd->chipOps.RandomWrite(_pAd, _RegPair, _Num);	\
+include/rtmp_chip.h:		if (_pAd->chipOps.RFRandomWrite != NULL)	\
+include/rtmp_chip.h:			_pAd->chipOps.RFRandomWrite(_pAd, _RegPair, _Num);	\
+include/rtmp_chip.h:	if (_pAd->chipOps.DisableTxRx != NULL)	\
+include/rtmp_chip.h:		_pAd->chipOps.DisableTxRx(_pAd, _Level);	\
+include/rtmp_chip.h:	if (_pAd->chipOps.AsicRadioOn != NULL)	\
+include/rtmp_chip.h:		_pAd->chipOps.AsicRadioOn(_pAd, _Stage);	\
+include/rtmp_chip.h:	if (_pAd->chipOps.AsicRadioOff != NULL)	\
+include/rtmp_chip.h:		_pAd->chipOps.AsicRadioOff(_pAd, _Stage);	\
+include/mlme.h:/* Once this attemp succeeds, all settings will be copy to pAd->StaActive. */
+include/mlme.h:/* separate this under-trial settings away from pAd->StaActive so that once */
+include/cfg80211extr.h:	CFG80211_RegRuleApply((VOID *)__pAd, NULL, __pAd->Cfg80211_Alpha2);
+include/cfg80211extr.h:	(__pBandInfo)->RFICType = __pAd->RFICType;								\
+include/cfg80211extr.h:	(__pBandInfo)->MpduDensity = __pAd->CommonCfg.BACapability.field.MpduDensity;\
+include/cfg80211extr.h:	(__pBandInfo)->TxStream = __pAd->CommonCfg.TxStream;					\
+include/cfg80211extr.h:	(__pBandInfo)->RxStream = __pAd->CommonCfg.RxStream;					\
+include/cfg80211extr.h:	(__pBandInfo)->MaxTxPwr = __pAd->CommonCfg.DefineMaxTxPwr;				\
+include/cfg80211extr.h:	if (WMODE_EQUAL(__pAd->CommonCfg.PhyMode, WMODE_B))				\
+include/cfg80211extr.h:	(__pBandInfo)->RtsThreshold = pAd->CommonCfg.RtsThreshold;				\
+include/cfg80211extr.h:	(__pBandInfo)->FragmentThreshold = pAd->CommonCfg.FragmentThreshold;	\
+include/cfg80211extr.h:	(__pBandInfo)->RFICType = __pAd->RFICType;								\
+include/cfg80211extr.h:	(__pBandInfo)->MpduDensity = __pAd->CommonCfg.BACapability.field.MpduDensity;\
+include/cfg80211extr.h:	(__pBandInfo)->TxStream = __pAd->CommonCfg.TxStream;					\
+include/cfg80211extr.h:	(__pBandInfo)->RxStream = __pAd->CommonCfg.RxStream;					\
+include/cfg80211extr.h:	if (WMODE_EQUAL(__pAd->CommonCfg.PhyMode, WMODE_B))				\
+include/cfg80211extr.h:	(__pBandInfo)->RtsThreshold = pAd->CommonCfg.RtsThreshold;				\
+include/cfg80211extr.h:	(__pBandInfo)->FragmentThreshold = pAd->CommonCfg.FragmentThreshold;	\
+include/wapi.h:#define IS_HW_WAPI_SUPPORT(__pAd)		(__pAd->chipCap.FlgIsHwWapiSup)
+include/rtmp_def.h:	RX Packet Filter control flags. Apply on pAd->PacketFilter
+include/rtmp_def.h:/* value domain of pAd->StaCfg.PortSecured. 802.1X controlled port definition */
+include/rtmp_def.h:/* value domain for pAd->EventTab.Log[].Event */
+include/rtmp_def.h:/* Maximum size of the ESSID and pAd->nickname strings */
+include/rtmp_def.h:						announce_802_3_packet, __ApIdx, __FrameBuf, __FrameLen, __pAd->OpMode)
+include/ap_mbss.h:		UCHAR __PhyMode = pAd->ApCfg.MBSSID[__BssId].PhyMode;	\
+include/rtmp_comm.h:/* definition of pAd->OpMode */
+include/rtmp_comm.h:#define IF_DEV_CONFIG_OPMODE_ON_AP(_pAd)		if(_pAd->OpMode == OPMODE_AP)
+include/rtmp_comm.h:#define IF_DEV_CONFIG_OPMODE_ON_STA(_pAd)		if(_pAd->OpMode == OPMODE_STA)
+include/chip/rtmp_phy.h:/* value domain of pAd->RfIcType */
+include/chip/rtmp_phy.h:	((__pAd->RfIcType == RFIC_2850) ||	\
+include/chip/rtmp_phy.h:	(__pAd->RfIcType == RFIC_2750) ||	\
+include/chip/rtmp_phy.h:	(__pAd->RfIcType == RFIC_3052) ||	\
+include/chip/rtmp_phy.h:	(__pAd->RfIcType == RFIC_2853) ||	\
+include/chip/rtmp_phy.h:	(__pAd->RfIcType == RFIC_3053) ||	\
+include/chip/rtmp_phy.h:	(__pAd->RfIcType == RFIC_3853) ||	\
+include/chip/rtmp_phy.h:	(__pAd->RfIcType == RFIC_5592) ||	\
+include/chip/rtmp_phy.h:	(__pAd->RfIcType == RFIC_UNKNOWN))
+include/chip/mt7601.h:#define	BW20_MCS_POWER_CCK_1M			((pAd->Tx20MPwrCfgGBand[0] & 0xFF) < 0x20)?(pAd->Tx20MPwrCfgGBand[0] & 0xFF):(CHAR)((pAd->Tx20MPwrCfgGBand[0] & 0xFF) - 0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_CCK_2M			((pAd->Tx20MPwrCfgGBand[0] & 0xFF) < 0x20)?(pAd->Tx20MPwrCfgGBand[0] & 0xFF):(CHAR)((pAd->Tx20MPwrCfgGBand[0] & 0xFF) - 0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_CCK_5M			(((pAd->Tx20MPwrCfgGBand[0] & 0xFF00) >> 8) < 0x20)?((pAd->Tx20MPwrCfgGBand[0] & 0xFF00) >> 8):(CHAR)(((pAd->Tx20MPwrCfgGBand[0] & 0xFF00) >> 8)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_CCK_11M			(((pAd->Tx20MPwrCfgGBand[0] & 0xFF00) >> 8) < 0x20)?((pAd->Tx20MPwrCfgGBand[0] & 0xFF00) >> 8):(CHAR)(((pAd->Tx20MPwrCfgGBand[0] & 0xFF00) >> 8)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_CCK_1M			((pAd->Tx40MPwrCfgGBand[0] & 0xFF) < 0x20)?(pAd->Tx40MPwrCfgGBand[0] & 0xFF) :(CHAR)(((pAd->Tx40MPwrCfgGBand[0] & 0xFF) < 0x20)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_CCK_2M			((pAd->Tx40MPwrCfgGBand[0] & 0xFF) < 0x20)?(pAd->Tx40MPwrCfgGBand[0] & 0xFF) :(CHAR)(((pAd->Tx40MPwrCfgGBand[0] & 0xFF) < 0x20)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_CCK_5M			(((pAd->Tx40MPwrCfgGBand[0] & 0xFF00) >> 8) < 0x20)?((pAd->Tx40MPwrCfgGBand[0] & 0xFF00) >> 8):(CHAR)(((pAd->Tx40MPwrCfgGBand[0] & 0xFF00) >> 8)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_CCK_11M			(((pAd->Tx40MPwrCfgGBand[0] & 0xFF00) >> 8) < 0x20)?((pAd->Tx40MPwrCfgGBand[0] & 0xFF00) >> 8):(CHAR)(((pAd->Tx40MPwrCfgGBand[0] & 0xFF00) >> 8)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_OFDM_6M			(((pAd->Tx20MPwrCfgGBand[0] & 0xFF0000) >> 16) < 0x20)?((pAd->Tx20MPwrCfgGBand[0] & 0xFF0000) >> 16):(CHAR)(((pAd->Tx20MPwrCfgGBand[0] & 0xFF0000) >> 16)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_OFDM_9M			(((pAd->Tx20MPwrCfgGBand[0] & 0xFF0000) >> 16) < 0x20)?((pAd->Tx20MPwrCfgGBand[0] & 0xFF0000) >> 16):(CHAR)(((pAd->Tx20MPwrCfgGBand[0] & 0xFF0000) >> 16)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_OFDM_12M		(((pAd->Tx20MPwrCfgGBand[0] & 0xFF000000) >> 24) < 0x20)?((pAd->Tx20MPwrCfgGBand[0] & 0xFF000000) >> 24):(CHAR)(((pAd->Tx20MPwrCfgGBand[0] & 0xFF000000) >> 24)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_OFDM_18M		(((pAd->Tx20MPwrCfgGBand[0] & 0xFF000000) >> 24) < 0x20)?((pAd->Tx20MPwrCfgGBand[0] & 0xFF000000) >> 24):(CHAR)(((pAd->Tx20MPwrCfgGBand[0] & 0xFF000000) >> 24)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_OFDM_24M		((pAd->Tx20MPwrCfgGBand[1] & 0xFF) < 0x20)?(pAd->Tx20MPwrCfgGBand[1] & 0xFF):(CHAR)((pAd->Tx20MPwrCfgGBand[1] & 0xFF)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_OFDM_36M		((pAd->Tx20MPwrCfgGBand[1] & 0xFF) < 0x20)?(pAd->Tx20MPwrCfgGBand[1] & 0xFF):(CHAR)((pAd->Tx20MPwrCfgGBand[1] & 0xFF)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_OFDM_48M		(((pAd->Tx20MPwrCfgGBand[1] & 0xFF00) >> 8) < 0x20)?((pAd->Tx20MPwrCfgGBand[1] & 0xFF00) >> 8):(CHAR)(((pAd->Tx20MPwrCfgGBand[1] & 0xFF00) >> 8)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_OFDM_54M		(((pAd->Tx20MPwrCfgGBand[1] & 0xFF00) >> 8) < 0x20)?((pAd->Tx20MPwrCfgGBand[1] & 0xFF00) >> 8):(CHAR)(((pAd->Tx20MPwrCfgGBand[1] & 0xFF00) >> 8)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_OFDM_6M			(((pAd->Tx40MPwrCfgGBand[0] & 0xFF0000) >> 16) < 0x20)?((pAd->Tx40MPwrCfgGBand[0] & 0xFF0000) >> 16):(CHAR)(((pAd->Tx40MPwrCfgGBand[0] & 0xFF0000) >> 16)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_OFDM_9M			(((pAd->Tx40MPwrCfgGBand[0] & 0xFF0000) >> 16) < 0x20)?((pAd->Tx40MPwrCfgGBand[0] & 0xFF0000) >> 16):(CHAR)(((pAd->Tx40MPwrCfgGBand[0] & 0xFF0000) >> 16)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_OFDM_12M		(((pAd->Tx40MPwrCfgGBand[0] & 0xFF000000) >> 24) < 0x20)?((pAd->Tx40MPwrCfgGBand[0] & 0xFF000000) >> 24):(CHAR)(((pAd->Tx40MPwrCfgGBand[0] & 0xFF000000) >> 24)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_OFDM_18M		(((pAd->Tx40MPwrCfgGBand[0] & 0xFF000000) >> 24) < 0x20)?((pAd->Tx40MPwrCfgGBand[0] & 0xFF000000) >> 24):(CHAR)(((pAd->Tx40MPwrCfgGBand[0] & 0xFF000000) >> 24)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_OFDM_24M		((pAd->Tx40MPwrCfgGBand[1] & 0xFF) < 0x20)?(pAd->Tx40MPwrCfgGBand[1] & 0xFF):(CHAR)((pAd->Tx40MPwrCfgGBand[1] & 0xFF)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_OFDM_36M		((pAd->Tx40MPwrCfgGBand[1] & 0xFF) < 0x20)?(pAd->Tx40MPwrCfgGBand[1] & 0xFF):(CHAR)((pAd->Tx40MPwrCfgGBand[1] & 0xFF)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_OFDM_48M		(((pAd->Tx40MPwrCfgGBand[1] & 0xFF00) >> 8) < 0x20)?((pAd->Tx40MPwrCfgGBand[1] & 0xFF00) >> 8):(CHAR)(((pAd->Tx40MPwrCfgGBand[1] & 0xFF00) >> 8)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_OFDM_54M		(((pAd->Tx40MPwrCfgGBand[1] & 0xFF00) >> 8) < 0x20)?((pAd->Tx40MPwrCfgGBand[1] & 0xFF00) >> 8):(CHAR)(((pAd->Tx40MPwrCfgGBand[1] & 0xFF00) >> 8)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_HT_MCS0			(((pAd->Tx20MPwrCfgGBand[1] & 0xFF0000) >> 16) < 0x20)?((pAd->Tx20MPwrCfgGBand[1] & 0xFF0000) >> 16):(CHAR)(((pAd->Tx20MPwrCfgGBand[1] & 0xFF0000) >> 16)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_HT_MCS1			(((pAd->Tx20MPwrCfgGBand[1] & 0xFF0000) >> 16) < 0x20)?((pAd->Tx20MPwrCfgGBand[1] & 0xFF0000) >> 16):(CHAR)(((pAd->Tx20MPwrCfgGBand[1] & 0xFF0000) >> 16)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_HT_MCS2			(((pAd->Tx20MPwrCfgGBand[1] & 0xFF000000) >> 24) < 0x20)?((pAd->Tx20MPwrCfgGBand[1] & 0xFF000000) >> 24):(CHAR)(((pAd->Tx20MPwrCfgGBand[1] & 0xFF000000) >> 24)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_HT_MCS3			(((pAd->Tx20MPwrCfgGBand[1] & 0xFF000000) >> 24) < 0x20)?((pAd->Tx20MPwrCfgGBand[1] & 0xFF000000) >> 24):(CHAR)(((pAd->Tx20MPwrCfgGBand[1] & 0xFF000000) >> 24)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_HT_MCS4			((pAd->Tx20MPwrCfgGBand[2] & 0xFF) < 0x20)?(pAd->Tx20MPwrCfgGBand[2] & 0xFF):(CHAR)((pAd->Tx20MPwrCfgGBand[2] & 0xFF)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_HT_MCS5			((pAd->Tx20MPwrCfgGBand[2] & 0xFF) < 0x20)?(pAd->Tx20MPwrCfgGBand[2] & 0xFF):(CHAR)((pAd->Tx20MPwrCfgGBand[2] & 0xFF)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_HT_MCS6			(((pAd->Tx20MPwrCfgGBand[2] & 0xFF00 ) >> 8) < 0x20)?((pAd->Tx20MPwrCfgGBand[2] & 0xFF00 ) >> 8):(CHAR)(((pAd->Tx20MPwrCfgGBand[2] & 0xFF00 ) >> 8)-0x40)
+include/chip/mt7601.h:#define	BW20_MCS_POWER_HT_MCS7			(((pAd->Tx20MPwrCfgGBand[2] & 0xFF00 ) >> 8) < 0x20)?((pAd->Tx20MPwrCfgGBand[2] & 0xFF00 ) >> 8):(CHAR)(((pAd->Tx20MPwrCfgGBand[2] & 0xFF00 ) >> 8)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_HT_MCS0			(((pAd->Tx40MPwrCfgGBand[1] & 0xFF0000) >> 16) < 0x20)?((pAd->Tx40MPwrCfgGBand[1] & 0xFF0000) >> 16):(CHAR)(((pAd->Tx40MPwrCfgGBand[1] & 0xFF0000) >> 16)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_HT_MCS1			(((pAd->Tx40MPwrCfgGBand[1] & 0xFF0000) >> 16) < 0x20)?((pAd->Tx40MPwrCfgGBand[1] & 0xFF0000) >> 16):(CHAR)(((pAd->Tx40MPwrCfgGBand[1] & 0xFF0000) >> 16)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_HT_MCS2			(((pAd->Tx40MPwrCfgGBand[1] & 0xFF000000) >> 24) < 0x20)?((pAd->Tx40MPwrCfgGBand[1] & 0xFF000000) >> 24):(CHAR)(((pAd->Tx40MPwrCfgGBand[1] & 0xFF000000) >> 24)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_HT_MCS3			(((pAd->Tx40MPwrCfgGBand[1] & 0xFF000000) >> 24) < 0x20)?((pAd->Tx40MPwrCfgGBand[1] & 0xFF000000) >> 24):(CHAR)(((pAd->Tx40MPwrCfgGBand[1] & 0xFF000000) >> 24)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_HT_MCS4			((pAd->Tx40MPwrCfgGBand[2] & 0xFF) < 0x20)?(pAd->Tx40MPwrCfgGBand[2] & 0xFF):(CHAR)((pAd->Tx40MPwrCfgGBand[2] & 0xFF)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_HT_MCS5			((pAd->Tx40MPwrCfgGBand[2] & 0xFF) < 0x20)?(pAd->Tx40MPwrCfgGBand[2] & 0xFF):(CHAR)((pAd->Tx40MPwrCfgGBand[2] & 0xFF)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_HT_MCS6			(((pAd->Tx40MPwrCfgGBand[2] & 0xFF00) >> 8) < 0x20)?(pAd->Tx40MPwrCfgGBand[2] & 0xFF00):(CHAR)((pAd->Tx40MPwrCfgGBand[2] & 0xFF00)-0x40)
+include/chip/mt7601.h:#define	BW40_MCS_POWER_HT_MCS7			(((pAd->Tx40MPwrCfgGBand[2] & 0xFF00) >> 8) < 0x20)?(pAd->Tx40MPwrCfgGBand[2] & 0xFF00):(CHAR)((pAd->Tx40MPwrCfgGBand[2] & 0xFF00)-0x40)
+include/chip/mt7601.h:#define	RF_PA_MODE_CCK_1M				(pAd->chipCap.PAModeCCK[0])
+include/chip/mt7601.h:#define	RF_PA_MODE_CCK_2M				(pAd->chipCap.PAModeCCK[1]) 
+include/chip/mt7601.h:#define	RF_PA_MODE_CCK_5M				(pAd->chipCap.PAModeCCK[2]) 
+include/chip/mt7601.h:#define	RF_PA_MODE_CCK_11M				(pAd->chipCap.PAModeCCK[3]) 
+include/chip/mt7601.h:#define	RF_PA_MODE_OFDM_6M				(pAd->chipCap.PAModeOFDM[0])
+include/chip/mt7601.h:#define	RF_PA_MODE_OFDM_9M				(pAd->chipCap.PAModeOFDM[1])
+include/chip/mt7601.h:#define	RF_PA_MODE_OFDM_12M				(pAd->chipCap.PAModeOFDM[2]) 
+include/chip/mt7601.h:#define	RF_PA_MODE_OFDM_18M				(pAd->chipCap.PAModeOFDM[3]) 
+include/chip/mt7601.h:#define	RF_PA_MODE_OFDM_24M				(pAd->chipCap.PAModeOFDM[4])
+include/chip/mt7601.h:#define	RF_PA_MODE_OFDM_36M				(pAd->chipCap.PAModeOFDM[5])
+include/chip/mt7601.h:#define	RF_PA_MODE_OFDM_48M				(pAd->chipCap.PAModeOFDM[6])
+include/chip/mt7601.h:#define	RF_PA_MODE_OFDM_54M				(pAd->chipCap.PAModeOFDM[7])
+include/chip/mt7601.h:#define	RF_PA_MODE_HT_MCS0				(pAd->chipCap.PAModeHT[0])
+include/chip/mt7601.h:#define	RF_PA_MODE_HT_MCS1				(pAd->chipCap.PAModeHT[1]) 
+include/chip/mt7601.h:#define	RF_PA_MODE_HT_MCS2				(pAd->chipCap.PAModeHT[2]) 
+include/chip/mt7601.h:#define	RF_PA_MODE_HT_MCS3				(pAd->chipCap.PAModeHT[3]) 
+include/chip/mt7601.h:#define	RF_PA_MODE_HT_MCS4				(pAd->chipCap.PAModeHT[4])
+include/chip/mt7601.h:#define	RF_PA_MODE_HT_MCS5				(pAd->chipCap.PAModeHT[5])
+include/chip/mt7601.h:#define	RF_PA_MODE_HT_MCS6				(pAd->chipCap.PAModeHT[6])
+include/chip/mt7601.h:#define	RF_PA_MODE_HT_MCS7				(pAd->chipCap.PAModeHT[7])
+include/chip/mt7601.h:#define	RF_PA_MODE_HT_MCS8				(pAd->chipCap.PAModeHT[8])
+include/chip/mt7601.h:#define	RF_PA_MODE_HT_MCS9				(pAd->chipCap.PAModeHT[9]) 
+include/chip/mt7601.h:#define	RF_PA_MODE_HT_MCS10				(pAd->chipCap.PAModeHT[10]) 
+include/chip/mt7601.h:#define	RF_PA_MODE_HT_MCS11				(pAd->chipCap.PAModeHT[11]) 
+include/chip/mt7601.h:#define	RF_PA_MODE_HT_MCS12				(pAd->chipCap.PAModeHT[12])
+include/chip/mt7601.h:#define	RF_PA_MODE_HT_MCS13				(pAd->chipCap.PAModeHT[13])
+include/chip/mt7601.h:#define	RF_PA_MODE_HT_MCS14				(pAd->chipCap.PAModeHT[14])
+include/chip/mt7601.h:#define	RF_PA_MODE_HT_MCS15				(pAd->chipCap.PAModeHT[15])
+include/rtmp_timer.h:	if ((_pQNode == NULL) && (_pAd->TimerQ.status & RTMP_TASK_CAN_DO_INSERT))	\
+include/wpa.h:	_pmk = _pAd->MBSS[_pEntry->apidx].PMK;					\
+include/wpa.h:	_gtk = _pAd->MBSS[_pEntry->apidx].GTK;					\
+include/os/rt_drv.h:	linux_pci_unmap_single(((POS_COOKIE)(_pAd->OS_Cookie))->pci_dev, _ptr, _size, _dir)
+include/os/rt_linux.h:		if (_pAd->infType == RTMP_DEV_INF_USB)	\
+include/os/rt_linux.h:			RTMP_SEM_EVENT_WAIT(&_pAd->McuCmdSem, _irqflags);\
+include/os/rt_linux.h:			RTMP_SEM_LOCK(&_pAd->McuCmdLock, _irqflags);\
+include/os/rt_linux.h:		if(_pAd->infType == RTMP_DEV_INF_USB)\
+include/os/rt_linux.h:			RTMP_SEM_EVENT_UP(&_pAd->McuCmdSem);\
+include/os/rt_linux.h:			RTMP_SEM_UNLOCK(&_pAd->McuCmdLock, _irqflags);\
+include/os/rt_linux.h:	linux_pci_unmap_single(((POS_COOKIE)(_pAd->OS_Cookie))->pci_dev, _ptr, _size, _dir)
+include/os/rt_linux.h:/* pRxContext->data_dma + pAd->NextRxBulkInPosition; */
+mac/rtmp_mac.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+mac/rtmp_mac.c:		pMac = &pAd->MacTab.Content[WCID];
+mac/rtmp_mac.c:	BASize = pAd->CommonCfg.TxBASize;
+mac/rtmp_mac.c:	if (pAd->MACVersion == 0x28720200)
+mac/rtmp_mac.c:	if (pMac && pAd->chipCap.FlgHwTxBfCap)
+mac/rtmp_mac.c:		pTxWI->TxWIBW = (pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth == 0) ? (BW_20) : (pTransmit->field.BW);
+mac/rtmp_mac.c:        if (pAd->CommonCfg.bMIMOPSEnable)
+mac/rtmp_mac.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+mac/rtmp_mac.c:		(pAd->StaCfg.BssType == BSS_INFRA))
+mac/rtmp_mac.c:		pTxWI->TxWIBW = (pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth == 0) ? (BW_20) : (pTransmit->field.BW);
+mac/rtmp_mac.c:	if ((pAd->force_amsdu == TRUE) && (pTxBlk->TxFrameType == TX_AMSDU_FRAME) && 
+mac/rtmp_mac.c:					__FUNCTION__, pAd->force_amsdu, pTxBlk->TxFrameType, pMacEntry->TXBAbitmap, 
+mac/rtmp_mac.c:		if ((pAd->force_amsdu == TRUE) && (pTxBlk->TxFrameType == TX_AMSDU_FRAME)
+mac/rtmp_mac.c:	BASize = pAd->CommonCfg.TxBASize;
+mac/rtmp_mac.c:		BASize = pAd->BATable.BAOriEntry[RABAOriIdx].BAWinSize;
+mac/rtmp_mac.c:		pAd->DiagStruct.TxDataCnt[pAd->DiagStruct.ArrayCurIdx]++;
+mac/rtmp_mac.c:		pAd->DiagStruct.TxMcsCnt[pAd->DiagStruct.ArrayCurIdx][pTxWI->MCS]++;
+mac/rtmp_mac.c:	if (pAd->fpga_on & 0x2)
+mac/rtmp_mac.c:		pTxWI->TxWIPHYMODE = pAd->data_phy;
+mac/rtmp_mac.c:		pTxWI->TxWIMCS = pAd->data_mcs;
+mac/rtmp_mac.c:		pTxWI->TxWIBW = pAd->data_bw;
+mac/rtmp_mac.c:		pTxWI->TxWIShortGI = pAd->data_gi;
+mac/rtmp_mac.c:		if (pAd->data_basize)
+mac/rtmp_mac.c:			pTxWI->TxWIBAWinSize = pAd->data_basize;
+mac/rtmp_mac.c:		pTxWI->TxWIBW = (pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth == 0) ? (BW_20) : (pTransmit->field.BW);
+mac/rtmp_mac.c:    if (pAd->CommonCfg.bMIMOPSEnable)
+mac/rtmp_mac.c:		pAd->DiagStruct.TxDataCnt[pAd->DiagStruct.ArrayCurIdx]++;
+mac/rtmp_mac.c:		pAd->DiagStruct.TxMcsCnt[pAd->DiagStruct.ArrayCurIdx][pTxWI->MCS]++;
+mac/rtmp_mac.c:	if (pAd->fpga_on & 0x2)
+mac/rtmp_mac.c:		pTxWI->TxWIPHYMODE = pAd->data_phy;
+mac/rtmp_mac.c:		pTxWI->TxWIMCS = pAd->data_mcs;
+mac/rtmp_mac.c:		pTxWI->TxWIBW = pAd->data_bw;
+mac/rtmp_mac.c:		pTxWI->TxWIShortGI = pAd->data_gi;
+mac/rtmp_mac.c:		if (pAd->data_basize)
+mac/rtmp_mac.c:			pTxWI->TxWIBAWinSize = pAd->data_basize;
+mcu/rtmp_mcu.c:	RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
+mcu/rtmp_M51.c:	pAd->FirmwareVersion = (FIRMWARE_MAJOR_VERSION << 8) + \
+mcu/rtmp_M51.c:					pAd->FirmwareVersion = \
+mcu/rtmp_M51.c:					if ((pAd->FirmwareVersion) < \
+mcu/rtmp_M51.c:	UINT32			Version = (pAd->MACVersion >> 16);
+mcu/rtmp_M51.c:		if (pAd->WOW_Cfg.bWOWFirmware == TRUE)
+mcu/rtmp_M51.c:				if (pAd->WOW_Cfg.bWOWFirmware == TRUE)
+mcu/rtmp_M51.c:	if (pAd->WOW_Cfg.bEnable == TRUE)
+mcu/rtmp_M51.c:		pAd->WOW_Cfg.bWOWFirmware = FALSE;
+mcu/rtmp_M51.c:		&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3) 
+mcu/rtmp_M51.c:		&& (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))
+mcu/rtmp_M51.c:		RTMP_SEM_LOCK(&pAd->McuCmdLock);
+mcu/rtmp_M51.c:		if ((pAd->brt30xxBanMcuCmd == TRUE)
+mcu/rtmp_M51.c:			RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
+mcu/rtmp_M51.c:			pAd->brt30xxBanMcuCmd = TRUE;
+mcu/rtmp_M51.c:			pAd->brt30xxBanMcuCmd = FALSE;
+mcu/rtmp_M51.c:		RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
+mcu/rtmp_M51.c:		&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3) 
+mcu/rtmp_M51.c:		&& (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
+mcu/rtmp_M51.c:			RTMP_SEM_EVENT_WAIT(&pAd->reg_atomic, ret);
+mcu/rtmp_M51.c:		&& (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3) 
+mcu/rtmp_M51.c:		&& (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))
+mcu/rtmp_M51.c:		/*NdisAcquireSpinLock(&pAd->McuCmdLock);*/
+mcu/rtmp_M51.c:		/*pAd->brt30xxBanMcuCmd = FALSE;*/
+mcu/rtmp_M51.c:		/*NdisReleaseSpinLock(&pAd->McuCmdLock);*/
+mcu/rtmp_M51.c:				if ((pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3) &&
+mcu/rtmp_M51.c:					(pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))
+mcu/rtmp_M51.c:					pAd->brt30xxBanMcuCmd = FALSE;
+mcu/rtmp_M51.c:		pAd->LastMCUCmd = Command;
+mcu/rtmp_M51.c:		RTMP_SEM_EVENT_UP(&pAd->reg_atomic);
+mcu/rtmp_and.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+mcu/rtmp_and.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+mcu/rtmp_and.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+mcu/rtmp_and.c:	struct MCU_CTRL *MCtrl = &pAd->MCUCtrl;
+mcu/rtmp_and.c:	struct MCU_CTRL *MCtrl = &pAd->MCUCtrl;
+mcu/rtmp_and.c:	struct MCU_CTRL *MCtrl = &pAd->MCUCtrl;
+mcu/rtmp_and.c:	struct MCU_CTRL *MCtrl = &pAd->MCUCtrl;
+mcu/rtmp_and.c:	struct MCU_CTRL *MCtrl = &pAd->MCUCtrl;
+mcu/rtmp_and.c:	struct MCU_CTRL *MCtrl = &pAd->MCUCtrl;
+mcu/rtmp_and.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+mcu/rtmp_and.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+mcu/rtmp_and.c:	struct MCU_CTRL *MCtrl = &pAd->MCUCtrl;
+mcu/rtmp_and.c:	if (pAd->PM_FlgSuspend)
+mcu/rtmp_and.c:		RTMP_OS_NETDEV_WAKE_QUEUE(pAd->net_dev);
+mcu/rtmp_and.c:		RTMP_OS_NETDEV_STOP_QUEUE(pAd->net_dev);
+mcu/rtmp_and.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+mcu/rtmp_and.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+mcu/rtmp_and.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+mcu/rtmp_and.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+mcu/rtmp_and.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+mcu/rtmp_and.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+mcu/rtmp_and.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+mcu/rtmp_and.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+mcu/rtmp_and.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+mcu/rtmp_and.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+mcu/rtmp_and.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+mcu/rtmp_and.c:	RTMP_CHIP_CAP *pChipCap = &pAd->chipCap;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo2.NonGfPresent = 1;
+mgmt/mgmt_ht.c:		pAd->MacTab.fAnyStationNonGF = TRUE;
+mgmt/mgmt_ht.c:		pAd->MacTab.fAnyStation20Only = TRUE;
+mgmt/mgmt_ht.c:	if ((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40) && 
+mgmt/mgmt_ht.c:		(pAd->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_ABOVE)
+mgmt/mgmt_ht.c:		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel + 2;
+mgmt/mgmt_ht.c:	else if ((pAd->CommonCfg.Channel > 2) && 
+mgmt/mgmt_ht.c:			(pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40) && 
+mgmt/mgmt_ht.c:			(pAd->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_BELOW))
+mgmt/mgmt_ht.c:		if (pAd->CommonCfg.Channel == 14)
+mgmt/mgmt_ht.c:			pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel - 1;
+mgmt/mgmt_ht.c:			pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel - 2;
+mgmt/mgmt_ht.c:	UCHAR RxStream = pAd->CommonCfg.RxStream;
+mgmt/mgmt_ht.c:	RT_HT_CAPABILITY *rt_ht_cap = &pAd->CommonCfg.DesiredHtPhy;
+mgmt/mgmt_ht.c:	HT_CAPABILITY_IE *ht_cap= &pAd->CommonCfg.HtCapability;
+mgmt/mgmt_ht.c:	if (CHAN_PropertyCheck(pAd, pAd->CommonCfg.Channel,
+mgmt/mgmt_ht.c:		if (CHAN_PropertyCheck(pAd, pAd->CommonCfg.Channel,
+mgmt/mgmt_ht.c:		if (CHAN_PropertyCheck(pAd, pAd->CommonCfg.Channel,
+mgmt/mgmt_ht.c:	RTMPZeroMemory(&pAd->CommonCfg.AddHTInfo, sizeof(pAd->CommonCfg.AddHTInfo));
+mgmt/mgmt_ht.c:	RTMPZeroMemory(&pAd->CommonCfg.NewExtChanOffset, sizeof(pAd->CommonCfg.NewExtChanOffset));
+mgmt/mgmt_ht.c:   	if (pAd->CommonCfg.bRdg)
+mgmt/mgmt_ht.c:	DBGPRINT(RT_DEBUG_TRACE, ("RTMPSetHT : RxBAWinLimit = %d\n", pAd->CommonCfg.BACapability.field.RxBAWinLimit));
+mgmt/mgmt_ht.c:	rt_ht_cap->AmsduEnable = (USHORT)pAd->CommonCfg.BACapability.field.AmsduEnable;
+mgmt/mgmt_ht.c:	rt_ht_cap->AmsduSize = (UCHAR)pAd->CommonCfg.BACapability.field.AmsduSize;
+mgmt/mgmt_ht.c:	rt_ht_cap->MimoPs = (UCHAR)pAd->CommonCfg.BACapability.field.MMPSmode;
+mgmt/mgmt_ht.c:	rt_ht_cap->MpduDensity = (UCHAR)pAd->CommonCfg.BACapability.field.MpduDensity;
+mgmt/mgmt_ht.c:	ht_cap->HtCapInfo.AMsduSize = (USHORT)pAd->CommonCfg.BACapability.field.AmsduSize;
+mgmt/mgmt_ht.c:	ht_cap->HtCapInfo.MimoPs = (USHORT)pAd->CommonCfg.BACapability.field.MMPSmode;
+mgmt/mgmt_ht.c:	ht_cap->HtCapParm.MpduDensity = (UCHAR)pAd->CommonCfg.BACapability.field.MpduDensity;
+mgmt/mgmt_ht.c:	if (pAd->CommonCfg.bForty_Mhz_Intolerant && (pHTPhyMode->BW == BW_40))
+mgmt/mgmt_ht.c:		if (pAd->CommonCfg.Channel <= 14) 		
+mgmt/mgmt_ht.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 1;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = (pHTPhyMode->ExtOffset == EXTCHA_BELOW)? (EXTCHA_BELOW): EXTCHA_ABOVE;
+mgmt/mgmt_ht.c:		if ((pAd->OpMode == OPMODE_AP) || INFRA_ON(pAd) || ADHOC_ON(pAd)
+mgmt/mgmt_ht.c:			if (pAd->ApCfg.bGreenAPActive == 1)
+mgmt/mgmt_ht.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 0;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = EXTCHA_NONE;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.vht_bw == VHT_BW_80 && 
+mgmt/mgmt_ht.c:		pAd->CommonCfg.vht_cent_ch)
+mgmt/mgmt_ht.c:		if (pAd->Antenna.field.TxPath >= 2)
+mgmt/mgmt_ht.c:		if (pAd->Antenna.field.RxPath >= 1)
+mgmt/mgmt_ht.c:	pAd->CommonCfg.AddHTInfo.ControlChan = pAd->CommonCfg.Channel;
+mgmt/mgmt_ht.c:	if (pAd->CommonCfg.APEdcaParm.bValid == FALSE)
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.bValid = TRUE;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.Aifsn[0] = 3;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.Aifsn[1] = 7;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.Aifsn[2] = 1;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.Aifsn[3] = 1;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.Cwmin[0] = 4;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.Cwmin[1] = 4;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.Cwmin[2] = 3;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.Cwmin[3] = 2;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.Cwmax[0] = 6;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.Cwmax[1] = 10;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.Cwmax[2] = 4;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.Cwmax[3] = 3;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.Txop[0]  = 0;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.Txop[1]  = 0;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.Txop[2]  = 94;	
+mgmt/mgmt_ht.c:		pAd->CommonCfg.APEdcaParm.Txop[3]  = 47;	
+mgmt/mgmt_ht.c:	AsicSetEdcaParm(pAd, &pAd->CommonCfg.APEdcaParm);
+mgmt/mgmt_ht.c:	if (pAd->chipCap.FlgHwTxBfCap)
+mgmt/mgmt_ht.c:		pAd->CommonCfg.RegTransmitSetting.field.ITxBfEn &= rtmp_chk_itxbf_calibration(pAd);
+mgmt/mgmt_ht.c:		for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+mgmt/mgmt_ht.c:		for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+mgmt/mgmt_ht.c:	UCHAR TxStream = pAd->CommonCfg.TxStream;		
+mgmt/mgmt_ht.c:			pDesired_ht_phy = &pAd->ApCfg.MBSSID[idx].DesiredHtPhyInfo;
+mgmt/mgmt_ht.c:			DesiredMcs = pAd->ApCfg.MBSSID[idx].DesiredTransmitSetting.field.MCS;			
+mgmt/mgmt_ht.c:			encrypt_mode = pAd->ApCfg.MBSSID[idx].WepStatus;
+mgmt/mgmt_ht.c:			pAd->ApCfg.MBSSID[idx].bWmmCapable = TRUE;	
+mgmt/mgmt_ht.c:			pAd->ApCfg.MBSSID[idx].bAutoTxRateSwitch = (DesiredMcs == MCS_AUTO) ? TRUE : FALSE;
+mgmt/mgmt_ht.c:					pDesired_ht_phy = &pAd->ApCfg.ApCliTab[idx].DesiredHtPhyInfo;									
+mgmt/mgmt_ht.c:					DesiredMcs = pAd->ApCfg.ApCliTab[idx].DesiredTransmitSetting.field.MCS;							
+mgmt/mgmt_ht.c:					encrypt_mode = pAd->ApCfg.ApCliTab[idx].WepStatus;
+mgmt/mgmt_ht.c:					pAd->ApCfg.ApCliTab[idx].bAutoTxRateSwitch = (DesiredMcs == MCS_AUTO) ? TRUE : FALSE;
+mgmt/mgmt_ht.c:			if ((apidx < pAd->ApCfg.BssidNum) && (apidx < MAX_MBSSID_NUM(pAd)) && (apidx < HW_BEACON_MAX_NUM))
+mgmt/mgmt_ht.c:				pDesired_ht_phy = &pAd->ApCfg.MBSSID[apidx].DesiredHtPhyInfo;									
+mgmt/mgmt_ht.c:				DesiredMcs = pAd->ApCfg.MBSSID[apidx].DesiredTransmitSetting.field.MCS;			
+mgmt/mgmt_ht.c:				encrypt_mode = pAd->ApCfg.MBSSID[apidx].WepStatus;
+mgmt/mgmt_ht.c:				pAd->ApCfg.MBSSID[apidx].bWmmCapable = TRUE;	
+mgmt/mgmt_ht.c:				pAd->ApCfg.MBSSID[apidx].bAutoTxRateSwitch = (DesiredMcs == MCS_AUTO) ? TRUE : FALSE;
+mgmt/mgmt_ht.c:			pDesired_ht_phy = &pAd->StaCfg.DesiredHtPhyInfo;					
+mgmt/mgmt_ht.c:			DesiredMcs = pAd->StaCfg.DesiredTransmitSetting.field.MCS;
+mgmt/mgmt_ht.c:			encrypt_mode = pAd->StaCfg.WepStatus;
+mgmt/mgmt_ht.c:	if ((pAd->CommonCfg.DesiredHtPhy.ChannelWidth == BW_20) && (DesiredMcs == MCS_32))
+mgmt/mgmt_ht.c:	if ((pAd->OpMode == OPMODE_STA) && (pAd->StaCfg.BssType == BSS_INFRA) && (apidx == MIN_NET_DEVICE_FOR_MBSSID))
+mgmt/mgmt_ht.c:	if (pAd->CommonCfg.HT_DisallowTKIP && IS_INVALID_HT_SECURITY(encrypt_mode))
+mgmt/mgmt_ht.c:	if (pAd->CommonCfg.HT_Disable)
+mgmt/mgmt_ht.c:		pAd->StaCfg.bAdhocN = FALSE;
+mgmt/mgmt_ht.c:	if(pAd->CommonCfg.DesiredHtPhy.ChannelWidth == BW_40)
+mgmt/mgmt_ht.c:	if (pAd->OpMode == OPMODE_STA)
+mgmt/mgmt_ht.c:	if (WMODE_CAP_AC(pAd->CommonCfg.PhyMode)) {
+mgmt/mgmt_ht.c:		for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+mgmt/mgmt_ht.c:			RTMPZeroMemory(&pAd->ApCfg.MBSSID[apidx].DesiredHtPhyInfo, sizeof(RT_PHY_INFO));
+mgmt/mgmt_ht.c:			RTMPZeroMemory(&pAd->ApCfg.ApCliTab[apidx].DesiredHtPhyInfo, sizeof(RT_PHY_INFO));
+mgmt/mgmt_ht.c:		for (apidx = 0; apidx < pAd->ApCfg.BssidNum; apidx++)
+mgmt/mgmt_ht.c:			RTMPZeroMemory(&pAd->ApCfg.MBSSID[apidx].DesiredHtPhyInfo, sizeof(RT_PHY_INFO));
+mgmt/mgmt_ht.c:			RTMPZeroMemory(&pAd->ApCfg.ApCliTab[apidx].DesiredHtPhyInfo, sizeof(RT_PHY_INFO));
+mgmt/mgmt_ht.c:		RTMPZeroMemory(&pAd->StaCfg.DesiredHtPhyInfo, sizeof(RT_PHY_INFO));
+mgmt/mgmt_ht.c:	if (!WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+mgmt/mgmt_ht.c:	SetHT.PhyMode = (RT_802_11_PHY_MODE)pAd->CommonCfg.PhyMode;
+mgmt/mgmt_ht.c:	SetHT.TransmitNo = ((UCHAR)pAd->Antenna.field.TxPath);
+mgmt/mgmt_ht.c:	SetHT.HtMode = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.HTMODE;
+mgmt/mgmt_ht.c:	SetHT.ExtOffset = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.EXTCHA;
+mgmt/mgmt_ht.c:	SetHT.BW = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.BW;
+mgmt/mgmt_ht.c:	SetHT.STBC = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.STBC;
+mgmt/mgmt_ht.c:	SetHT.SHORTGI = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.ShortGI;		
+mgmt/mgmt_ht.c:	if(pAd->CommonCfg.bBssCoexEnable && pAd->CommonCfg.Bss2040NeedFallBack)
+mgmt/mgmt_ht.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 0;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = 0;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.LastBSSCoexist2040.field.BSS20WidthReq = 1;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.Bss2040CoexistFlag |= BSS_2040_COEXIST_INFO_SYNC;
+mgmt/mgmt_ht.c:		pAd->CommonCfg.Bss2040NeedFallBack = 1;
+mgmt/mgmt_vht.c:	if (!WMODE_CAP_AC(pAd->CommonCfg.PhyMode))
+mgmt/mgmt_vht.c:	pAd->CommonCfg.vht_cent_ch = vht_cent_ch_freq(pAd, pAd->CommonCfg.Channel);
+mgmt/mgmt_vht.c:				__FUNCTION__, cent_ch, pAd->CommonCfg.vht_cent_ch, pAd->CommonCfg.vht_cent_ch2));
+mgmt/mgmt_hw.c:	struct hw_setting *hw_cfg = &pAd->hw_cfg, new_cfg;
+mgmt/mgmt_entrytb.c:	pEntry = pAd->MacTab.Hash[HashIdx];
+mgmt/mgmt_entrytb.c:	if (pAd->MacTab.Size >= MAX_LEN_OF_MAC_TABLE)
+mgmt/mgmt_entrytb.c:	if (pAd->StaCfg.BssType == BSS_INFRA)
+mgmt/mgmt_entrytb.c:	NdisAcquireSpinLock(&pAd->MacTabLock);
+mgmt/mgmt_entrytb.c:		if (IS_ENTRY_NONE(&pAd->MacTab.Content[i]))
+mgmt/mgmt_entrytb.c:			pEntry = &pAd->MacTab.Content[i];
+mgmt/mgmt_entrytb.c:						pAd->P2pCfg.MyGOwcid = i;
+mgmt/mgmt_entrytb.c:						if ((apidx < pAd->ApCfg.BssidNum) &&
+mgmt/mgmt_entrytb.c:							(pAd->ApCfg.MBSSID[apidx].MaxStaNum != 0) &&
+mgmt/mgmt_entrytb.c:							(pAd->ApCfg.MBSSID[apidx].StaCount >= pAd->ApCfg.MBSSID[apidx].MaxStaNum))
+mgmt/mgmt_entrytb.c:							NdisReleaseSpinLock(&pAd->MacTabLock);
+mgmt/mgmt_entrytb.c:			if (pAd->chipCap.FlgHwTxBfCap)
+mgmt/mgmt_entrytb.c:			if ((apidx < pAd->ApCfg.BssidNum) &&
+mgmt/mgmt_entrytb.c:				pEntry->pMbss = &pAd->ApCfg.MBSSID[pEntry->apidx];
+mgmt/mgmt_entrytb.c:						pEntry->AuthMode = pAd->ApCfg.ApCliTab[pEntry->apidx].AuthMode;
+mgmt/mgmt_entrytb.c:						pEntry->WepStatus = pAd->ApCfg.ApCliTab[pEntry->apidx].WepStatus;
+mgmt/mgmt_entrytb.c:						pEntry->AuthMode = pAd->ApCfg.MBSSID[apidx].AuthMode;
+mgmt/mgmt_entrytb.c:						pEntry->WepStatus = pAd->ApCfg.MBSSID[apidx].WepStatus;
+mgmt/mgmt_entrytb.c:						pEntry->GroupKeyWepStatus = pAd->ApCfg.MBSSID[apidx].GroupKeyWepStatus;
+mgmt/mgmt_entrytb.c:						pEntry->StaIdleTimeout = pAd->ApCfg.StaIdleTimeout;
+mgmt/mgmt_entrytb.c:						pAd->ApCfg.MBSSID[apidx].StaCount++;
+mgmt/mgmt_entrytb.c:						pAd->ApCfg.EntryClientCount++;
+mgmt/mgmt_entrytb.c:					pEntry->AuthMode = pAd->StaCfg.AuthMode;
+mgmt/mgmt_entrytb.c:					pEntry->WepStatus = pAd->StaCfg.WepStatus;
+mgmt/mgmt_entrytb.c:					COPY_MAC_ADDR(pEntry->HdrAddr2, pAd->ApCfg.ApCliTab[pEntry->apidx].CurrentAddress);
+mgmt/mgmt_entrytb.c:					COPY_MAC_ADDR(pEntry->HdrAddr2, pAd->P2PCurrentAddress);
+mgmt/mgmt_entrytb.c:					COPY_MAC_ADDR(pEntry->HdrAddr3, pAd->P2PCurrentAddress);
+mgmt/mgmt_entrytb.c:					COPY_MAC_ADDR(pEntry->HdrAddr2, pAd->ApCfg.MBSSID[apidx].Bssid);
+mgmt/mgmt_entrytb.c:					COPY_MAC_ADDR(pEntry->HdrAddr3, pAd->ApCfg.MBSSID[apidx].Bssid);
+mgmt/mgmt_entrytb.c:					COPY_MAC_ADDR(pEntry->HdrAddr2, pAd->CurrentAddress);
+mgmt/mgmt_entrytb.c:			pAd->MacTab.Size ++;
+mgmt/mgmt_entrytb.c:			if (pAd->chipCap.FlgHwTxBfCap)
+mgmt/mgmt_entrytb.c:			DBGPRINT(RT_DEBUG_TRACE, ("MacTableInsertEntry - allocate entry #%d, Total= %d\n",i, pAd->MacTab.Size));
+mgmt/mgmt_entrytb.c:		if (pAd->MacTab.Hash[HashIdx] == NULL)
+mgmt/mgmt_entrytb.c:			pAd->MacTab.Hash[HashIdx] = pEntry;
+mgmt/mgmt_entrytb.c:			pCurrEntry = pAd->MacTab.Hash[HashIdx];
+mgmt/mgmt_entrytb.c:				(pEntry->apidx < pAd->ApCfg.BssidNum) &&
+mgmt/mgmt_entrytb.c:				MAC_ADDR_EQUAL(pEntry->Addr, pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryAddr))
+mgmt/mgmt_entrytb.c:				NdisZeroMemory(pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryAddr, MAC_ADDR_LEN);
+mgmt/mgmt_entrytb.c:		if (pAd->StaCfg.BssType == BSS_ADHOC)
+mgmt/mgmt_entrytb.c:			pWscPeerEntry = WscFindPeerEntry(&pAd->StaCfg.WscControl.WscPeerList, pEntry->Addr);
+mgmt/mgmt_entrytb.c:	NdisReleaseSpinLock(&pAd->MacTabLock);
+mgmt/mgmt_entrytb.c:	NdisAcquireSpinLock(&pAd->MacTabLock);
+mgmt/mgmt_entrytb.c:	/*pEntry = pAd->MacTab.Hash[HashIdx];*/
+mgmt/mgmt_entrytb.c:	pEntry = &pAd->MacTab.Content[wcid];
+mgmt/mgmt_entrytb.c:			if (pAd->chipCap.FlgHwTxBfCap)
+mgmt/mgmt_entrytb.c:					pAd->ApCfg.MBSSID[pEntry->apidx].IEEE8021X)
+mgmt/mgmt_entrytb.c:				IgmpGroupDelMembers(pAd, (PUCHAR)pEntry->Addr, pAd->ApCfg.MBSSID[pEntry->apidx].MSSIDDev);
+mgmt/mgmt_entrytb.c:				pAd->ApCfg.MBSSID[pEntry->apidx].StaCount--;
+mgmt/mgmt_entrytb.c:				pAd->ApCfg.EntryClientCount--;
+mgmt/mgmt_entrytb.c:				if(pEntry && pAd->ApCfg.MBSSID[pEntry->apidx].Hostapd == TRUE )
+mgmt/mgmt_entrytb.c:					RtmpOSWrielessEventSendExt(pAd->net_dev, RT_WLAN_EVENT_EXPIRED, -1, pEntry->Addr,
+mgmt/mgmt_entrytb.c:				if ((pAd->Cfg80211VifDevSet.vifDevList.size > 0) && 	   
+mgmt/mgmt_entrytb.c:					CFG80211OS_DelSta(pAd->net_dev, pEntry->Addr);	
+mgmt/mgmt_entrytb.c:			pProbeEntry = pAd->MacTab.Hash[HashIdx];
+mgmt/mgmt_entrytb.c:							pAd->MacTab.Hash[HashIdx] = pEntry->pNext;
+mgmt/mgmt_entrytb.c:            	PWSC_CTRL	pWscControl = &pAd->ApCfg.MBSSID[pEntry->apidx].WscControl;
+mgmt/mgmt_entrytb.c:			pAd->MacTab.Size --;
+mgmt/mgmt_entrytb.c:			if (pAd->chipCap.FlgHwTxBfCap)
+mgmt/mgmt_entrytb.c:				PWSC_CTRL           pWscControl = &pAd->ApCfg.MBSSID[0].WscControl;
+mgmt/mgmt_entrytb.c:					pEntry = &pAd->MacTab.Content[i];
+mgmt/mgmt_entrytb.c:					(pAd->flg_p2p_OpStatusFlags == P2P_GO_UP))
+mgmt/mgmt_entrytb.c:				DBGPRINT(RT_DEBUG_ERROR, ("MacTableDeleteEntry1 - Total= %d. p2pEntry = %d.\n", pAd->MacTab.Size, p2pEntryCnt));
+mgmt/mgmt_entrytb.c:			DBGPRINT(RT_DEBUG_TRACE, ("MacTableDeleteEntry1 - Total= %d\n", pAd->MacTab.Size));
+mgmt/mgmt_entrytb.c:	NdisReleaseSpinLock(&pAd->MacTabLock);
+mgmt/mgmt_entrytb.c:	if (pAd->MacTab.Size == 0)
+mgmt/mgmt_entrytb.c:		pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode = 0;
+mgmt/mgmt_entrytb.c:	/*NdisAcquireSpinLock(&pAd->MacTabLock);*/
+mgmt/mgmt_entrytb.c:		if (IS_ENTRY_CLIENT(&pAd->MacTab.Content[i]))
+mgmt/mgmt_entrytb.c:			/*MacTableDeleteEntry(pAd, i, pAd->MacTab.Content[i].Addr);*/
+mgmt/mgmt_entrytb.c:			RTMPReleaseTimer(&pAd->MacTab.Content[i].EnqueueStartForPSKTimer, &Cancelled);
+mgmt/mgmt_entrytb.c:				RTMPReleaseTimer(&pAd->MacTab.Content[i].WPA_Authenticator.MsgRetryTimer, &Cancelled);
+mgmt/mgmt_entrytb.c:            pAd->MacTab.Content[i].EnqueueEapolStartTimerRunning = EAPOL_START_DISABLE;
+mgmt/mgmt_entrytb.c:				if (pAd->MacTab.Content[i].Sst == SST_ASSOC)
+mgmt/mgmt_entrytb.c:						/*NdisReleaseSpinLock(&pAd->MacTabLock);*/
+mgmt/mgmt_entrytb.c:					DBGPRINT(RT_DEBUG_WARN, ("Send DEAUTH - Reason = %d frame tO %02x:%02x:%02x:%02x:%02x:%02x \n",Reason, PRINT_MAC(pAd->MacTab.Content[i].Addr)));
+mgmt/mgmt_entrytb.c:					MgtMacHeaderInit(pAd, &DeAuthHdr, SUBTYPE_DEAUTH, 0, pAd->MacTab.Content[i].Addr, 
+mgmt/mgmt_entrytb.c:										pAd->ApCfg.MBSSID[pAd->MacTab.Content[i].apidx].Bssid,
+mgmt/mgmt_entrytb.c:										pAd->ApCfg.MBSSID[pAd->MacTab.Content[i].apidx].Bssid);
+mgmt/mgmt_entrytb.c:			MacTableDeleteEntry(pAd, i, pAd->MacTab.Content[i].Addr);
+mgmt/mgmt_entrytb.c:			MacTableDeleteEntry(pAd, i, pAd->MacTab.Content[i].Addr);
+mgmt/mgmt_entrytb.c:		for (apidx = MAIN_MBSSID; apidx < pAd->ApCfg.BssidNum; apidx++)
+mgmt/mgmt_entrytb.c:	    	RTMPCancelTimer(&pAd->ApCfg.MBSSID[apidx].WscControl.EapolTimer, &Cancelled);
+mgmt/mgmt_entrytb.c:	    	pAd->ApCfg.MBSSID[apidx].WscControl.EapolTimerRunning = FALSE;
+mgmt/mgmt_entrytb.c:			NdisZeroMemory(pAd->ApCfg.MBSSID[apidx].WscControl.EntryAddr, MAC_ADDR_LEN);
+mgmt/mgmt_entrytb.c:	    	pAd->ApCfg.MBSSID[apidx].WscControl.EapMsgRunning = FALSE;
+mgmt/mgmt_entrytb.c:			pAd->ApCfg.MBSSID[apidx].StaCount = 0; 
+mgmt/mgmt_entrytb.c:		DBGPRINT(RT_DEBUG_TRACE, ("McastPsQueue.Number %ld...\n",pAd->MacTab.McastPsQueue.Number));
+mgmt/mgmt_entrytb.c:		if (pAd->MacTab.McastPsQueue.Number > 0)
+mgmt/mgmt_entrytb.c:			APCleanupPsQueue(pAd, &pAd->MacTab.McastPsQueue);
+mgmt/mgmt_entrytb.c:		DBGPRINT(RT_DEBUG_TRACE, ("2McastPsQueue.Number %ld...\n",pAd->MacTab.McastPsQueue.Number));
+mgmt/mgmt_entrytb.c:/*		NdisZeroMemory(&pAd->MacTab, sizeof(MAC_TABLE));*/
+mgmt/mgmt_entrytb.c:		NdisZeroMemory(&pAd->MacTab.Size,
+mgmt/mgmt_entrytb.c:							sizeof(pAd->MacTab.Hash)-
+mgmt/mgmt_entrytb.c:							sizeof(pAd->MacTab.Content));
+mgmt/mgmt_entrytb.c:		InitializeQueueHeader(&pAd->MacTab.McastPsQueue);
+mgmt/mgmt_entrytb.c:		/*NdisReleaseSpinLock(&pAd->MacTabLock);*/
+mgmt/mgmt_dev.c:			wdev = &pAd->ApCfg.MBSSID[idx - MIN_NET_DEVICE_FOR_P2P_GO].wdev;
+mgmt/mgmt_dev.c:				wdev = &pAd->ApCfg.ApCliTab[idx].wdev;
+mgmt/mgmt_dev.c:			if ((idx < pAd->ApCfg.BssidNum) && (idx < MAX_MBSSID_NUM(pAd)) && (idx < HW_BEACON_MAX_NUM))
+mgmt/mgmt_dev.c:				wdev = &pAd->ApCfg.MBSSID[idx].wdev;
+mgmt/mgmt_dev.c:			wdev = &pAd->StaCfg.wdev;
+Binary file os/linux/cfg80211drv.o matches
+Binary file os/linux/mt7601Usta.ko matches
+os/linux/cfg80211drv.c:#define CFG80211CB			(pAd->pCfg80211_CB)
+os/linux/cfg80211drv.c:	if ( pAd->ApCfg.ApCliTab[MAIN_MBSSID].Valid && 
+os/linux/cfg80211drv.c:            (pAd->LatchRfRegs.Channel != pAd->ApCliMlmeAux.Channel))
+os/linux/cfg80211drv.c:		DBGPRINT(RT_DEBUG_TRACE, ("CFG80211_ROC: ROC_Timeout APCLI_ON Channel: %d\n", pAd->ApCliMlmeAux.Channel));
+os/linux/cfg80211drv.c:              AsicSwitchChannel(pAd, pAd->ApCliMlmeAux.Channel, FALSE);
+os/linux/cfg80211drv.c:              AsicLockChannel(pAd, pAd->ApCliMlmeAux.Channel);
+os/linux/cfg80211drv.c:			RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, 
+os/linux/cfg80211drv.c:								pAd->CommonCfg.bAPSDForcePowerSave ? PWR_SAVE : pAd->StaCfg.Psm);			
+os/linux/cfg80211drv.c:		RTMPSetTimer(&pAd->Cfg80211RemainOnChannelDurationTimer, RESTORE_COM_CH_TIME);
+os/linux/cfg80211drv.c:	   	     (pAd->LatchRfRegs.Channel != pAd->CommonCfg.Channel))
+os/linux/cfg80211drv.c:		DBGPRINT(RT_DEBUG_TRACE, ("CFG80211_ROC: ROC_Timeout INFRA_ON Channel: %d\n", pAd->CommonCfg.Channel));
+os/linux/cfg80211drv.c:              	AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+os/linux/cfg80211drv.c:              	AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+os/linux/cfg80211drv.c:		RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, 
+os/linux/cfg80211drv.c:							pAd->CommonCfg.bAPSDForcePowerSave ? PWR_SAVE : pAd->StaCfg.Psm);
+os/linux/cfg80211drv.c:		RTMPSetTimer(&pAd->Cfg80211RemainOnChannelDurationTimer, RESTORE_COM_CH_TIME);		    	 
+os/linux/cfg80211drv.c:        	cfg80211_remain_on_channel_expired(pAd->dummy_p2p_net_dev, pAd->CfgChanInfo.cookie, 
+os/linux/cfg80211drv.c:                  	                           pAd->CfgChanInfo.chan, pAd->CfgChanInfo.ChanType, GFP_KERNEL);
+os/linux/cfg80211drv.c:		pAd->Cfg80211RocTimerRunning = FALSE;
+os/linux/cfg80211drv.c:        pEntry = MacTableLookup(pAd, pAd->ApCliMlmeAux.Bssid);
+os/linux/cfg80211drv.c:                	                           PRINT_MAC(pAd->ApCliMlmeAux.Bssid)));
+os/linux/cfg80211drv.c:			*(VOID **)pData = (VOID *)(pAd->pCfg80211_CB);
+os/linux/cfg80211drv.c:			pAd->pCfg80211_CB = pData;
+os/linux/cfg80211drv.c:			if (pAd->LatchRfRegs.Channel != Data)
+os/linux/cfg80211drv.c:				DBGPRINT(RT_DEBUG_INFO, ("OFF-Channel Send Packet:  %d-%d\n", Data, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:				DBGPRINT(RT_DEBUG_INFO, ("OFF-Channel Channel Equal:  %d-%d\n", Data, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:			if (pAd->Cfg80211RocTimerRunning == TRUE)
+os/linux/cfg80211drv.c:				if (pAd->LatchRfRegs.Channel != pAd->CfgChanInfo.ChanId)
+os/linux/cfg80211drv.c:					AsicSwitchChannel(pAd, pAd->CfgChanInfo.ChanId, FALSE);
+os/linux/cfg80211drv.c:					AsicLockChannel(pAd, pAd->CfgChanInfo.ChanId);
+os/linux/cfg80211drv.c:					DBGPRINT(RT_DEBUG_TRACE, ("After OFF-Channel Send, restore to ROC: %d\n", pAd->CfgChanInfo.ChanId));
+os/linux/cfg80211drv.c:					DBGPRINT(RT_DEBUG_TRACE, ("After OFF-Channel Send, Keep in ROC: %d\n", pAd->CfgChanInfo.ChanId));	
+os/linux/cfg80211drv.c:				if (pAd->LatchRfRegs.Channel != pAd->CommonCfg.Channel)
+os/linux/cfg80211drv.c:					AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+os/linux/cfg80211drv.c:					AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+os/linux/cfg80211drv.c:					DBGPRINT(RT_DEBUG_TRACE, ("After OFF-Channel Send, restore to Common: %d\n", pAd->CommonCfg.Channel));
+os/linux/cfg80211drv.c:					DBGPRINT(RT_DEBUG_TRACE, ("After OFF-Channel Send, Keep in Common: %d\n", pAd->CommonCfg.Channel));	
+os/linux/cfg80211drv.c:			pAd->TxStatusInUsed = TRUE;
+os/linux/cfg80211drv.c:			pAd->TxStatusSeq = pAd->Sequence;
+os/linux/cfg80211drv.c:				if (pAd->StaCfg.WfdCfg.bSuppInsertWfdIe)
+os/linux/cfg80211drv.c:							if (pAd->pTxStatusBuf != NULL)
+os/linux/cfg80211drv.c:								os_free_mem(NULL, pAd->pTxStatusBuf);
+os/linux/cfg80211drv.c:							os_alloc_mem(NULL, (UCHAR **)&pAd->pTxStatusBuf, Data);
+os/linux/cfg80211drv.c:							if (pAd->pTxStatusBuf != NULL)
+os/linux/cfg80211drv.c:								NdisCopyMemory(pAd->pTxStatusBuf, pOutBuffer, Data);
+os/linux/cfg80211drv.c:								pAd->TxStatusBufLen = Data;
+os/linux/cfg80211drv.c:					if (pAd->pTxStatusBuf != NULL)
+os/linux/cfg80211drv.c:						os_free_mem(NULL, pAd->pTxStatusBuf);
+os/linux/cfg80211drv.c:						pAd->pTxStatusBuf = NULL;
+os/linux/cfg80211drv.c:					os_alloc_mem(NULL, (UCHAR **)&pAd->pTxStatusBuf, Data);
+os/linux/cfg80211drv.c:					if (pAd->pTxStatusBuf != NULL)
+os/linux/cfg80211drv.c:						NdisCopyMemory(pAd->pTxStatusBuf, pData, Data);
+os/linux/cfg80211drv.c:						pAd->TxStatusBufLen = Data;
+os/linux/cfg80211drv.c:			RTMPInitTimer(pAd, &pAd->Cfg80211RemainOnChannelDurationTimer, GET_TIMER_FUNCTION(RemainOnChannelTimeout), pAd, FALSE);
+os/linux/cfg80211drv.c:				if (pAd->pCfg80211ChanList != NULL)
+os/linux/cfg80211drv.c:					os_free_mem(NULL, pAd->pCfg80211ChanList);
+os/linux/cfg80211drv.c:				os_alloc_mem(NULL, (UINT32 **)&pAd->pCfg80211ChanList, sizeof(UINT32 *) * Data);
+os/linux/cfg80211drv.c:				if (pAd->pCfg80211ChanList != NULL)
+os/linux/cfg80211drv.c:					NdisCopyMemory(pAd->pCfg80211ChanList, pChanList, sizeof(UINT32 *) * Data);
+os/linux/cfg80211drv.c:					pAd->Cfg80211ChanListLan = Data;
+os/linux/cfg80211drv.c:			pAd->StaCfg.WfdCfg.bSuppGoOn = FALSE;
+os/linux/cfg80211drv.c:				if (pAd->pCfg80211RrobeRsp != NULL)
+os/linux/cfg80211drv.c:					os_free_mem(NULL, pAd->pCfg80211RrobeRsp);
+os/linux/cfg80211drv.c:				os_alloc_mem(NULL, (UCHAR **)&pAd->pCfg80211RrobeRsp, Data);
+os/linux/cfg80211drv.c:				if (pAd->pCfg80211RrobeRsp != NULL)
+os/linux/cfg80211drv.c:					NdisCopyMemory(pAd->pCfg80211RrobeRsp, pData, Data);
+os/linux/cfg80211drv.c:					pAd->Cfg80211AssocRspLen = Data;
+os/linux/cfg80211drv.c:		//	pAd->CommonCfg.PhyMode = PHY_11AN_MIXED;
+os/linux/cfg80211drv.c:		//	RTMPSetPhyMode(pAd,  pAd->CommonCfg.PhyMode);
+os/linux/cfg80211drv.c:            //*(VOID *)pData = (VOID *)pAd->Cfg80211VifDevSet.Cfg80211VifDev[0].net_dev;
+os/linux/cfg80211drv.c:			DBGPRINT(RT_DEBUG_ERROR, ("CFG80211_PKT: %s ProbeRsp Frame %d\n", preStr, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:			DBGPRINT(RT_DEBUG_ERROR, ("CFG80211_PKT: %s Deauth Frame\n", preStr, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:									preStr, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:									preStr, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:									preStr,  pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:									preStr, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:									preStr, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:									preStr, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:									preStr, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:                                                                        preStr, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:                                                                        preStr, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:                                                                        preStr, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:                                                                        preStr, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:                                                                        preStr, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:                                                                        preStr, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:				DBGPRINT(RT_DEBUG_ERROR, ("CFG80211_PKT: %s ACTION Frame %d\n", preStr, pAd->LatchRfRegs.Channel));
+os/linux/cfg80211drv.c:	pAd->ApCfg.MBSSID[MAIN_MBSSID].bBcnSntReq = FALSE;
+os/linux/cfg80211drv.c:	if (pAd->CommonCfg.BBPCurrentBW == BW_40)
+os/linux/cfg80211drv.c:   		pAd->CommonCfg.BBPCurrentBW = BW_20; // skynien follow YF's suggestion add here , for GO/p2p switch 
+os/linux/cfg80211drv.c:	PLIST_HEADER  pCacheList = &pAd->Cfg80211VifDevSet.vifDevList;
+os/linux/cfg80211drv.c:	if ((pAd->Cfg80211VifDevSet.vifDevList.size > 0) &&
+os/linux/cfg80211drv.c:		pAd->Cfg80211ProbeReqCount++;
+os/linux/cfg80211drv.c:		pAd->Cfg80211ProbeReqCount--;	
+os/linux/cfg80211drv.c:	if (pAd->Cfg80211ProbeReqCount > 0)
+os/linux/cfg80211drv.c:		pAd->Cfg80211RegisterProbeReqFrame = TRUE;
+os/linux/cfg80211drv.c:		pAd->Cfg80211RegisterProbeReqFrame = FALSE;
+os/linux/cfg80211drv.c:		pAd->Cfg80211ProbeReqCount = 0;
+os/linux/cfg80211drv.c:	DBGPRINT(RT_DEBUG_INFO, ("pAd->Cfg80211RegisterProbeReqFrame=%d[%d]\n",pAd->Cfg80211RegisterProbeReqFrame, pAd->Cfg80211ProbeReqCount));
+os/linux/cfg80211drv.c:	PLIST_HEADER  pCacheList = &pAd->Cfg80211VifDevSet.vifDevList;
+os/linux/cfg80211drv.c:	if ((pAd->Cfg80211VifDevSet.vifDevList.size > 0) &&
+os/linux/cfg80211drv.c:		pAd->Cfg80211ActionCount++;
+os/linux/cfg80211drv.c:		pAd->Cfg80211ActionCount--;	
+os/linux/cfg80211drv.c:	if (pAd->Cfg80211ActionCount > 0)
+os/linux/cfg80211drv.c:		pAd->Cfg80211RegisterActionFrame = TRUE;
+os/linux/cfg80211drv.c:		pAd->Cfg80211RegisterActionFrame = FALSE;
+os/linux/cfg80211drv.c:		pAd->Cfg80211ActionCount = 0;
+os/linux/cfg80211drv.c:	DBGPRINT(RT_DEBUG_INFO, ("TYPE pAd->Cfg80211RegisterActionFrame=%d[%d]\n",pAd->Cfg80211RegisterActionFrame, pAd->Cfg80211ActionCount));
+os/linux/cfg80211drv.c:	if (pAd->Cfg80211VifDevSet.isGoingOn)
+os/linux/cfg80211drv.c:	pAd->Cfg80211VifDevSet.isGoingOn = TRUE;
+os/linux/cfg80211drv.c:        	pAd->CommonCfg.TxPreamble = (pBssInfo->use_short_preamble == 0 ? Rt802_11PreambleLong : Rt802_11PreambleShort);	
+os/linux/cfg80211drv.c:		TxPreamble = (pAd->CommonCfg.TxPreamble == Rt802_11PreambleLong ? 0 : 1);
+os/linux/cfg80211drv.c:		MlmeSetTxPreamble(pAd, (USHORT)pAd->CommonCfg.TxPreamble);			
+os/linux/cfg80211drv.c:			pAd->CommonCfg.RegTransmitSetting.field.BW = BW_20;
+os/linux/cfg80211drv.c:			pAd->CommonCfg.HT_Disable = 0;
+os/linux/cfg80211drv.c:			pAd->CommonCfg.RegTransmitSetting.field.BW = BW_40;
+os/linux/cfg80211drv.c:			pAd->CommonCfg.HT_Disable = 0;
+os/linux/cfg80211drv.c:			pAd->CommonCfg.RegTransmitSetting.field.BW = BW_20;
+os/linux/cfg80211drv.c:			pAd->CommonCfg.HT_Disable = 1;	
+os/linux/cfg80211drv.c:		CFG80211DBG(RT_DEBUG_TRACE, ("80211> New BW = %d\n", pAd->CommonCfg.RegTransmitSetting.field.BW));
+os/linux/cfg80211drv.c:		CFG80211DBG(RT_DEBUG_TRACE, ("80211> HT Disable = %d\n", pAd->CommonCfg.HT_Disable));	
+os/linux/cfg80211drv.c:		pAd->CommonCfg.HT_Disable = 0;
+os/linux/cfg80211drv.c:		pAd->CommonCfg.RegTransmitSetting.field.BW = BW_40;
+os/linux/cfg80211drv.c:		if (pAd->LatchRfRegs.Channel != pAd->CommonCfg.Channel)
+os/linux/cfg80211drv.c:			AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+os/linux/cfg80211drv.c:			AsicLockChannel(pAd, pAd->CommonCfg.Channel);	
+os/linux/cfg80211drv.c:		//pAd->OpMode = OPMODE_AP;
+os/linux/cfg80211drv.c:		// Set_SSID_Proc(pAd, (PSTRING)pAd->CommonCfg.Ssid);
+os/linux/cfg80211drv.c:		Set_SSID_Proc(pAd, (PSTRING)pAd->CommonCfg.Ssid);
+os/linux/cfg80211drv.c:    CFG80211_CB *p80211CB = pAd->pCfg80211_CB;
+os/linux/cfg80211drv.c:		if (pAd->VifNextMode == RT_CMD_80211_IFTYPE_AP)
+os/linux/cfg80211drv.c:		pAd->VifNextMode = RT_CMD_80211_IFTYPE_STATION;
+os/linux/cfg80211drv.c:		pAd->OpMode = OPMODE_STA;
+os/linux/cfg80211drv.c:		pAd->VifNextMode = RT_CMD_80211_IFTYPE_AP;
+os/linux/cfg80211drv.c:                //pAd->OpMode = OPMODE_AP;
+os/linux/cfg80211drv.c:	if (pAd->FlgCfg80211Scanning == TRUE || 
+os/linux/cfg80211drv.c:		CFG80211DBG(RT_DEBUG_ERROR, ("pAd->FlgCfg80211Scanning == %d\n", 
+os/linux/cfg80211drv.c:				pAd->FlgCfg80211Scanning)); 	
+os/linux/cfg80211drv.c:	    pAd->FlgCfg80211Connecting == TRUE &&
+os/linux/cfg80211drv.c:	pAd->FlgCfg80211Scanning = TRUE;
+os/linux/cfg80211drv.c:	*(ptr + 2) = pAd->ApCfg.DtimCount;
+os/linux/cfg80211drv.c:	*(ptr + 3) = pAd->ApCfg.DtimPeriod;	
+os/linux/cfg80211drv.c:	pTim = pAd->ApCfg.MBSSID[MAIN_MBSSID].TimBitmaps;	
+os/linux/cfg80211drv.c:    	if (pAd->ApCfg.DtimCount == 0)
+os/linux/cfg80211drv.c:		*(ptr + 4) |= (pAd->ApCfg.MBSSID[MAIN_MBSSID].TimBitmaps[WLAN_CT_TIM_BCMC_OFFSET] & 0x01); 
+os/linux/cfg80211drv.c:	TXWI_STRUC *pTxWI = &pAd->BeaconTxWI;
+os/linux/cfg80211drv.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+os/linux/cfg80211drv.c:	PUCHAR pBeaconFrame = (PUCHAR)pAd->ApCfg.MBSSID[MAIN_MBSSID].BeaconBuf;
+os/linux/cfg80211drv.c:		pAd->ApCfg.MBSSID[MAIN_MBSSID].TimIELocationInBeacon = beacon_head_len;
+os/linux/cfg80211drv.c:		if (pAd->beacon_tail_buf != NULL)
+os/linux/cfg80211drv.c:			 os_free_mem(NULL, pAd->beacon_tail_buf);
+os/linux/cfg80211drv.c:		os_alloc_mem(NULL, (UCHAR **)&pAd->beacon_tail_buf, beacon_tail_len);
+os/linux/cfg80211drv.c:		if (pAd->beacon_tail_buf != NULL)
+os/linux/cfg80211drv.c:			NdisCopyMemory(pAd->beacon_tail_buf, beacon_tail_buf, beacon_tail_len);
+os/linux/cfg80211drv.c:			pAd->beacon_tail_len = beacon_tail_len;
+os/linux/cfg80211drv.c:		if (pAd->ApCfg.DtimCount == 0)
+os/linux/cfg80211drv.c:			pAd->ApCfg.DtimCount = pAd->ApCfg.DtimPeriod - 1;
+os/linux/cfg80211drv.c:			pAd->ApCfg.DtimCount -= 1;
+os/linux/cfg80211drv.c:		New_Tim_Len = CFG80211DRV_UpdateTimIE(pAd, pBeaconFrame, pAd->ApCfg.MBSSID[MAIN_MBSSID].TimIELocationInBeacon);
+os/linux/cfg80211drv.c:		if (pAd->beacon_tail_buf != NULL)
+os/linux/cfg80211drv.c:			NdisCopyMemory(pAd->ApCfg.MBSSID[MAIN_MBSSID].BeaconBuf + pAd->ApCfg.MBSSID[MAIN_MBSSID].TimIELocationInBeacon + New_Tim_Len, 
+os/linux/cfg80211drv.c:							pAd->beacon_tail_buf, pAd->beacon_tail_len);
+os/linux/cfg80211drv.c:			beacon_len = pAd->ApCfg.MBSSID[MAIN_MBSSID].TimIELocationInBeacon + pAd->beacon_tail_len + New_Tim_Len;
+os/linux/cfg80211drv.c:	//RT28xx_UpdateBeaconToAsic(pAd, MAIN_MBSSID, beacon_len, pAd->ApCfg.MBSSID[MAIN_MBSSID].TimIELocationInBeacon);		
+os/linux/cfg80211drv.c:    ptr = (PUCHAR)&pAd->BeaconTxWI;
+os/linux/cfg80211drv.c:		RTMP_IO_WRITE32(pAd, pAd->BeaconOffset[0] + i, longValue);
+os/linux/cfg80211drv.c:    ptr = pAd->ApCfg.MBSSID[MAIN_MBSSID].BeaconBuf;
+os/linux/cfg80211drv.c:		RTMP_IO_WRITE32(pAd, pAd->BeaconOffset[0] + TXWISize + i, longValue);
+os/linux/cfg80211drv.c:	BEACON_SYNC_STRUCT	*pBeaconSync = pAd->CommonCfg.pBeaconSync;
+os/linux/cfg80211drv.c:	ptr = (PUCHAR) (pAd->ApCfg.MBSSID[MAIN_MBSSID].BeaconBuf + pAd->ApCfg.MBSSID[MAIN_MBSSID].TimIELocationInBeacon);
+os/linux/cfg80211drv.c:	if (pAd->StaCfg.WfdCfg.bSuppInsertWfdIe)
+os/linux/cfg80211drv.c:		pAd->ApCfg.BssidNum = 1;
+os/linux/cfg80211drv.c:		pAd->MacTab.MsduLifeTime = 20; /* default 5 seconds */
+os/linux/cfg80211drv.c:		pAd->ApCfg.MBSSID[MAIN_MBSSID].bBcnSntReq = TRUE;
+os/linux/cfg80211drv.c:		pAd->ApCfg.StaIdleTimeout = 30;
+os/linux/cfg80211drv.c:		pAd->ApCfg.MBSSID[MAIN_MBSSID].StationKeepAliveTime = 10;
+os/linux/cfg80211drv.c:		if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
+os/linux/cfg80211drv.c:			if (pAd->CommonCfg.Channel > 14)
+os/linux/cfg80211drv.c:				pAd->ApCfg.MBSSID[MAIN_MBSSID].PhyMode = PHY_11AN_MIXED;
+os/linux/cfg80211drv.c:				pAd->ApCfg.MBSSID[MAIN_MBSSID].PhyMode = PHY_11BGN_MIXED;
+os/linux/cfg80211drv.c:			if (pAd->CommonCfg.Channel > 14)
+os/linux/cfg80211drv.c:				pAd->ApCfg.MBSSID[MAIN_MBSSID].PhyMode = PHY_11A;
+os/linux/cfg80211drv.c:				pAd->ApCfg.MBSSID[MAIN_MBSSID].PhyMode = PHY_11BG_MIXED;
+os/linux/cfg80211drv.c:		TxPreamble = (pAd->CommonCfg.TxPreamble == Rt802_11PreambleLong ? 0 : 1);	
+os/linux/cfg80211drv.c:	PMULTISSID_STRUCT pMbss = &pAd->ApCfg.MBSSID[MAIN_MBSSID];
+os/linux/cfg80211drv.c:		if ((pAd->Cfg80211VifDevSet.vifDevList.size > 0) &&
+os/linux/cfg80211drv.c:			pMbss->MSSIDDev = pAd->net_dev;
+os/linux/cfg80211drv.c:			COPY_MAC_ADDR(pMbss->Bssid, pAd->CurrentAddress);
+os/linux/cfg80211drv.c:				     TxPreamble, pAd->CommonCfg.bUseShortSlotTime, SpectrumMgmt);
+os/linux/cfg80211drv.c:		RTMPSetPhyMode(pAd,  pAd->CommonCfg.PhyMode);
+os/linux/cfg80211drv.c:		if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) && (pAd->Antenna.field.TxPath == 2))
+os/linux/cfg80211drv.c:		if(pAd->Antenna.field.RxPath == 3)
+os/linux/cfg80211drv.c:		else if(pAd->Antenna.field.RxPath == 2)
+os/linux/cfg80211drv.c:		else if(pAd->Antenna.field.RxPath == 1)
+os/linux/cfg80211drv.c:			if ((pAd->CommonCfg.PhyMode > PHY_11G) || bWmmCapable)
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.bValid = TRUE;
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.Aifsn[0] = 3;
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.Aifsn[1] = 7;
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.Aifsn[2] = 1;
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.Aifsn[3] = 1;
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.Cwmin[0] = 4;
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.Cwmin[1] = 4;
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.Cwmin[2] = 3;
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.Cwmin[3] = 2;
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.Cwmax[0] = 6;
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.Cwmax[1] = 10;
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.Cwmax[2] = 4;
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.Cwmax[3] = 3;
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.Txop[0]  = 0;
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.Txop[1]  = 0;
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.Txop[2]  = 94;	/*96; */
+os/linux/cfg80211drv.c:				pAd->CommonCfg.APEdcaParm.Txop[3]  = 47;	/*48; */
+os/linux/cfg80211drv.c:				AsicSetEdcaParm(pAd, &pAd->CommonCfg.APEdcaParm);
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.bValid = TRUE;
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.Aifsn[0] = 3;
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.Aifsn[1] = 7;
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.Aifsn[2] = 2;
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.Aifsn[3] = 2;
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.Cwmin[0] = 4;
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.Cwmin[1] = 4;
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.Cwmin[2] = 3;
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.Cwmin[3] = 2;
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.Cwmax[0] = 10;
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.Cwmax[1] = 10;
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.Cwmax[2] = 4;
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.Cwmax[3] = 3;
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.Txop[0]  = 0;
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.Txop[1]  = 0;
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.Txop[2]  = 94;	/*96; */
+os/linux/cfg80211drv.c:				pAd->ApCfg.BssEdcaParm.Txop[3]  = 47;	/*48; */
+os/linux/cfg80211drv.c:		if (pAd->CommonCfg.PhyMode < PHY_11ABGN_MIXED)
+os/linux/cfg80211drv.c:			pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth = BW_20;
+os/linux/cfg80211drv.c:		if (pAd->CommonCfg.bRdg)
+os/linux/cfg80211drv.c:		AsicSetBssid(pAd, pAd->CurrentAddress); 
+os/linux/cfg80211drv.c:		pAd->MacTab.Content[0].Addr[0] = 0x01;
+os/linux/cfg80211drv.c:		pAd->MacTab.Content[0].HTPhyMode.field.MODE = MODE_OFDM;
+os/linux/cfg80211drv.c:		pAd->MacTab.Content[0].HTPhyMode.field.MCS = 3;
+os/linux/cfg80211drv.c:		//MlmeSetTxPreamble(pAd, (USHORT)pAd->CommonCfg.TxPreamble);	
+os/linux/cfg80211drv.c:#ifdef DOT11_N_SUPPORT if (pAd->CommonCfg.PhyMode > PHY_11G)		
+os/linux/cfg80211drv.c:	//pAd->ApCfg.MBSSID[MAIN_MBSSID].PhyMode = PHY_11BGN_MIXED;
+os/linux/cfg80211drv.c:		pAd->CommonCfg.BeaconPeriod = pBeacon->interval;
+os/linux/cfg80211drv.c:		pAd->ApCfg.DtimPeriod = pBeacon->dtim_period;	
+os/linux/cfg80211drv.c:		DBGPRINT(RT_DEBUG_TRACE, ("CFG_TIM Apply BI %d\n", pAd->CommonCfg.BeaconPeriod));
+os/linux/cfg80211drv.c:		pAd->P2pCfg.bSentProbeRSP = TRUE;
+os/linux/cfg80211drv.c:	 	 * the value on pAd->CommonCfg.NumOfBulkInIRP may be large than 1.
+os/linux/cfg80211drv.c:		for(num_idx=0; num_idx < pAd->CommonCfg.NumOfBulkInIRP; num_idx++)
+os/linux/cfg80211drv.c:		RTMPCancelTimer(&pAd->CommonCfg.BeaconUpdateTimer, & Cancelled);
+os/linux/cfg80211drv.c:		RTMPInitTimer(pAd, &pAd->CommonCfg.BeaconUpdateTimer, GET_TIMER_FUNCTION(BeaconUpdateExec), pAd, TRUE);
+os/linux/cfg80211drv.c:		RTMPSetTimer(&pAd->CommonCfg.BeaconUpdateTimer, 10 /*pAd->CommonCfg.BeaconPeriod*/);
+os/linux/cfg80211drv.c:	pAd->StaCfg.WfdCfg.bSuppGoOn = TRUE;
+os/linux/cfg80211drv.c:	CFG80211_CB *pCfg80211_CB = pAd->pCfg80211_CB;
+os/linux/cfg80211drv.c:	if (pAd->StaCfg.pWpsProbeReqIe)
+os/linux/cfg80211drv.c:		os_free_mem(NULL, pAd->StaCfg.pWpsProbeReqIe);
+os/linux/cfg80211drv.c:		pAd->StaCfg.pWpsProbeReqIe = NULL;
+os/linux/cfg80211drv.c:	pAd->StaCfg.WpsProbeReqIeLen = 0;
+os/linux/cfg80211drv.c:	CFG80211DBG(RT_DEBUG_INFO, ("80211> is_wpa_supplicant_up ==> %d\n", pAd->StaCfg.WpaSupplicantUP)); 
+os/linux/cfg80211drv.c:	os_alloc_mem(pAd, (UCHAR **)&(pAd->StaCfg.pWpsProbeReqIe), ie_len);
+os/linux/cfg80211drv.c:	if (pAd->StaCfg.pWpsProbeReqIe)
+os/linux/cfg80211drv.c:		memcpy(pAd->StaCfg.pWpsProbeReqIe, pCfg80211_CB->pCfg80211_ScanReq->ie, ie_len);
+os/linux/cfg80211drv.c:		pAd->StaCfg.WpsProbeReqIeLen = ie_len;
+os/linux/cfg80211drv.c:		//hex_dump("WpsProbeReqIe", pAd->StaCfg.pWpsProbeReqIe, pAd->StaCfg.WpsProbeReqIeLen);
+os/linux/cfg80211drv.c:					pAd->StaCfg.WpsProbeReqIeLen));
+os/linux/cfg80211drv.c:	pAd->StaCfg.bAutoReconnect = TRUE;
+os/linux/cfg80211drv.c:	pAd->CommonCfg.BeaconPeriod = pIbssInfo->BeaconInterval;
+os/linux/cfg80211drv.c:	pAd->StaCfg.bAutoReconnect = FALSE;
+os/linux/cfg80211drv.c:	pAd->FlgCfg80211Connecting = FALSE;
+os/linux/cfg80211drv.c:        pAd->MlmeAux.AutoReconnectSsidLen= 32;
+os/linux/cfg80211drv.c:        NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen);
+os/linux/cfg80211drv.c:		COPY_MAC_ADDR(DeAuthReq.Addr, pAd->ApCliMlmeAux.Bssid);
+os/linux/cfg80211drv.c:		COPY_MAC_ADDR(DeAuthReq.Addr, pAd->CommonCfg.Bssid);
+os/linux/cfg80211drv.c:    if ((!WMODE_CAP_N(pAd->CommonCfg.PhyMode)) ||
+os/linux/cfg80211drv.c:	 (pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE <= MODE_OFDM))
+os/linux/cfg80211drv.c:		PhyInfo.word = pAd->StaCfg.HTPhyMode.word;
+os/linux/cfg80211drv.c:		PhyInfo.word = pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word;
+os/linux/cfg80211drv.c:	RSSI = RTMPAvgRssi(pAd, &pAd->StaCfg.RssiSample);
+os/linux/cfg80211drv.c:		pAd->ApCfg.MBSSID[MAIN_MBSSID].WepStatus = Ndis802_11WEPEnabled;
+os/linux/cfg80211drv.c:		pAd->ApCfg.MBSSID[MAIN_MBSSID].WepStatus = Ndis802_11Encryption3Enabled;
+os/linux/cfg80211drv.c:		pAd->ApCfg.MBSSID[MAIN_MBSSID].GroupKeyWepStatus = Ndis802_11Encryption3Enabled;
+os/linux/cfg80211drv.c:			PMULTISSID_STRUCT pMbss = &pAd->ApCfg.MBSSID[MAIN_MBSSID];
+os/linux/cfg80211drv.c:			if (pAd->ApCfg.MBSSID[MAIN_MBSSID].GroupKeyWepStatus == Ndis802_11Encryption3Enabled)
+os/linux/cfg80211drv.c:				pAd->SharedKey[MAIN_MBSSID][pKeyInfo->KeyId].KeyLen= LEN_TK;
+os/linux/cfg80211drv.c:				NdisMoveMemory(pAd->SharedKey[MAIN_MBSSID][pKeyInfo->KeyId].Key, pKeyInfo->KeyBuf, pKeyInfo->KeyLen);
+os/linux/cfg80211drv.c:				//NdisMoveMemory(pAd->SharedKey[MAIN_MBSSID][pMbss->DefaultKeyId].RxMic, (Key.ik_keydata+16+8), 8);
+os/linux/cfg80211drv.c:				//NdisMoveMemory(pAd->SharedKey[MAIN_MBSSID][pMbss->DefaultKeyId].TxMic, (Key.ik_keydata+16), 8);
+os/linux/cfg80211drv.c:				pAd->SharedKey[MAIN_MBSSID][pKeyInfo->KeyId].CipherAlg = CIPHER_AES;
+os/linux/cfg80211drv.c:						&pAd->SharedKey[MAIN_MBSSID][pKeyInfo->KeyId]);
+os/linux/cfg80211drv.c:						pAd->SharedKey[MAIN_MBSSID][pKeyInfo->KeyId].CipherAlg, Wcid, SHAREDKEYTABLE);
+os/linux/cfg80211drv.c:		BssIdx = pAd->ApCfg.BssidNum + MAX_MESH_NUM + MAIN_MBSSID;
+os/linux/cfg80211drv.c:		pApCliEntry = &pAd->ApCfg.ApCliTab[MAIN_MBSSID];
+os/linux/cfg80211drv.c:		pMacEntry = &pAd->MacTab.Content[pApCliEntry->MacTabWCID]; 
+os/linux/cfg80211drv.c:		if (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled)
+os/linux/cfg80211drv.c:		else if (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled)
+os/linux/cfg80211drv.c:			if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption2Enabled)
+os/linux/cfg80211drv.c:			else if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption3Enabled)
+os/linux/cfg80211drv.c:			if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
+os/linux/cfg80211drv.c:			else if (pAd->StaCfg.PairCipher == Ndis802_11Encryption3Enabled)
+os/linux/cfg80211drv.c:		if (pAd->ApCfg.ApCliTab[MAIN_MBSSID].pWpaAssocIe)
+os/linux/cfg80211drv.c:			os_free_mem(NULL, pAd->ApCfg.ApCliTab[MAIN_MBSSID].pWpaAssocIe);
+os/linux/cfg80211drv.c:			pAd->ApCfg.ApCliTab[MAIN_MBSSID].pWpaAssocIe = NULL;
+os/linux/cfg80211drv.c:		os_alloc_mem(NULL, (UCHAR **)&pAd->ApCfg.ApCliTab[MAIN_MBSSID].pWpaAssocIe, ie_len);
+os/linux/cfg80211drv.c:		if (pAd->ApCfg.ApCliTab[MAIN_MBSSID].pWpaAssocIe)
+os/linux/cfg80211drv.c:			pAd->ApCfg.ApCliTab[MAIN_MBSSID].WpaAssocIeLen = ie_len;
+os/linux/cfg80211drv.c:			NdisMoveMemory(pAd->ApCfg.ApCliTab[MAIN_MBSSID].pWpaAssocIe, pData, pAd->ApCfg.ApCliTab[MAIN_MBSSID].WpaAssocIeLen);
+os/linux/cfg80211drv.c:			pAd->ApCfg.ApCliTab[MAIN_MBSSID].WpaAssocIeLen=0;
+os/linux/cfg80211drv.c:		if (pAd->ApCfg.ApCliTab[MAIN_MBSSID].pWpaAssocIe)
+os/linux/cfg80211drv.c:			os_free_mem(NULL, pAd->ApCfg.ApCliTab[MAIN_MBSSID].pWpaAssocIe);
+os/linux/cfg80211drv.c:			pAd->ApCfg.ApCliTab[MAIN_MBSSID].pWpaAssocIe = NULL;
+os/linux/cfg80211drv.c:		pAd->ApCfg.ApCliTab[MAIN_MBSSID].WpaAssocIeLen=0;	
+os/linux/cfg80211drv.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+os/linux/cfg80211drv.c:	pAd->ApCfg.ApCliTab[MAIN_MBSSID].WpaSupplicantUP = WPA_SUPPLICANT_ENABLE; 
+os/linux/cfg80211drv.c:		pAd->ApCfg.ApCliTab[MAIN_MBSSID].WpaSupplicantUP |= WPA_SUPPLICANT_ENABLE_WPS;
+os/linux/cfg80211drv.c:		NdisZeroMemory(pAd->ApCfg.ApCliTab[0].CfgApCliBssid, MAC_ADDR_LEN);
+os/linux/cfg80211drv.c:		NdisCopyMemory(pAd->ApCfg.ApCliTab[0].CfgApCliBssid, pConnInfo->pBssid, MAC_ADDR_LEN);
+os/linux/cfg80211drv.c:		NdisCopyMemory(pAd->P2pCfg.Bssid, pConnInfo->pBssid, MAC_ADDR_LEN);
+os/linux/cfg80211drv.c:	pAd->FlgCfg80211Connecting = TRUE;
+os/linux/cfg80211drv.c:		pAd->StaCfg.WpaSupplicantUP |= WPA_SUPPLICANT_ENABLE_WPS;  /* Set_Wpa_Support(pAd, "3") */
+os/linux/cfg80211drv.c:		pAd->StaCfg.WpaSupplicantUP = WPA_SUPPLICANT_ENABLE; /* Set_Wpa_Support(pAd, "1")*/
+os/linux/cfg80211drv.c:				("80211> AuthMode = %d\n", pAd->StaCfg.AuthMode));
+os/linux/cfg80211drv.c:				("80211> EncrypType = %d\n", pAd->StaCfg.WepStatus));
+os/linux/cfg80211drv.c:		pAd->StaCfg.DefaultKeyId = pConnInfo->KeyIdx; /* base 0 */
+os/linux/cfg80211drv.c:					("80211> pAd->StaCfg.DefaultKeyId = %d\n",
+os/linux/cfg80211drv.c:					pAd->StaCfg.DefaultKeyId));
+os/linux/cfg80211drv.c:	pAd->FlgCfg80211Connecting = TRUE;
+os/linux/cfg80211drv.c:	pAd->Cfg80211_Alpha2[0] = pRegInfo->Alpha2[0];
+os/linux/cfg80211drv.c:	pAd->Cfg80211_Alpha2[1] = pRegInfo->Alpha2[1];
+os/linux/cfg80211drv.c:	pSurveyInfo->pCfg80211 = pAd->pCfg80211_CB;
+os/linux/cfg80211drv.c:	pSurveyInfo->ChannelTimeBusy = pAd->QloadLatestChannelBusyTimePri;
+os/linux/cfg80211drv.c:	pSurveyInfo->ChannelTimeExtBusy = pAd->QloadLatestChannelBusyTimeSec;
+os/linux/cfg80211drv.c:	if (pAd->pCfg80211_CB == NULL)
+os/linux/cfg80211drv.c:	CFG80211OS_UnRegister(pAd->pCfg80211_CB, pNetDev);
+os/linux/cfg80211drv.c:	pAd->Cfg80211RegisterActionFrame = FALSE, 
+os/linux/cfg80211drv.c:	pAd->Cfg80211ActionCount = 0;
+os/linux/cfg80211drv.c:	pAd->Cfg80211RegisterProbeReqFrame = FALSE;
+os/linux/cfg80211drv.c:	pAd->Cfg80211ProbeReqCount = 0;	
+os/linux/cfg80211drv.c:	pAd->pCfg80211_CB = NULL;
+os/linux/cfg80211drv.c:	pAd->CommonCfg.HT_Disable = 0;
+os/linux/cfg80211drv.c:        if (pAd->pCfg80211ChanList != NULL)
+os/linux/cfg80211drv.c:                os_free_mem(NULL, pAd->pCfg80211ChanList);
+os/linux/cfg80211drv.c:                pAd->pCfg80211ChanList = NULL;
+os/linux/cfg80211drv.c:                pAd->Cfg80211ChanListLan = 0;
+os/linux/cfg80211drv.c:        if (pAd->pTxStatusBuf != NULL)
+os/linux/cfg80211drv.c:                os_free_mem(NULL, pAd->pTxStatusBuf);
+os/linux/cfg80211drv.c:                pAd->pTxStatusBuf = NULL;
+os/linux/cfg80211drv.c:        if (pAd->beacon_tail_buf != NULL)
+os/linux/cfg80211drv.c:                os_free_mem(NULL, pAd->beacon_tail_buf);
+os/linux/cfg80211drv.c:                pAd->beacon_tail_buf = NULL;
+os/linux/cfg80211drv.c:	CFG80211_CB *p80211CB = pAd->pCfg80211_CB;
+os/linux/cfg80211drv.c:	pAd->FlgCfg80211Connecting = FALSE;
+os/linux/cfg80211drv.c:	if ((pAd->Cfg80211VifDevSet.vifDevList.size > 0) &&        
+os/linux/cfg80211drv.c:	CFG80211_CB *p80211CB = pAd->pCfg80211_CB;
+os/linux/cfg80211drv.c:	pAd->StaCfg.bAutoReconnect = FALSE;
+os/linux/cfg80211drv.c:	//cfg80211_disconnected(pAd->net_dev, 0, NULL, 0, GFP_KERNEL);
+os/linux/cfg80211drv.c:		   cfg80211_connect_result(pAd->net_dev, NULL, NULL, 0, NULL, 0,
+os/linux/cfg80211drv.c:		   cfg80211_disconnected(pAd->net_dev, 0, NULL, 0, GFP_KERNEL);
+os/linux/cfg80211drv.c:	if (pAd->Cfg80211RocTimerRunning == TRUE)
+os/linux/cfg80211drv.c:			RTMPCancelTimer(&pAd->Cfg80211RemainOnChannelDurationTimer, &Cancelled);
+os/linux/cfg80211drv.c:			pAd->Cfg80211RocTimerRunning = FALSE;
+os/linux/cfg80211drv.c://	cfg80211_remain_on_channel_expired(pAd->dummy_p2p_net_dev, cookie, pAd->CfgChanInfo.chan, 
+os/linux/cfg80211drv.c://				pAd->CfgChanInfo.ChanType, GFP_KERNEL);
+os/linux/cfg80211drv.c:	if ( pAd->ApCfg.ApCliTab[MAIN_MBSSID].Valid && 
+os/linux/cfg80211drv.c:	    (pAd->ApCliMlmeAux.Channel != pChanInfo->ChanId) &&
+os/linux/cfg80211drv.c:           (pAd->ApCliMlmeAux.Channel == pAd->LatchRfRegs.Channel))	
+os/linux/cfg80211drv.c:	    (pAd->CommonCfg.Channel != pChanInfo->ChanId) &&
+os/linux/cfg80211drv.c:           (pAd->CommonCfg.Channel == pAd->LatchRfRegs.Channel))	
+os/linux/cfg80211drv.c:		  RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, 
+os/linux/cfg80211drv.c:	if (pAd->LatchRfRegs.Channel != pChanInfo->ChanId) 
+os/linux/cfg80211drv.c:	cfg80211_ready_on_channel(pAd->dummy_p2p_net_dev,  pChanInfo->cookie, pChanInfo->chan, pChanInfo->ChanType, duration, GFP_KERNEL);
+os/linux/cfg80211drv.c:	NdisCopyMemory(&pAd->CfgChanInfo, pChanInfo, sizeof(CMD_RTPRIV_IOCTL_80211_CHAN));
+os/linux/cfg80211drv.c:	if (pAd->Cfg80211RocTimerInit == FALSE)
+os/linux/cfg80211drv.c:		RTMPInitTimer(pAd, &pAd->Cfg80211RemainOnChannelDurationTimer, GET_TIMER_FUNCTION(RemainOnChannelTimeout), pAd, FALSE);
+os/linux/cfg80211drv.c:		pAd->Cfg80211RocTimerInit = TRUE;
+os/linux/cfg80211drv.c:	if (pAd->Cfg80211RocTimerRunning == TRUE)
+os/linux/cfg80211drv.c:		RTMPCancelTimer(&pAd->Cfg80211RemainOnChannelDurationTimer, &Cancelled);
+os/linux/cfg80211drv.c:		pAd->Cfg80211RocTimerRunning = FALSE;
+os/linux/cfg80211drv.c:	RTMPSetTimer(&pAd->Cfg80211RemainOnChannelDurationTimer, duration + 20);
+os/linux/cfg80211drv.c:	pAd->Cfg80211RocTimerRunning = TRUE;
+os/linux/cfg80211drv.c:	RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+os/linux/cfg80211drv.c:	NdisZeroMemory(pAd->ChannelList,
+os/linux/cfg80211drv.c:	pRadarDetect = &pAd->CommonCfg.RadarDetect;
+os/linux/cfg80211drv.c:					if (pAd->CommonCfg.DfsType != MAX_RD_REGION)
+os/linux/cfg80211drv.c:						DfsType = pAd->CommonCfg.DfsType;
+os/linux/cfg80211drv.c:			if ((pAd->CommonCfg.PhyMode == PHY_11A) ||
+os/linux/cfg80211drv.c:				(pAd->CommonCfg.PhyMode == PHY_11AN_MIXED))
+os/linux/cfg80211drv.c:			if ((pAd->CommonCfg.PhyMode != PHY_11A) &&
+os/linux/cfg80211drv.c:				(pAd->CommonCfg.PhyMode != PHY_11ABG_MIXED) &&
+os/linux/cfg80211drv.c:				(pAd->CommonCfg.PhyMode != PHY_11AN_MIXED) &&
+os/linux/cfg80211drv.c:				(pAd->CommonCfg.PhyMode != PHY_11ABGN_MIXED) &&
+os/linux/cfg80211drv.c:				(pAd->CommonCfg.PhyMode != PHY_11AGN_MIXED))
+os/linux/cfg80211drv.c:				if (ChanId == pAd->TxPower[IdPwr].Channel)
+os/linux/cfg80211drv.c:					NdisMoveMemory(&pAd->ChannelList[RecId],
+os/linux/cfg80211drv.c:									&pAd->TxPower[IdPwr],
+os/linux/cfg80211drv.c:					pAd->ChannelList[RecId].Channel = ChanId;
+os/linux/cfg80211drv.c:					pAd->ChannelList[RecId].MaxTxPwr = Power;
+os/linux/cfg80211drv.c:						pAd->ChannelList[RecId].DfsReq = TRUE;
+os/linux/cfg80211drv.c:						pAd->ChannelList[RecId].DfsReq = FALSE;
+os/linux/cfg80211drv.c:					pAd->ChannelList[RecId].RegulatoryDomain = DfsType;
+os/linux/cfg80211drv.c:					pAd->CommonCfg.RDDurRegion = DfsType;
+os/linux/cfg80211drv.c:	pAd->ChannelListNum = RecId;
+os/linux/cfg80211drv.c:	RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+os/linux/cfg80211drv.c:	VOID *pCfg80211_CB = pAd->pCfg80211_CB;
+os/linux/cfg80211drv.c:	if ((pAd->FlgCfg80211Scanning == FALSE) &&
+os/linux/cfg80211drv.c:		(pAd->FlgCfg80211Connecting == FALSE))
+os/linux/cfg80211drv.c:	if (WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+os/linux/cfg80211drv.c:	if (pAd->CommonCfg.RegTransmitSetting.field.BW == BW_20)
+os/linux/cfg80211drv.c:	CFG80211_CB *pCfg80211_CB  = (CFG80211_CB *)pAd->pCfg80211_CB;
+os/linux/cfg80211drv.c:	if (pAd->FlgCfg80211Scanning == FALSE)
+os/linux/cfg80211drv.c:		for (index = 0; index < pAd->ScanTab.BssNr; index++) 
+os/linux/cfg80211drv.c:			pBssEntry = &pAd->ScanTab.BssEntry[index];
+os/linux/cfg80211drv.c:			if (pAd->ScanTab.BssEntry[index].Channel > 14) 
+os/linux/cfg80211drv.c:				CenFreq = ieee80211_channel_to_frequency(pAd->ScanTab.BssEntry[index].Channel , IEEE80211_BAND_5GHZ);
+os/linux/cfg80211drv.c:				CenFreq = ieee80211_channel_to_frequency(pAd->ScanTab.BssEntry[index].Channel , IEEE80211_BAND_2GHZ);
+os/linux/cfg80211drv.c:			CenFreq = ieee80211_channel_to_frequency(pAd->ScanTab.BssEntry[index].Channel);
+os/linux/cfg80211drv.c:	pAd->FlgCfg80211Scanning = FALSE;
+os/linux/cfg80211drv.c:	pAd->FlgCfg80211Connecting = FALSE;
+os/linux/cfg80211drv.c:	CFG80211OS_P2pClientConnectResultInform(pAd->ApCfg.ApCliTab[MAIN_MBSSID].dev, pBSSID, 
+os/linux/cfg80211drv.c:	pAd->FlgCfg80211Connecting = FALSE;
+os/linux/cfg80211drv.c:    pAd->StaCfg.DefaultKeyId = Data; /* base 0 */
+os/linux/cfg80211drv.c:    pAd->ApCfg.MBSSID[MAIN_MBSSID].DefaultKeyId = Data;
+os/linux/cfg80211drv.c:	pAd->Cfg80211RegisterProbeReqFrame = FALSE;
+os/linux/cfg80211drv.c:	pAd->Cfg80211RegisterActionFrame = FALSE;
+os/linux/cfg80211drv.c:	pAd->Cfg80211ProbeReqCount = 0;
+os/linux/cfg80211drv.c:	pAd->Cfg80211ActionCount = 0;
+os/linux/cfg80211drv.c:	pAd->Cfg80211RocTimerInit = FALSE;
+os/linux/cfg80211drv.c:	pAd->Cfg80211RocTimerRunning = FALSE;
+os/linux/cfg80211drv.c:	pAd->FlgCfg80211Scanning = FALSE;
+os/linux/cfg80211drv.c:	CFG80211_CB *p80211CB = pAd->pCfg80211_CB;
+os/linux/cfg80211drv.c:        CFG80211_CB *pCfg80211_CB  = (CFG80211_CB *)pAd->pCfg80211_CB;
+os/linux/cfg80211drv.c:    CFG80211_CB *pCfg80211_CB  = (CFG80211_CB *)pAd->pCfg80211_CB;
+os/linux/cfg80211drv.c:        if (MAC_ADDR_EQUAL(pAd->ApCliMlmeAux.Bssid, ZERO_MAC_ADDR))
+os/linux/cfg80211drv.c:		CFG80211DBG(RT_DEBUG_ERROR, ("pAd->ApCliMlmeAux.Bssid ==> ZERO_MAC_ADDR\n"));
+os/linux/cfg80211drv.c:		//ToDo: pAd->ApCfg.ApCliTab[0].CfgApCliBssid
+os/linux/cfg80211drv.c:	bss = cfg80211_get_bss(pWiphy, NULL, pAd->ApCliMlmeAux.Bssid,
+os/linux/cfg80211drv.c:			       pAd->ApCliMlmeAux.Ssid, pAd->ApCliMlmeAux.SsidLen, 
+os/linux/cfg80211drv.c:		DBGPRINT(RT_DEBUG_TRACE, ("Found %s in Kernel_ScanTable with CH[%d]\n", pAd->ApCliMlmeAux.Ssid, bss->channel->center_freq));
+os/linux/cfg80211drv.c:		DBGPRINT(RT_DEBUG_ERROR, ("Can't Found %s in Kernel_ScanTable & Try Fake it\n", pAd->ApCliMlmeAux.Ssid));
+os/linux/cfg80211drv.c:	bss_idx = BssSsidTableSearchBySSID(&pAd->ScanTab, pAd->ApCliMlmeAux.Ssid, pAd->ApCliMlmeAux.SsidLen);
+os/linux/cfg80211drv.c:		pBssEntry = &pAd->ScanTab.BssEntry[bss_idx];
+os/linux/cfg80211drv.c:		if (pAd->ScanTab.BssEntry[bss_idx].Channel > 14)
+os/linux/cfg80211drv.c:		ieLen = 2 + pAd->ApCliMlmeAux.SsidLen + pBssEntry->VarIeFromProbeRspLen;
+os/linux/cfg80211drv.c:		ie[1] = pAd->ApCliMlmeAux.SsidLen;
+os/linux/cfg80211drv.c:		NdisCopyMemory(ie + 2, pAd->ApCliMlmeAux.Ssid, pAd->ApCliMlmeAux.SsidLen);
+os/linux/cfg80211drv.c:		NdisCopyMemory(ie + 2 + pAd->ApCliMlmeAux.SsidLen, pBssEntry->pVarIeFromProbRsp, 
+os/linux/cfg80211drv.c:					  pAd->ApCliMlmeAux.Bssid, timestamp, WLAN_CAPABILITY_ESS, pAd->ApCliMlmeAux.BeaconPeriod,
+os/linux/cfg80211drv.c:					pAd->ApCliMlmeAux.Ssid, 
+os/linux/cfg80211drv.c:					PRINT_MAC(pAd->ApCliMlmeAux.Bssid),bss->channel->center_freq, pBssEntry->Channel,
+os/linux/cfg80211drv.c:					pAd->ApCliMlmeAux.BeaconPeriod, pBssEntry->VarIeFromProbeRspLen);	
+os/linux/cfg80211drv.c:		printk("%s Not In Driver Scan Table\n", pAd->ApCliMlmeAux.Ssid);
+os/linux/cfg80211drv.c:        CFG80211_CB *pCfg80211_CB  = (CFG80211_CB *)pAd->pCfg80211_CB;
+os/linux/vr_ikans.c:	pAd->IkanosTxInfo.netdev = pNetDev;
+os/linux/vr_ikans.c:	pAd->IkanosTxInfo.fp = fp;
+os/linux/vr_ikans.c:	pSkb->apFlowData.txHandle = &(pAd->IkanosTxInfo);
+os/linux/vr_ikans.c:	/*dev = pAd->ApCfg.MBSSID[index].MSSIDDev; */
+os/linux/vr_ikans.c:    pAd->IkanosRxInfo[index].netdev = dev;
+os/linux/vr_ikans.c:    pAd->IkanosRxInfo[index].fp = &IKANOS_WlanDataFramesTx;
+os/linux/vr_ikans.c:    skb->apFlowData.rxHandle = &(pAd->IkanosRxInfo[index]);
+os/linux/rt_profile.c:		src = (PSTRING)pAd->MC_FileName;
+os/linux/rt_profile.c:		for (i = 0; i < pAd->ApCfg.BssidNum; i++)
+os/linux/rt_profile.c:			pAd->ApCfg.MBSSID[i].Hostapd=FALSE;
+os/linux/rt_profile.c:	if (pAd->CommonCfg.bWirelessEvent == FALSE)
+os/linux/rt_profile.c:		RtmpOSWrielessEventSend(pAd->net_dev, RT_WLAN_EVENT_CUSTOM, Event_flag, NULL, (PUCHAR)pBuf, BufLen);
+os/linux/rt_profile.c:	pAd->IndicateMediaState = media_state;
+os/linux/rt_profile.c:		if (pAd->IndicateMediaState == NdisMediaStateConnected)
+os/linux/rt_profile.c:			RTMPSendWirelessEvent(pAd, IW_STA_LINKUP_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
+os/linux/rt_profile.c:			RTMPSendWirelessEvent(pAd, IW_STA_LINKDOWN_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0); 		
+os/linux/rt_profile.c:			|| (pAd->VifNextMode == RT_CMD_80211_IFTYPE_AP)	
+os/linux/rt_profile.c:	if (pAd->OpMode == OPMODE_AP)
+os/linux/rt_profile.c:		if ((pAd->ApCfg.DtimCount + 1) == pAd->ApCfg.DtimPeriod)
+os/linux/rt_profile.c:/*			NdisAcquireSpinLock(&pAd->MacTabLock); */
+os/linux/rt_profile.c:/*			NdisAcquireSpinLock(&pAd->TxSwQueueLock); */
+os/linux/rt_profile.c:			RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+os/linux/rt_profile.c:			while (pAd->MacTab.McastPsQueue.Head)
+os/linux/rt_profile.c:				if (pAd->TxSwQueue[QID_AC_BE].Number <= (pAd->TxSwQMaxLen + MAX_PACKETS_IN_MCAST_PS_QUEUE))
+os/linux/rt_profile.c:					pEntry = RemoveHeadQueue(&pAd->MacTab.McastPsQueue);
+os/linux/rt_profile.c:					/*if(pAd->MacTab.McastPsQueue.Number) */
+os/linux/rt_profile.c:					InsertHeadQueue(&pAd->TxSwQueue[QID_AC_BE], pEntry);
+os/linux/rt_profile.c:			RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+os/linux/rt_profile.c:/*			NdisReleaseSpinLock(&pAd->TxSwQueueLock); */
+os/linux/rt_profile.c:/*			NdisReleaseSpinLock(&pAd->MacTabLock); */
+os/linux/rt_profile.c:			if (pAd->MacTab.McastPsQueue.Number == 0)
+os/linux/rt_profile.c:				for(bss_index=BSS0; bss_index<pAd->ApCfg.BssidNum; bss_index++)
+os/linux/rt_profile.c:			pAd->MacTab.PsQIdleCount = 0;
+os/linux/rt_profile.c:	if (ppa_hook_directpath_send_fn && pAd->PPAEnable==TRUE ) 
+os/linux/rt_profile.c:	BssMonitorFlag11n = (pAd->StaCfg.BssMonitorFlag & MONITOR_FLAG_11N_SNIFFER);
+os/linux/rt_profile.c:	pDevName = (UCHAR *)RtmpOsGetNetDevName(pAd->net_dev);
+os/linux/rt_profile.c:	Channel = pAd->CommonCfg.Channel;
+os/linux/rt_profile.c:	CentralChannel = pAd->CommonCfg.CentralChannel;
+os/linux/rt_profile.c:	os_cookie=(POS_COOKIE)pAd->OS_Cookie;
+os/linux/rt_profile.c:	if (pAd->BeaconBuf)
+os/linux/rt_profile.c:		os_free_mem(NULL, pAd->BeaconBuf);
+os/linux/rt_profile.c:	NdisFreeSpinLock(&pAd->MgmtRingLock);
+os/linux/rt_profile.c:		NdisFreeSpinLock(&pAd->TxSwQueueLock[index]);
+os/linux/rt_profile.c:		NdisFreeSpinLock(&pAd->DeQueueLock[index]);
+os/linux/rt_profile.c:		pAd->DeQueueRunning[index] = FALSE;
+os/linux/rt_profile.c:	NdisFreeSpinLock(&pAd->irq_lock);
+os/linux/rt_profile.c:	NdisFreeSpinLock(&pAd->UAPSDEOSPLock); /* OS_ABL_SUPPORT */
+os/linux/rt_profile.c:	NdisFreeSpinLock(&pAd->mpdu_blk_pool.lock);
+os/linux/rt_profile.c:	if (pAd->iw_stats)
+os/linux/rt_profile.c:		os_free_mem(NULL, pAd->iw_stats);
+os/linux/rt_profile.c:		pAd->iw_stats = NULL;
+os/linux/rt_profile.c:	if (pAd->stats)
+os/linux/rt_profile.c:		os_free_mem(NULL, pAd->stats);
+os/linux/rt_profile.c:		pAd->stats = NULL;
+os/linux/rt_profile.c:	RTMP_OS_ATMOIC_DESTROY(&pAd->BulkOutRemained);
+os/linux/rt_profile.c:	RTMP_OS_ATMOIC_DESTROY(&pAd->BulkInRemained);
+os/linux/rt_profile.c:	INC_COUNTER64(pAd->WlanCounters.TransmitCountFrmOs);
+os/linux/rt_profile.c:			dev_p = pAd->ApCfg.MBSSID[BSS0].MSSIDDev;
+os/linux/rt_profile.c:			dev_p = (infRealIdx >= MAX_APCLI_NUM ? NULL : pAd->ApCfg.ApCliTab[infRealIdx].dev);
+os/linux/rt_profile.c:			(FromWhichBSSID < pAd->ApCfg.BssidNum) &&
+os/linux/rt_profile.c:    	    		dev_p = pAd->ApCfg.MBSSID[FromWhichBSSID].MSSIDDev;
+os/linux/rt_profile.c:			dev_p = pAd->net_dev;
+os/linux/rt_profile.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+os/linux/rt_profile.c:/*    	if (!RTMPEqualMemory(net_dev->name, pAd->net_dev->name, 3))  // for multi-physical card, no MBSSID */
+os/linux/rt_profile.c:		if (strcmp(pConfig->name, RtmpOsGetNetDevName(pAd->net_dev)) != 0) /* sample */
+os/linux/rt_profile.c:	        for (index = 1; index < pAd->ApCfg.BssidNum; index++)
+os/linux/rt_profile.c:	    	    if (pAd->ApCfg.MBSSID[index].MSSIDDev == pConfig->net_dev)
+os/linux/rt_profile.c:	        if(index == pAd->ApCfg.BssidNum)
+os/linux/rt_profile.c:			if (pAd->ApCfg.ApCliTab[index].dev == pConfig->net_dev)
+os/linux/cfg80211_inf.c:	return pAd->Cfg80211VifDevSet.isGoingOn;
+os/linux/cfg80211_inf.c:	if ((pAd->Cfg80211VifDevSet.vifDevList.size > 0) &&
+os/linux/cfg80211_inf.c:        if ((pAd->Cfg80211VifDevSet.vifDevList.size > 0) &&
+os/linux/cfg80211_inf.c:	PLIST_HEADER  pCacheList = &pAd->Cfg80211VifDevSet.vifDevList;
+os/linux/cfg80211_inf.c:	PLIST_HEADER  pCacheList = &pAd->Cfg80211VifDevSet.vifDevList;
+os/linux/cfg80211_inf.c:		insertTailList(&pAd->Cfg80211VifDevSet.vifDevList, (PLIST_ENTRY)pNewVifDev);	
+os/linux/cfg80211_inf.c:		delEntryList(&pAd->Cfg80211VifDevSet.vifDevList, pListEntry);
+os/linux/cfg80211_inf.c:	//return pAd->Cfg80211VifDevSet.Cfg80211VifDev[0].net_dev;
+os/linux/cfg80211_inf.c:        PLIST_HEADER  pCacheList = &pAd->Cfg80211VifDevSet.vifDevList;
+os/linux/cfg80211_inf.c:	pAd->flg_apcli_init = FALSE;
+os/linux/cfg80211_inf.c:	pAd->ApCfg.ApCliTab[MAIN_MBSSID].dev = NULL;
+os/linux/cfg80211_inf.c:		pAd->flg_apcli_init = TRUE;
+os/linux/cfg80211_inf.c:		CFG80211OS_ScanEnd(pAd->pCfg80211_CB, TRUE);
+os/linux/cfg80211_inf.c:	CFG80211_CB *p80211CB = pAd->pCfg80211_CB;
+os/linux/cfg80211_inf.c:	NdisMoveMemory(&pNetDevOps->devAddr[0], &pAd->CurrentAddress[0], MAC_ADDR_LEN);
+os/linux/cfg80211_inf.c:	if (pAd->chipCap.MBSSIDMode == MBSSID_MODE1)
+os/linux/cfg80211_inf.c:			pAd->ApCfg.ApCliTab[MAIN_MBSSID].dev = NULL;
+os/linux/cfg80211_inf.c:			pApCliEntry = &pAd->ApCfg.ApCliTab[MAIN_MBSSID];
+os/linux/cfg80211_inf.c:			COPY_MAC_ADDR(pAd->P2PCurrentAddress, pNetDevOps->devAddr);
+os/linux/cfg80211_inf.c:			COPY_MAC_ADDR(pApCliEntry->CurrentAddress, pAd->P2PCurrentAddress);
+os/linux/cfg80211_inf.c:			pAd->ApCfg.MBSSID[MAIN_MBSSID].MSSIDDev = NULL;
+os/linux/cfg80211_inf.c:			//pAd->ApCfg.MBSSID[MAIN_MBSSID].MSSIDDev = new_dev_p;
+os/linux/cfg80211_inf.c:			pAd->VifNextMode = RT_CMD_80211_IFTYPE_AP;
+os/linux/cfg80211_inf.c:			COPY_MAC_ADDR(pAd->P2PCurrentAddress, pNetDevOps->devAddr);
+os/linux/cfg80211_inf.c:	RtmpOSNetDevAttach(pAd->OpMode, new_dev_p, pNetDevOps);
+os/linux/cfg80211_inf.c:	AsicSetBssid(pAd, pAd->CurrentAddress); 
+os/linux/cfg80211_inf.c:	//	pAd->flg_apcli_init = TRUE;
+os/linux/cfg80211_inf.c:		pAd->Cfg80211VifDevSet.isGoingOn = FALSE;
+os/linux/cfg80211_inf.c:			pAd->ApCfg.MBSSID[MAIN_MBSSID].MSSIDDev = NULL;
+os/linux/cfg80211_inf.c:		else if (pAd->flg_apcli_init)
+os/linux/cfg80211_inf.c:			pAd->flg_apcli_init = FALSE;
+os/linux/cfg80211_inf.c:			pAd->ApCfg.ApCliTab[MAIN_MBSSID].dev = NULL;
+os/linux/cfg80211_inf.c:	pAd->RalinkCounters.PendingNdisPacketCount ++;
+os/linux/cfg80211_inf.c:	SET_OS_PKT_NETDEV(pPktSrc, pAd->net_dev);
+os/linux/cfg80211_inf.c:	PNET_DEV dummy_p2p_dev = (PNET_DEV)pAd->dummy_p2p_net_dev;
+os/linux/cfg80211_inf.c:	if (pAd->dummy_p2p_net_dev)
+os/linux/cfg80211_inf.c:		RTMP_OS_NETDEV_STOP_QUEUE(pAd->dummy_p2p_net_dev);
+os/linux/cfg80211_inf.c:		RtmpOSNetDevDetach(pAd->dummy_p2p_net_dev);
+os/linux/cfg80211_inf.c:		RtmpOSNetDevFree(pAd->dummy_p2p_net_dev);	
+os/linux/cfg80211_inf.c:		pAd->flg_cfg_dummy_p2p_init = FALSE;
+os/linux/cfg80211_inf.c:	CFG80211_CB *p80211CB = pAd->pCfg80211_CB;
+os/linux/cfg80211_inf.c:	if (pAd->flg_cfg_dummy_p2p_init != FALSE)
+os/linux/cfg80211_inf.c:	NdisMoveMemory(&pNetDevOps->devAddr[0], &pAd->CurrentAddress[0], MAC_ADDR_LEN);
+os/linux/cfg80211_inf.c:	RtmpOSNetDevAttach(pAd->OpMode, new_dev_p, pNetDevOps); 
+os/linux/cfg80211_inf.c:	pAd->dummy_p2p_net_dev = new_dev_p;
+os/linux/cfg80211_inf.c:	pAd->flg_cfg_dummy_p2p_init = TRUE;	
+os/linux/cfg80211.c:		; //pAd->isCfgDeviceInP2p = TRUE;
+os/linux/rt_usb.c:	pTask = &pAd->timerTask;
+os/linux/rt_usb.c:		printk (KERN_WARNING "%s: unable to start RtmpTimerQThread\n", RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev));
+os/linux/rt_usb.c:	pTask = &pAd->mlmeTask;
+os/linux/rt_usb.c:		printk (KERN_WARNING "%s: unable to start MlmeThread\n", RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev));
+os/linux/rt_usb.c:	pTask = &pAd->cmdQTask;
+os/linux/rt_usb.c:		printk (KERN_WARNING "%s: unable to start RTUSBCmdThread\n", RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev));
+os/linux/rt_usb.c:	pTask = &pAd->mlmeTask;
+os/linux/rt_usb.c:/*					RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev), pTask->taskName)); */
+os/linux/rt_usb.c:	pTask = &pAd->cmdQTask;
+os/linux/rt_usb.c:		NdisAcquireSpinLock(&pAd->CmdQLock);
+os/linux/rt_usb.c:		pAd->CmdQ.CmdQState = RTMP_TASK_STAT_STOPED;
+os/linux/rt_usb.c:		NdisReleaseSpinLock(&pAd->CmdQLock);
+os/linux/rt_usb.c:		/*RTUSBCMDUp(&pAd->cmdQTask); */
+os/linux/rt_usb.c:/*					RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev), pTask->taskName)); */
+os/linux/rt_usb.c:		pAd->CmdQ.CmdQState = RTMP_TASK_STAT_UNKNOWN;
+os/linux/rt_usb.c:	pTask = &pAd->timerTask;
+os/linux/rt_usb.c:/*					RTMP_OS_NETDEV_GET_DEVNAME(pAd->net_dev), pTask->taskName)); */
+os/linux/rt_usb.c:	pObj 			= (POS_COOKIE) pAd->OS_Cookie;
+os/linux/rt_usb.c:	pAd->BulkOutDataOneSecCount++;
+os/linux/rt_usb.c:	RTMP_IRQ_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+os/linux/rt_usb.c:	pAd->BulkOutPending[BulkOutPipeId] = FALSE;
+os/linux/rt_usb.c:	pAd->watchDogTxPendingCnt[BulkOutPipeId] = 0;
+os/linux/rt_usb.c:		pAd->BulkOutComplete++;
+os/linux/rt_usb.c:		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+os/linux/rt_usb.c:		pAd->Counters8023.GoodTransmits++;
+os/linux/rt_usb.c:		/*RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags); */
+os/linux/rt_usb.c:		/*RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags); */
+os/linux/rt_usb.c:	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags2);
+os/linux/rt_usb.c:	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags2);
+os/linux/rt_usb.c:		pAd->BulkOutCompleteOther++;
+os/linux/rt_usb.c:			pAd->bulkResetPipeid = BulkOutPipeId;
+os/linux/rt_usb.c:			pAd->bulkResetReq[BulkOutPipeId] = pAd->BulkOutReq;
+os/linux/rt_usb.c:		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+os/linux/rt_usb.c:		DBGPRINT_RAW(RT_DEBUG_ERROR, ("\t>>BulkOut Req=0x%lx, Complete=0x%lx, Other=0x%lx\n", pAd->BulkOutReq, pAd->BulkOutComplete, pAd->BulkOutCompleteOther));
+os/linux/rt_usb.c:		/*DBGPRINT_RAW(RT_DEBUG_ERROR, (">>BulkOutCompleteCancel=0x%x, BulkOutCompleteOther=0x%x\n", pAd->BulkOutCompleteCancel, pAd->BulkOutCompleteOther)); */
+os/linux/rt_usb.c:	/*RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags); */
+os/linux/rt_usb.c:	/*RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[BulkOutPipeId], IrqFlags); */
+os/linux/rt_usb.c:	RTMP_IRQ_LOCK(&pAd->BulkOutLock[0], irqFlag);
+os/linux/rt_usb.c:	pAd->BulkOutPending[0] = FALSE;
+os/linux/rt_usb.c:	pAd->watchDogTxPendingCnt[0] = 0;
+os/linux/rt_usb.c:		RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
+os/linux/rt_usb.c:			pAd->bulkResetPipeid = (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
+os/linux/rt_usb.c:			RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
+os/linux/rt_usb.c:			RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[0], irqFlag);
+os/linux/rt_usb.c:	pAd->watchDogTxPendingCnt[0] = 0;
+os/linux/rt_usb.c:			pAd->bulkResetPipeid = (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
+os/linux/rt_usb.c:	RTMP_SEM_LOCK(&pAd->BulkOutLock[0]);
+os/linux/rt_usb.c:	pAd->BulkOutPending[0] = FALSE;
+os/linux/rt_usb.c:	RTMP_SEM_UNLOCK(&pAd->BulkOutLock[0]);
+os/linux/rt_usb.c:	RTMP_IRQ_LOCK(&pAd->BulkInLock, IrqFlags);
+os/linux/rt_usb.c:	/*NdisInterlockedDecrement(&pAd->PendingRx); */
+os/linux/rt_usb.c:	if ( pAd->PendingRx > 0 )
+os/linux/rt_usb.c:	pAd->PendingRx--;
+os/linux/rt_usb.c:		pAd->BulkInComplete++;
+os/linux/rt_usb.c:		pAd->NextRxBulkInPosition = 0;
+os/linux/rt_usb.c:			INC_RING_INDEX(pAd->NextRxBulkInIndex, RX_RING_SIZE);
+os/linux/rt_usb.c:		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
+os/linux/rt_usb.c:		pAd->BulkInCompleteFail++;
+os/linux/rt_usb.c:		RTMP_IRQ_UNLOCK(&pAd->BulkInLock, IrqFlags);
+os/linux/rt_usb.c:							Status, pAd->NextRxBulkInIndex, pAd->NextRxBulkInReadIndex, RTMP_USB_URB_LEN_GET(pRxContext->pUrb))); /*->actual_length)); */
+os/linux/rt_usb.c:		if (pAd->ContinBulkIn == TRUE)		
+os/linux/rt_usb.c:	RTMP_IRQ_LOCK(&pAd->CmdRspLock, IrqFlags);
+os/linux/rt_usb.c:	RTMP_IRQ_UNLOCK(&pAd->CmdRspLock, IrqFlags);
+os/linux/rt_usb.c:		RTMP_IRQ_LOCK(&pAd->CmdRspLock, IrqFlags);
+os/linux/rt_usb.c:		RTMP_IRQ_UNLOCK(&pAd->CmdRspLock, IrqFlags);
+os/linux/rt_usb.c:		RTMP_IRQ_LOCK(&pAd->CmdRspLock, IrqFlags);
+os/linux/rt_usb.c:		RTMP_IRQ_UNLOCK(&pAd->CmdRspLock, IrqFlags);
+os/linux/rt_usb.c:	ASSERT((pAd->MgmtRing.TxDmaIdx == index));
+os/linux/rt_usb.c:	RTMP_IRQ_LOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
+os/linux/rt_usb.c:		MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[pMLMEContext->Wcid];
+os/linux/rt_usb.c:			MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[pMLMEContext->Wcid];
+os/linux/rt_usb.c:			pAd->bulkResetPipeid = (MGMTPIPEIDX | BULKOUT_MGMT_RESET_FLAG);
+os/linux/rt_usb.c:	pAd->BulkOutPending[MGMTPIPEIDX] = FALSE;
+os/linux/rt_usb.c:	RTMP_IRQ_UNLOCK(&pAd->BulkOutLock[MGMTPIPEIDX], IrqFlags);
+os/linux/rt_usb.c:	RTMP_IRQ_LOCK(&pAd->MLMEBulkOutLock, IrqFlags);
+os/linux/rt_usb.c:	pPacket = pAd->MgmtRing.Cell[index].pNdisPacket;
+os/linux/rt_usb.c:	pAd->MgmtRing.Cell[index].pNdisPacket = NULL;
+os/linux/rt_usb.c:	INC_RING_INDEX(pAd->MgmtRing.TxDmaIdx, MGMT_RING_SIZE);
+os/linux/rt_usb.c:	pAd->MgmtRing.TxSwFreeIdx++;
+os/linux/rt_usb.c:	RTMP_IRQ_UNLOCK(&pAd->MLMEBulkOutLock, IrqFlags);
+os/linux/rt_usb.c:	pHeader = (HEADER_802_11 *)(GET_OS_PKT_DATAPTR(pPacket)+ TXINFO_SIZE + pAd->chipCap.TXWISize);
+os/linux/rt_usb.c:	if (pAd->TxStatusInUsed /*&& (pAd->TxStatusSeq == pHeader->Sequence)*/)
+os/linux/rt_usb.c:		CFG80211OS_TxStatus(pAd->dummy_p2p_net_dev, 5678, pAd->pTxStatusBuf, pAd->TxStatusBufLen, TRUE);
+os/linux/rt_usb.c:		pAd->TxStatusSeq = 0;
+os/linux/rt_usb.c:		pAd->TxStatusInUsed = FALSE;
+os/linux/rt_usb.c:			((pAd->bulkResetPipeid & BULKOUT_MGMT_RESET_FLAG) == BULKOUT_MGMT_RESET_FLAG))
+os/linux/rt_usb.c:			if (pAd->MgmtRing.TxSwFreeIdx < MGMT_RING_SIZE /* pMLMEContext->bWaitingBulkOut == TRUE */)
+os/linux/rt_usb.c:		{	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
+os/linux/rt_usb.c:			if ((pAd->TxSwQueue[BulkOutPipeId].Number > 0) && 
+os/linux/rt_usb.c:				(pAd->DeQueueRunning[BulkOutPipeId] == FALSE) && 
+os/linux/rt_usb.c:		{	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
+os/linux/rt_usb.c:			if ((pAd->TxSwQueue[BulkOutPipeId].Number > 0) && 
+os/linux/rt_usb.c:				(pAd->DeQueueRunning[BulkOutPipeId] == FALSE) && 
+os/linux/rt_usb.c:		{	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
+os/linux/rt_usb.c:			if ((pAd->TxSwQueue[BulkOutPipeId].Number > 0) && 
+os/linux/rt_usb.c:				(pAd->DeQueueRunning[BulkOutPipeId] == FALSE) && 
+os/linux/rt_usb.c:		{	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
+os/linux/rt_usb.c:			if ((pAd->TxSwQueue[BulkOutPipeId].Number > 0) && 
+os/linux/rt_usb.c:				(pAd->DeQueueRunning[BulkOutPipeId] == FALSE) && 
+os/linux/rt_usb.c:		{	pHTTXContext = &pAd->TxContext[BulkOutPipeId];
+os/linux/rt_usb.c:			if ((pAd->TxSwQueue[BulkOutPipeId].Number > 0) && 
+os/linux/rt_usb.c:				(pAd->DeQueueRunning[BulkOutPipeId] == FALSE) &&
+os/linux/rt_usb.c:	pAd->BulkOutDataOneSecCount++;
+os/linux/rt_usb.c:		if ((ATE_ON(pAd)) && (pAd->ate.bQATxStart == TRUE))
+os/linux/rt_usb.c:			if (pAd->ate.QID == BulkOutPipeId)
+os/linux/rt_usb.c:				pAd->ate.TxDoneCount++;
+os/linux/rt_usb.c:				DBGPRINT(RT_DEBUG_INFO, ("pAd->ate.TxDoneCount == %d\n", pAd->ate.TxDoneCount));
+os/linux/rt_usb.c:				pAd->RalinkCounters.KickTxCount++;
+os/linux/rt_usb.c:				ASSERT(pAd->ate.QID == 0);
+os/linux/rt_usb.c:				pAd->ate.TxAc0++;
+os/linux/rt_usb.c:		pAd->BulkOutComplete++;
+os/linux/rt_usb.c:		pAd->Counters8023.GoodTransmits++;
+os/linux/rt_usb.c:		pAd->BulkOutCompleteOther++;
+os/linux/rt_usb.c:		DBGPRINT(RT_DEBUG_ERROR, (">>BulkOutReq=0x%lx, BulkOutComplete=0x%lx\n", pAd->BulkOutReq, pAd->BulkOutComplete));
+os/linux/rt_usb.c:			BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+os/linux/rt_usb.c:			pAd->BulkOutPending[BulkOutPipeId] = FALSE;
+os/linux/rt_usb.c:			pAd->bulkResetPipeid = BulkOutPipeId;
+os/linux/rt_usb.c:			BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+os/linux/rt_usb.c:	if (atomic_read(&pAd->BulkOutRemained) > 0)
+os/linux/rt_usb.c:		atomic_dec(&pAd->BulkOutRemained);
+os/linux/rt_usb.c:		DBGPRINT(RT_DEBUG_INFO, ("Bulk Out Remained = %d\n", atomic_read(&pAd->BulkOutRemained)));
+os/linux/rt_usb.c:	OldValue = pAd->WlanCounters.TransmittedFragmentCount.u.LowPart;
+os/linux/rt_usb.c:	pAd->WlanCounters.TransmittedFragmentCount.u.LowPart++;
+os/linux/rt_usb.c:	if (pAd->WlanCounters.TransmittedFragmentCount.u.LowPart < OldValue)
+os/linux/rt_usb.c:		pAd->WlanCounters.TransmittedFragmentCount.u.HighPart++;
+os/linux/rt_usb.c:	if (((pAd->ContinBulkOut == TRUE ) ||(atomic_read(&pAd->BulkOutRemained) > 0))
+os/linux/rt_usb.c:		&& (pAd->ate.Mode & ATE_TXFRAME))
+os/linux/rt_usb.c:		pAd->ate.TxStatus = 0;
+os/linux/rt_usb.c:	BULK_OUT_LOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);
+os/linux/rt_usb.c:	pAd->BulkOutPending[BulkOutPipeId] = FALSE;
+os/linux/rt_usb.c:	BULK_OUT_UNLOCK(&pAd->BulkOutLock[BulkOutPipeId], IrqFlags);	
+os/linux/rt_usb.c:	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
+os/linux/rt_usb.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+os/linux/rt_usb.c:		/*down(&(pAd->usbdev_semaphore)); */
+os/linux/rt_usb.c:		if (!pAd->PM_FlgSuspend)
+os/linux/rt_usb.c:	NdisAcquireSpinLock(&pAd->CmdQLock);
+os/linux/rt_usb.c:	pAd->CmdQ.CmdQState = RTMP_TASK_STAT_RUNNING;
+os/linux/rt_usb.c:	NdisReleaseSpinLock(&pAd->CmdQLock);
+os/linux/rt_usb.c:	while (pAd->CmdQ.CmdQState == RTMP_TASK_STAT_RUNNING)
+os/linux/rt_usb.c:		if (pAd->CmdQ.CmdQState == RTMP_TASK_STAT_STOPED)
+os/linux/rt_usb.c:		if (!pAd->PM_FlgSuspend)
+os/linux/rt_usb.c:	if (!pAd->PM_FlgSuspend)
+os/linux/rt_usb.c:		NdisAcquireSpinLock(&pAd->CmdQLock);
+os/linux/rt_usb.c:		pAd->CmdQ.CmdQState = RTMP_TASK_STAT_STOPED;
+os/linux/rt_usb.c:		while(pAd->CmdQ.size)
+os/linux/rt_usb.c:			RTThreadDequeueCmd(&pAd->CmdQ, &pCmdQElmt);
+os/linux/rt_usb.c:		NdisReleaseSpinLock(&pAd->CmdQLock);
+os/linux/rt_usb_util.c:	/*while((i < 25) && atomic_read(&pAd->PendingRx) > 0) */
+os/linux/sta_ioctl.c:/*	range->num_channels =  pAd->ChannelListNum; */
+os/linux/sta_ioctl.c:/*		MAP_CHANNEL_ID_TO_KHZ(pAd->ChannelList[i-1].Channel, m); */
+os/linux/sta_ioctl.c:/*    iq->updated = pAd->iw_stats.qual.updated; */
+os/linux/sta_ioctl.c:/*	iq->updated = ((struct iw_statistics *)(pAd->iw_stats))->qual.updated; */
+os/linux/sta_ioctl.c:		if (i >=  pBssList->BssNum) /*pAd->ScanTab.BssNr) */
+os/linux/sta_ioctl.c:		set_quality(pAd, &qual[i], pList); /*&pAd->ScanTab.BssEntry[i]); */
+os/linux/sta_ioctl.c:/*    pAd->StaCfg.bScanReqIsFromWebUI = FALSE; */
+os/linux/sta_ioctl.c:/*	DBGPRINT(RT_DEBUG_ERROR ,("===>rt_ioctl_giwscan. %d(%d) BSS returned, data->length = %d\n",i , pAd->ScanTab.BssNr, data->length)); */
+os/linux/sta_ioctl.c:/*	if (val != pAd->CommonCfg.RtsThreshold) */
+os/linux/sta_ioctl.c:/*		pAd->CommonCfg.RtsThreshold = val; */
+os/linux/sta_ioctl.c:/*	pAd->CommonCfg.FragmentThreshold = val; */
+os/linux/sta_ioctl.c:/*	pObj = (POS_COOKIE) pAd->OS_Cookie; */
+os/linux/sta_ioctl.c:/*	pObj = (POS_COOKIE) pAd->OS_Cookie; */
+os/linux/sta_ioctl.c:/*			memcpy(wrqin->u.name, pAd->CurrentAddress, ETH_ALEN); */
+os/linux/sta_ioctl.c:            erq->length = pNickName->NameLen; /*strlen((PSTRING) pAd->nickname); */
+os/linux/rt_linux.c:	daemonize((PSTRING) & pTask->taskName[0] /*"%s",pAd->net_dev->name */ );
+os/linux/rt_linux.c:/*		NdisZeroMemory(pAd->StaCfg.dev_name, 16); */
+os/linux/rt_linux.c:/*		NdisMoveMemory(pAd->StaCfg.dev_name, net_dev->name, strlen(net_dev->name)); */
+os/linux/rt_linux.c:/*	pAd->CommonCfg.bWirelessEvent = FlgIsWEntSup; */
+os/linux/rt_linux.c:	ret = ppa_hook_directpath_send_fn(pAd->g_if_id, pRxPkt, pRxPkt->len, ppa_flags);
+os/linux/rt_main_dev.c:/*	pAd->ApCfg.MBSSID[MAIN_MBSSID].bBcnSntReq = TRUE; */
+os/linux/rt_main_dev.c:	    pStats->rx_crc_errors = 0;/*pAd->WlanCounters.FCSErrorCount;     // recved pkt with crc error */
+os/linux/usb_main_dev.c:/*    pAd->StaCfg.OriDevType = net_dev->type; */
+os/linux/usb_main_dev.c:/*	pAd->pCfgDev = &(usb_dev->dev); */
+os/linux/usb_main_dev.c:/*	pAd->CFG80211_Register = CFG80211_Register; */
+os/linux/usb_main_dev.c:/*	pAd->pDirectpathCb = (PPA_DIRECTPATH_CB *) kmalloc (sizeof(PPA_DIRECTPATH_CB), GFP_ATOMIC); */
+os/linux/usb_main_dev.c:/*	os_alloc_mem(NULL, (UCHAR **)&(pAd->pDirectpathCb), sizeof(PPA_DIRECTPATH_CB)); */
+Binary file os/linux/rt_usb.o matches
+Binary file os/linux/mt7601Usta.o matches
+os/linux/ap_ioctl.c:/*	pObj = (POS_COOKIE) pAd->OS_Cookie; */
+os/linux/ap_ioctl.c:/*    			strcpy((PSTRING) wrq->u.name, (PSTRING) pAd->ApCfg.MBSSID[pObj->ioctl_if].Bssid); */
+os/linux/ap_ioctl.c:              /*erq->length = pAd->ApCfg.MBSSID[pObj->ioctl_if].SsidLen; */
+os/linux/ap_ioctl.c:					/*if(copy_to_user(erq->pointer, pAd->ApCfg.MBSSID[pObj->ioctl_if].Ssid, erq->length)) */
+os/linux/ap_ioctl.c:			wrqin->u.freq.m = Channel; /*pAd->CommonCfg.Channel; */
+os/linux/ap_ioctl.c:				/*memcpy(wrqin->u.ap_addr.sa_data, &pAd->ApCfg.MBSSID[pObj->ioctl_if].Bssid, ETH_ALEN); */
+Binary file phy/rtmp_phy.o matches
+phy/rtmp_phy.c:	{BBP_R66,		0x38},	/* Also set this default value to pAd->BbpTuning.R66CurrentValue at initial*/
+phy/rtmp_phy.c:	if (pAd->chipCap.pBBPRegTable)
+phy/rtmp_phy.c:		REG_PAIR *pbbpRegTb = pAd->chipCap.pBBPRegTable;
+phy/rtmp_phy.c:		for (Index = 0; Index < pAd->chipCap.bbpRegTbSize; Index++)
+phy/rtmp_phy.c:	if (pAd->chipOps.AsicBbpInit != NULL)
+phy/rtmp_phy.c:		pAd->chipOps.AsicBbpInit(pAd);
+phy/rtmp_phy.c:	if (((pAd->MACVersion & 0xffff) != 0x0101) &&
+phy/rtmp_phy.c:	if (pAd->MACVersion == 0x28600100)
+phy/rtmp_phy.c:	if (bw != pAd->CommonCfg.BBPCurrentBW)
+phy/rtmp_phy.c:	pAd->CommonCfg.BBPCurrentBW = bw;
+phy/rtmp_phy.c:	if (((pAd->MACVersion & 0xf0000000) < 0x28830000) || 
+phy/rtmp_phy.c:		(pAd->Antenna.field.RxPath == 1))
+phy/rtmp_phy.c:		if (idx >= pAd->Antenna.field.RxPath)
+phy/rtmp_phy.c:	if (((pAd->MACVersion & 0xffff0000) < 0x28830000) || 
+phy/rtmp_phy.c:		(pAd->Antenna.field.RxPath == 1))
+phy/rtmp_phy.c:		if (idx >= pAd->Antenna.field.RxPath)
+phy/rtmp_phy.c:		if (WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_B))
+phy/rtmp_phy.c:		if (pAd->MacTab.Size !=1 || pAd->CommonCfg.CFOTrack==0)
+phy/rtmp_phy.c:			RT3883_AsicSetFreqOffset(pAd, pAd->RfFreqOffset);
+phy/rtmp_phy.c:			pAd->CommonCfg.CFOTrack < 8 && 
+phy/rtmp_phy.c:			if (pAd->CommonCfg.CFOTrack != 1)
+phy/rtmp_phy.c:				pAd->CommonCfg.CFOTrack++;
+phy/rtmp_phy.c:		RTMP_SEM_EVENT_WAIT(&pAd->reg_atomic, ret);
+phy/rtmp_phy.c:	ASSERT((regID <= pAd->chipCap.MaxNumOfBbpId));
+phy/rtmp_phy.c:		RTMP_SEM_EVENT_UP(&pAd->reg_atomic);
+phy/rtmp_phy.c:		RTMP_SEM_EVENT_WAIT(&pAd->reg_atomic, i);
+phy/rtmp_phy.c:	ASSERT((regID <= pAd->chipCap.MaxNumOfBbpId));
+phy/rtmp_phy.c:		RTMP_SEM_EVENT_UP(&pAd->reg_atomic);
+Binary file phy/rlt_rf.o matches
+phy/rlt_rf.c:	if (pAd->WlanFunCtrl.field.WLAN_EN == 0)
+phy/rlt_rf.c:		RTMP_SEM_EVENT_WAIT(&pAd->reg_atomic, ret);
+phy/rlt_rf.c:	ASSERT((regID <= pAd->chipCap.MaxNumOfRfId));
+phy/rlt_rf.c:		RTMP_SEM_EVENT_UP(&pAd->reg_atomic);
+phy/rlt_rf.c:	if (pAd->WlanFunCtrl.field.WLAN_EN == 0)
+phy/rlt_rf.c:		RTMP_SEM_EVENT_WAIT(&pAd->reg_atomic, i);
+phy/rlt_rf.c:	ASSERT((regID <= pAd->chipCap.MaxNumOfRfId));
+phy/rlt_rf.c:		RTMP_SEM_EVENT_UP(&pAd->reg_atomic);
+phy/rlt_phy.c:	if (pAd->chipCap.pBBPRegTable)
+phy/rlt_phy.c:		RTMP_REG_PAIR *reg = (RTMP_REG_PAIR *)pAd->chipCap.pBBPRegTable;
+phy/rlt_phy.c:		for (idx = 0; idx < pAd->chipCap.bbpRegTbSize; idx++)
+phy/rlt_phy.c:	if (pAd->chipOps.AsicBbpInit != NULL)
+phy/rlt_phy.c:		pAd->chipOps.AsicBbpInit(pAd);
+phy/rlt_phy.c:	if (pAd->CommonCfg.BBPCurrentBW == BW_80 && 
+phy/rlt_phy.c:		pAd->CommonCfg.Channel >= 36 &&
+phy/rlt_phy.c:		pAd->CommonCfg.vht_cent_ch)
+phy/rlt_phy.c:		if (pAd->CommonCfg.Channel < pAd->CommonCfg.vht_cent_ch)
+phy/rlt_phy.c:			switch (pAd->CommonCfg.vht_cent_ch - pAd->CommonCfg.Channel)
+phy/rlt_phy.c:		else if (pAd->CommonCfg.Channel > pAd->CommonCfg.vht_cent_ch)
+phy/rlt_phy.c:			switch (pAd->CommonCfg.Channel - pAd->CommonCfg.vht_cent_ch)
+phy/rlt_phy.c:	pAd->CommonCfg.BBPCurrentBW = bw;
+phy/rlt_phy.c:	if (((pAd->MACVersion & 0xffff0000) < 0x28830000) || 
+phy/rlt_phy.c:		(pAd->Antenna.field.RxPath == 1))
+phy/rlt_phy.c:		if (idx >= pAd->Antenna.field.RxPath)
+phy/rlt_phy.c:	if (((pAd->MACVersion & 0xf0000000) < 0x28830000) || 
+phy/rlt_phy.c:		(pAd->Antenna.field.RxPath == 1))
+phy/rlt_phy.c:		if (idx >= pAd->Antenna.field.RxPath)
+phy/rlt_phy.c:		if (WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_B))
+rate_ctrl/alg_ags.c:	MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[1];
+rate_ctrl/alg_ags.c:				RssiOffset = AgsRssiOffsetTable[1][pAd->CommonCfg.BBPCurrentBW];
+rate_ctrl/alg_ags.c:				RssiOffset = AgsRssiOffsetTable[0][pAd->CommonCfg.BBPCurrentBW];
+rate_ctrl/alg_ags.c:		(!pAd->StaCfg.StaQuickResponeForRateUpTimerRunning))
+rate_ctrl/alg_ags.c:		RTMPSetTimer(&pAd->StaCfg.StaQuickResponeForRateUpTimer, pAd->ra_fast_interval);
+rate_ctrl/alg_ags.c:		pAd->StaCfg.StaQuickResponeForRateUpTimerRunning = TRUE;
+rate_ctrl/alg_ags.c:		if ((pAd->CommonCfg.bRdg == TRUE) &&
+rate_ctrl/alg_ags.c:			CLIENT_STATUS_TEST_FLAG(&pAd->MacTab.Content[BSSID_WCID],
+rate_ctrl/alg_ags.c:			if ((pAd->RalinkCounters.OneSecReceivedByteCount > (pAd->RalinkCounters.OneSecTransmittedByteCount * 5)) && 
+rate_ctrl/alg_ags.c:			     ((pAd->RalinkCounters.OneSecReceivedByteCount + pAd->RalinkCounters.OneSecTransmittedByteCount) >= (50 * 1024)))
+rate_ctrl/alg_ags.c:	pAd->StaCfg.StaQuickResponeForRateUpTimerRunning = FALSE;
+rate_ctrl/alg_ags.c:	MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[idx];
+rate_ctrl/alg_ags.c:	if (pAd->MacTab.Size == 1)
+rate_ctrl/alg_ags.c:				RssiOffset = AgsRssiOffsetTable[1][pAd->CommonCfg.BBPCurrentBW];
+rate_ctrl/alg_ags.c:				RssiOffset = AgsRssiOffsetTable[0][pAd->CommonCfg.BBPCurrentBW];
+rate_ctrl/alg_ags.c:		(!pAd->ApCfg.ApQuickResponeForRateUpTimerRunning))
+rate_ctrl/alg_ags.c:		RTMPSetTimer(&pAd->ApCfg.ApQuickResponeForRateUpTimer, pAd->ra_fast_interval);
+rate_ctrl/alg_ags.c:		pAd->ApCfg.ApQuickResponeForRateUpTimerRunning = TRUE;
+rate_ctrl/alg_ags.c:	pAd->ApCfg.ApQuickResponeForRateUpTimerRunning = FALSE;
+rate_ctrl/alg_ags.c:	pEntry = &pAd->MacTab.Content[idx]; /* point to information of the individual station */
+rate_ctrl/alg_ags.c:	if (pAd->MacTab.Size == 1)
+rate_ctrl/ra_ctrl.c:	if (pAd->CommonCfg.DebugFlags & DBF_INIT_MCS_DIS1)
+rate_ctrl/ra_ctrl.c:         || (pAd->WIFItestbed.bShortGI && pEntry->MaxHTPhyMode.field.ShortGI) )
+rate_ctrl/ra_ctrl.c:	if ((pAd->WIFItestbed.bGreenField & pEntry->HTCapability.HtCapInfo.GF) && (pEntry->HTPhyMode.field.MODE == MODE_HTMIX))
+rate_ctrl/ra_ctrl.c:	if (pAd->CommonCfg.bRcvBSSWidthTriggerEvents ||
+rate_ctrl/ra_ctrl.c:		(pAd->CommonCfg.BBPCurrentBW==BW_20))
+rate_ctrl/ra_ctrl.c:	if (pAd->CommonCfg.BBPCurrentBW==BW_80 &&
+rate_ctrl/ra_ctrl.c:			&& (pAd->CommonCfg.DebugFlags & DBF_DISABLE_20MHZ_MCS0) == 0
+rate_ctrl/ra_ctrl.c:				(pAd->CommonCfg.DebugFlags & DBF_FORCE_20MHZ) == 0
+rate_ctrl/ra_ctrl.c:				&& (pAd->CommonCfg.DebugFlags & DBF_DISABLE_20MHZ_MCS1) == 0
+rate_ctrl/ra_ctrl.c:			&& (pAd->CommonCfg.DebugFlags & DBF_ENABLE_20MHZ_MCS8)
+rate_ctrl/ra_ctrl.c:	if (pAd->CommonCfg.DebugFlags & DBF_FORCE_40MHZ)
+rate_ctrl/ra_ctrl.c:	else if (pAd->CommonCfg.DebugFlags & DBF_FORCE_20MHZ)
+rate_ctrl/ra_ctrl.c:	if (pAd->CommonCfg.DebugFlags & DBF_FORCE_SGI)
+rate_ctrl/ra_ctrl.c:	pAd->LastTxRate = (USHORT)(pEntry->HTPhyMode.word);
+rate_ctrl/ra_ctrl.c:	if (pTxRate->STBC && (pAd->StaCfg.MaxHTPhyMode.field.STBC))
+rate_ctrl/ra_ctrl.c:		pAd->StaCfg.HTPhyMode.field.STBC = STBC_USE;
+rate_ctrl/ra_ctrl.c:		pAd->StaCfg.HTPhyMode.field.STBC = STBC_NONE;
+rate_ctrl/ra_ctrl.c:		pAd->StaCfg.HTPhyMode.field.MCS = pTxRate->CurrMCS;
+rate_ctrl/ra_ctrl.c:	if (pAd->StaCfg.HTPhyMode.field.MCS > 7)
+rate_ctrl/ra_ctrl.c:		pAd->StaCfg.HTPhyMode.field.STBC = STBC_NONE;
+rate_ctrl/ra_ctrl.c:		pAd->StaCfg.HTPhyMode.field.ShortGI = GI_800;
+rate_ctrl/ra_ctrl.c:		pEntry->HTPhyMode.field.ShortGI = pAd->StaCfg.HTPhyMode.field.ShortGI;
+rate_ctrl/ra_ctrl.c:		pEntry->HTPhyMode.field.MCS = pAd->StaCfg.HTPhyMode.field.MCS;
+rate_ctrl/ra_ctrl.c:		pAd->StaCfg.HTPhyMode.field.MODE = pEntry->HTPhyMode.field.MODE;
+rate_ctrl/ra_ctrl.c:        if ((pAd->CommonCfg.RegTransmitSetting.field.HTMODE == HTMODE_GF) &&
+rate_ctrl/ra_ctrl.c:			(pAd->MlmeAux.HtCapability.HtCapInfo.GF == HTMODE_GF))
+rate_ctrl/ra_ctrl.c:            pAd->StaCfg.HTPhyMode.field.MODE = MODE_HTGREENFIELD;
+rate_ctrl/ra_ctrl.c:			pAd->StaCfg.HTPhyMode.field.MODE = pTxRate->Mode;
+rate_ctrl/ra_ctrl.c:        if (pTxRate->ShortGI && (pAd->StaCfg.MaxHTPhyMode.field.ShortGI))
+rate_ctrl/ra_ctrl.c:			pAd->StaCfg.HTPhyMode.field.ShortGI = GI_400;
+rate_ctrl/ra_ctrl.c:			pAd->StaCfg.HTPhyMode.field.ShortGI = GI_800;
+rate_ctrl/ra_ctrl.c:		if (pEntry->MaxHTPhyMode.field.BW==BW_20 || pAd->CommonCfg.BBPCurrentBW==BW_20)
+rate_ctrl/ra_ctrl.c:		if (pEntry->MaxHTPhyMode.field.BW==BW_80 || pAd->CommonCfg.BBPCurrentBW==BW_80)
+rate_ctrl/ra_ctrl.c:    		if ((pAd->StaCfg.HTPhyMode.field.MCS==32)
+rate_ctrl/ra_ctrl.c:			&& (pAd->CommonCfg.DebugFlags & DBF_DISABLE_20MHZ_MCS0)==0
+rate_ctrl/ra_ctrl.c:    			pAd->StaCfg.HTPhyMode.field.MCS = 0;
+rate_ctrl/ra_ctrl.c:				if (pTxRate->STBC && pAd->StaCfg.MaxHTPhyMode.field.STBC)
+rate_ctrl/ra_ctrl.c:					pAd->StaCfg.HTPhyMode.field.STBC = STBC_USE;
+rate_ctrl/ra_ctrl.c:    		else if (pAd->StaCfg.HTPhyMode.field.MCS==0
+rate_ctrl/ra_ctrl.c:				&& (pAd->CommonCfg.DebugFlags & DBF_FORCE_20MHZ)==0
+rate_ctrl/ra_ctrl.c:				&& (pAd->CommonCfg.DebugFlags & DBF_DISABLE_20MHZ_MCS1)==0
+rate_ctrl/ra_ctrl.c:    			pAd->StaCfg.HTPhyMode.field.MCS = 1;
+rate_ctrl/ra_ctrl.c:    		else if (pAd->StaCfg.HTPhyMode.field.MCS==8
+rate_ctrl/ra_ctrl.c:				&& (pAd->CommonCfg.DebugFlags & DBF_ENABLE_20MHZ_MCS8)
+rate_ctrl/ra_ctrl.c:    	if (pAd->CommonCfg.DebugFlags & DBF_FORCE_40MHZ)
+rate_ctrl/ra_ctrl.c:    	else if (pAd->CommonCfg.DebugFlags & DBF_FORCE_20MHZ)
+rate_ctrl/ra_ctrl.c:    		pAd->StaCfg.HTPhyMode.field.ShortGI = GI_800;
+rate_ctrl/ra_ctrl.c:		if (pAd->CommonCfg.DebugFlags & DBF_FORCE_SGI)
+rate_ctrl/ra_ctrl.c:			pAd->StaCfg.HTPhyMode.field.ShortGI = GI_400;
+rate_ctrl/ra_ctrl.c:		if (((pEntry->HTPhyMode.field.MCS == 0) && (pAd->StaCfg.HTPhyMode.field.MCS != 0)) ||
+rate_ctrl/ra_ctrl.c:			((pEntry->HTPhyMode.field.MCS == 8) && (pAd->StaCfg.HTPhyMode.field.MCS != 8)))
+rate_ctrl/ra_ctrl.c:			pEntry->HTPhyMode.field.MCS = pAd->StaCfg.HTPhyMode.field.MCS;
+rate_ctrl/ra_ctrl.c:			if (pAd->MacTab.fAnyBASession)
+rate_ctrl/ra_ctrl.c:				OperationMode = pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode;
+rate_ctrl/ra_ctrl.c:		else if ((pEntry->HTPhyMode.field.MCS != 0) && (pAd->StaCfg.HTPhyMode.field.MCS == 0))
+rate_ctrl/ra_ctrl.c:		else if ((pEntry->HTPhyMode.field.MCS != 8) && (pAd->StaCfg.HTPhyMode.field.MCS == 8))
+rate_ctrl/ra_ctrl.c:							(BOOLEAN)pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent);
+rate_ctrl/ra_ctrl.c:		pEntry->HTPhyMode.field.STBC	= pAd->StaCfg.HTPhyMode.field.STBC;
+rate_ctrl/ra_ctrl.c:		pEntry->HTPhyMode.field.ShortGI = pAd->StaCfg.HTPhyMode.field.ShortGI;
+rate_ctrl/ra_ctrl.c:		pEntry->HTPhyMode.field.MCS = pAd->StaCfg.HTPhyMode.field.MCS;
+rate_ctrl/ra_ctrl.c:		pEntry->HTPhyMode.field.MODE = pAd->StaCfg.HTPhyMode.field.MODE;
+rate_ctrl/ra_ctrl.c:		if (WMODE_CAP_AC(pAd->CommonCfg.PhyMode) &&
+rate_ctrl/ra_ctrl.c:			if (pAd->rateAlg == RATE_ALG_GRP)
+rate_ctrl/ra_ctrl.c:			if (pAd->rateAlg == RATE_ALG_AGS)
+rate_ctrl/ra_ctrl.c:		if ((pAd->OpMode == OPMODE_STA) && ADHOC_ON(pAd))
+rate_ctrl/ra_ctrl.c:			if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) && 
+rate_ctrl/ra_ctrl.c:				((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1)))
+rate_ctrl/ra_ctrl.c:					if (pAd->LatchRfRegs.Channel <= 14)
+rate_ctrl/ra_ctrl.c:			else if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) && 
+rate_ctrl/ra_ctrl.c:					(((pAd->Antenna.field.TxPath == 3) && (pEntry->HTCapability.MCSSet[2] == 0x00)) || (pAd->Antenna.field.TxPath == 2)))
+rate_ctrl/ra_ctrl.c:					if (pAd->LatchRfRegs.Channel <= 14)
+rate_ctrl/ra_ctrl.c:					(pAd->Antenna.field.TxPath == 3))
+rate_ctrl/ra_ctrl.c:			else if (pAd->LatchRfRegs.Channel <= 14)
+rate_ctrl/ra_ctrl.c:		/*if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 12) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) &&*/
+rate_ctrl/ra_ctrl.c:		/*	((pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1)))*/
+rate_ctrl/ra_ctrl.c:			((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->CommonCfg.TxStream == 1)))
+rate_ctrl/ra_ctrl.c:			if (pAd->rateAlg == RATE_ALG_GRP)
+rate_ctrl/ra_ctrl.c:			if ((pAd->LatchRfRegs.Channel <= 14) && (pEntry->SupportRateMode & (SUPPORT_CCK_MODE)))
+rate_ctrl/ra_ctrl.c:			(pAd->CommonCfg.TxStream == 3))
+rate_ctrl/ra_ctrl.c:		/*else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 12) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) &&*/
+rate_ctrl/ra_ctrl.c:		/*	(pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2))*/
+rate_ctrl/ra_ctrl.c:			(((pAd->Antenna.field.TxPath == 3) && (pEntry->HTCapability.MCSSet[2] == 0x00)) || (pAd->CommonCfg.TxStream == 2)))
+rate_ctrl/ra_ctrl.c:				if (pAd->rateAlg == RATE_ALG_GRP)
+rate_ctrl/ra_ctrl.c:			if ((pAd->LatchRfRegs.Channel <= 14) && (pEntry->SupportRateMode & (SUPPORT_CCK_MODE)))
+rate_ctrl/ra_ctrl.c:			(pAd->CommonCfg.TxStream == 3))
+rate_ctrl/ra_ctrl.c:			if (pAd->rateAlg == RATE_ALG_GRP)
+rate_ctrl/ra_ctrl.c:			if ((pAd->LatchRfRegs.Channel <= 14) && (pEntry->SupportRateMode & (SUPPORT_CCK_MODE)))
+rate_ctrl/ra_ctrl.c:		/*else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && ((pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1)))*/
+rate_ctrl/ra_ctrl.c:			((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->CommonCfg.TxStream == 1)))
+rate_ctrl/ra_ctrl.c:				if (pAd->rateAlg == RATE_ALG_GRP)
+rate_ctrl/ra_ctrl.c:				if (pAd->LatchRfRegs.Channel <= 14)
+rate_ctrl/ra_ctrl.c:		/*else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2))*/
+rate_ctrl/ra_ctrl.c:			(pAd->CommonCfg.TxStream == 2))
+rate_ctrl/ra_ctrl.c:				if (pAd->rateAlg == RATE_ALG_GRP)
+rate_ctrl/ra_ctrl.c:				if (pAd->LatchRfRegs.Channel <= 14)
+rate_ctrl/ra_ctrl.c:			(pAd->CommonCfg.TxStream == 3))
+rate_ctrl/ra_ctrl.c:			if (pAd->rateAlg == RATE_ALG_GRP)
+rate_ctrl/ra_ctrl.c:				if (pAd->LatchRfRegs.Channel <= 14)
+rate_ctrl/ra_ctrl.c:		if (pAd->CommonCfg.TxStream == 3)
+rate_ctrl/ra_ctrl.c:					if (pAd->rateAlg == RATE_ALG_GRP)
+rate_ctrl/ra_ctrl.c:						if ((pAd->LatchRfRegs.Channel <= 14) && (pEntry->SupportRateMode & (SUPPORT_CCK_MODE)))
+rate_ctrl/ra_ctrl.c:						if (pAd->rateAlg == RATE_ALG_GRP)
+rate_ctrl/ra_ctrl.c:						if (pAd->LatchRfRegs.Channel <= 14)
+rate_ctrl/ra_ctrl.c:						if (pAd->rateAlg == RATE_ALG_GRP)
+rate_ctrl/ra_ctrl.c:						if ((pAd->LatchRfRegs.Channel <= 14) && (pEntry->SupportRateMode & (SUPPORT_CCK_MODE)))
+rate_ctrl/ra_ctrl.c:						if (pAd->rateAlg == RATE_ALG_GRP)
+rate_ctrl/ra_ctrl.c:						if (pAd->LatchRfRegs.Channel <= 14)
+rate_ctrl/ra_ctrl.c:			WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_B)) 
+rate_ctrl/ra_ctrl.c:		/*else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen > 8) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0))*/
+rate_ctrl/ra_ctrl.c:		/*else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 8) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0))*/
+rate_ctrl/ra_ctrl.c:			if (pAd->CommonCfg.TxStream >= 3)
+rate_ctrl/ra_ctrl.c:				if (pAd->rateAlg == RATE_ALG_GRP)
+rate_ctrl/ra_ctrl.c:				if (pAd->LatchRfRegs.Channel <= 14)
+rate_ctrl/ra_ctrl.c:			/*else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0))*/
+rate_ctrl/ra_ctrl.c:				if (pAd->CommonCfg.MaxTxRate <= RATE_11)
+rate_ctrl/ra_ctrl.c:				else if ((pAd->CommonCfg.MaxTxRate > RATE_11) && (pAd->CommonCfg.MinTxRate > RATE_11))
+rate_ctrl/ra_ctrl.c:			if (SUPPORT_AGS(pAd) && (pAd->CommonCfg.TxStream == 3))
+rate_ctrl/ra_ctrl.c:			if (pAd->LatchRfRegs.Channel <= 14)
+rate_ctrl/ra_ctrl.c:				if (pAd->CommonCfg.TxStream == 1)
+rate_ctrl/ra_ctrl.c:				else if (pAd->CommonCfg.TxStream == 2)
+rate_ctrl/ra_ctrl.c:					if (pAd->rateAlg == RATE_ALG_GRP)
+rate_ctrl/ra_ctrl.c:				if (pAd->CommonCfg.TxStream == 1)
+rate_ctrl/ra_ctrl.c:				else if (pAd->CommonCfg.TxStream == 2)
+rate_ctrl/ra_ctrl.c:					if (pAd->rateAlg == RATE_ALG_GRP)
+rate_ctrl/ra_ctrl.c:						pAd->StaActive.SupRateLen,
+rate_ctrl/ra_ctrl.c:						pAd->StaActive.ExtRateLen,
+rate_ctrl/ra_ctrl.c:						pAd->StaActive.SupportedPhyInfo.MCSSet[0],
+rate_ctrl/ra_ctrl.c:						pAd->StaActive.SupportedPhyInfo.MCSSet[1]));
+rate_ctrl/ra_ctrl.c:		|| (pAd->CommonCfg.DebugFlags & DBF_SHOW_ZERO_RA_LOG)
+rate_ctrl/ra_ctrl.c:			tp = (100-TxErrorRatio)*TxTotalCnt*RA_INTERVAL/(100*pAd->ra_fast_interval);
+rate_ctrl/ra_ctrl.c:				&& (pAd->CommonCfg.DebugFlags & DBF_FORCE_QUICK_DRS)==0
+rate_ctrl/ra_ctrl.c:			tp = (100-TxErrorRatio)*TxTotalCnt*RA_INTERVAL/(100*(RA_INTERVAL-pAd->ra_fast_interval));
+rate_ctrl/ra_ctrl.c:			&& (pAd->CommonCfg.DebugFlags & DBF_DBQ_RA_LOG)==0
+rate_ctrl/ra_ctrl.c:		if (pAd->CommonCfg.DebugFlags & DBF_DBQ_RA_LOG)
+rate_ctrl/ra_ctrl.c:		) && pAd->RalinkCounters.OneSecReceivedByteCount > 50000 &&
+rate_ctrl/ra_ctrl.c:		pAd->RalinkCounters.OneSecTransmittedByteCount > 50000 &&
+rate_ctrl/ra_ctrl.c:		if (pAd->RalinkCounters.OneSecReceivedByteCount > (pAd->RalinkCounters.OneSecTransmittedByteCount * 5) &&
+rate_ctrl/ra_ctrl.c:	if (pAd->chipCap.FlgHwTxBfCap)
+rate_ctrl/ra_ctrl.c:	pAd->LastTxRate = (USHORT)(pEntry->HTPhyMode.word);
+rate_ctrl/ra_ctrl.c:	if (pAd->CommonCfg.StreamMode!=0 &&
+rate_ctrl/ra_ctrl.c:				(pAd->CommonCfg.StreamModeMCS & (1<<pEntry->HTPhyMode.field.MCS))==0 &&
+rate_ctrl/ra_ctrl.c:			pDesired_ht_phy = &pAd->StaCfg.DesiredHtPhyInfo;
+rate_ctrl/ra_ctrl.c:				pDesired_ht_phy = &pAd->ApCfg.ApCliTab[pEntry->apidx].DesiredHtPhyInfo;
+rate_ctrl/ra_ctrl.c:				pDesired_ht_phy = &pAd->ApCfg.MBSSID[pEntry->apidx].DesiredHtPhyInfo;
+rate_ctrl/ra_ctrl.c:			switch (pAd->CommonCfg.TxStream)
+rate_ctrl/ra_ctrl.c:	if ((ra_alg < RATE_ALG_MAX_NUM) && (ra_alg != pAd->rateAlg))
+rate_ctrl/ra_ctrl.c:		pAd->rateAlg = ra_alg;
+rate_ctrl/ra_ctrl.c:			pAd->MacTab.Content[IdEntry].rateAlg = ra_alg;
+rate_ctrl/alg_grp.c:	if ((pEntry->HTCapability.MCSSet[2] == 0xff) && (pAd->CommonCfg.TxStream == 3))
+rate_ctrl/alg_grp.c:		(pAd->CommonCfg.TxStream > 1) &&
+rate_ctrl/alg_grp.c:		((pAd->CommonCfg.TxStream == 2) || (pEntry->HTCapability.MCSSet[2] == 0x0)))
+rate_ctrl/alg_grp.c:		if ((pAd->CommonCfg.TxStream == 2) && (pEntry->SupportVHTMCS[8] == 0x1))
+rate_ctrl/alg_grp.c:		if ((pEntry->HTCapability.MCSSet[2] == 0xff) && (pAd->CommonCfg.TxStream == 3))
+rate_ctrl/alg_grp.c:				 (pAd->CommonCfg.TxStream > 1) &&
+rate_ctrl/alg_grp.c:				 ((pAd->CommonCfg.TxStream == 2) || (pEntry->HTCapability.MCSSet[2] == 0x0)))
+rate_ctrl/alg_grp.c:				&& (pAd->CommonCfg.DebugFlags & DBF_ENABLE_HT_DUP)
+rate_ctrl/alg_grp.c:			if ((pAd->CommonCfg.DebugFlags & DBF_DISABLE_20MHZ_MCS0)==0)
+rate_ctrl/alg_grp.c:				pAd->CommonCfg.BBPCurrentBW != BW_40 ||
+rate_ctrl/alg_grp.c:			if ((pAd->LatchRfRegs.Channel<=14
+rate_ctrl/alg_grp.c:				|| (pAd->CommonCfg.DebugFlags & DBF_ENABLE_CCK_5G)
+rate_ctrl/alg_grp.c:				&& ((pAd->CommonCfg.DebugFlags & DBF_DISABLE_CCK)==0)
+rate_ctrl/alg_grp.c:			if ((pEntry->MaxHTPhyMode.field.BW == BW_40 && pAd->CommonCfg.BBPCurrentBW == BW_40)
+rate_ctrl/alg_grp.c:				|| (pEntry->MaxHTPhyMode.field.BW == BW_80 && pAd->CommonCfg.BBPCurrentBW == BW_80)
+rate_ctrl/alg_grp.c:				&& ((pAd->CommonCfg.DebugFlags & DBF_DISABLE_20MHZ_MCS0)==0)
+rate_ctrl/alg_grp.c:				&& (pAd->CommonCfg.DebugFlags & DBF_ENABLE_HT_DUP)
+rate_ctrl/alg_grp.c:		if ((pCurrTxRate->CurrMCS >= 8 && pAd->CommonCfg.TxStream < 2) ||
+rate_ctrl/alg_grp.c:			(pCurrTxRate->CurrMCS >= 16 && pAd->CommonCfg.TxStream < 3))
+rate_ctrl/alg_grp.c:	if (pAd->CommonCfg.DebugFlags & DBF_INIT_MCS_DIS1)
+rate_ctrl/alg_grp.c:	if (pAd->CommonCfg.DebugFlags & DBF_INIT_MCS_MARGIN)
+rate_ctrl/alg_grp.c:		if ((pEntry->HTCapability.MCSSet[2] == 0xff) && (pAd->CommonCfg.TxStream == 3))
+rate_ctrl/alg_grp.c:				(pAd->CommonCfg.TxStream > 1) &&
+rate_ctrl/alg_grp.c:				((pAd->CommonCfg.TxStream == 2) || (pEntry->HTCapability.MCSSet[2] == 0x0)))
+rate_ctrl/alg_grp.c:		if ((pAd->CommonCfg.DebugFlags & DBF_DISABLE_20MHZ_MCS0)==0)
+rate_ctrl/alg_grp.c:			|| (pAd->CommonCfg.DebugFlags & DBF_FORCE_40MHZ)
+rate_ctrl/alg_grp.c:	if (100*NewTxOkCount < pAd->CommonCfg.TrainUpLowThrd*pEntry->LastTxOkCount)
+rate_ctrl/alg_grp.c:	if (100*NewTxOkCount > pAd->CommonCfg.TrainUpHighThrd*pEntry->LastTxOkCount)
+rate_ctrl/alg_grp.c:			&& ((pAd->CommonCfg.DebugFlags & DBF_NO_BF_AWARE_RA)==0)
+rate_ctrl/alg_grp.c:		if ((pAd->CommonCfg.DebugFlags & DBF_NO_BF_AWARE_RA)==0)
+rate_ctrl/alg_grp.c:		|| (pAd->CommonCfg.DebugFlags & DBF_FORCE_QUICK_DRS)
+rate_ctrl/alg_grp.c:			if (!pAd->ApCfg.ApQuickResponeForRateUpTimerRunning)
+rate_ctrl/alg_grp.c:				RTMPSetTimer(&pAd->ApCfg.ApQuickResponeForRateUpTimer, pAd->ra_fast_interval);
+rate_ctrl/alg_grp.c:				pAd->ApCfg.ApQuickResponeForRateUpTimerRunning = TRUE;
+rate_ctrl/alg_grp.c:			if (!pAd->StaCfg.StaQuickResponeForRateUpTimerRunning)
+rate_ctrl/alg_grp.c:				RTMPSetTimer(&pAd->StaCfg.StaQuickResponeForRateUpTimer, pAd->ra_fast_interval);
+rate_ctrl/alg_grp.c:				pAd->StaCfg.StaQuickResponeForRateUpTimerRunning = TRUE;
+rate_ctrl/alg_grp.c:	pEntry = &pAd->MacTab.Content[idx];
+rate_ctrl/alg_grp.c:	if (pAd->MacTab.Size == 1)
+rate_ctrl/alg_grp.c:		AccuTxTotalCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount + 
+rate_ctrl/alg_grp.c:							pAd->RalinkCounters.OneSecTxRetryOkCount + 
+rate_ctrl/alg_grp.c:							pAd->RalinkCounters.OneSecTxFailCount;
+rate_ctrl/alg_grp.c:		if (pAd->Antenna.field.TxPath > 1)
+rate_ctrl/alg_grp.c:	if ((pAd->CommonCfg.DebugFlags & DBF_SHOW_RA_LOG) || (pAd->CommonCfg.DebugFlags & DBF_DBQ_RA_LOG))
+rate_ctrl/alg_grp.c:		LastTxCount is based on a time interval of 500 msec or "500 - pAd->ra_fast_interval" ms.
+rate_ctrl/alg_grp.c:		&& (pAd->CommonCfg.DebugFlags & DBF_FORCE_QUICK_DRS)==0
+rate_ctrl/alg_grp.c:		ratio = RA_INTERVAL / pAd->ra_fast_interval;
+rate_ctrl/alg_grp.c:		ratio = (RA_INTERVAL - pAd->ra_fast_interval) / pAd->ra_fast_interval;
+rate_ctrl/alg_grp.c:	if (pAd->MacTab.Size == 1)
+rate_ctrl/alg_grp.c:		if (pAd->CommonCfg.TrainUpRule == 0)
+rate_ctrl/alg_grp.c:		else if (pAd->CommonCfg.TrainUpRule==2 && Rssi<=pAd->CommonCfg.TrainUpRuleRSSI)
+rate_ctrl/alg_grp.c:		else if (pAd->CommonCfg.TrainUpRule==3 && Rssi<=pAd->CommonCfg.TrainUpRuleRSSI)
+rate_ctrl/alg_grp.c:	pEntry = &pAd->MacTab.Content[i]; /* point to information of the individual station */
+rate_ctrl/alg_grp.c:	if (pAd->MacTab.Size == 1)
+rate_ctrl/alg_grp.c:	if ((pAd->CommonCfg.DebugFlags & DBF_SHOW_RA_LOG) || (pAd->CommonCfg.DebugFlags & DBF_DBQ_RA_LOG))
+rate_ctrl/alg_grp.c:		if (pEntry->lowTrafficCount >= pAd->CommonCfg.lowTrafficThrd)
+rate_ctrl/alg_grp.c:		if (pAd->CommonCfg.DebugFlags & DBF_NO_BF_AWARE_RA)
+rate_ctrl/alg_grp.c:		if (pAd->chipCap.FlgHwTxBfCap)
+rate_ctrl/alg_grp.c:	if (pAd->chipCap.FlgHwTxBfCap)
+rate_ctrl/alg_grp.c:	pEntry = &pAd->MacTab.Content[i];
+rate_ctrl/alg_grp.c:	if (pAd->MacTab.Size == 1)
+rate_ctrl/alg_grp.c:	if ((pAd->CommonCfg.DebugFlags & DBF_SHOW_RA_LOG) || (pAd->CommonCfg.DebugFlags & DBF_DBQ_RA_LOG))
+rate_ctrl/alg_grp.c:		LastTxCount is based on a time interval of 500 msec or "500-pAd->ra_fast_interval" ms.
+rate_ctrl/alg_grp.c:		&& (pAd->CommonCfg.DebugFlags & DBF_FORCE_QUICK_DRS)==0
+rate_ctrl/alg_grp.c:		ratio = RA_INTERVAL/pAd->ra_fast_interval;
+rate_ctrl/alg_grp.c:		ratio = (RA_INTERVAL-pAd->ra_fast_interval)/pAd->ra_fast_interval;
+rate_ctrl/alg_grp.c:		if (pAd->CommonCfg.TrainUpRule == 0)
+rate_ctrl/alg_grp.c:		else if (pAd->CommonCfg.TrainUpRule==2 && Rssi<=pAd->CommonCfg.TrainUpRuleRSSI)
+rate_ctrl/alg_grp.c:		else if (pAd->CommonCfg.TrainUpRule==3 && Rssi<=pAd->CommonCfg.TrainUpRuleRSSI)
+rate_ctrl/alg_grp.c:	pEntry = &pAd->MacTab.Content[i];
+rate_ctrl/alg_grp.c:	if ((pAd->MacTab.Size == 1) || (IS_ENTRY_DLS(pEntry)))
+rate_ctrl/alg_grp.c:		/* Rssi = RTMPMaxRssi(pAd, (CHAR)pAd->StaCfg.RssiSample.AvgRssi0, (CHAR)pAd->StaCfg.RssiSample.AvgRssi1, (CHAR)pAd->StaCfg.RssiSample.AvgRssi2); */
+rate_ctrl/alg_grp.c:		Rssi = RTMPAvgRssi(pAd, &pAd->StaCfg.RssiSample);
+rate_ctrl/alg_grp.c:	if ((pAd->CommonCfg.DebugFlags & DBF_SHOW_RA_LOG) || (pAd->CommonCfg.DebugFlags & DBF_DBQ_RA_LOG))
+rate_ctrl/alg_grp.c:		if (pEntry->lowTrafficCount >= pAd->CommonCfg.lowTrafficThrd)
+rate_ctrl/alg_grp.c:			if (pAd->LatchRfRegs.Channel <= 14)
+rate_ctrl/alg_grp.c:				if (pAd->NicConfig2.field.ExternalLNAForG)
+rate_ctrl/alg_grp.c:				if (pAd->NicConfig2.field.ExternalLNAForA)
+rate_ctrl/alg_grp.c:		if (pAd->CommonCfg.DebugFlags & DBF_NO_BF_AWARE_RA)
+rate_ctrl/alg_grp.c:		if (pAd->chipCap.FlgHwTxBfCap)
+rate_ctrl/alg_grp.c:	if (pAd->chipCap.FlgHwTxBfCap)
+rate_ctrl/alg_grp.c:		pEntry = &pAd->MacTab.Content[i];
+rate_ctrl/alg_grp.c:		pAd->MacTab.Content[i].perThrdAdj = simple_strtol(arg, 0, 10);
+rate_ctrl/alg_grp.c:	pAd->CommonCfg.lowTrafficThrd = simple_strtol(arg, 0, 10);
+rate_ctrl/alg_grp.c:	pAd->CommonCfg.TrainUpRule = simple_strtol(arg, 0, 10);
+rate_ctrl/alg_grp.c:	pAd->CommonCfg.TrainUpRuleRSSI = simple_strtol(arg, 0, 10);
+rate_ctrl/alg_grp.c:	pAd->CommonCfg.TrainUpLowThrd = simple_strtol(arg, 0, 10);
+rate_ctrl/alg_grp.c:	pAd->CommonCfg.TrainUpHighThrd = simple_strtol(arg, 0, 10);
+rate_ctrl/alg_legacy.c:		pEntry = &pAd->MacTab.Content[i];
+rate_ctrl/alg_legacy.c:		if (pAd->MacTab.Size == 1)
+rate_ctrl/alg_legacy.c:		if (pAd->CommonCfg.DebugFlags & DBF_SHOW_RA_LOG)
+rate_ctrl/alg_legacy.c:			if (pAd->CommonCfg.DebugFlags & DBF_NO_BF_AWARE_RA)
+rate_ctrl/alg_legacy.c:			if (pAd->chipCap.FlgHwTxBfCap)
+rate_ctrl/alg_legacy.c:		if (pAd->chipCap.FlgHwTxBfCap)
+rate_ctrl/alg_legacy.c:	pAd->ApCfg.ApQuickResponeForRateUpTimerRunning = FALSE;
+rate_ctrl/alg_legacy.c:       	 pEntry = &pAd->MacTab.Content[i];
+rate_ctrl/alg_legacy.c:			&& (pAd->CommonCfg.DebugFlags & DBF_FORCE_QUICK_DRS)==0
+rate_ctrl/alg_legacy.c:		if (pAd->MacTab.Size == 1)
+rate_ctrl/alg_legacy.c:			AccuTxTotalCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount + 
+rate_ctrl/alg_legacy.c:					 pAd->RalinkCounters.OneSecTxRetryOkCount + 
+rate_ctrl/alg_legacy.c:					 pAd->RalinkCounters.OneSecTxFailCount;
+rate_ctrl/alg_legacy.c:			if (pAd->Antenna.field.TxPath > 1)
+rate_ctrl/alg_legacy.c:		if (pAd->CommonCfg.DebugFlags & DBF_SHOW_RA_LOG)
+rate_ctrl/alg_legacy.c:				LastTxCount is based on a time interval of "500" msec or "500-pAd->ra_fast_interval" ms.
+rate_ctrl/alg_legacy.c:				&& (pAd->CommonCfg.DebugFlags & DBF_FORCE_QUICK_DRS)==0
+rate_ctrl/alg_legacy.c:				ratio = RA_INTERVAL/pAd->ra_fast_interval;
+rate_ctrl/alg_legacy.c:				ratio = (RA_INTERVAL-pAd->ra_fast_interval)/pAd->ra_fast_interval;
+rate_ctrl/alg_legacy.c:			if (pAd->MacTab.Size == 1)
+rate_ctrl/alg_legacy.c:	RSSI_SAMPLE				*pRssi = &pAd->StaCfg.RssiSample;
+rate_ctrl/alg_legacy.c:		pEntry = &pAd->MacTab.Content[i];
+rate_ctrl/alg_legacy.c:		if ((pAd->MacTab.Size == 1) || IS_ENTRY_DLS(pEntry))
+rate_ctrl/alg_legacy.c:			AccuTxTotalCnt = pAd->RalinkCounters.OneSecTxNoRetryOkCount + 
+rate_ctrl/alg_legacy.c:						 pAd->RalinkCounters.OneSecTxRetryOkCount + 
+rate_ctrl/alg_legacy.c:						 pAd->RalinkCounters.OneSecTxFailCount;
+rate_ctrl/alg_legacy.c:				((AccuTxTotalCnt > 150) || (pAd->AntennaDiversityState == 1)) &&
+rate_ctrl/alg_legacy.c:				(pAd->CommonCfg.BBPCurrentBW == BW_40))
+rate_ctrl/alg_legacy.c:				MlmeAntSelection(pAd, AccuTxTotalCnt, TxErrorRatio, TxSuccess, pAd->StaCfg.RssiSample.AvgRssi0);
+rate_ctrl/alg_legacy.c:			if (0) //IS_RT3290(pAd) &&  ((AccuTxTotalCnt > 150) || (pAd->AntennaDiversityInfo.AntennaDiversityState == 1)) && (pAd->CommonCfg.BBPCurrentBW == BW_40))
+rate_ctrl/alg_legacy.c:		if (pAd->CommonCfg.DebugFlags & DBF_SHOW_RA_LOG)
+rate_ctrl/alg_legacy.c:			if (pAd->LatchRfRegs.Channel <= 14)
+rate_ctrl/alg_legacy.c:				RssiOffset = pAd->NicConfig2.field.ExternalLNAForG? 2: 5;
+rate_ctrl/alg_legacy.c:				RssiOffset = pAd->NicConfig2.field.ExternalLNAForA? 5: 8;
+rate_ctrl/alg_legacy.c:			if (pAd->CommonCfg.DebugFlags & DBF_NO_BF_AWARE_RA)
+rate_ctrl/alg_legacy.c:			if (pAd->chipCap.FlgHwTxBfCap)
+rate_ctrl/alg_legacy.c:		if (pAd->chipCap.FlgHwTxBfCap)
+rate_ctrl/alg_legacy.c:	pAd->StaCfg.StaQuickResponeForRateUpTimerRunning = FALSE;
+rate_ctrl/alg_legacy.c:		pEntry = &pAd->MacTab.Content[i];
+rate_ctrl/alg_legacy.c:			&& (pAd->CommonCfg.DebugFlags & DBF_FORCE_QUICK_DRS)==0
+rate_ctrl/alg_legacy.c:			Rssi = RTMPAvgRssi(pAd, &pAd->StaCfg.RssiSample);
+rate_ctrl/alg_legacy.c:		if (pAd->MacTab.Size == 1)
+rate_ctrl/alg_legacy.c:			pAd->RalinkCounters.OneSecTxRetryOkCount += StaTx1.field.TxRetransmit;
+rate_ctrl/alg_legacy.c:			pAd->RalinkCounters.OneSecTxNoRetryOkCount += StaTx1.field.TxSuccess;
+rate_ctrl/alg_legacy.c:			pAd->RalinkCounters.OneSecTxFailCount += TxStaCnt0.field.TxFailCount;
+rate_ctrl/alg_legacy.c:			pAd->WlanCounters.TransmittedFragmentCount.u.LowPart += StaTx1.field.TxSuccess;
+rate_ctrl/alg_legacy.c:			pAd->WlanCounters.RetryCount.u.LowPart += StaTx1.field.TxRetransmit;
+rate_ctrl/alg_legacy.c:			pAd->WlanCounters.FailedCount.u.LowPart += TxStaCnt0.field.TxFailCount;
+rate_ctrl/alg_legacy.c:			if (pAd->chipCap.FlgHwFifoExtCap)
+rate_ctrl/alg_legacy.c:		if (pAd->CommonCfg.DebugFlags & DBF_SHOW_RA_LOG)
+rate_ctrl/alg_legacy.c:				LastTxCount is based on a time interval of 500 msec or "500-pAd->ra_fast_interval" ms.
+rate_ctrl/alg_legacy.c:				&& (pAd->CommonCfg.DebugFlags & DBF_FORCE_QUICK_DRS)==0
+rate_ctrl/alg_legacy.c:				ratio = RA_INTERVAL/pAd->ra_fast_interval;
+rate_ctrl/alg_legacy.c:				ratio = (RA_INTERVAL-pAd->ra_fast_interval)/pAd->ra_fast_interval;
+rate_ctrl/alg_legacy.c:			&& ((pAd->CommonCfg.DebugFlags & DBF_NO_BF_AWARE_RA)==0)
+rate_ctrl/alg_legacy.c:					&& ((pAd->CommonCfg.DebugFlags & DBF_NO_BF_AWARE_RA)==0)
+rate_ctrl/alg_legacy.c:			if (!pAd->ApCfg.ApQuickResponeForRateUpTimerRunning)
+rate_ctrl/alg_legacy.c:				RTMPSetTimer(&pAd->ApCfg.ApQuickResponeForRateUpTimer, pAd->ra_fast_interval);
+rate_ctrl/alg_legacy.c:				pAd->ApCfg.ApQuickResponeForRateUpTimerRunning = TRUE;
+rate_ctrl/alg_legacy.c:			if (!pAd->StaCfg.StaQuickResponeForRateUpTimerRunning)
+rate_ctrl/alg_legacy.c:				RTMPSetTimer(&pAd->StaCfg.StaQuickResponeForRateUpTimer, pAd->ra_fast_interval);
+rate_ctrl/alg_legacy.c:				pAd->StaCfg.StaQuickResponeForRateUpTimerRunning = TRUE;
+sta/auth_rsp.c:						pAd->CurrentAddress,
+sta/auth_rsp.c:						pAd->MlmeAux.Bssid);
+sta/auth_rsp.c:		    && (MAC_ADDR_EQUAL(Addr1, pAd->CurrentAddress)
+sta/auth_rsp.c:		    && MAC_ADDR_EQUAL(Addr2, pAd->CommonCfg.Bssid)
+sta/auth_rsp.c:		    && MAC_ADDR_EQUAL(Addr3, pAd->CommonCfg.Bssid)
+sta/auth_rsp.c:					       pAd->StaCfg.AuthMode,
+sta/auth_rsp.c:			RtmpOSWrielessEventSend(pAd->net_dev,
+sta/auth_rsp.c:			if ((pAd->StaCfg.WpaSupplicantUP !=
+sta/auth_rsp.c:			    && (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
+sta/auth_rsp.c:			    && (pAd->StaCfg.PortSecured ==
+sta/auth_rsp.c:				pAd->StaCfg.bLostAp = TRUE;
+sta/auth_rsp.c:			if ((pAd->StaCfg.PortSecured ==
+sta/auth_rsp.c:			    ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK)
+sta/auth_rsp.c:			     || (pAd->StaCfg.AuthMode ==
+sta/auth_rsp.c:			    && (pAd->StaCfg.WscControl.WscState <
+sta/auth_rsp.c:				pAd->MlmeAux.BssIdx++;
+sta/auth_rsp.c:			 && (MAC_ADDR_EQUAL(Addr1, pAd->CurrentAddress)
+sta/connect.c:/* and are copied to pAd->StaActive */
+sta/connect.c:	pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:	switch (pAd->Mlme.CntlMachine.CurrState) {
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:			pAd->StaCfg.bImprovedScan = FALSE;
+sta/connect.c:			if (pAd->LedCntl.bLedOnScanning) {
+sta/connect.c:				pAd->LedCntl.bLedOnScanning = FALSE;
+sta/connect.c:				RTMPSetLED(pAd, pAd->LedCntl.LedStatus);
+sta/connect.c:			if ((pAd->CommonCfg.BSSCoexist2040.field.InfoReq == 1)
+sta/connect.c:                        if ((pAd->IndicateMediaState != NdisMediaStateConnected) && 
+sta/connect.c:			    (pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_ENABLE_WITH_WEB_UI) 
+sta/connect.c:                                        BssTableSsidSort(pAd, &pAd->MlmeAux.SsidBssTab, (PCHAR)pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
+sta/connect.c:                                        pAd->MlmeAux.BssIdx = 0;
+sta/connect.c:						MaintainBssTable(pAd, &pAd->ScanTab, 120, 2);
+sta/connect.c:				if (!((pAd->MlmeAux.ScanType == SCAN_P2P_SEARCH) || (pAd->MlmeAux.ScanType == SCAN_P2P)))
+sta/connect.c:					RtmpOSWrielessEventSend(pAd->net_dev, RT_WLAN_EVENT_SCAN, -1, NULL, NULL, 0);
+sta/connect.c:				if (pAd->P2pCfg.P2pCounter.bStartScan &&
+sta/connect.c:					((pAd->MlmeAux.ScanType == SCAN_P2P) || (pAd->MlmeAux.ScanType == SCAN_P2P_SEARCH)))
+sta/connect.c:				pAd->P2pCfg.bPeriodicListen = TRUE;
+sta/connect.c:			if (pAd->StaCfg.BssType == BSS_ADHOC)
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:			BssTableSsidSort(pAd, &pAd->MlmeAux.SsidBssTab, (PCHAR)pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
+sta/connect.c:			pAd->MlmeAux.BssIdx = 0;
+sta/connect.c:		DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid,
+sta/connect.c:		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_DISASSOC;
+sta/connect.c:		if ((pAd->StaCfg.WpaSupplicantUP & 0x7F) !=
+sta/connect.c:			pAd->MlmeAux.AutoReconnectSsidLen = 32;
+sta/connect.c:			NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid,
+sta/connect.c:				       pAd->MlmeAux.AutoReconnectSsidLen);
+sta/connect.c:	if (pAd->P2pCfg.P2pCounter.bStartScan == TRUE)
+sta/connect.c:		    BssSsidTableSearch(&pAd->ScanTab, pAd->CommonCfg.Bssid,
+sta/connect.c:				       (PUCHAR) pAd->CommonCfg.Ssid,
+sta/connect.c:				       pAd->CommonCfg.SsidLen,
+sta/connect.c:				       pAd->CommonCfg.Channel);
+sta/connect.c:			NdisMoveMemory(pCurrBss, &pAd->ScanTab.BssEntry[BssIdx],
+sta/connect.c:	pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+sta/connect.c:	NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
+sta/connect.c:	NdisMoveMemory(pAd->MlmeAux.Ssid, pOidSsid->Ssid, pOidSsid->SsidLength);
+sta/connect.c:	pAd->MlmeAux.SsidLen = (UCHAR) pOidSsid->SsidLength;
+sta/connect.c:	if (pAd->StaCfg.BssType == BSS_INFRA)
+sta/connect.c:		NdisZeroMemory(pAd->MlmeAux.Bssid, MAC_ADDR_LEN);
+sta/connect.c:	pAd->MlmeAux.BssType = pAd->StaCfg.BssType;
+sta/connect.c:	pAd->StaCfg.bAutoConnectByBssid = FALSE;
+sta/connect.c:	NdisZeroMemory(pAd->StaCfg.ConnectinfoSsid, MAX_LEN_OF_SSID);
+sta/connect.c:	NdisMoveMemory(pAd->StaCfg.ConnectinfoSsid, pOidSsid->Ssid, pOidSsid->SsidLength);
+sta/connect.c:	pAd->StaCfg.ConnectinfoSsidLen = pOidSsid->SsidLength;
+sta/connect.c:	pAd->StaCfg.ConnectinfoBssType = pAd->StaCfg.BssType;
+sta/connect.c:	NdisZeroMemory(pAd->CommonCfg.Ssid, MAX_LEN_OF_SSID);
+sta/connect.c:	NdisMoveMemory(pAd->CommonCfg.Ssid, pOidSsid->Ssid, pOidSsid->SsidLength);
+sta/connect.c:	pAd->CommonCfg.SsidLen = (UCHAR) pOidSsid->SsidLength;
+sta/connect.c:	NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, MAX_LEN_OF_SSID);
+sta/connect.c:	NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.Ssid,
+sta/connect.c:		       pAd->MlmeAux.SsidLen);
+sta/connect.c:	pAd->MlmeAux.AutoReconnectSsidLen = pAd->MlmeAux.SsidLen;
+sta/connect.c:	BssTableSsidSort(pAd, &pAd->MlmeAux.SsidBssTab,
+sta/connect.c:			 (PCHAR) pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
+sta/connect.c:		  pAd->MlmeAux.SsidBssTab.BssNr, pAd->ScanTab.BssNr));
+sta/connect.c:	if (pAd->MlmeAux.SsidLen == MAX_LEN_OF_SSID)
+sta/connect.c:		hex_dump("\nSSID", pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
+sta/connect.c:			 ("(%d)SSID - %s\n", pAd->MlmeAux.SsidLen,
+sta/connect.c:			  pAd->MlmeAux.Ssid));
+sta/connect.c:	    (pAd->CommonCfg.SsidLen == pAd->MlmeAux.SsidBssTab.BssEntry[0].SsidLen)
+sta/connect.c:	    && NdisEqualMemory(pAd->CommonCfg.Ssid, pAd->MlmeAux.SsidBssTab.BssEntry[0].Ssid, pAd->CommonCfg.SsidLen)
+sta/connect.c:	    && MAC_ADDR_EQUAL(pAd->CommonCfg.Bssid, pAd->MlmeAux.SsidBssTab.BssEntry[0].Bssid)) {
+sta/connect.c:		if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
+sta/connect.c:		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+sta/connect.c:		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
+sta/connect.c:		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+sta/connect.c:		     || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAIPSK)
+sta/connect.c:		     || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAICERT)
+sta/connect.c:		    (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED)) {
+sta/connect.c:					 pAd->CommonCfg.Bssid,
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+sta/connect.c:		} else if (pAd->bConfigChanged == TRUE) {
+sta/connect.c:					 pAd->CommonCfg.Bssid,
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+sta/connect.c:				pAd->ExtraInfo = GENERAL_LINK_UP;	/* Update extra information to link is up */
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:			RtmpOSWrielessEventSend(pAd->net_dev,
+sta/connect.c:						&pAd->MlmeAux.Bssid[0], NULL,
+sta/connect.c:		if (!SSID_EQUAL(pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen)) {
+sta/connect.c:			pAd->MlmeAux.CurrReqIsFromNdis = TRUE;
+sta/connect.c:		DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid,
+sta/connect.c:		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+sta/connect.c:			pAd->ExtraInfo = GENERAL_LINK_DOWN;
+sta/connect.c:		if ((pAd->MlmeAux.SsidBssTab.BssNr == 0) &&
+sta/connect.c:		    (pAd->StaCfg.bAutoReconnect == TRUE) &&
+sta/connect.c:		    (((pAd->MlmeAux.BssType == BSS_INFRA) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)))
+sta/connect.c:		     || ((pAd->MlmeAux.BssType == BSS_ADHOC) && !pAd->StaCfg.bNotFirstScan))
+sta/connect.c:		    && (MlmeValidateSSID(pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen) == TRUE)
+sta/connect.c:			if (pAd->MlmeAux.BssType == BSS_ADHOC)
+sta/connect.c:				pAd->StaCfg.bNotFirstScan = TRUE;
+sta/connect.c:			if((pAd->StaCfg.ConnectinfoChannel != 0) && (pAd->StaCfg.Connectinfoflag == TRUE))
+sta/connect.c:				ScanParmFill(pAd, &ScanReq, (PSTRING) pAd->MlmeAux.Ssid,
+sta/connect.c:					pAd->MlmeAux.SsidLen, BSS_ANY, SCAN_ACTIVE);
+sta/connect.c:				pAd->Mlme.CntlMachine.CurrState =	CNTL_WAIT_SCAN_FOR_CONNECT;
+sta/connect.c:				ScanParmFill(pAd, &ScanReq, (PSTRING) pAd->MlmeAux.Ssid,
+sta/connect.c:					     pAd->MlmeAux.SsidLen, BSS_ANY, SCAN_ACTIVE);
+sta/connect.c:				pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+sta/connect.c:			NdisGetSystemUpTime(&pAd->StaCfg.LastScanTime);
+sta/connect.c:			pAd->StaCfg.bNotFirstScan = TRUE;				
+sta/connect.c:			if (pAd->MlmeAux.BssType == BSS_INFRA) {
+sta/connect.c:			if ((pAd->CommonCfg.CountryRegion & 0x7f) == REGION_33_BG_BAND)
+sta/connect.c:				entry = &pAd->MlmeAux.SsidBssTab.BssEntry[pAd->MlmeAux.BssIdx];
+sta/connect.c:				if ((entry->Channel == 14) && (pAd->CommonCfg.SavedPhyMode = 0xff)) {
+sta/connect.c:					pAd->CommonCfg.SavedPhyMode = pAd->CommonCfg.PhyMode;
+sta/connect.c:				} else if (pAd->CommonCfg.SavedPhyMode != 0xff) {
+sta/connect.c:					RTMPSetPhyMode(pAd, pAd->CommonCfg.SavedPhyMode);
+sta/connect.c:					pAd->CommonCfg.SavedPhyMode = 0xFF;
+sta/connect.c:								__FUNCTION__, pAd->CommonCfg.SavedPhyMode, entry->Channel));
+sta/connect.c:			pAd->MlmeAux.BssIdx = 0;
+sta/connect.c:		if ((pAd->MlmeAux.SsidBssTab.BssNr == 0) && (pAd->MlmeAux.BssType == BSS_INFRA) 
+sta/connect.c:		    && (pAd->FlgCfg80211Connecting == TRUE))
+sta/connect.c:					 ("CFG80211_MLME: No matching BSS, Report cfg80211_layer SM to Idle --> %d\n", pAd->Mlme.CntlMachine.CurrState));			
+sta/connect.c:			pAd->Cfg_pending_SsidLen = pAd->MlmeAux.SsidLen;
+sta/connect.c:			NdisZeroMemory(pAd->Cfg_pending_Ssid, MAX_LEN_OF_SSID);
+sta/connect.c:			NdisMoveMemory(pAd->Cfg_pending_Ssid, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
+sta/connect.c:			RT_CFG80211_CONN_RESULT_INFORM(pAd, pAd->MlmeAux.Bssid, NULL, 0,
+sta/connect.c:	/*       pAd->StaCfg.WscControl.WscAPBssid has been filled with valid BSSID. */
+sta/connect.c:	if ((pAd->StaCfg.WscControl.WscState >= WSC_STATE_START) &&
+sta/connect.c:	    (pAd->StaCfg.WscControl.WscStatus != STATUS_WSC_SCAN_AP)) {
+sta/connect.c:		pAd->StaCfg.WscControl.WscState = WSC_STATE_START;
+sta/connect.c:		pAd->StaCfg.WscControl.WscStatus = STATUS_WSC_START_ASSOC;
+sta/connect.c:		if (pAd->StaCfg.BssType == BSS_INFRA) {
+sta/connect.c:				    pAd->StaCfg.WscControl.WscBssid, 0);
+sta/connect.c:				    (VOID *) & pAd->StaCfg.WscControl.WscSsid,
+sta/connect.c:		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:	PWSC_CTRL pWpsCtrl = &pAd->StaCfg.WscControl;
+sta/connect.c:	COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pOidBssid);
+sta/connect.c:	pAd->MlmeAux.BssType = pAd->StaCfg.BssType;
+sta/connect.c:	NdisZeroMemory(pAd->StaCfg.ConnectinfoBssid, MAC_ADDR_LEN);
+sta/connect.c:	NdisMoveMemory(pAd->StaCfg.ConnectinfoBssid, pOidBssid, MAC_ADDR_LEN);
+sta/connect.c:		pAd->StaCfg.ConnectinfoBssid[0], pAd->StaCfg.ConnectinfoBssid[1], pAd->StaCfg.ConnectinfoBssid[2],
+sta/connect.c:		pAd->StaCfg.ConnectinfoBssid[3], pAd->StaCfg.ConnectinfoBssid[4], pAd->StaCfg.ConnectinfoBssid[5]));
+sta/connect.c:	BssIdx = BssTableSearch(&pAd->ScanTab, pOidBssid, pAd->MlmeAux.Channel);
+sta/connect.c:	if (pAd->StaCfg.WpaSupplicantUP & WPA_SUPPLICANT_ENABLE_WPS) ;
+sta/connect.c:	if (pAd->StaCfg.WpaSupplicantUP & WPA_SUPPLICANT_ENABLE) ;
+sta/connect.c:		pInBss = &pAd->ScanTab.BssEntry[BssIdx];
+sta/connect.c:		if (SSID_EQUAL(pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen, pInBss->Ssid, pInBss->SsidLen) == FALSE)
+sta/connect.c:		if (pAd->StaCfg.AuthMode <= Ndis802_11AuthModeAutoSwitch) {
+sta/connect.c:			if (pAd->StaCfg.WepStatus != pInBss->WepStatus)
+sta/connect.c:			if ((pAd->StaCfg.AuthMode != pInBss->AuthMode) &&
+sta/connect.c:			    (pAd->StaCfg.AuthMode != pInBss->AuthModeAux))
+sta/connect.c:		(pAd->StaCfg.bSkipAutoScanConn == TRUE))
+sta/connect.c:		pAd->StaCfg.bSkipAutoScanConn = FALSE;
+sta/connect.c:		if (((pAd->StaCfg.BssType == BSS_INFRA) && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))) ||
+sta/connect.c:		    (pAd->StaCfg.bNotFirstScan == FALSE)) {
+sta/connect.c:			if (pAd->StaCfg.BssType == BSS_ADHOC)
+sta/connect.c:				pAd->StaCfg.bNotFirstScan = TRUE;
+sta/connect.c:			if((pAd->StaCfg.ConnectinfoChannel  != 0)&& (pAd->StaCfg.Connectinfoflag == TRUE))
+sta/connect.c:					PRINT_MAC(pAd->StaCfg.ConnectinfoBssid)));
+sta/connect.c:				pAd->CommonCfg.Channel = pAd->StaCfg.ConnectinfoChannel;
+sta/connect.c:				pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_JOIN;
+sta/connect.c:				ScanParmFill(pAd, &ScanReq, (PSTRING) pAd->MlmeAux.Ssid,
+sta/connect.c:				     pAd->MlmeAux.SsidLen, BSS_ANY, SCAN_ACTIVE);
+sta/connect.c:				pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+sta/connect.c:			NdisGetSystemUpTime(&pAd->StaCfg.LastScanTime);
+sta/connect.c:				  pAd->MlmeAux.Ssid));
+sta/connect.c:			StartParmFill(pAd, &StartReq, (PCHAR)pAd->MlmeAux.Ssid,
+sta/connect.c:				      pAd->MlmeAux.SsidLen);
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_START;
+sta/connect.c:	pInBss = &pAd->ScanTab.BssEntry[BssIdx];
+sta/connect.c:	NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, MAX_LEN_OF_SSID);
+sta/connect.c:	pAd->MlmeAux.AutoReconnectSsidLen = pInBss->SsidLen;
+sta/connect.c:	NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid, pInBss->Ssid, pInBss->SsidLen);
+sta/connect.c:	pAd->MlmeAux.BssIdx = 0;
+sta/connect.c:	pAd->MlmeAux.SsidBssTab.BssNr = 1;
+sta/connect.c:	NdisMoveMemory(&pAd->MlmeAux.SsidBssTab.BssEntry[0], pInBss,
+sta/connect.c:					 pAd->CommonCfg.Bssid,
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+sta/connect.c:				pAd->ExtraInfo = GENERAL_LINK_DOWN;
+sta/connect.c:			pInBss = &pAd->MlmeAux.SsidBssTab.BssEntry[0];
+sta/connect.c:			pAd->StaCfg.PairCipher = pAd->StaCfg.WepStatus;
+sta/connect.c:			if (pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_DISABLE)
+sta/connect.c:			pAd->StaCfg.GroupCipher = pAd->StaCfg.WepStatus;
+sta/connect.c:			if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA)
+sta/connect.c:			    || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK)) {
+sta/connect.c:				pAd->StaCfg.GroupCipher = pInBss->WPA.GroupCipher;
+sta/connect.c:				if (pAd->StaCfg.WepStatus == pInBss->WPA.PairCipher)
+sta/connect.c:					pAd->StaCfg.PairCipher = pInBss->WPA.PairCipher;
+sta/connect.c:					pAd->StaCfg.PairCipher = pInBss->WPA.PairCipherAux;
+sta/connect.c:					pAd->StaCfg.PairCipher = Ndis802_11Encryption2Enabled;
+sta/connect.c:			    if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
+sta/connect.c:				|| (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)) {
+sta/connect.c:				pAd->StaCfg.GroupCipher = pInBss->WPA2.GroupCipher;
+sta/connect.c:				if (pAd->StaCfg.WepStatus == pInBss->WPA2.PairCipher)
+sta/connect.c:					pAd->StaCfg.PairCipher = pInBss->WPA2.PairCipher;
+sta/connect.c:					pAd->StaCfg.PairCipher = pInBss->WPA2.PairCipherAux;
+sta/connect.c:					pAd->StaCfg.PairCipher = Ndis802_11Encryption2Enabled;
+sta/connect.c:				pAd->StaCfg.RsnCapability = pInBss->WPA2.RsnCapability;
+sta/connect.c:			else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAICERT)
+sta/connect.c:				 || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAIPSK)) {
+sta/connect.c:				pAd->StaCfg.GroupCipher = pInBss->WAPI.GroupCipher;
+sta/connect.c:				pAd->StaCfg.PairCipher = pInBss->WAPI.PairCipher;
+sta/connect.c:			pAd->StaCfg.bMixCipher = (pAd->StaCfg.PairCipher == pAd->StaCfg.GroupCipher) ? FALSE : TRUE;
+sta/connect.c:			JoinParmFill(pAd, &JoinReq, pAd->MlmeAux.BssIdx);
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_JOIN;
+sta/connect.c:		NdisMoveMemory(&pAd->MlmeAux.SsidBssTab, &pAd->MlmeAux.RoamTab,
+sta/connect.c:			       sizeof (pAd->MlmeAux.RoamTab));
+sta/connect.c:		pAd->MlmeAux.SsidBssTab.BssNr = pAd->MlmeAux.RoamTab.BssNr;
+sta/connect.c:		BssTableSortByRssi(&pAd->MlmeAux.SsidBssTab);
+sta/connect.c:		pAd->MlmeAux.BssIdx = 0;
+sta/connect.c:	if (!pAd->CommonCfg.bDLSCapable)
+sta/connect.c:			if (pDLS->Valid && pAd->StaCfg.DLSEntry[i].Valid
+sta/connect.c:			    && (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH)
+sta/connect.c:				pAd->StaCfg.DLSEntry[i].TimeOut)
+sta/connect.c:					      pAd->StaCfg.DLSEntry[i].
+sta/connect.c:			} else if (!pDLS->Valid && pAd->StaCfg.DLSEntry[i].Valid
+sta/connect.c:				   && (pAd->StaCfg.DLSEntry[i].Status ==
+sta/connect.c:						     pAd->StaCfg.DLSEntry[i].
+sta/connect.c:				pAd->StaCfg.DLSEntry[i].Valid = FALSE;
+sta/connect.c:				pAd->StaCfg.DLSEntry[i].Status = DLS_NONE;
+sta/connect.c:					    &pAd->StaCfg.DLSEntry[i], reason);
+sta/connect.c:				   && !pAd->StaCfg.DLSEntry[i].Valid) {
+sta/connect.c:				NdisMoveMemory(&pAd->StaCfg.DLSEntry[i], pDLS,
+sta/connect.c:				pAd->StaCfg.DLSEntry[i].CountDownTimer =
+sta/connect.c:				    pAd->StaCfg.DLSEntry[i].TimeOut;
+sta/connect.c:					    &pAd->StaCfg.DLSEntry[i], reason);
+sta/connect.c:				   && pAd->StaCfg.DLSEntry[i].Valid
+sta/connect.c:				   && (pAd->StaCfg.DLSEntry[i].Status ==
+sta/connect.c:						      pAd->StaCfg.DLSEntry[i].
+sta/connect.c:				pAd->StaCfg.DLSEntry[i].Valid = FALSE;
+sta/connect.c:				pAd->StaCfg.DLSEntry[i].Status = DLS_NONE;
+sta/connect.c:					    &pAd->StaCfg.DLSEntry[i], reason);
+sta/connect.c:				NdisMoveMemory(&pAd->StaCfg.DLSEntry[i], pDLS,
+sta/connect.c:					    &pAd->StaCfg.DLSEntry[i], reason);
+sta/connect.c:			} else if (pDLS->Valid && pAd->StaCfg.DLSEntry[i].Valid
+sta/connect.c:						     pAd->StaCfg.DLSEntry[i].
+sta/connect.c:				   && (pAd->StaCfg.DLSEntry[i].TimeOut !=
+sta/connect.c:				pAd->StaCfg.DLSEntry[i].TimeOut = pDLS->TimeOut;
+sta/connect.c:				pAd->StaCfg.DLSEntry[i].CountDownTimer =
+sta/connect.c:				    pAd->StaCfg.DLSEntry[i].TimeOut;
+sta/connect.c:					    &pAd->StaCfg.DLSEntry[i], reason);
+sta/connect.c:			} else if (pDLS->Valid && pAd->StaCfg.DLSEntry[i].Valid
+sta/connect.c:				   && (pAd->StaCfg.DLSEntry[i].Status !=
+sta/connect.c:						     pAd->StaCfg.DLSEntry[i].
+sta/connect.c:					    &pAd->StaCfg.DLSEntry[i], reason);
+sta/connect.c:					  i, pAd->StaCfg.DLSEntry[i].Valid,
+sta/connect.c:					  pAd->StaCfg.DLSEntry[i].Status,
+sta/connect.c:					  pAd->StaCfg.DLSEntry[i].TimeOut));
+sta/connect.c:		if ((pAd->MlmeAux.SsidBssTab.BssNr == 0)
+sta/connect.c:		    && (pAd->StaCfg.BssType == BSS_ADHOC)) {
+sta/connect.c:				  pAd->MlmeAux.Ssid));
+sta/connect.c:			StartParmFill(pAd, &StartReq, (PCHAR) pAd->MlmeAux.Ssid,
+sta/connect.c:				      pAd->MlmeAux.SsidLen);
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_START;
+sta/connect.c:			/*pAd->MlmeAux.BssIdx = 0;*/
+sta/connect.c:			pAd->MlmeAux.BssIdx++;
+sta/connect.c:			if (pAd->StaCfg.WscControl.WscState >= WSC_STATE_START)
+sta/connect.c:			else if (((pAd->StaCfg.WscControl.bWscTrigger == FALSE)
+sta/connect.c:				 && (pAd->StaCfg.WscControl.WscState !=
+sta/connect.c:				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:			if (pAd->MlmeAux.BssType == BSS_ADHOC) {
+sta/connect.c:				if ((pAd->CommonCfg.bIEEE80211H == 1) &&
+sta/connect.c:				    RadarChannelCheck(pAd, pAd->CommonCfg.Channel))
+sta/connect.c:					pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:						  pAd->CommonCfg.Channel));
+sta/connect.c:				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:					  PRINT_MAC(pAd->CommonCfg.Bssid)));
+sta/connect.c:				pAd->ExtraInfo = GENERAL_LINK_UP;
+sta/connect.c:					if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeShared)
+sta/connect.c:					    || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeAutoSwitch))
+sta/connect.c:							     pAd->MlmeAux.Bssid,
+sta/connect.c:							     pAd->MlmeAux.Bssid,
+sta/connect.c:				pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_AUTH;
+sta/connect.c:			pAd->MlmeAux.BssIdx++;
+sta/connect.c:			if ((pAd->CommonCfg.bIEEE80211H == 1) &&
+sta/connect.c:			    RadarChannelCheck(pAd, pAd->CommonCfg.Channel)
+sta/connect.c:				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:					  pAd->CommonCfg.Channel));
+sta/connect.c:			rt_phy_info = &pAd->StaActive.SupportedPhyInfo;
+sta/connect.c:			if (WMODE_CAP_N(pAd->CommonCfg.PhyMode)
+sta/connect.c:			    && (pAd->StaCfg.bAdhocN == TRUE)
+sta/connect.c:			    && (!pAd->CommonCfg.HT_DisallowTKIP
+sta/connect.c:				|| !IS_INVALID_HT_SECURITY(pAd->StaCfg.WepStatus)))
+sta/connect.c:				pAd->MlmeAux.CentralChannel = get_cent_ch_by_htinfo(pAd,
+sta/connect.c:												&pAd->CommonCfg.AddHTInfo,
+sta/connect.c:												&pAd->CommonCfg.HtCapability);
+sta/connect.c:				NdisMoveMemory(&pAd->MlmeAux.AddHtInfo,
+sta/connect.c:					       &pAd->CommonCfg.AddHTInfo,
+sta/connect.c:					    &pAd->CommonCfg.HtCapability,
+sta/connect.c:					    &pAd->CommonCfg.AddHTInfo);
+sta/connect.c:					       &pAd->CommonCfg.HtCapability.MCSSet[0], 16);
+sta/connect.c:				if (WMODE_CAP_AC(pAd->CommonCfg.PhyMode) &&
+sta/connect.c:					pAd->MlmeAux.vht_cap_len) {
+sta/connect.c:					RT_VHT_CAP *rt_vht_cap = &pAd->StaActive.SupVhtCap;
+sta/connect.c:					rt_vht_cap->sgi_80m = pAd->MlmeAux.vht_cap.vht_cap.sgi_80M;
+sta/connect.c:					rt_vht_cap->vht_txstbc = pAd->MlmeAux.vht_cap.vht_cap.tx_stbc;
+sta/connect.c:					rt_vht_cap->vht_rxstbc = pAd->MlmeAux.vht_cap.vht_cap.rx_stbc;
+sta/connect.c:					rt_vht_cap->vht_htc = pAd->MlmeAux.vht_cap.vht_cap.htc_vht_cap;
+sta/connect.c:				pAd->StaActive.SupportedPhyInfo.bHtEnable = FALSE;
+sta/connect.c:			pAd->StaCfg.bAdhocCreator = TRUE;
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:			if ((pAd->CommonCfg.Channel > 14)
+sta/connect.c:			    && (pAd->CommonCfg.bIEEE80211H == 1)
+sta/connect.c:			    && RadarChannelCheck(pAd, pAd->CommonCfg.Channel)) {
+sta/connect.c:				pAd->Dot11_H.RDMode = RD_SILENCE_MODE;
+sta/connect.c:				pAd->Dot11_H.RDCount = 0;
+sta/connect.c:				  PRINT_MAC(pAd->CommonCfg.Bssid)));
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:			AssocParmFill(pAd, &AssocReq, pAd->MlmeAux.Bssid,
+sta/connect.c:				      pAd->MlmeAux.CapabilityInfo,
+sta/connect.c:				      pAd->StaCfg.DefaultListenCount);
+sta/connect.c:				pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_ASSOC;
+sta/connect.c:				if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeShared)
+sta/connect.c:				    || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeAutoSwitch))
+sta/connect.c:						     pAd->MlmeAux.Bssid,
+sta/connect.c:						     pAd->MlmeAux.Bssid,
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_AUTH2;
+sta/connect.c:			AssocParmFill(pAd, &AssocReq, pAd->MlmeAux.Bssid,
+sta/connect.c:				      pAd->MlmeAux.CapabilityInfo,
+sta/connect.c:				      pAd->StaCfg.DefaultListenCount);
+sta/connect.c:				pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_ASSOC;
+sta/connect.c:			if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeAutoSwitch)
+sta/connect.c:				    && (pAd->MlmeAux.Alg == Ndis802_11AuthModeShared)) {
+sta/connect.c:				AuthParmFill(pAd, &AuthReq, pAd->MlmeAux.Bssid,
+sta/connect.c:				pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_AUTH2;
+sta/connect.c:                        RT_CFG80211_CONN_RESULT_INFORM(pAd, pAd->MlmeAux.Bssid, NULL, 0,
+sta/connect.c:				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:				pAd->MlmeAux.BssIdx++;
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:				 ("CNTL - Association successful on BSS #%ld\n", pAd->MlmeAux.BssIdx));
+sta/connect.c:				 ("CNTL - Association fails on BSS #%ld\n", pAd->MlmeAux.BssIdx));
+sta/connect.c:                        RT_CFG80211_CONN_RESULT_INFORM(pAd, pAd->MlmeAux.Bssid, NULL, 0,
+sta/connect.c:			pAd->MlmeAux.BssIdx++;
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:				  pAd->MlmeAux.RoamIdx));
+sta/connect.c:				  pAd->MlmeAux.RoamIdx));
+sta/connect.c:				pAd->MlmeAux.RoamIdx++;
+sta/connect.c:	if (pAd->CommonCfg.APEdcaParm.bValid == FALSE) {
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.bValid = TRUE;
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.Aifsn[0] = 3;
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.Aifsn[1] = 7;
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.Aifsn[2] = 1;
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.Aifsn[3] = 1;
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.Cwmin[0] = 4;
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.Cwmin[1] = 4;
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.Cwmin[2] = 3;
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.Cwmin[3] = 2;
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.Cwmax[0] = 10;
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.Cwmax[1] = 6;
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.Cwmax[2] = 4;
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.Cwmax[3] = 3;
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.Txop[0] = 0;
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.Txop[1] = 0;
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.Txop[2] = AC2_DEF_TXOP;
+sta/connect.c:		pAd->CommonCfg.APEdcaParm.Txop[3] = AC3_DEF_TXOP;
+sta/connect.c:	AsicSetEdcaParm(pAd, &pAd->CommonCfg.APEdcaParm);
+sta/connect.c:	pAd->Mlme.ChannelQuality = 50;
+sta/connect.c:	pAd->StaCfg.bImprovedScan = FALSE;
+sta/connect.c:	pAd->StaCfg.bNotFirstScan = TRUE;
+sta/connect.c:	pAd->StaCfg.bAutoConnectByBssid = FALSE;
+sta/connect.c:	pAd->CountDowntoPsm = STAY_10_SECONDS_AWAKE;
+sta/connect.c:	pEntry = &pAd->MacTab.Content[BSSID_WCID];
+sta/connect.c:	RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer, &Cancelled);
+sta/connect.c:	tmpWscSsidLen = pAd->CommonCfg.SsidLen;
+sta/connect.c:	NdisMoveMemory(tmpWscSsid, pAd->CommonCfg.Ssid, tmpWscSsidLen);
+sta/connect.c:		pApCliEntry = &pAd->ApCfg.ApCliTab[BSS0];
+sta/connect.c:			pAd->CommonCfg.CentralChannel = pAd->MlmeAux.ConCurrentCentralChannel;
+sta/connect.c:			if (pAd->MlmeAux.bBwFallBack == TRUE)
+sta/connect.c:				pAd->StaActive.SupportedHtPhy.ChannelWidth = BW_20;
+sta/connect.c:		pAd->CommonCfg.CarrierDetect.CD_State = CD_NORMAL;
+sta/connect.c:		if (WMODE_CAP_N(pAd->CommonCfg.PhyMode)
+sta/connect.c:		    && (pAd->StaCfg.bAdhocN == TRUE))
+sta/connect.c:		  BssType, pAd->StaActive.Aid, pAd->CommonCfg.Ssid,
+sta/connect.c:		  pAd->CommonCfg.Channel, pAd->CommonCfg.CentralChannel));
+sta/connect.c:	DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK UP !!! (Density =%d, )\n", pAd->MacTab.Content[BSSID_WCID].MpduDensity));
+sta/connect.c:		AsicSetBssid(pAd, pAd->CommonCfg.Bssid);
+sta/connect.c:	AsicSetStreamMode(pAd, &pAd->CommonCfg.Bssid[0], 1, TRUE);
+sta/connect.c:	AsicSetEdcaParm(pAd, &pAd->CommonCfg.APEdcaParm);
+sta/connect.c:	if ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE)) {
+sta/connect.c:		if (pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent == 1) {
+sta/connect.c:					  pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode, ALLN_SETPROTECT, FALSE,
+sta/connect.c:					  pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode, ALLN_SETPROTECT, FALSE,
+sta/connect.c:	NdisZeroMemory(&pAd->DrsCounters, sizeof (COUNTER_DRS));
+sta/connect.c:	pAd->StaCfg.LastBeaconRxTime = Now;	/* last RX timestamp */
+sta/connect.c:	if ((pAd->CommonCfg.TxPreamble != Rt802_11PreambleLong) &&
+sta/connect.c:	    CAP_IS_SHORT_PREAMBLE_ON(pAd->StaActive.CapabilityInfo)) {
+sta/connect.c:	pAd->Dot11_H.RDMode = RD_NORMAL_MODE;
+sta/connect.c:	if (pAd->StaCfg.WepStatus <= Ndis802_11WEPDisabled) 
+sta/connect.c:		if (pAd->StaCfg.WpaSupplicantUP &&
+sta/connect.c:		    (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) &&
+sta/connect.c:		    (pAd->StaCfg.IEEE8021X == TRUE)) ;
+sta/connect.c:			pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+sta/connect.c:			pAd->StaCfg.PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
+sta/connect.c:		if ((pAd->CommonCfg.Channel > 14)
+sta/connect.c:		    && (pAd->CommonCfg.bIEEE80211H == 1)
+sta/connect.c:		    && RadarChannelCheck(pAd, pAd->CommonCfg.Channel)) {
+sta/connect.c:		if (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) {
+sta/connect.c:				CipherAlg = pAd->SharedKey[BSS0][idx].CipherAlg;
+sta/connect.c:				if (pAd->SharedKey[BSS0][idx].KeyLen > 0) {
+sta/connect.c:							      &pAd->SharedKey[BSS0][idx]);
+sta/connect.c:					if (idx == pAd->StaCfg.DefaultKeyId) {
+sta/connect.c:							pAd->SharedKey[BSS0][idx].TxTsc[cnt] = RandomByte(pAd);
+sta/connect.c:		else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone) {
+sta/connect.c:			pAd->StaCfg.DefaultKeyId = 0;	/* always be zero */
+sta/connect.c:			NdisZeroMemory(&pAd->SharedKey[BSS0][0], sizeof (CIPHER_KEY));
+sta/connect.c:			pAd->SharedKey[BSS0][0].KeyLen = LEN_TK;
+sta/connect.c:			NdisMoveMemory(pAd->SharedKey[BSS0][0].Key, pAd->StaCfg.PMK, LEN_TK);
+sta/connect.c:			if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled) {
+sta/connect.c:				NdisMoveMemory(pAd->SharedKey[BSS0][0].RxMic,
+sta/connect.c:					       &pAd->StaCfg.PMK[16], LEN_TKIP_MIC);
+sta/connect.c:				NdisMoveMemory(pAd->SharedKey[BSS0][0].TxMic,
+sta/connect.c:					       &pAd->StaCfg.PMK[16], LEN_TKIP_MIC);
+sta/connect.c:			if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
+sta/connect.c:				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_TKIP;
+sta/connect.c:			else if (pAd->StaCfg.PairCipher == Ndis802_11Encryption3Enabled)
+sta/connect.c:				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_AES;
+sta/connect.c:					  pAd->StaCfg.PairCipher));
+sta/connect.c:				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_AES;
+sta/connect.c:					      BSS0, 0, &pAd->SharedKey[BSS0][0]);
+sta/connect.c:						pAd->SharedKey[BSS0][0].CipherAlg, MCAST_WCID,
+sta/connect.c:		else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+sta/connect.c:			 && (pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_DISABLE)
+sta/connect.c:			pAd->StaCfg.DefaultKeyId = 0;	/* always be zero */
+sta/connect.c:			NdisZeroMemory(&pAd->SharedKey[BSS0][0], sizeof (CIPHER_KEY));
+sta/connect.c:			pAd->SharedKey[BSS0][0].KeyLen = LEN_TK;
+sta/connect.c:			NdisMoveMemory(pAd->SharedKey[BSS0][0].Key, pAd->StaCfg.PMK, LEN_TK);
+sta/connect.c:			pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_AES;
+sta/connect.c:			GenRandom(pAd, pAd->CommonCfg.Bssid, pAd->StaCfg.GMK);
+sta/connect.c:			GenRandom(pAd, pAd->CommonCfg.Bssid, pAd->StaCfg.GNonce);
+sta/connect.c:			WpaDeriveGTK(pAd->StaCfg.GMK,
+sta/connect.c:				     pAd->StaCfg.GNonce,
+sta/connect.c:				     pAd->CurrentAddress,
+sta/connect.c:				     pAd->StaCfg.GTK, LEN_TKIP_GTK);
+sta/connect.c:			if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption3Enabled) {
+sta/connect.c:				NdisZeroMemory(&pAd->StaCfg.TxGTK, sizeof (CIPHER_KEY));
+sta/connect.c:				NdisMoveMemory(pAd->StaCfg.TxGTK.Key, pAd->StaCfg.GTK, LEN_TK);
+sta/connect.c:				pAd->StaCfg.TxGTK.CipherAlg = CIPHER_AES;
+sta/connect.c:				pAd->StaCfg.TxGTK.KeyLen = LEN_TK;
+sta/connect.c:							&pAd->StaCfg.TxGTK);
+sta/connect.c:							pAd->StaCfg.TxGTK.CipherAlg, (UCHAR) Wcid,
+sta/connect.c:			if (pAd->CommonCfg.LastSsidLen == pAd->CommonCfg.SsidLen) {
+sta/connect.c:				if (RTMPCompareMemory(pAd->CommonCfg.LastSsid, pAd->CommonCfg.Ssid, pAd->CommonCfg.LastSsidLen) == 0) {
+sta/connect.c:			pAd->ExtraInfo = GENERAL_LINK_DOWN;
+sta/connect.c:		if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) {
+sta/connect.c:			pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+sta/connect.c:			pAd->StaCfg.PrivacyFilter = Ndis802_11PrivFilter8021xWEP;
+sta/connect.c:                                && (pAd->StaCfg.WepStatus == Ndis802_11EncryptionSMS4Enabled))
+sta/connect.c:			if ((pAd->CommonCfg.Channel != pAd->P2PChannel))
+sta/connect.c:							,pAd->P2PChannel,pAd->CommonCfg.Channel));
+sta/connect.c:							,pAd->P2PExtChOffset,pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset));
+sta/connect.c:			if ((pAd->CommonCfg.Channel != pAd->P2PChannel))
+sta/connect.c:							,pAd->P2PChannel,pAd->CommonCfg.Channel));
+sta/connect.c:							,pAd->P2PExtChOffset,pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset));
+sta/connect.c:		AsicUpdateRxWCIDTable(pAd, BSSID_WCID, pAd->CommonCfg.Bssid);
+sta/connect.c:		if (((pAd->StaCfg.WpaSupplicantUP) &&
+sta/connect.c:		     (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) &&
+sta/connect.c:		     (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_SECURED)) ||
+sta/connect.c:		    ((pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_DISABLE) &&
+sta/connect.c:		     (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled)))
+sta/connect.c:		if (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled)
+sta/connect.c:				CipherAlg = pAd->SharedKey[BSS0][idx].CipherAlg;
+sta/connect.c:				if (pAd->SharedKey[BSS0][idx].KeyLen > 0) {
+sta/connect.c:							      &pAd->SharedKey[BSS0][idx]);
+sta/connect.c:					if (idx == pAd->StaCfg.DefaultKeyId) {
+sta/connect.c:		if (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA) 
+sta/connect.c:			if (((pAd->StaCfg.WpaSupplicantUP) && (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) && (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_SECURED)) 
+sta/connect.c:				|| ((pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_DISABLE) && (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled)) 
+sta/connect.c:				|| (pAd->StaCfg.WepStatus == Ndis802_11WEPDisabled))
+sta/connect.c:				pAd->ExtraInfo = GENERAL_LINK_UP;
+sta/connect.c:		} else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+sta/connect.c:			   (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+sta/connect.c:			if (pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_DISABLE)
+sta/connect.c:				RTMPSetTimer(&pAd->Mlme.LinkDownTimer, LINK_DOWN_TIMEOUT);
+sta/connect.c:			if (pAd->StaCfg.WscControl.WscProfileRetryTimerRunning) {
+sta/connect.c:				RTMPSetTimer(&pAd->StaCfg.WscControl.WscProfileRetryTimer,
+sta/connect.c:			  pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
+sta/connect.c:		if ((pAd->StaCfg.WscControl.WscConfMode != WSC_DISABLE) &&
+sta/connect.c:		    (pAd->StaCfg.WscControl.bWscTrigger
+sta/connect.c:			RTMPCancelTimer(&pAd->Mlme.LinkDownTimer, &Cancelled);
+sta/connect.c:			pAd->StaCfg.WscControl.WscState = WSC_STATE_LINK_UP;
+sta/connect.c:			pAd->StaCfg.WscControl.WscStatus = WSC_STATE_LINK_UP;
+sta/connect.c:			NdisZeroMemory(pAd->CommonCfg.Ssid, MAX_LEN_OF_SSID);
+sta/connect.c:			NdisMoveMemory(pAd->CommonCfg.Ssid, tmpWscSsid,
+sta/connect.c:			pAd->CommonCfg.SsidLen = tmpWscSsidLen;
+sta/connect.c:						&pAd->StaCfg.WscControl);
+sta/connect.c:			  pAd->StaActive.SupportedPhyInfo.bHtEnable));
+sta/connect.c:		if (pAd->CommonCfg.bAggregationCapable) {
+sta/connect.c:			if ((pAd->CommonCfg.bPiggyBackCapable)
+sta/connect.c:			    && (pAd->MlmeAux.APRalinkIe & 0x00000003) == 3) {
+sta/connect.c:			} else if (pAd->MlmeAux.APRalinkIe & 0x00000001) {
+sta/connect.c:		if (pAd->MlmeAux.APRalinkIe != 0x0) {
+sta/connect.c:	/*if (pAd->StaCfg.WscControl.bWPSSession == FALSE) */
+sta/connect.c:	if (pAd->StaCfg.WscControl.WscConfMode == WSC_DISABLE) {
+sta/connect.c:			if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeOpen)
+sta/connect.c:			    && (pAd->StaCfg.WepStatus == Ndis802_11WEPDisabled)) {
+sta/connect.c:		  pAd->CommonCfg.BACapability.word,
+sta/connect.c:		  pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
+sta/connect.c:	pAd->Mlme.PeriodicRound = 0;
+sta/connect.c:	pAd->Mlme.OneSecPeriodicRound = 0;
+sta/connect.c:	pAd->bConfigChanged = FALSE;	/* Reset config flag */
+sta/connect.c:	pAd->ExtraInfo = GENERAL_LINK_UP;	/* Update extra information to link is up */
+sta/connect.c:				      &pAd->CommonCfg.TxRateIndex);
+sta/connect.c:	NdisAcquireSpinLock(&pAd->MacTabLock);
+sta/connect.c:	pEntry->HTPhyMode.word = pAd->StaCfg.HTPhyMode.word;
+sta/connect.c:	pEntry->MaxHTPhyMode.word = pAd->StaCfg.HTPhyMode.word;
+sta/connect.c:	if (pAd->StaCfg.bAutoTxRateSwitch == FALSE) {
+sta/connect.c:			RTMPUpdateLegacyTxSetting((UCHAR) pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode, pEntry);
+sta/connect.c:	NdisReleaseSpinLock(&pAd->MacTabLock);
+sta/connect.c:	pAd->LastTxRate = (USHORT) (pEntry->HTPhyMode.word);
+sta/connect.c:	if (pAd->StaActive.SupportedPhyInfo.MCSSet[0] != 0x00)
+sta/connect.c:			if (pAd->Antenna.field.TxPath >= 2)
+sta/connect.c:	if ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE)) {
+sta/connect.c:	if (!((pAd->CommonCfg.RxStream == 1) && (pAd->CommonCfg.TxStream == 1))
+sta/connect.c:	    && (pAd->StaCfg.bForceTxBurst == FALSE)
+sta/connect.c:	    (((pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE)
+sta/connect.c:	     || ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE)
+sta/connect.c:		 && (pAd->CommonCfg.BACapability.field.Policy == BA_NOTUSE)))) {
+sta/connect.c:	if (pAd->CommonCfg.bEnableTxBurst) {
+sta/connect.c:		pAd->CommonCfg.IOTestParm.bNowAtherosBurstOn = TRUE;
+sta/connect.c:	if ((pAd->CommonCfg.IOTestParm.bLastAtheros == TRUE)
+sta/connect.c:		pAd->CommonCfg.IOTestParm.bNextDisableRxBA = TRUE;
+sta/connect.c:		if (pAd->CommonCfg.bEnableTxBurst) {
+sta/connect.c:			pAd->CommonCfg.IOTestParm.bNowAtherosBurstOn = FALSE;
+sta/connect.c:		pAd->CommonCfg.IOTestParm.bNextDisableRxBA = FALSE;
+sta/connect.c:	pAd->CommonCfg.IOTestParm.bLastAtheros = FALSE;
+sta/connect.c:	if ((pAd->StaCfg.BssType == BSS_INFRA) &&
+sta/connect.c:	    (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) &&
+sta/connect.c:	    (NdisEqualMemory(pAd->CommonCfg.Bssid, pAd->CommonCfg.LastBssid, MAC_ADDR_LEN) == FALSE) &&
+sta/connect.c:	     (pAd->StaCfg.bLostAp == TRUE)) {
+sta/connect.c:		pAd->StaCfg.bLostAp = FALSE;
+sta/connect.c:	COPY_MAC_ADDR(pAd->CommonCfg.LastBssid, pAd->CommonCfg.Bssid);
+sta/connect.c:		 ("!!!pAd->bNextDisableRxBA= %d \n",
+sta/connect.c:		  pAd->CommonCfg.IOTestParm.bNextDisableRxBA));
+sta/connect.c:	NdisAcquireSpinLock(&pAd->MacTabLock);
+sta/connect.c:	pEntry->PortSecured = pAd->StaCfg.PortSecured;
+sta/connect.c:	NdisReleaseSpinLock(&pAd->MacTabLock);
+sta/connect.c:	if ((pAd->StaCfg.WscControl.WscConfMode != WSC_DISABLE) &&
+sta/connect.c:	    (pAd->StaCfg.WscControl.bWscTrigger
+sta/connect.c:		if (pAd->StaCfg.BssType == BSS_INFRA) {
+sta/connect.c:			NdisMoveMemory(pAd->StaCfg.WscControl.WscPeerMAC,
+sta/connect.c:				       pAd->CommonCfg.Bssid, MAC_ADDR_LEN);
+sta/connect.c:			NdisMoveMemory(pAd->StaCfg.WscControl.EntryAddr,
+sta/connect.c:				       pAd->CommonCfg.Bssid, MAC_ADDR_LEN);
+sta/connect.c:					  pAd->StaCfg.WscControl.WscPeerMAC, STA_MODE);
+sta/connect.c:		if ((pAd->CommonCfg.bBssCoexEnable == TRUE)
+sta/connect.c:		    && (pAd->CommonCfg.Channel <= 14)
+sta/connect.c:		    && (pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE)
+sta/connect.c:		    && (pAd->MlmeAux.ExtCapInfo.BssCoexistMgmtSupport == 1)) {
+sta/connect.c:				  pAd->CommonCfg.Dot11BssWidthTriggerScanInt));
+sta/connect.c:				 ("pAd->CommonCfg Info: bBssCoexEnable=%d, Channel=%d, CentralChannel=%d, PhyMode=%d\n",
+sta/connect.c:					pAd->CommonCfg.bBssCoexEnable, pAd->CommonCfg.Channel,
+sta/connect.c:					pAd->CommonCfg.CentralChannel, pAd->CommonCfg.PhyMode));
+sta/connect.c:				 ("pAd->StaActive.SupportedHtPhy.bHtEnable=%d\n",
+sta/connect.c:				  pAd->StaActive.SupportedPhyInfo.bHtEnable));
+sta/connect.c:				 ("pAd->MlmeAux.ExtCapInfo.BssCoexstSup=%d\n",
+sta/connect.c:				  pAd->MlmeAux.ExtCapInfo.BssCoexistMgmtSupport));
+sta/connect.c:	if ((pAd->StaCfg.BssType == BSS_INFRA) &&
+sta/connect.c:	    (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) &&
+sta/connect.c:	     (pAd->CommonCfg.Bssid, pAd->CommonCfg.LastBssid, MAC_ADDR_LEN))
+sta/connect.c:	    && (pAd->StaCfg.bLostAp == TRUE)) {
+sta/connect.c:		WpaSendEapolStart(pAd, pAd->CommonCfg.Bssid);
+sta/connect.c:		pAd->StaCfg.bLostAp = FALSE;
+sta/connect.c:						&pAd->MacTab.Content[BSSID_WCID],
+sta/connect.c:		AndesCalibrationOP(pAd, ANDES_CALIBRATION_DPD, pAd->chipCap.CurrentTemperature);
+sta/connect.c:	pAd->MacTab.MsduLifeTime = 5; /* default 5 seconds */
+sta/connect.c:	DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK DOWN !!! - %d - %d\n", pAd->StaCfg.bImprovedScan, pAd->MlmeAux.Channel));
+sta/connect.c:	pAd->StaCfg.bImprovedScan = FALSE;
+sta/connect.c:    if (pAd->FlgCfg80211Scanning) 
+sta/connect.c:	   DBGPRINT(RT_DEBUG_TRACE, ("---> CFG80211_MLME Disconnect in Scaning, ORI ==> %d\n", pAd->Mlme.CntlMachine.CurrState)); 	
+sta/connect.c:	   RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &Cancelled);
+sta/connect.c:	   pAd->MlmeAux.Channel = 0;
+sta/connect.c:	   pAd->FlgCfg80211Scanning = FALSE;	
+sta/connect.c:	   DBGPRINT(RT_DEBUG_TRACE, ("<--- CFG80211_MLME Disconnect in Scaning END, ORI ==> %d\n", pAd->Mlme.CntlMachine.CurrState)); 
+sta/connect.c:	if (pAd->FlgCfg80211Connecting)
+sta/connect.c:		DBGPRINT(RT_DEBUG_TRACE, ("---> CFG80211_MLME Disconnect in Connecting, ORI ==> %d\n", pAd->Mlme.CntlMachine.CurrState)); 
+sta/connect.c:		DBGPRINT(RT_DEBUG_TRACE, ("<--- CFG80211_MLME Disconnect in Connecting END, ORI ==> %d\n", pAd->Mlme.CntlMachine.CurrState)); 
+sta/connect.c:		pAd->Mlme.bPsPollTimerRunning = FALSE;
+sta/connect.c:		RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled);
+sta/connect.c:	pAd->bPCIclkOff = FALSE;
+sta/connect.c:		if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK) {
+sta/connect.c:				if (IS_ENTRY_CLIENT(&pAd->MacTab.Content[i]))
+sta/connect.c:							 &pAd->MacTab.
+sta/connect.c:		pAd->ExtraInfo = GENERAL_LINK_DOWN;
+sta/connect.c:		BssTableDeleteEntry(&pAd->ScanTab, pAd->CommonCfg.Bssid,
+sta/connect.c:				    pAd->CommonCfg.Channel);
+sta/connect.c:			 ("!!! MacTab.Size=%d !!!\n", pAd->MacTab.Size));
+sta/connect.c:		if (pAd->CommonCfg.bDLSCapable) {
+sta/connect.c:				if (pAd->StaCfg.DLSEntry[i].Valid
+sta/connect.c:				    && (pAd->StaCfg.DLSEntry[i].Status ==
+sta/connect.c:					pAd->StaCfg.DLSEntry[i].Status =
+sta/connect.c:								 pAd->StaCfg.
+sta/connect.c:				if (pAd->StaCfg.DLSEntry[i].Valid && (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH)) {
+sta/connect.c:					pAd->StaCfg.DLSEntry[i].Status = DLS_NONE;
+sta/connect.c:					RTMPSendDLSTearDownFrame(pAd, pAd->StaCfg.DLSEntry[i].MacAddr);
+sta/connect.c:		pAd->CommonCfg.LastSsidLen = pAd->CommonCfg.SsidLen;
+sta/connect.c:		NdisMoveMemory(pAd->CommonCfg.LastSsid, pAd->CommonCfg.Ssid,
+sta/connect.c:			       pAd->CommonCfg.LastSsidLen);
+sta/connect.c:		COPY_MAC_ADDR(pAd->CommonCfg.LastBssid, pAd->CommonCfg.Bssid);
+sta/connect.c:		if (pAd->MlmeAux.CurrReqIsFromNdis == TRUE) {
+sta/connect.c:			pAd->MlmeAux.CurrReqIsFromNdis = FALSE;
+sta/connect.c:			if ((pAd->StaCfg.PortSecured == WPA_802_1X_PORT_SECURED)
+sta/connect.c:			    || (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA)) {
+sta/connect.c:				BssTableDeleteEntry(&pAd->ScanTab,
+sta/connect.c:						    pAd->CommonCfg.Bssid,
+sta/connect.c:						    pAd->CommonCfg.Channel);
+sta/connect.c:		if (pAd->StaCfg.IEEE80211dClientMode != Rt802_11_D_None) {
+sta/connect.c:			NdisMoveMemory(&pAd->CommonCfg.CountryCode[0],
+sta/connect.c:				       &pAd->StaCfg.StaOriCountryCode[0], 2);
+sta/connect.c:			pAd->CommonCfg.Geography = pAd->StaCfg.StaOriGeography;
+sta/connect.c:	if (pAd->StaCfg.WepStatus == Ndis802_11EncryptionSMS4Enabled) {
+sta/connect.c:		/*NdisZeroMemory(pAd->StaCfg.rx_iv, LEN_WAPI_TSC); */
+sta/connect.c:					       &pAd->MacTab.
+sta/connect.c:		if (IS_ENTRY_CLIENT(&pAd->MacTab.Content[i])
+sta/connect.c:			&& (!IS_P2P_GO_ENTRY(&pAd->MacTab.Content[i]))
+sta/connect.c:			MacTableDeleteEntry(pAd, pAd->MacTab.Content[i].Aid,
+sta/connect.c:					    pAd->MacTab.Content[i].Addr);
+sta/connect.c:	pAd->LedCntl.LedIndicatorStrength = 0xF0;
+sta/connect.c:	pAd->Mlme.PeriodicRound = 0;
+sta/connect.c:	pAd->Mlme.OneSecPeriodicRound = 0;
+sta/connect.c:	NdisZeroMemory(&pAd->MlmeAux.HtCapability, sizeof (HT_CAPABILITY_IE));
+sta/connect.c:	NdisZeroMemory(&pAd->MlmeAux.AddHtInfo, sizeof (ADD_HT_INFO_IE));
+sta/connect.c:	pAd->MlmeAux.HtCapabilityLen = 0;
+sta/connect.c:	pAd->MlmeAux.NewExtChannelOffset = 0xff;
+sta/connect.c:	NdisZeroMemory((PUCHAR) (&pAd->MlmeAux.ExtCapInfo),
+sta/connect.c:	if (pAd->StaCfg.WpaState != SS_NOTUSE) {
+sta/connect.c:		pAd->StaCfg.WpaState = SS_START;
+sta/connect.c:		NdisZeroMemory(pAd->StaCfg.ReplayCounter, 8);
+sta/connect.c:		if (pAd->CommonCfg.bDLSCapable)
+sta/connect.c:			NdisZeroMemory(pAd->StaCfg.DlsReplayCounter, 8);
+sta/connect.c:	if ((IsReqFromAP) && (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)) {
+sta/connect.c:	if (pAd->StaCfg.WpaSupplicantUP &&
+sta/connect.c:	    (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) &&
+sta/connect.c:	    (pAd->StaCfg.IEEE8021X == FALSE)) {
+sta/connect.c:		pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+sta/connect.c:		pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+sta/connect.c:		pAd->StaCfg.PrivacyFilter = Ndis802_11PrivFilter8021xWEP;
+sta/connect.c:	NdisAcquireSpinLock(&pAd->MacTabLock);
+sta/connect.c:	NdisZeroMemory(&pAd->MacTab.Content[BSSID_WCID], sizeof(MAC_TABLE_ENTRY));
+sta/connect.c:	pAd->MacTab.Content[BSSID_WCID].PortSecured = pAd->StaCfg.PortSecured;
+sta/connect.c:	NdisReleaseSpinLock(&pAd->MacTabLock);
+sta/connect.c:	pAd->StaCfg.MicErrCnt = 0;
+sta/connect.c:	pAd->ExtraInfo = GENERAL_LINK_DOWN;
+sta/connect.c:	pAd->StaActive.SupportedPhyInfo.bHtEnable = FALSE;
+sta/connect.c:	pAd->bUsbTxBulkAggre = FALSE;
+sta/connect.c:	NdisZeroMemory(&pAd->StaCfg.AssocInfo,
+sta/connect.c:	pAd->StaCfg.AssocInfo.Length =
+sta/connect.c:	pAd->StaCfg.ReqVarIELen = 0;
+sta/connect.c:	pAd->StaCfg.ResVarIELen = 0;
+sta/connect.c:	NdisZeroMemory((PUCHAR) (&pAd->StaCfg.RssiSample),
+sta/connect.c:		       sizeof (pAd->StaCfg.RssiSample));
+sta/connect.c:	pAd->CommonCfg.MlmeRate = pAd->CommonCfg.BasicMlmeRate;
+sta/connect.c:	pAd->CommonCfg.RtsRate = pAd->CommonCfg.BasicMlmeRate;
+sta/connect.c:	if (pAd->CommonCfg.BBPCurrentBW != BW_20) {
+sta/connect.c:		pApCliEntry = &pAd->ApCfg.ApCliTab[BSS0];
+sta/connect.c:			if (pAd->Antenna.field.TxPath >= 2)
+sta/connect.c:	pAd->CommonCfg.BACapability.word = pAd->CommonCfg.REGBACapability.word;
+sta/connect.c:	pAd->CommonCfg.IOTestParm.bCurrentAtheros = FALSE;
+sta/connect.c:	pAd->CommonCfg.IOTestParm.bNowAtherosBurstOn = FALSE;
+sta/connect.c:	pAd->CommonCfg.BSSCoexist2040.word = 0;
+sta/connect.c:	for (i = 0; i < (pAd->ChannelListNum - 1); i++) {
+sta/connect.c:		pAd->ChannelList[i].bEffectedChannel = FALSE;
+sta/connect.c:	if (pAd->StaCfg.WpaSupplicantUP) {
+sta/connect.c:		RtmpOSWrielessEventSend(pAd->net_dev, RT_WLAN_EVENT_CUSTOM,
+sta/connect.c:	RtmpOSWrielessEventSend(pAd->net_dev, RT_WLAN_EVENT_CGIWAP, -1, NULL,
+sta/connect.c:	if (pAd->StaCfg.BssType != BSS_ADHOC)
+sta/connect.c:		pAd->StaCfg.bNotFirstScan = FALSE;
+sta/connect.c:		pAd->StaCfg.bAdhocCreator = FALSE;
+sta/connect.c:	pAd->StaCfg.RssiSample.AvgRssi0	= -127;
+sta/connect.c:	pAd->StaCfg.RssiSample.AvgRssi1	= -127;
+sta/connect.c:	pAd->StaCfg.RssiSample.AvgRssi2	= -127;
+sta/connect.c:	NdisZeroMemory(pAd->StaCfg.ConnectinfoSsid, MAX_LEN_OF_SSID);
+sta/connect.c:	NdisZeroMemory(pAd->StaCfg.ConnectinfoBssid, MAC_ADDR_LEN);
+sta/connect.c:	pAd->StaCfg.ConnectinfoSsidLen  = 0;
+sta/connect.c:	pAd->StaCfg.ConnectinfoBssType  = 1;
+sta/connect.c:	pAd->StaCfg.ConnectinfoChannel = 0;
+sta/connect.c:	if (pAd->chipCap.FreqCalibrationSupport) 
+sta/connect.c:	pAd->StaCfg.PairCipher = pAd->StaCfg.WepStatus;
+sta/connect.c:	if (pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_DISABLE)
+sta/connect.c:	pAd->StaCfg.GroupCipher = pAd->StaCfg.WepStatus;
+sta/connect.c:	BssIdx = pAd->MlmeAux.BssIdx;
+sta/connect.c:	if (pAd->StaCfg.BssType == BSS_ADHOC) {
+sta/connect.c:		if (BssIdx < pAd->MlmeAux.SsidBssTab.BssNr) {
+sta/connect.c:			pInBss = &pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx];
+sta/connect.c:				  pAd->MlmeAux.SsidBssTab.BssNr));
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_JOIN;
+sta/connect.c:			if (pAd->StaCfg.WscControl.WscState >= WSC_STATE_START) {
+sta/connect.c:				NdisMoveMemory(pAd->StaCfg.WscControl.
+sta/connect.c:				NdisMoveMemory(pAd->StaCfg.WscControl.EntryAddr,
+sta/connect.c:		if (pAd->StaCfg.WscControl.bWscTrigger == TRUE)
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - All BSS fail; start a new ADHOC (Ssid=%s)...\n",pAd->MlmeAux.Ssid));
+sta/connect.c:			StartParmFill(pAd, &StartReq, (PCHAR) pAd->MlmeAux.Ssid,pAd->MlmeAux.SsidLen);
+sta/connect.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_START;
+sta/connect.c:	} else if ((BssIdx < pAd->MlmeAux.SsidBssTab.BssNr) &&
+sta/connect.c:		   (pAd->StaCfg.BssType == BSS_INFRA)) {
+sta/connect.c:		pInBss = &pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx];
+sta/connect.c:		if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA)
+sta/connect.c:		    || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK)) {
+sta/connect.c:			pAd->StaCfg.GroupCipher = pInBss->WPA.GroupCipher;
+sta/connect.c:			if (pAd->StaCfg.WepStatus == pInBss->WPA.PairCipher)
+sta/connect.c:				pAd->StaCfg.PairCipher = pInBss->WPA.PairCipher;
+sta/connect.c:				pAd->StaCfg.PairCipher = pInBss->WPA.PairCipherAux;
+sta/connect.c:				pAd->StaCfg.PairCipher = Ndis802_11Encryption2Enabled;
+sta/connect.c:		} else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
+sta/connect.c:			   || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)) {
+sta/connect.c:			pAd->StaCfg.GroupCipher = pInBss->WPA2.GroupCipher;
+sta/connect.c:			if (pAd->StaCfg.WepStatus == pInBss->WPA2.PairCipher)
+sta/connect.c:				pAd->StaCfg.PairCipher = pInBss->WPA2.PairCipher;
+sta/connect.c:				pAd->StaCfg.PairCipher = pInBss->WPA2.PairCipherAux;
+sta/connect.c:				pAd->StaCfg.PairCipher = Ndis802_11Encryption2Enabled;
+sta/connect.c:			pAd->StaCfg.RsnCapability = pInBss->WPA2.RsnCapability;
+sta/connect.c:		else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAICERT)
+sta/connect.c:			 || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAIPSK)) {
+sta/connect.c:			pAd->StaCfg.GroupCipher = pInBss->WAPI.GroupCipher;
+sta/connect.c:			pAd->StaCfg.PairCipher = pInBss->WAPI.PairCipher;
+sta/connect.c:		pAd->StaCfg.bMixCipher =
+sta/connect.c:		    (pAd->StaCfg.PairCipher ==
+sta/connect.c:		     pAd->StaCfg.GroupCipher) ? FALSE : TRUE;
+sta/connect.c:			  pAd->MlmeAux.SsidBssTab.BssNr));
+sta/connect.c:		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_JOIN;
+sta/connect.c:				  pAd->CommonCfg.Channel, pAd->ScanTab.BssNr));
+sta/connect.c:		pAd->MlmeAux.SsidBssTab.BssNr = 0;
+sta/connect.c:		BssTableDeleteEntry(&pAd->ScanTab,
+sta/connect.c:				    pAd->MlmeAux.SsidBssTab.BssEntry[0].Bssid,
+sta/connect.c:							pAd->MlmeAux.SsidBssTab.BssEntry[0].Channel);
+sta/connect.c:		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:	BssIdx = pAd->MlmeAux.RoamIdx;
+sta/connect.c:	pBss = &pAd->MlmeAux.RoamTab.BssEntry[BssIdx];
+sta/connect.c:	if (BssIdx < pAd->MlmeAux.RoamTab.BssNr) {
+sta/connect.c:			  pAd->MlmeAux.RoamTab.BssNr));
+sta/connect.c:			      pAd->StaCfg.DefaultListenCount);
+sta/connect.c:		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_REASSOC;
+sta/connect.c:			rf_channel = pAd->CommonCfg.Channel;
+sta/connect.c:				  __FUNCTION__, pAd->CommonCfg.Channel,
+sta/connect.c:				  pAd->CommonCfg.CentralChannel));
+sta/connect.c:		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+sta/connect.c:	TXWI_STRUC *pTxWI = &pAd->BeaconTxWI;
+sta/connect.c:	UCHAR *pBeaconFrame = pAd->BeaconBuf;
+sta/connect.c:	if (WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_B)
+sta/connect.c:	    && (pAd->CommonCfg.Channel <= 14)) {
+sta/connect.c:	} else if (pAd->CommonCfg.Channel > 14) {
+sta/connect.c:		pAd->CommonCfg.MlmeRate = RATE_6;
+sta/connect.c:		pAd->CommonCfg.RtsRate = RATE_6;
+sta/connect.c:		pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
+sta/connect.c:		pAd->CommonCfg.MlmeTransmit.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
+sta/connect.c:		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MODE = MODE_OFDM;
+sta/connect.c:		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
+sta/connect.c:	pAd->StaActive.SupRateLen = SupRateLen;
+sta/connect.c:	NdisMoveMemory(pAd->StaActive.SupRate, SupRate, SupRateLen);
+sta/connect.c:	pAd->StaActive.ExtRateLen = ExtRateLen;
+sta/connect.c:	NdisMoveMemory(pAd->StaActive.ExtRate, ExtRate, ExtRateLen);
+sta/connect.c:						pAd->CurrentAddress,
+sta/connect.c:			 pAd->CommonCfg.Bssid);
+sta/connect.c:	Privacy = (pAd->StaCfg.WepStatus == Ndis802_11Encryption1Enabled)
+sta/connect.c:	    || (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled)
+sta/connect.c:	    || (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled);
+sta/connect.c:			 (pAd->CommonCfg.TxPreamble == Rt802_11PreambleShort),
+sta/connect.c:			  2, &pAd->CommonCfg.BeaconPeriod,
+sta/connect.c:			  1, &pAd->CommonCfg.SsidLen,
+sta/connect.c:			  pAd->CommonCfg.SsidLen, pAd->CommonCfg.Ssid,
+sta/connect.c:			  1, &pAd->CommonCfg.Channel,
+sta/connect.c:			  1, &IbssLen, 2, &pAd->StaActive.AtimWin, END_OF_ARGS);
+sta/connect.c:	if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
+sta/connect.c:	    || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+sta/connect.c:		RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus,
+sta/connect.c:		if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+sta/connect.c:				  1, &pAd->StaCfg.RSNIE_Len,
+sta/connect.c:				  pAd->StaCfg.RSNIE_Len, pAd->StaCfg.RSN_IE,
+sta/connect.c:	if (pAd->StaCfg.WpsIEBeacon.ValueLen != 0) {
+sta/connect.c:				  pAd->StaCfg.WpsIEBeacon.ValueLen,
+sta/connect.c:				  pAd->StaCfg.WpsIEBeacon.Value, END_OF_ARGS);
+sta/connect.c:	if (WMODE_CAP_N(pAd->CommonCfg.PhyMode)
+sta/connect.c:	    && (pAd->StaCfg.bAdhocN == TRUE)) {
+sta/connect.c:		HtLen = sizeof (pAd->CommonCfg.HtCapability);
+sta/connect.c:		HtLen1 = sizeof (pAd->CommonCfg.AddHTInfo);
+sta/connect.c:				  HtLen, &pAd->CommonCfg.HtCapability,
+sta/connect.c:				  HtLen1, &pAd->CommonCfg.AddHTInfo,
+sta/connect.c:		NdisMoveMemory(&HtCapabilityTmp, &pAd->CommonCfg.HtCapability,
+sta/connect.c:		NdisMoveMemory(&addHTInfoTmp, &pAd->CommonCfg.AddHTInfo,
+sta/connect.c:	if (pAd->CommonCfg.Channel > 14) {
+sta/connect.c:			      &pAd->CommonCfg.MlmeTransmit);
+sta/connect.c:		  FrameLen, SupRateLen, ExtRateLen, pAd->CommonCfg.Channel,
+sta/connect.c:		  pAd->CommonCfg.PhyMode));
+sta/connect.c:	pAd->CommonCfg.CentralChannel = pAd->MlmeAux.CentralChannel;
+sta/connect.c:	pAd->CommonCfg.Channel = pAd->MlmeAux.Channel;
+sta/connect.c:	if ((pAd->CommonCfg.CentralChannel > pAd->CommonCfg.Channel)
+sta/connect.c:	    && (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40)) {
+sta/connect.c:	    	rf_channel = pAd->CommonCfg.CentralChannel;
+sta/connect.c:	else if ((pAd->CommonCfg.CentralChannel < pAd->CommonCfg.Channel)
+sta/connect.c:			&& (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40))
+sta/connect.c:	    	rf_channel = pAd->CommonCfg.CentralChannel;
+sta/connect.c:	    	rf_channel = pAd->CommonCfg.CentralChannel;
+sta/connect.c:		  pAd->CommonCfg.Channel, 
+sta/connect.c:		  pAd->CommonCfg.CentralChannel));
+sta/connect.c:	rtmp_bbp_get_agc(pAd, &pAd->BbpTuning.R66CurrentValue, RX_CHAIN_0);
+sta/connect.c:			&& NdisEqualMemory(pBss->Ssid, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen))
+sta/connect.c:	pAd->CommonCfg.CentralChannel = ExtraCh;
+sta/connect.c:	pAd->CommonCfg.Channel = PriCh;
+sta/connect.c:	if ((pAd->CommonCfg.CentralChannel > pAd->CommonCfg.Channel) && (BandWidth == BW_40))
+sta/connect.c:		rf_channel = pAd->CommonCfg.CentralChannel;
+sta/connect.c:	else if ((pAd->CommonCfg.CentralChannel < pAd->CommonCfg.Channel) && (BandWidth == BW_40))
+sta/connect.c:		rf_channel = pAd->CommonCfg.CentralChannel;
+sta/connect.c:		rf_channel = pAd->CommonCfg.Channel;
+sta/connect.c:		pAd->StaActive.SupportedPhyInfo.bVhtEnable == TRUE &&
+sta/connect.c:		pAd->StaActive.SupportedPhyInfo.vht_bw == VHT_BW_80) {
+sta/connect.c:		rf_channel = pAd->CommonCfg.vht_cent_ch;
+sta/connect.c:				__FUNCTION__, rf_bw, rf_channel, pAd->CommonCfg.vht_bw, pAd->CommonCfg.Channel,
+sta/connect.c:				pAd->CommonCfg.vht_cent_ch));
+sta/connect.c:				pAd->LatchRfRegs.Channel,
+sta/connect.c:				pAd->CommonCfg.Channel,
+sta/connect.c:				pAd->CommonCfg.CentralChannel));
+sta/connect.c:	DBGPRINT(RT_DEBUG_TRACE, ("VHT-CentralCh=%d\n", pAd->CommonCfg.vht_cent_ch));
+sta/p2pcli_assoc.c:	RTMPInitTimer(pAd, &pAd->ApCliMlmeAux.ApCliAssocTimer, GET_TIMER_FUNCTION(ApCliAssocTimeout), pAd, FALSE);
+sta/p2pcli_assoc.c:		pAd->ApCfg.ApCliTab[i].AssocCurrState = APCLI_ASSOC_IDLE;
+sta/p2pcli_assoc.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].AssocCurrState;
+sta/p2pcli_assoc.c:	pAd->ApCfg.ApCliTab[ifIndex].ReqVarIELen = 0;
+sta/p2pcli_assoc.c:	NdisZeroMemory(pAd->ApCfg.ApCliTab[ifIndex].ReqVarIEs, MAX_VIE_LEN);
+sta/p2pcli_assoc.c:	if (pAd->ApCfg.ApCliTab[ifIndex].bBlockAssoc == TRUE)
+sta/p2pcli_assoc.c:		RTMPCancelTimer(&pAd->ApCliMlmeAux.ApCliAssocTimer, &Cancelled);
+sta/p2pcli_assoc.c:			1,                        &pAd->ApCliMlmeAux.SsidLen, 
+sta/p2pcli_assoc.c:			pAd->ApCliMlmeAux.SsidLen,     pAd->ApCliMlmeAux.Ssid,
+sta/p2pcli_assoc.c:			1,                        &pAd->ApCliMlmeAux.SupRateLen,
+sta/p2pcli_assoc.c:			pAd->ApCliMlmeAux.SupRateLen,  pAd->ApCliMlmeAux.SupRate,
+sta/p2pcli_assoc.c:		if(pAd->ApCliMlmeAux.ExtRateLen != 0)
+sta/p2pcli_assoc.c:				1,                        &pAd->ApCliMlmeAux.ExtRateLen,
+sta/p2pcli_assoc.c:				pAd->ApCliMlmeAux.ExtRateLen,  pAd->ApCliMlmeAux.ExtRate,                           
+sta/p2pcli_assoc.c:		if ((pAd->ApCliMlmeAux.HtCapabilityLen > 0) && 
+sta/p2pcli_assoc.c:			WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+sta/p2pcli_assoc.c:							  1,                                &pAd->ApCliMlmeAux.HtCapabilityLen,
+sta/p2pcli_assoc.c:							 pAd->ApCliMlmeAux.HtCapabilityLen,          &pAd->ApCliMlmeAux.HtCapability, 
+sta/p2pcli_assoc.c:               	 	NdisMoveMemory(&HtCapabilityTmp, &pAd->ApCliMlmeAux.HtCapability, pAd->ApCliMlmeAux.HtCapabilityLen);
+sta/p2pcli_assoc.c:        							1,                           &pAd->ApCliMlmeAux.HtCapabilityLen,
+sta/p2pcli_assoc.c:        							pAd->ApCliMlmeAux.HtCapabilityLen,&HtCapabilityTmp, 
+sta/p2pcli_assoc.c:		if (pAd->CommonCfg.bAggregationCapable)
+sta/p2pcli_assoc.c:			if ((pAd->CommonCfg.bPiggyBackCapable) && ((pAd->ApCliMlmeAux.APRalinkIe & 0x00000003) == 3))
+sta/p2pcli_assoc.c:			if (pAd->ApCliMlmeAux.APRalinkIe & 0x00000001)
+sta/p2pcli_assoc.c:		if (pAd->ApCliMlmeAux.APEdcaParm.bValid)
+sta/p2pcli_assoc.c:			if (pAd->ApCfg.ApCliTab[0].UapsdInfo.bAPSDCapable && pAd->ApCliMlmeAux.APEdcaParm.bAPSDCapable)
+sta/p2pcli_assoc.c:				QosInfo.UAPSD_AC_BE = pAd->CommonCfg.bAPSDAC_BE;
+sta/p2pcli_assoc.c:				QosInfo.UAPSD_AC_BK = pAd->CommonCfg.bAPSDAC_BK;
+sta/p2pcli_assoc.c:				QosInfo.UAPSD_AC_VI = pAd->CommonCfg.bAPSDAC_VI;
+sta/p2pcli_assoc.c:				QosInfo.UAPSD_AC_VO = pAd->CommonCfg.bAPSDAC_VO;
+sta/p2pcli_assoc.c:				QosInfo.MaxSPLength = pAd->CommonCfg.MaxSPLength;
+sta/p2pcli_assoc.c:                /* WmeIe[8] |= (pAd->MlmeAux.APEdcaParm.EdcaUpdateCount & 0x0f); */
+sta/p2pcli_assoc.c:		if ((pAd->ApCfg.ApCliTab[ifIndex].WpaSupplicantUP & 0x7F ) ==  WPA_SUPPLICANT_ENABLE)
+sta/p2pcli_assoc.c:	                        	pAd->ApCfg.ApCliTab[ifIndex].WpaAssocIeLen, pAd->ApCfg.ApCliTab[ifIndex].pWpaAssocIe,
+sta/p2pcli_assoc.c:			NdisMoveMemory(pAd->ApCfg.ApCliTab[ifIndex].ReqVarIEs + VarIesOffset, pAd->ApCfg.ApCliTab[ifIndex].pWpaAssocIe, pAd->ApCfg.ApCliTab[ifIndex].WpaAssocIeLen);
+sta/p2pcli_assoc.c:			VarIesOffset += pAd->ApCfg.ApCliTab[ifIndex].WpaAssocIeLen;
+sta/p2pcli_assoc.c:			pAd->ApCfg.ApCliTab[ifIndex].ReqVarIELen = VarIesOffset;
+sta/p2pcli_assoc.c:		if (((pAd->ApCfg.ApCliTab[ifIndex].AuthMode == Ndis802_11AuthModeWPAPSK) || 
+sta/p2pcli_assoc.c:            (pAd->ApCfg.ApCliTab[ifIndex].AuthMode == Ndis802_11AuthModeWPA2PSK))            
+sta/p2pcli_assoc.c:			&& (pAd->ApCfg.ApCliTab[ifIndex].WscControl.WscConfMode == WSC_DISABLE)
+sta/p2pcli_assoc.c:			if (pAd->ApCfg.ApCliTab[ifIndex].AuthMode == Ndis802_11AuthModeWPA2PSK)
+sta/p2pcli_assoc.c:	                        1,                                      	&pAd->ApCfg.ApCliTab[ifIndex].RSNIE_Len,
+sta/p2pcli_assoc.c:	                        pAd->ApCfg.ApCliTab[ifIndex].RSNIE_Len,		pAd->ApCfg.ApCliTab[ifIndex].RSN_IE,
+sta/p2pcli_assoc.c:		if (pAd->ApCfg.ApCliTab[ifIndex].WscControl.WscConfMode != WSC_DISABLE)
+sta/p2pcli_assoc.c:				WscBuildAssocReqIE(&pAd->ApCfg.ApCliTab[ifIndex].WscControl, pWscBuf, &WscIeLen);
+sta/p2pcli_assoc.c:		RTMPSetTimer(&pAd->ApCliMlmeAux.ApCliAssocTimer, Timeout);
+sta/p2pcli_assoc.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].AssocCurrState;
+sta/p2pcli_assoc.c:	/* pAd->MlmeAux.SsidLen = MAX_LEN_OF_SSID; */
+sta/p2pcli_assoc.c:	/* NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID); */
+sta/p2pcli_assoc.c:	/* NdisZeroMemory(pAd->MlmeAux.Bssid, MAC_ADDR_LEN); */
+sta/p2pcli_assoc.c:	//pAd->PortCfg.DisassocReason = REASON_DISASSOC_STA_LEAVING; */
+sta/p2pcli_assoc.c:	//COPY_MAC_ADDR(pAd->PortCfg.DisassocSta, pDisassocReq->Addr); */
+sta/p2pcli_assoc.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].AssocCurrState;
+sta/p2pcli_assoc.c:		if(MAC_ADDR_EQUAL(Addr2, pAd->ApCliMlmeAux.Bssid))
+sta/p2pcli_assoc.c:			NdisZeroMemory(pAd->ApCfg.ApCliTab[0].ResVarIEs, MAX_VIE_LEN);
+sta/p2pcli_assoc.c:			pAd->ApCfg.ApCliTab[0].ResVarIELen = 0;
+sta/p2pcli_assoc.c:			pAd->ApCfg.ApCliTab[0].ResVarIELen = Elem->MsgLen - 6 - sizeof (HEADER_802_11);
+sta/p2pcli_assoc.c:			NdisCopyMemory(pAd->ApCfg.ApCliTab[0].ResVarIEs, &pFrame->Octet[6], pAd->ApCfg.ApCliTab[0].ResVarIELen);
+sta/p2pcli_assoc.c:			RTMPCancelTimer(&pAd->ApCliMlmeAux.ApCliAssocTimer, &Cancelled);
+sta/p2pcli_assoc.c:			pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli_assoc.c:				pAd->ApCliMlmeAux.Aid=Aid;
+sta/p2pcli_assoc.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].AssocCurrState;
+sta/p2pcli_assoc.c:		if (MAC_ADDR_EQUAL(pAd->ApCliMlmeAux.Bssid, Addr2))
+sta/p2pcli_assoc.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].AssocCurrState;
+sta/p2pcli_assoc.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].AssocCurrState;
+sta/p2pcli_assoc.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].AssocCurrState;
+sta/p2pcli_assoc.c:	pAd->ApCliMlmeAux.BssType = BSS_INFRA;	
+sta/p2pcli_assoc.c:	pAd->ApCliMlmeAux.CapabilityInfo = CapabilityInfo & SUPPORTED_CAPABILITY_INFO;
+sta/p2pcli_assoc.c:	NdisMoveMemory(&pAd->ApCliMlmeAux.APEdcaParm, pEdcaParm, sizeof(EDCA_PARM));
+sta/p2pcli_assoc.c:	pAd->ApCliMlmeAux.SupRateLen = SupRateLen;
+sta/p2pcli_assoc.c:	NdisMoveMemory(pAd->ApCliMlmeAux.SupRate, SupRate, SupRateLen);
+sta/p2pcli_assoc.c:    RTMPCheckRates(pAd, pAd->ApCliMlmeAux.SupRate, &pAd->ApCliMlmeAux.SupRateLen);
+sta/p2pcli_assoc.c:	pAd->ApCliMlmeAux.ExtRateLen = ExtRateLen;
+sta/p2pcli_assoc.c:	NdisMoveMemory(pAd->ApCliMlmeAux.ExtRate, ExtRate, ExtRateLen);
+sta/p2pcli_assoc.c:    RTMPCheckRates(pAd, pAd->ApCliMlmeAux.ExtRate, &pAd->ApCliMlmeAux.ExtRateLen);
+sta/p2pcli_assoc.c:	if (HtCapabilityLen > 0 && WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+sta/auth.c:	RTMPInitTimer(pAd, &pAd->MlmeAux.AuthTimer,
+sta/auth.c:	if (pAd->Mlme.AuthMachine.CurrState == AUTH_WAIT_SEQ2)
+sta/auth.c:		Cls2errAction(pAd, pAd->MlmeAux.Bssid);
+sta/auth.c:	if (AUTH_ReqSend(pAd, Elem, &pAd->MlmeAux.AuthTimer, "AUTH", 1, NULL, 0))
+sta/auth.c:		pAd->Mlme.AuthMachine.CurrState = AUTH_WAIT_SEQ2;
+sta/auth.c:		pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+sta/auth.c:		if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, Addr2) && Seq == 2) {
+sta/auth.c:			RTMPCancelTimer(&pAd->MlmeAux.AuthTimer,
+sta/auth.c:				if (pAd->MlmeAux.Alg == Ndis802_11AuthModeOpen) {
+sta/auth.c:					pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+sta/auth.c:						pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+sta/auth.c:							pAd->CurrentAddress,
+sta/auth.c:							 pAd->MlmeAux.Bssid);
+sta/auth.c:					INC_TX_TSC(pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].TxTsc, LEN_WEP_TSC);
+sta/auth.c:					RTMPConstructWEPIVHdr(pAd->StaCfg.DefaultKeyId,
+sta/auth.c:							      pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].TxTsc, iv_hdr);
+sta/auth.c:							       &pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId],
+sta/auth.c:						pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+sta/auth.c:					RTMPSetTimer(&pAd->MlmeAux.AuthTimer, AUTH_TIMEOUT);
+sta/auth.c:					pAd->Mlme.AuthMachine.CurrState = AUTH_WAIT_SEQ4;
+sta/auth.c:				pAd->StaCfg.AuthFailReason = Status;
+sta/auth.c:				COPY_MAC_ADDR(pAd->StaCfg.AuthFailSta, Addr2);
+sta/auth.c:				pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+sta/auth.c:		if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, Addr2) && Seq == 4) {
+sta/auth.c:			RTMPCancelTimer(&pAd->MlmeAux.AuthTimer,
+sta/auth.c:				pAd->StaCfg.AuthFailReason = Status;
+sta/auth.c:				COPY_MAC_ADDR(pAd->StaCfg.AuthFailSta, Addr2);
+sta/auth.c:			pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+sta/auth.c:		pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+sta/auth.c:			       pAd->StaCfg.AuthMode,
+sta/auth.c:			       BSS0, pAd->MlmeAux.Bssid, WAI_MLME_DISCONNECT);
+sta/auth.c:						pAd->CurrentAddress,
+sta/auth.c:						pAd->MlmeAux.Bssid);
+sta/auth.c:	pAd->StaCfg.DeauthReason = pInfo->Reason;
+sta/auth.c:	COPY_MAC_ADDR(pAd->StaCfg.DeauthSta, pInfo->Addr);
+sta/auth.c:	pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+sta/auth.c:	pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+sta/auth.c:		  pAd->Mlme.AuthMachine.CurrState));
+sta/auth.c:	pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+sta/auth.c:						pAd->CurrentAddress,
+sta/auth.c:						pAd->MlmeAux.Bssid);
+sta/auth.c:	pAd->StaCfg.DeauthReason = Reason;
+sta/auth.c:	COPY_MAC_ADDR(pAd->StaCfg.DeauthSta, pAddr);
+sta/auth.c:	if (pAd->StaCfg.bBlockAssoc == TRUE) {
+sta/auth.c:		pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+sta/auth.c:		COPY_MAC_ADDR(pAd->MlmeAux.Bssid, Addr);
+sta/auth.c:		pAd->MlmeAux.Alg = Alg;
+sta/auth.c:			pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+sta/auth.c:							pAd->CurrentAddress,
+sta/auth.c:							pAd->MlmeAux.Bssid);
+sta/sta_iwsc.c:								pAd->Mlme.IWscMachine.CurrState, pElem->MsgType));
+sta/sta_iwsc.c:	PIWSC_INFO	pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/sta_iwsc.c:	initList(&pAd->StaCfg.WscControl.WscConfiguredPeerList);
+sta/sta_iwsc.c:	NdisAllocateSpinLock(pAd, &pAd->StaCfg.WscControl.WscConfiguredPeerListSemLock);
+sta/sta_iwsc.c:	PWSC_CTRL	pWpsCtrl = &pAd->StaCfg.WscControl;
+sta/sta_iwsc.c:	PIWSC_INFO	pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/sta_iwsc.c:		pAd->StaCfg.WpsIEBeacon.ValueLen = 0;
+sta/sta_iwsc.c:		pAd->StaCfg.WpsIEProbeResp.ValueLen = 0;
+sta/sta_iwsc.c:	pAd->Mlme.IWscMachine.CurrState = IWSC_IDLE;
+sta/sta_iwsc.c:		pWpsCtrl = &pAd->StaCfg.WscControl;
+sta/sta_iwsc.c:			pAd->StaCfg.IWscInfo.bDoNotStop = FALSE;
+sta/sta_iwsc.c:			pAd->StaCfg.IWscInfo.IWscConfMode = WSC_DISABLE;
+sta/sta_iwsc.c:		pWpsCtrl = &pAd->StaCfg.WscControl;
+sta/sta_iwsc.c:			pAd->Mlme.IWscMachine.CurrState = IWSC_SCAN;			
+sta/sta_iwsc.c:		pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/sta_iwsc.c:								pAd->StaCfg.WscControl.WscConfStatus, 
+sta/sta_iwsc.c:								pAd->StaCfg.WscControl.WscConfigMethods, 
+sta/sta_iwsc.c:			RTMPSendWirelessEvent(pAd, IW_IWSC_ENTRY_TIMER_TIMEOUT, NULL, pAd->StaCfg.WscControl.EntryIfIdx, 0);
+sta/sta_iwsc.c:		pIWscInfo = &pAd->StaCfg.IWscInfo;		
+sta/sta_iwsc.c:	PWSC_CTRL	pWpsCtrl = &pAd->StaCfg.WscControl;
+sta/sta_iwsc.c:	PIWSC_INFO	pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/sta_iwsc.c:	if (pAd->Mlme.IWscMachine.CurrState != IWSC_IDLE)
+sta/sta_iwsc.c:			pAd->Mlme.IWscMachine.CurrState = IWSC_START;
+sta/sta_iwsc.c:			pAd->Mlme.IWscMachine.CurrState = IWSC_SCAN;
+sta/sta_iwsc.c:			pAd->Mlme.IWscMachine.CurrState = IWSC_SCAN;
+sta/sta_iwsc.c:				if ((pAd->StaCfg.IWscInfo.bSinglePIN == FALSE)
+sta/sta_iwsc.c:			pAd->Mlme.IWscMachine.CurrState = IWSC_START;
+sta/sta_iwsc.c:	PWSC_CTRL pWpsCtrl = &pAd->StaCfg.WscControl;
+sta/sta_iwsc.c:	if (pAd->StaCfg.IWscInfo.bSinglePIN &&
+sta/sta_iwsc.c:		pAd->StaCfg.IWscInfo.bDoNotStop)
+sta/sta_iwsc.c:	pAd->StaCfg.IWscInfo.IWscConfMode = WSC_DISABLE;
+sta/sta_iwsc.c:	if (pAd->Mlme.IWscMachine.CurrState != IWSC_IDLE)
+sta/sta_iwsc.c:	PWSC_CTRL	pWpsCtrl = &pAd->StaCfg.WscControl;
+sta/sta_iwsc.c:	if (pAd->Mlme.IWscMachine.CurrState != IWSC_SCAN)
+sta/sta_iwsc.c:		if (pAd->Mlme.IWscMachine.CurrState != IWSC_IDLE)
+sta/sta_iwsc.c:			DBGPRINT(RT_DEBUG_TRACE, ("IWSC_ScanDoneAction:: CurrState = %ld\n", pAd->Mlme.IWscMachine.CurrState));
+sta/sta_iwsc.c:				if (pAd->StaCfg.IWscInfo.IWscConfMode != WSC_ENROLLEE)
+sta/sta_iwsc.c:					RTMPSetTimer(&pAd->StaCfg.IWscInfo.IWscT2Timer, (RandomTime*100));
+sta/sta_iwsc.c:					pAd->StaCfg.IWscInfo.bIWscT2TimerRunning = TRUE;
+sta/sta_iwsc.c:					pAd->Mlme.IWscMachine.CurrState = IWSC_START;
+sta/sta_iwsc.c:			pAd->Mlme.IWscMachine.CurrState = IWSC_START;
+sta/sta_iwsc.c:			pAd->StaCfg.IWscInfo.bSendEapolStart = TRUE;
+sta/sta_iwsc.c:		if (pAd->StaCfg.IWscInfo.bIwscSmpbcScanningOnly)
+sta/sta_iwsc.c:			pAd->Mlme.IWscMachine.CurrState = IWSC_START;
+sta/sta_iwsc.c:			pAd->StaCfg.IWscInfo.bSendEapolStart = TRUE;
+sta/sta_iwsc.c:			if (pAd->StaCfg.IWscInfo.IWscConfMode == WSC_ENROLLEE)
+sta/sta_iwsc.c:				RTMPSetTimer(&pAd->StaCfg.IWscInfo.IWscT2Timer, (RandomTime*100));
+sta/sta_iwsc.c:				pAd->StaCfg.IWscInfo.bIWscT2TimerRunning = TRUE;
+sta/sta_iwsc.c:				pAd->Mlme.IWscMachine.CurrState = IWSC_START;
+sta/sta_iwsc.c:	PWSC_CTRL	pWpsCtrl = &pAd->StaCfg.WscControl;
+sta/sta_iwsc.c:	PWSC_CTRL		pWpsCtrl = &pAd->StaCfg.WscControl;
+sta/sta_iwsc.c:	PWSC_CTRL		pWpsCtrl = &pAd->StaCfg.WscControl;
+sta/sta_iwsc.c:	templen = AppendWSCTLV(WSC_ID_MAC_ADDR, pData, &pAd->CurrentAddress[0], 0);
+sta/sta_iwsc.c:	PIWSC_INFO		pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/sta_iwsc.c:		ActHeaderInit(pAd, &ActHdr, pIWscInfo->IWscDevQueryReqMacAddr, pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+sta/sta_iwsc.c:		ActHeaderInit(pAd, &ActHdr, BROADCAST_ADDR, pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+sta/sta_iwsc.c:	PIWSC_INFO	pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/sta_iwsc.c:								pAd->StaCfg.WscControl.WscConfStatus, 
+sta/sta_iwsc.c:			if (pAd->StaCfg.WscControl.bWscTrigger == FALSE)
+sta/sta_iwsc.c:				pAd->StaCfg.WpsIEProbeResp.ValueLen = 0;
+sta/sta_iwsc.c:			if (pAd->StaCfg.IWscInfo.bBlockConnection)
+sta/sta_iwsc.c:                if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK) 
+sta/sta_iwsc.c:						if (PeerMAC[i] > pAd->CurrentAddress[i])
+sta/sta_iwsc.c:						else if (PeerMAC[i] < pAd->CurrentAddress[i])
+sta/sta_iwsc.c:					hex_dump("IWSC_PeerAction:: pAd->CurrentAddress", pAd->CurrentAddress, MAC_ADDR_LEN);
+sta/sta_iwsc.c:					if (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA)
+sta/sta_iwsc.c:			if (pAd->StaCfg.IWscInfo.bBlockConnection)
+sta/sta_iwsc.c:                if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK) 
+sta/sta_iwsc.c:						if (PeerMAC[i] > pAd->CurrentAddress[i])
+sta/sta_iwsc.c:						else if (PeerMAC[i] < pAd->CurrentAddress[i])
+sta/sta_iwsc.c:					hex_dump("IWSC_PeerAction:: pAd->CurrentAddress", pAd->CurrentAddress, MAC_ADDR_LEN);
+sta/sta_iwsc.c:					if (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA)
+sta/sta_iwsc.c:	PWSC_CTRL	pWscCtrl = &pAd->StaCfg.WscControl;
+sta/sta_iwsc.c:	PIWSC_INFO	pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/sta_iwsc.c:			if (pAd->StaCfg.IWscInfo.bLimitedUI)
+sta/sta_iwsc.c:	pAd->Mlme.IWscMachine.CurrState = IWSC_WAIT_JOIN;
+sta/sta_iwsc.c:	PWSC_CTRL	pWscCtrl = &pAd->StaCfg.WscControl;
+sta/sta_iwsc.c:	PIWSC_INFO	pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/sta_iwsc.c:		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer,	   &Cancelled);
+sta/sta_iwsc.c:		pAd->MlmeAux.Channel = 0;
+sta/sta_iwsc.c:		AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+sta/sta_iwsc.c:		AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+sta/sta_iwsc.c:		pAd->Mlme.CntlMachine.CurrState    = CNTL_IDLE;
+sta/sta_iwsc.c:		pAd->Mlme.SyncMachine.CurrState    = SYNC_IDLE;
+sta/sta_iwsc.c:	if (pAd->StaCfg.IWscInfo.bLimitedUI)
+sta/sta_iwsc.c:			pAd->Mlme.IWscMachine.CurrState = IWSC_START;
+sta/sta_iwsc.c:			pAd->StaCfg.IWscInfo.bSendEapolStart = TRUE;
+sta/sta_iwsc.c:		pAd->Mlme.IWscMachine.CurrState = IWSC_WAIT_PIN;
+sta/sta_iwsc.c:	PWSC_CTRL	pWscCtrl = &pAd->StaCfg.WscControl;
+sta/sta_iwsc.c:		pAd->StaCfg.IWscInfo.bSendEapolStart = TRUE;
+sta/sta_iwsc.c:	pAd->Mlme.IWscMachine.CurrState = IWSC_START;
+sta/sta_iwsc.c:	PWSC_CTRL	pWpsCtrl = &pAd->StaCfg.WscControl;
+sta/sta_iwsc.c:	PIWSC_INFO	pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/sta_iwsc.c:		if ((pAd->CommonCfg.WscStaPbcProbeInfo.WscPBCStaProbeCount == 1) &&
+sta/sta_iwsc.c:			!NdisEqualMemory(pAd->CommonCfg.WscStaPbcProbeInfo.StaMacAddr[0], &ZERO_MAC_ADDR[0], MAC_ADDR_LEN) &&
+sta/sta_iwsc.c:			(NdisEqualMemory(pAd->CommonCfg.WscStaPbcProbeInfo.StaMacAddr[0], &pEntry->Addr[0], 6) == FALSE))
+sta/sta_iwsc.c:			pAd->CommonCfg.WscPBCOverlap = TRUE;
+sta/sta_iwsc.c:		//if (pAd->CommonCfg.WscPBCOverlap)
+sta/sta_iwsc.c:			hex_dump("StaMacAddr0", pAd->CommonCfg.WscStaPbcProbeInfo.StaMacAddr[0], 6);
+sta/sta_iwsc.c:			hex_dump("StaMacAddr1", pAd->CommonCfg.WscStaPbcProbeInfo.StaMacAddr[1], 6);
+sta/sta_iwsc.c:			hex_dump("StaMacAddr2", pAd->CommonCfg.WscStaPbcProbeInfo.StaMacAddr[2], 6);
+sta/sta_iwsc.c:			hex_dump("StaMacAddr3", pAd->CommonCfg.WscStaPbcProbeInfo.StaMacAddr[3], 6);
+sta/sta_iwsc.c:		if (pAd->CommonCfg.WscPBCOverlap == TRUE)
+sta/sta_iwsc.c:	PWSC_CTRL	pWpsCtrl = &pAd->StaCfg.WscControl;
+sta/sta_iwsc.c:		if (!pAd->StaCfg.IWscInfo.bLimitedUI)
+sta/sta_iwsc.c:		pAd->MlmeAux.AutoReconnectSsidLen= 32;
+sta/sta_iwsc.c:		NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen);
+sta/sta_iwsc.c:		pAd->StaCfg.WpsIEBeacon.ValueLen = 0;
+sta/sta_iwsc.c:		pAd->StaCfg.WpsIEProbeResp.ValueLen = 0;
+sta/sta_iwsc.c:	PWSC_CTRL pWpsCtrl = &pAd->StaCfg.WscControl;
+sta/sta_iwsc.c:	PIWSC_INFO	pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/sta_iwsc.c:								pAd->StaCfg.WscControl.WscConfStatus, 
+sta/sta_iwsc.c:								pAd->StaCfg.WscControl.WscConfigMethods, 
+sta/sta_iwsc.c:								pAd->StaCfg.WscControl.WscConfStatus, 
+sta/sta_iwsc.c:								pAd->StaCfg.WscControl.WscConfigMethods, 
+sta/sta_iwsc.c:	for (i = 0; i < pAd->ScanTab.BssNr; i++) 
+sta/sta_iwsc.c:		pBss = &pAd->ScanTab.BssEntry[i];
+sta/sta_iwsc.c:	PWSC_CTRL		pWpsCtrl = &pAd->StaCfg.WscControl;
+sta/sta_iwsc.c:	PIWSC_INFO	pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/sta_iwsc.c:	PIWSC_INFO	pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/p2pcli_auth.c:	RTMPInitTimer(pAd, &pAd->ApCliMlmeAux.ApCliAuthTimer, GET_TIMER_FUNCTION(ApCliAuthTimeout), pAd, FALSE);
+sta/p2pcli_auth.c:		pAd->ApCfg.ApCliTab[i].AuthCurrState = APCLI_AUTH_REQ_IDLE;
+sta/p2pcli_auth.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].AuthCurrState;
+sta/p2pcli_auth.c:	if (pAd->ApCfg.ApCliTab[ifIndex].bBlockAssoc == TRUE)
+sta/p2pcli_auth.c:		RTMPCancelTimer(&pAd->ApCliMlmeAux.ApCliAuthTimer, &Cancelled);
+sta/p2pcli_auth.c:		pAd->ApCliMlmeAux.Alg  = Alg;
+sta/p2pcli_auth.c:		ApCliMgtMacHeaderInit(pAd, &AuthHdr, SUBTYPE_AUTH, 0, Addr, pAd->ApCliMlmeAux.Bssid, ifIndex);
+sta/p2pcli_auth.c:		RTMPSetTimer(&pAd->ApCliMlmeAux.ApCliAuthTimer, AUTH_TIMEOUT);
+sta/p2pcli_auth.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].AuthCurrState;
+sta/p2pcli_auth.c:		if(MAC_ADDR_EQUAL(pAd->ApCliMlmeAux.Bssid, Addr2) && Seq == 2)
+sta/p2pcli_auth.c:			RTMPCancelTimer(&pAd->ApCliMlmeAux.ApCliAuthTimer, &Cancelled);
+sta/p2pcli_auth.c:				if(pAd->ApCliMlmeAux.Alg == Ndis802_11AuthModeOpen)
+sta/p2pcli_auth.c:					UINT	default_key = pAd->ApCfg.ApCliTab[ifIndex].DefaultKeyId;
+sta/p2pcli_auth.c:					pKey = &pAd->ApCfg.ApCliTab[ifIndex].SharedKey[default_key];
+sta/p2pcli_auth.c:					ApCliMgtMacHeaderInit(pAd, &AuthHdr, SUBTYPE_AUTH, 0, Addr2, pAd->ApCliMlmeAux.Bssid, ifIndex);
+sta/p2pcli_auth.c:					RTMPSetTimer(&pAd->ApCliMlmeAux.ApCliAuthTimer, AUTH_TIMEOUT);
+sta/p2pcli_auth.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].AuthCurrState;
+sta/p2pcli_auth.c:		if(MAC_ADDR_EQUAL(pAd->ApCliMlmeAux.Bssid, Addr2) && Seq == 4)
+sta/p2pcli_auth.c:			RTMPCancelTimer(&pAd->ApCliMlmeAux.ApCliAuthTimer, &Cancelled);
+sta/p2pcli_auth.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].AuthCurrState;
+sta/p2pcli_auth.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].AuthCurrState;
+sta/p2pcli_auth.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].AuthCurrState;
+sta/p2pcli_auth.c:		pAd->Mlme.ApCliAuthMachine.CurrState));
+sta/p2pcli_auth.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].AuthCurrState;
+sta/p2pcli_auth.c:		pAd->Mlme.ApCliAuthMachine.CurrState));
+Binary file sta/sync.o matches
+sta/rtmp_data.c:	if (pAd->StaCfg.WpaSupplicantUP) {
+sta/rtmp_data.c:			if ((pAd->StaCfg.IEEE8021X == TRUE) &&
+sta/rtmp_data.c:			    (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) &&
+sta/rtmp_data.c:				if (pAd->StaCfg.IEEE8021x_required_keys == FALSE) {
+sta/rtmp_data.c:					idx = pAd->StaCfg.DesireSharedKeyId;
+sta/rtmp_data.c:					CipherAlg = pAd->StaCfg.DesireSharedKey[idx].CipherAlg;
+sta/rtmp_data.c:					Key = pAd->StaCfg.DesireSharedKey[idx].Key;
+sta/rtmp_data.c:					if (pAd->StaCfg.DesireSharedKey[idx].KeyLen > 0) {
+sta/rtmp_data.c:									   &pAd->StaCfg.DesireSharedKey[idx]);
+sta/rtmp_data.c:						pAd->ExtraInfo = GENERAL_LINK_UP;
+sta/rtmp_data.c:						pAd->SharedKey[BSS0][idx].CipherAlg = CipherAlg;
+sta/rtmp_data.c:						pAd->SharedKey[BSS0][idx].KeyLen =
+sta/rtmp_data.c:						    pAd->StaCfg.DesireSharedKey[idx].KeyLen;
+sta/rtmp_data.c:						NdisMoveMemory(pAd->SharedKey[BSS0][idx].Key,
+sta/rtmp_data.c:							       pAd->StaCfg.DesireSharedKey[idx].Key,
+sta/rtmp_data.c:							       pAd->StaCfg.DesireSharedKey[idx].KeyLen);
+sta/rtmp_data.c:				if (pAd->StaCfg.WscControl.WscState >= WSC_STATE_LINK_UP) {
+sta/rtmp_data.c:				if (pAd->StaCfg.WepStatus ==
+sta/rtmp_data.c:				if ((pAd->StaCfg.WepStatus !=
+sta/rtmp_data.c:				    && (pAd->StaCfg.PortSecured ==
+sta/rtmp_data.c:		    && (pAd->CommonCfg.bDisableReordering == 0)) {
+sta/rtmp_data.c:				if (pAd->StaCfg.WepStatus ==
+sta/rtmp_data.c:				if ((pAd->StaCfg.WepStatus !=
+sta/rtmp_data.c:				    && (pAd->StaCfg.PortSecured ==
+sta/rtmp_data.c:		    && (pAd->CommonCfg.bDisableReordering == 0)) {
+sta/rtmp_data.c:	pWpaKey = &pAd->SharedKey[BSS0][pRxBlk->pRxWI->RxWIKeyIndex];
+sta/rtmp_data.c:		if (pAd->StaCfg.WpaSupplicantUP) {
+sta/rtmp_data.c:			WpaSendMicFailureToWpaSupplicant(pAd->net_dev,
+sta/rtmp_data.c:			    && IS_ENTRY_CLIENT(&pAd->MacTab.Content[pRxWI->RxWIWirelessCliID])) {
+sta/rtmp_data.c:			pEntry = &pAd->MacTab.Content[pRxWI->RxWIWirelessCliID];
+sta/rtmp_data.c:				(MAC_ADDR_EQUAL(pAd->CommonCfg.Bssid, pHeader->Addr2)) &&
+sta/rtmp_data.c:			//pAd->Rssi[pAd->WlanFunCtrl.field.INV_TR_SW0] = pAd->StaCfg.RssiSample.AvgRssi0;
+sta/rtmp_data.c:		pAd->RalinkCounters.RxCountSinceLastNULL++;
+sta/rtmp_data.c:		if (pAd->StaCfg.UapsdInfo.bAPSDCapable
+sta/rtmp_data.c:		    && pAd->CommonCfg.APEdcaParm.bAPSDCapable
+sta/rtmp_data.c:				if (pAd->StaCfg.FlgPsmCanNotSleep == TRUE)
+sta/rtmp_data.c:				pAd->CommonCfg.bInServicePeriod = FALSE;
+sta/rtmp_data.c:			    && (pAd->CommonCfg.bInServicePeriod)) {
+sta/rtmp_data.c:		if (pAd->StaCfg.BssType == BSS_INFRA) {
+sta/rtmp_data.c:			    && (!pAd->CommonCfg.bDLSCapable)
+sta/rtmp_data.c:				if (!RTMPEqualMemory(&pHeader->Addr2, &pAd->MlmeAux.Bssid, 6))
+sta/rtmp_data.c:			if (!RTMPEqualMemory(&pHeader->Addr3, &pAd->CommonCfg.Bssid, 6)) {
+sta/rtmp_data.c:			pEntry = &pAd->MacTab.Content[pRxWI->RxWIWirelessCliID];
+sta/rtmp_data.c:		if (pAd->StaCfg.BssType == BSS_INFRA) {
+sta/rtmp_data.c:			pAd->CommonCfg.IOTestParm.bCurrentAtheros = TRUE;
+sta/rtmp_data.c:			pAd->CommonCfg.IOTestParm.bLastAtheros = TRUE;
+sta/rtmp_data.c:				if ((((UserPriority == 0) || (UserPriority == 3)) && pAd->CommonCfg.bAPSDAC_BE == 0) ||
+sta/rtmp_data.c:		    			(((UserPriority == 1) || (UserPriority == 2)) && pAd->CommonCfg.bAPSDAC_BK == 0) ||
+sta/rtmp_data.c:					(((UserPriority == 4) || (UserPriority == 5)) && pAd->CommonCfg.bAPSDAC_VI == 0) ||
+sta/rtmp_data.c:					(((UserPriority == 6) || (UserPriority == 7)) && pAd->CommonCfg.bAPSDAC_VO == 0)) {
+sta/rtmp_data.c:	if (pAd->StaCfg.TdlsInfo.TdlsAutoLink)
+sta/rtmp_data.c:		INC_COUNTER64(pAd->WlanCounters.MulticastReceivedFrameCount);
+sta/rtmp_data.c:		    && MAC_ADDR_EQUAL(pHeader->Addr3, pAd->CurrentAddress)) {
+sta/rtmp_data.c:		pAd->LastRxRate = (UINT32)((pRxWI->RxWIMCS) +
+sta/rtmp_data.c:			pDlsEntry = &pAd->MacTab.Content[pRxWI->RxWIWirelessCliID];
+sta/rtmp_data.c:				NdisAcquireSpinLock(&pAd->MacTabLock);
+sta/rtmp_data.c:				NdisReleaseSpinLock(&pAd->MacTabLock);
+sta/rtmp_data.c:			MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[BSSID_WCID];
+sta/rtmp_data.c:		Update_Rssi_Sample(pAd, &pAd->StaCfg.RssiSample, pRxWI);
+sta/rtmp_data.c:		pAd->StaCfg.LastSNR0 = (UCHAR) (pRxWI->RxWISNR0);
+sta/rtmp_data.c:		pAd->StaCfg.LastSNR1 = (UCHAR) (pRxWI->RxWISNR1);
+sta/rtmp_data.c:		if (pAd->CommonCfg.RxStream == 3)
+sta/rtmp_data.c:			pAd->StaCfg.LastSNR2 = (UCHAR) (pRxWI->RxWISNR2);
+sta/rtmp_data.c:		pAd->RalinkCounters.OneSecRxOkDataCnt++;
+sta/rtmp_data.c:			pEntry->LastRxRate = pAd->LastRxRate;
+sta/rtmp_data.c:		if (pAd->CountDowntoPsm < 12)
+sta/rtmp_data.c:			pAd->CountDowntoPsm = 12;
+sta/rtmp_data.c:			pEntry = &pAd->MacTab.Content[pRxWI->RxWIWirelessCliID];
+sta/rtmp_data.c:	else if (pAd->StaCfg.PSPXlink) {
+sta/rtmp_data.c:			    && IS_ENTRY_CLIENT(&pAd->MacTab.Content[pRxWI->RxWIWirelessCliID])) {
+sta/rtmp_data.c:				(MAC_ADDR_EQUAL(pAd->CommonCfg.Bssid, pHeader->Addr2)) &&
+sta/rtmp_data.c:			//pAd->Rssi[pAd->WlanFunCtrl.field.INV_TR_SW0] = pAd->StaCfg.RssiSample.AvgRssi0;
+sta/rtmp_data.c:		pAd->RalinkCounters.RxCountSinceLastNULL++;
+sta/rtmp_data.c:		if (pAd->StaCfg.UapsdInfo.bAPSDCapable
+sta/rtmp_data.c:		    && pAd->CommonCfg.APEdcaParm.bAPSDCapable
+sta/rtmp_data.c:				pAd->CommonCfg.bInServicePeriod = FALSE;
+sta/rtmp_data.c:			    && (pAd->CommonCfg.bInServicePeriod)) {
+sta/rtmp_data.c:		if (pAd->StaCfg.BssType == BSS_INFRA) {
+sta/rtmp_data.c:			    && (!pAd->CommonCfg.bDLSCapable)
+sta/rtmp_data.c:			    && (!pAd->StaCfg.bTDLSCapable)
+sta/rtmp_data.c:				    (&pHeader->Addr2, &pAd->MlmeAux.Bssid, 6)) {
+sta/rtmp_data.c:			if (!RTMPEqualMemory(&pHeader->Addr3, &pAd->CommonCfg.Bssid, 6)) {
+sta/rtmp_data.c:			pEntry = &pAd->MacTab.Content[pRxWI->RxWIWirelessCliID];
+sta/rtmp_data.c:		if (pAd->StaCfg.BssType == BSS_INFRA) {
+sta/rtmp_data.c:			pAd->CommonCfg.IOTestParm.bCurrentAtheros = TRUE;
+sta/rtmp_data.c:			pAd->CommonCfg.IOTestParm.bLastAtheros = TRUE;
+sta/rtmp_data.c:	if ((pAd->StaCfg.Psm == PWR_SAVE) && (pHeader->FC.MoreData == 1)) {
+sta/rtmp_data.c:		     pAd->CommonCfg.bAPSDAC_BE == 0) ||
+sta/rtmp_data.c:		     pAd->CommonCfg.bAPSDAC_BK == 0) ||
+sta/rtmp_data.c:		     pAd->CommonCfg.bAPSDAC_VI == 0) ||
+sta/rtmp_data.c:		     pAd->CommonCfg.bAPSDAC_VO == 0)) {
+sta/rtmp_data.c:		INC_COUNTER64(pAd->WlanCounters.MulticastReceivedFrameCount);
+sta/rtmp_data.c:		    && MAC_ADDR_EQUAL(pHeader->Addr3, pAd->CurrentAddress)) {
+sta/rtmp_data.c:		pAd->LastRxRate = (USHORT)((pRxWI->RxWIMCS) +
+sta/rtmp_data.c:			pDlsEntry = &pAd->MacTab.Content[pRxWI->RxWIWirelessCliID];
+sta/rtmp_data.c:				NdisAcquireSpinLock(&pAd->MacTabLock);
+sta/rtmp_data.c:				NdisReleaseSpinLock(&pAd->MacTabLock);
+sta/rtmp_data.c:		Update_Rssi_Sample(pAd, &pAd->StaCfg.RssiSample, pRxWI);
+sta/rtmp_data.c:		pAd->StaCfg.LastSNR0 = (UCHAR) (pRxWI->RxWISNR0);
+sta/rtmp_data.c:		pAd->StaCfg.LastSNR1 = (UCHAR) (pRxWI->RxWISNR1);
+sta/rtmp_data.c:		if (pAd->CommonCfg.RxStream == 3)
+sta/rtmp_data.c:			pAd->StaCfg.LastSNR2 = (UCHAR) (pRxWI->RxWISNR2);
+sta/rtmp_data.c:		pAd->RalinkCounters.OneSecRxOkDataCnt++;
+sta/rtmp_data.c:			pEntry->LastRxRate = pAd->LastRxRate;
+sta/rtmp_data.c:		if (pAd->CountDowntoPsm < 12)
+sta/rtmp_data.c:			pAd->CountDowntoPsm = 12;
+sta/rtmp_data.c:			pEntry = &pAd->MacTab.Content[pRxWI->RxWIWirelessCliID];
+sta/rtmp_data.c:	else if (pAd->StaCfg.PSPXlink) {
+sta/rtmp_data.c:        MAP_CHANNEL_ID_TO_KHZ(pAd->LatchRfRegs.Channel, freq);
+sta/rtmp_data.c:		if (pAd->Cfg80211VifDevSet.vifDevList.size > 0)
+sta/rtmp_data.c:		if ( ((pHeader->FC.SubType == SUBTYPE_PROBE_REQ) && ( pAd->Cfg80211RegisterProbeReqFrame == TRUE) ) ||
+sta/rtmp_data.c:			 ((pHeader->FC.SubType == SUBTYPE_ACTION)  && ( pAd->Cfg80211RegisterActionFrame == TRUE) ))
+sta/rtmp_data.c:			if (CFG80211OS_RxMgmt(pAd->dummy_p2p_net_dev, freq, (PUCHAR)pHeader, pRxWI->RXWI_O.MPDUtotalByteCnt))
+sta/rtmp_data.c:			if (pAd->CommonCfg.bAPSDAC_VO == 0) {
+sta/rtmp_data.c:		    && (MAC_ADDR_EQUAL(&pAd->CommonCfg.Bssid, &pHeader->Addr2))
+sta/rtmp_data.c:		    && (pAd->RxAnt.EvaluatePeriod == 0)) {
+sta/rtmp_data.c:			Update_Rssi_Sample(pAd, &pAd->StaCfg.RssiSample, pRxWI);
+sta/rtmp_data.c:			pAd->StaCfg.LastSNR0 = (UCHAR) (pRxWI->RxWISNR0);
+sta/rtmp_data.c:			pAd->StaCfg.LastSNR1 = (UCHAR) (pRxWI->RxWISNR1);
+sta/rtmp_data.c:			pAd->StaCfg.LastSNR2 = (UCHAR) (pRxWI->RxWISNR2);
+sta/rtmp_data.c:			pEntry = &pAd->MacTab.Content[pRxWI->RxWIWirelessCliID];
+sta/rtmp_data.c:		if (pAd->chipCap.FlgHwTxBfCap)
+sta/rtmp_data.c:	UINT8 RXWISize = pAd->chipCap.RXWISize;
+sta/rtmp_data.c:		if (pAd->CommonCfg.DebugFlags & DBF_DBQ_RXWI)
+sta/rtmp_data.c:			dbQueueEnqueueRxFrame(pData, (UCHAR *)pHeader, pAd->CommonCfg.DebugFlags);
+sta/rtmp_data.c:		pAd->RalinkCounters.ReceivedByteCount += pRxWI->RxWIMPDUByteCnt;
+sta/rtmp_data.c:		pAd->RalinkCounters.OneSecReceivedByteCount += pRxWI->RxWIMPDUByteCnt;
+sta/rtmp_data.c:		pAd->RalinkCounters.RxCount++;
+sta/rtmp_data.c:		INC_COUNTER64(pAd->WlanCounters.ReceivedFragmentCount);
+sta/rtmp_data.c:			pAd->ate.RxCntPerSec++;
+sta/rtmp_data.c:			if (pAd->ate.bQARxStart == TRUE) {
+sta/rtmp_data.c:			if (pAd->chipCap.FlgHwTxBfCap)
+sta/rtmp_data.c:						if (pAd->ate.sounding == 1) {
+sta/rtmp_data.c:							pAd->ate.soundingSNR[0] = (CHAR)((pRxBlk ->pData)[8]);
+sta/rtmp_data.c:							pAd->ate.soundingSNR[1] = (Nc<2)? 0: (CHAR)((pRxBlk ->pData)[9]);
+sta/rtmp_data.c:							pAd->ate.soundingSNR[2] = (Nc<3)? 0: (CHAR)((pRxBlk ->pData)[10]);
+sta/rtmp_data.c:							pAd->ate.sounding = 2;
+sta/rtmp_data.c:							pAd->ate.soundingRespSize = pRxBlk->DataSize;
+sta/rtmp_data.c:							for (i=0; i<pRxBlk->DataSize && i<sizeof(pAd->ate.soundingResp); i++)
+sta/rtmp_data.c:								pAd->ate.soundingResp[i] = pRxBlk->pData[i];
+sta/rtmp_data.c:			if (pAd->chipCap.FreqCalibrationSupport)
+sta/rtmp_data.c:			if ((pAd->FreqCalibrationCtrl.bEnableFrequencyCalibration == TRUE)
+sta/rtmp_data.c:			    && (MAC_ADDR_EQUAL(&pAd->CommonCfg.Bssid, &pHeader->Addr2)))
+sta/rtmp_data.c:					pAd->FreqCalibrationCtrl.LatestFreqOffsetOverBeacon =
+sta/rtmp_data.c:					pAd->FreqCalibrationCtrl.BeaconPhyMode = (UCHAR) (pRxWI->RxWIPhyMode);
+sta/rtmp_data.c:			pAd->Counters8023.RxErrors++;
+sta/rtmp_data.c:		pAd->ate.RxCntPerSec++;
+sta/rtmp_data.c:		if (pAd->ate.bQARxStart == TRUE)
+sta/rtmp_data.c:		if (pAd->chipCap.FlgHwTxBfCap)
+sta/rtmp_data.c:					if (pAd->ate.sounding == 1)
+sta/rtmp_data.c:						pAd->ate.soundingSNR[0] = (CHAR)((pRxBlk ->pData)[8]);
+sta/rtmp_data.c:						pAd->ate.soundingSNR[1] = (Nc<2)? 0: (CHAR)((pRxBlk ->pData)[9]);
+sta/rtmp_data.c:						pAd->ate.soundingSNR[2] = (Nc<3)? 0: (CHAR)((pRxBlk ->pData)[10]);
+sta/rtmp_data.c:						pAd->ate.sounding = 2;
+sta/rtmp_data.c:						pAd->ate.soundingRespSize = pRxBlk->DataSize;
+sta/rtmp_data.c:						for (i=0; i<pRxBlk->DataSize && i<sizeof(pAd->ate.soundingResp); i++)
+sta/rtmp_data.c:							pAd->ate.soundingResp[i] = pRxBlk->pData[i];
+sta/rtmp_data.c:		if (pAd->chipCap.FreqCalibrationSupport)
+sta/rtmp_data.c:		if ((pAd->FreqCalibrationCtrl.bEnableFrequencyCalibration == TRUE)
+sta/rtmp_data.c:			&& (MAC_ADDR_EQUAL(&pAd->CommonCfg.Bssid, &pHeader->Addr2)))
+sta/rtmp_data.c:				pAd->FreqCalibrationCtrl.LatestFreqOffsetOverBeacon = GetFrequencyOffset(pAd, pRxWI);
+sta/rtmp_data.c:				pAd->FreqCalibrationCtrl.BeaconPhyMode = (UCHAR) (pRxWI->RxWIPhyMode);
+sta/rtmp_data.c:		pAd->Counters8023.RxErrors++;
+sta/rtmp_data.c:				    || (pAd->CommonCfg.bDLSCapable)
+sta/rtmp_data.c:				pAd->RalinkCounters.PendingNdisPacketCount++;
+sta/rtmp_data.c:		if (pAd->StaCfg.BssType == BSS_INFRA) {
+sta/rtmp_data.c:			    (IS_ENTRY_DLS(&pAd->MacTab.Content[tmpWcid]) ||
+sta/rtmp_data.c:			     IS_ENTRY_TDLS(&pAd->MacTab.Content[tmpWcid]))) {
+sta/rtmp_data.c:				pEntry = &pAd->MacTab.Content[tmpWcid];
+sta/rtmp_data.c:				Rate = pAd->MacTab.Content[tmpWcid].CurrTxRate;
+sta/rtmp_data.c:				pEntry = &pAd->MacTab.Content[BSSID_WCID];
+sta/rtmp_data.c:				Rate = pAd->CommonCfg.TxRate;
+sta/rtmp_data.c:				pEntry = &pAd->MacTab.Content[MCAST_WCID];
+sta/rtmp_data.c:				if (pAd->StaCfg.PSPXlink) {
+sta/rtmp_data.c:					    &pAd->MacTab.Content[MCAST_WCID];
+sta/rtmp_data.c:			Rate = pAd->CommonCfg.TxRate;
+sta/rtmp_data.c:		pEntry = &pAd->MacTab.Content[BSSID_WCID];
+sta/rtmp_data.c:		Rate = pAd->CommonCfg.TxRate;
+sta/rtmp_data.c:	if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAICERT) ||
+sta/rtmp_data.c:	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAIPSK))
+sta/rtmp_data.c:	    && (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED)
+sta/rtmp_data.c:	if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
+sta/rtmp_data.c:	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+sta/rtmp_data.c:	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
+sta/rtmp_data.c:	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+sta/rtmp_data.c:	     || (pAd->StaCfg.IEEE8021X == TRUE)
+sta/rtmp_data.c:	    && ((pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED)
+sta/rtmp_data.c:		|| (pAd->StaCfg.MicErrCnt >= 2))
+sta/rtmp_data.c:	if ((pAd->StaCfg.WscControl.WscConfMode != WSC_DISABLE) &&
+sta/rtmp_data.c:	    (pAd->StaCfg.WscControl.bWscTrigger == TRUE) &&
+sta/rtmp_data.c:	else if ((pAd->StaCfg.HTPhyMode.field.MODE == MODE_HTMIX)
+sta/rtmp_data.c:		 || (pAd->StaCfg.HTPhyMode.field.MODE == MODE_HTGREENFIELD))
+sta/rtmp_data.c:		    (pAd->CommonCfg.FragmentThreshold) - LENGTH_802_11 -
+sta/rtmp_data.c:		    (pAd->CommonCfg.FragmentThreshold >
+sta/rtmp_data.c:		     pAd->CommonCfg.RtsThreshold) ? 1 : 0;
+sta/rtmp_data.c:		     pAd->CommonCfg.RtsThreshold) ? 1 : 0;
+sta/rtmp_data.c:	RTMP_SET_PACKET_TXRATE(pPacket, pAd->CommonCfg.TxRate);
+sta/rtmp_data.c:		RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+sta/rtmp_data.c:		if (pAd->TxSwQueue[QueIdx].Number >= pAd->TxSwQMaxLen) {
+sta/rtmp_data.c:			RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+sta/rtmp_data.c:				InsertTailQueueAc(pAd, pEntry, &pAd->TxSwQueue[QueIdx], PACKET_TO_QUEUE_ENTRY(pPacket));
+sta/rtmp_data.c:		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+sta/rtmp_data.c:	if ((pAd->CommonCfg.BACapability.field.AutoBA == TRUE) &&
+sta/rtmp_data.c:		    ((IS_ENTRY_CLIENT(pEntry) && pAd->MlmeAux.APRalinkIe != 0x0)
+sta/rtmp_data.c:		    && (!(IS_RT3290(pAd) && pAd->WlanBTCoexInfo.ampduOff == TRUE))
+sta/rtmp_data.c:	pAd->RalinkCounters.OneSecOsTxCount[QueIdx]++;	/* TODO: for debug only. to be removed */
+sta/rtmp_data.c:			pHTTXContext = &pAd->TxContext[QueIdx];
+sta/rtmp_data.c:			RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx],
+sta/rtmp_data.c:			RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx],
+sta/rtmp_data.c:		if (pAd->MgmtRing.TxSwFreeIdx != MGMT_RING_SIZE)
+sta/rtmp_data.c:	if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
+sta/rtmp_data.c:	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+sta/rtmp_data.c:	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
+sta/rtmp_data.c:	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+sta/rtmp_data.c:	     || (pAd->StaCfg.IEEE8021X == TRUE)
+sta/rtmp_data.c:	     || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAICERT)
+sta/rtmp_data.c:	     || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAIPSK)
+sta/rtmp_data.c:	    ) && (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED)) {
+sta/rtmp_data.c:	COPY_MAC_ADDR(pHeader_802_11->Addr1, pAd->CommonCfg.Bssid);
+sta/rtmp_data.c:	COPY_MAC_ADDR(pHeader_802_11->Addr2, pAd->CurrentAddress);
+sta/rtmp_data.c:	COPY_MAC_ADDR(pHeader_802_11->Addr3, pAd->CommonCfg.Bssid);
+sta/rtmp_data.c:	if (pAd->CommonCfg.bAPSDForcePowerSave) {
+sta/rtmp_data.c:		if (pAd->StaCfg.TdlsInfo.TdlsFlgIsKeepingActiveCountDown == TRUE)
+sta/rtmp_data.c:	pHeader_802_11->Duration = pAd->CommonCfg.Dsifs + RTMPCalcDuration(pAd, TxRate, 14);
+sta/rtmp_data.c:	pHeader_802_11->Sequence = pAd->Sequence;
+sta/rtmp_data.c:	pAd->Sequence = (pAd->Sequence + 1) & MAXSEQ;	/* next sequence  */
+sta/rtmp_data.c:			Cipher = pAd->StaCfg.GroupCipher;	/* Cipher for Multicast or Broadcast */
+sta/rtmp_data.c:			Cipher = pAd->StaCfg.PairCipher;	/* Cipher for Unicast */
+sta/rtmp_data.c:			ASSERT(pAd->SharedKey[BSS0][0].CipherAlg <=
+sta/rtmp_data.c:			    (pAd->SharedKey[BSS0][0].CipherAlg) &&
+sta/rtmp_data.c:			    (pAd->SharedKey[BSS0][0].KeyLen)) {
+sta/rtmp_data.c:				CipherAlg = pAd->SharedKey[BSS0][0].CipherAlg;
+sta/rtmp_data.c:			KeyIdx = pAd->StaCfg.DefaultKeyId;
+sta/rtmp_data.c:				KeyIdx = pAd->StaCfg.DefaultKeyId;
+sta/rtmp_data.c:			else if (pAd->SharedKey[BSS0][0].KeyLen)
+sta/rtmp_data.c:				KeyIdx = pAd->StaCfg.DefaultKeyId;
+sta/rtmp_data.c:			 && (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+sta/rtmp_data.c:			 && (pAd->StaCfg.PortSecured ==
+sta/rtmp_data.c:			pKey = &pAd->SharedKey[BSS0][KeyIdx];
+sta/rtmp_data.c:			 || (pAd->SharedKey[BSS0][KeyIdx].KeyLen == 0))
+sta/rtmp_data.c:		else if (pAd->StaCfg.WpaSupplicantUP &&
+sta/rtmp_data.c:			 (pAd->StaCfg.IEEE8021X == TRUE) &&
+sta/rtmp_data.c:			 (pAd->StaCfg.PortSecured ==
+sta/rtmp_data.c:			CipherAlg = pAd->SharedKey[BSS0][KeyIdx].CipherAlg;
+sta/rtmp_data.c:			pKey = &pAd->SharedKey[BSS0][KeyIdx];
+sta/rtmp_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+sta/rtmp_data.c:		pWI->field.Seq_Num = pAd->Sequence;
+sta/rtmp_data.c:		pAd->Sequence = (pAd->Sequence + 1) & MAXSEQ;	/* next sequence  */
+sta/rtmp_data.c:	if (pAd->StaCfg.BssType == BSS_INFRA) {
+sta/rtmp_data.c:	if (pAd->CommonCfg.bAPSDForcePowerSave)
+sta/rtmp_data.c:		pWI->field.PS = (pAd->StaCfg.Psm == PWR_SAVE);
+sta/rtmp_data.c:	if (pAd->CommonCfg.bAPSDForcePowerSave)
+sta/rtmp_data.c:		pWI->field.PS = (pAd->StaCfg.Psm == PWR_SAVE);
+sta/rtmp_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+sta/rtmp_data.c:		wifi_hdr->Sequence = pAd->Sequence;
+sta/rtmp_data.c:		pAd->Sequence = (pAd->Sequence + 1) & MAXSEQ;	/* next sequence  */
+sta/rtmp_data.c:		if (pAd->StaCfg.BssType == BSS_INFRA) {
+sta/rtmp_data.c:				COPY_MAC_ADDR(wifi_hdr->Addr2, pAd->CurrentAddress);
+sta/rtmp_data.c:				COPY_MAC_ADDR(wifi_hdr->Addr3, pAd->CommonCfg.Bssid);
+sta/rtmp_data.c:				COPY_MAC_ADDR(wifi_hdr->Addr2, pAd->CurrentAddress);
+sta/rtmp_data.c:				COPY_MAC_ADDR(wifi_hdr->Addr3, pAd->CommonCfg.Bssid);
+sta/rtmp_data.c:				COPY_MAC_ADDR(wifi_hdr->Addr1, pAd->CommonCfg.Bssid);
+sta/rtmp_data.c:				COPY_MAC_ADDR(wifi_hdr->Addr2, pAd->CurrentAddress);
+sta/rtmp_data.c:				     pAd->CurrentAddress)) {
+sta/rtmp_data.c:			if (pAd->StaCfg.PSPXlink)
+sta/rtmp_data.c:				COPY_MAC_ADDR(wifi_hdr->Addr2, pAd->CurrentAddress);
+sta/rtmp_data.c:			COPY_MAC_ADDR(wifi_hdr->Addr3, pAd->CommonCfg.Bssid);
+sta/rtmp_data.c:	if (pAd->CommonCfg.bAPSDForcePowerSave)
+sta/rtmp_data.c:			COPY_MAC_ADDR(pHeader80211->Addr3, pAd->CommonCfg.Bssid);
+sta/rtmp_data.c:			COPY_MAC_ADDR(pHeader80211->Addr3, pAd->CommonCfg.Bssid);
+sta/rtmp_data.c:				      pAd->CommonCfg.Bssid);
+sta/rtmp_data.c:			     pAd->CurrentAddress)) {
+sta/rtmp_data.c:	if (pAd->CommonCfg.bAPSDForcePowerSave)
+sta/rtmp_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+sta/rtmp_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+sta/rtmp_data.c:	    (pTxBlk->UserPriority & 0x0F) | (pAd->CommonCfg.
+sta/rtmp_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+sta/rtmp_data.c:			if ((pAd->CommonCfg.bRdg == TRUE)
+sta/rtmp_data.c:					if (pAd->CommonCfg.ETxBfNoncompress==0 &&
+sta/rtmp_data.c:					if (pAd->CommonCfg.ETxBfNoncompress==0 &&
+sta/rtmp_data.c:			if (pAd->CommonCfg.HtCapability.ExtHtCapInfo.MCSFeedback >=MCSFBK_MRQ && pMacEntry->toTxMfb == 1)
+sta/rtmp_data.c:			pAd->RalinkCounters.TransmittedMPDUsInAMPDUCount.u.LowPart++;
+sta/rtmp_data.c:			pAd->RalinkCounters.TransmittedOctetsInAMPDUCount.QuadPart += pTxBlk->SrcBufLen;
+sta/rtmp_data.c:		if (pAd->CommonCfg.DebugFlags & DBF_DBQ_TXFRAME)
+sta/rtmp_data.c:		pAd->RalinkCounters.KickTxCount++;
+sta/rtmp_data.c:		pAd->RalinkCounters.OneSecTxDoneCount++;
+sta/rtmp_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+sta/rtmp_data.c:			if ((pAd->CommonCfg.bRdg == TRUE)
+sta/rtmp_data.c:			pAd->RalinkCounters.TransmittedMPDUsInAMPDUCount.u.LowPart++;
+sta/rtmp_data.c:			pAd->RalinkCounters.TransmittedOctetsInAMPDUCount.QuadPart += pTxBlk->SrcBufLen;
+sta/rtmp_data.c:		if (pAd->CommonCfg.DebugFlags & DBF_DBQ_TXFRAME)
+sta/rtmp_data.c:		pAd->RalinkCounters.KickTxCount++;
+sta/rtmp_data.c:		pAd->RalinkCounters.OneSecTxDoneCount++;
+sta/rtmp_data.c:		if (pAd->CommonCfg.DebugFlags & DBF_DBQ_TXFRAME)
+sta/rtmp_data.c:		pAd->RalinkCounters.KickTxCount++;
+sta/rtmp_data.c:		pAd->RalinkCounters.OneSecTxDoneCount++;
+sta/rtmp_data.c:			pAd->RalinkCounters.TransmittedAMSDUCount.u.LowPart++;
+sta/rtmp_data.c:			pAd->RalinkCounters.TransmittedOctetsInAMSDU.QuadPart +=
+sta/rtmp_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+sta/rtmp_data.c:		INC_COUNTER64(pAd->WlanCounters.MulticastTransmittedFrameCount);
+sta/rtmp_data.c:	if (pTxBlk->TxRate < pAd->CommonCfg.MinTxRate)
+sta/rtmp_data.c:		pTxBlk->TxRate = pAd->CommonCfg.MinTxRate;
+sta/rtmp_data.c:		    ((pTxBlk->UserPriority & 0x0F) | (pAd->CommonCfg.AckPolicy[pTxBlk->QueIdx] << 5));
+sta/rtmp_data.c:	    && (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+sta/rtmp_data.c:	    && (pAd->StaCfg.GroupCipher == Ndis802_11Encryption3Enabled)
+sta/rtmp_data.c:	if (pAd->CommonCfg.DebugFlags & DBF_DBQ_TXFRAME)
+sta/rtmp_data.c:	pAd->RalinkCounters.KickTxCount++;
+sta/rtmp_data.c:	pAd->RalinkCounters.OneSecTxDoneCount++;
+sta/rtmp_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+sta/rtmp_data.c:		INC_COUNTER64(pAd->WlanCounters.MulticastTransmittedFrameCount);
+sta/rtmp_data.c:	if (pTxBlk->TxRate < pAd->CommonCfg.MinTxRate)
+sta/rtmp_data.c:		pTxBlk->TxRate = pAd->CommonCfg.MinTxRate;
+sta/rtmp_data.c:	    && (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+sta/rtmp_data.c:	    && (pAd->StaCfg.GroupCipher == Ndis802_11Encryption3Enabled)
+sta/rtmp_data.c:	if (pAd->CommonCfg.DebugFlags & DBF_DBQ_TXFRAME)
+sta/rtmp_data.c:	pAd->RalinkCounters.KickTxCount++;
+sta/rtmp_data.c:	pAd->RalinkCounters.OneSecTxDoneCount++;
+sta/rtmp_data.c:		if (pAd->CommonCfg.DebugFlags & DBF_DBQ_TXFRAME)
+sta/rtmp_data.c:		pAd->RalinkCounters.OneSecTxAggregationCount++;
+sta/rtmp_data.c:		pAd->RalinkCounters.KickTxCount++;
+sta/rtmp_data.c:		pAd->RalinkCounters.OneSecTxDoneCount++;
+sta/rtmp_data.c:	UINT8 TXWISize = pAd->chipCap.TXWISize;
+sta/rtmp_data.c:			       &pAd->PrivateInfo.Tx.MIC[0], 8);
+sta/rtmp_data.c:				     pAd->CommonCfg.ExpectedACKRate[pTxBlk->TxRate],
+sta/rtmp_data.c:		FreeMpduSize = pAd->CommonCfg.FragmentThreshold - LENGTH_CRC - pTxBlk->MpduHeaderLen;
+sta/rtmp_data.c:			    pAd->CommonCfg.Dsifs + AckDuration;
+sta/rtmp_data.c:				((UINT) pAd->CommonCfg.FragmentThreshold));
+sta/rtmp_data.c:			    (3 * pAd->CommonCfg.Dsifs) + (2 * AckDuration) +
+sta/rtmp_data.c:		if (pAd->CommonCfg.DebugFlags & DBF_DBQ_TXFRAME)
+sta/rtmp_data.c:		pAd->RalinkCounters.KickTxCount++;
+sta/rtmp_data.c:		pAd->RalinkCounters.OneSecTxDoneCount++;
+sta/rtmp_data.c:	if (pAd->CountDowntoPsm < 12)
+sta/rtmp_data.c:		pAd->CountDowntoPsm = 12;
+sta/rtmp_data.c:	if ((pAd->StaCfg.Psm == PWR_SAVE)
+sta/rtmp_data.c:	     (pAd->StaCfg.UapsdInfo.bAPSDCapable
+sta/rtmp_data.c:	      && pAd->CommonCfg.APEdcaParm.bAPSDCapable)
+sta/rtmp_data.c:	     && (pAd->CommonCfg.bAPSDForcePowerSave == FALSE))
+sta/rtmp_data.c:		    (pAd->StaCfg.WindowsPowerMode ==
+Binary file sta/rtmp_data.o matches
+Binary file sta/sta_cfg.o matches
+sta/tdls_tlv.c:						6,				pAd->CommonCfg.Bssid,
+sta/tdls_tlv.c:						2,				&pAd->StaActive.CapabilityInfo,
+sta/tdls_tlv.c:						1,							&pAd->CommonCfg.SsidLen, 
+sta/tdls_tlv.c:						pAd->CommonCfg.SsidLen,		pAd->CommonCfg.Ssid,
+sta/tdls_tlv.c:						1,						&pAd->StaActive.SupRateLen,
+sta/tdls_tlv.c:						pAd->StaActive.SupRateLen,	pAd->StaActive.SupRate,
+sta/tdls_tlv.c:	if (pAd->CommonCfg.bCountryFlag)
+sta/tdls_tlv.c:			regclass = TDLS_GetRegulatoryClass(pAd, pAd->CommonCfg.RegTransmitSetting.field.BW, pAd->CommonCfg.Channel);
+sta/tdls_tlv.c:							3,				pAd->CommonCfg.CountryCode,
+sta/tdls_tlv.c:								3,				pAd->CommonCfg.CountryCode,
+sta/tdls_tlv.c:	if (pAd->StaCfg.TdlsInfo.TdlsChSwitchSupp)
+sta/tdls_tlv.c:		if ((pAd->CommonCfg.PhyMode == PHY_11BG_MIXED) ||
+sta/tdls_tlv.c:			(pAd->CommonCfg.PhyMode == PHY_11B) ||
+sta/tdls_tlv.c:			(pAd->CommonCfg.PhyMode == PHY_11G) ||
+sta/tdls_tlv.c:			(pAd->CommonCfg.PhyMode == PHY_11BGN_MIXED))
+sta/tdls_tlv.c:		else if ((pAd->CommonCfg.PhyMode == PHY_11A) ||
+sta/tdls_tlv.c:				(pAd->CommonCfg.PhyMode == PHY_11AN_MIXED))
+sta/tdls_tlv.c:		else if ((pAd->CommonCfg.PhyMode == PHY_11BG_MIXED) ||
+sta/tdls_tlv.c:				(pAd->CommonCfg.PhyMode == PHY_11ABG_MIXED) ||
+sta/tdls_tlv.c:				(pAd->CommonCfg.PhyMode == PHY_11BGN_MIXED) ||
+sta/tdls_tlv.c:				(pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED))
+sta/tdls_tlv.c:	if (pAd->StaActive.ExtRateLen != 0)
+sta/tdls_tlv.c:							1,						&pAd->StaActive.ExtRateLen,
+sta/tdls_tlv.c:							pAd->StaActive.ExtRateLen,	pAd->StaActive.ExtRate,							
+sta/tdls_tlv.c:	/* if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) || (pAd->CommonCfg.bWmmCapable)) */
+sta/tdls_tlv.c:	if (pAd->CommonCfg.bWmmCapable)
+sta/tdls_tlv.c:		if (pAd->StaCfg.UapsdInfo.bAPSDCapable)
+sta/tdls_tlv.c:			QosInfo.UAPSD_AC_BE = pAd->CommonCfg.TDLS_bAPSDAC_BE;
+sta/tdls_tlv.c:			QosInfo.UAPSD_AC_BK = pAd->CommonCfg.TDLS_bAPSDAC_BK;
+sta/tdls_tlv.c:			QosInfo.UAPSD_AC_VI = pAd->CommonCfg.TDLS_bAPSDAC_VI;
+sta/tdls_tlv.c:			QosInfo.UAPSD_AC_VO = pAd->CommonCfg.TDLS_bAPSDAC_VO;
+sta/tdls_tlv.c:			QosInfo.MaxSPLength = pAd->CommonCfg.TDLS_MaxSPLength;
+sta/tdls_tlv.c:	if (pAd->CommonCfg.bWmmCapable)
+sta/tdls_tlv.c:		if (pAd->StaCfg.UapsdInfo.bAPSDCapable)
+sta/tdls_tlv.c:				QosInfo.UAPSD_AC_BE = pAd->CommonCfg.TDLS_bAPSDAC_BE;
+sta/tdls_tlv.c:				QosInfo.UAPSD_AC_BK = pAd->CommonCfg.TDLS_bAPSDAC_BK;
+sta/tdls_tlv.c:				QosInfo.UAPSD_AC_VI = pAd->CommonCfg.TDLS_bAPSDAC_VI;
+sta/tdls_tlv.c:				QosInfo.UAPSD_AC_VO = pAd->CommonCfg.TDLS_bAPSDAC_VO;
+sta/tdls_tlv.c:				QosInfo.MaxSPLength = pAd->CommonCfg.TDLS_MaxSPLength;
+sta/tdls_tlv.c:					pAd->CommonCfg.TDLS_bAPSDAC_BE,
+sta/tdls_tlv.c:					pAd->CommonCfg.TDLS_bAPSDAC_BK,
+sta/tdls_tlv.c:					pAd->CommonCfg.TDLS_bAPSDAC_VI,
+sta/tdls_tlv.c:					pAd->CommonCfg.TDLS_bAPSDAC_VO,
+sta/tdls_tlv.c:					pAd->CommonCfg.TDLS_MaxSPLength));
+sta/tdls_tlv.c:	if ((WMODE_CAP_N(pAd->CommonCfg.PhyMode) || (pAd->CommonCfg.bWmmCapable)) && (pTDLS->bWmmCapable))
+sta/tdls_tlv.c:	if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) || (pAd->CommonCfg.bWmmCapable))
+sta/tdls_tlv.c:		if (pAd->StaCfg.UapsdInfo.bAPSDCapable)
+sta/tdls_tlv.c:			QosInfo.UAPSD_AC_BE = pAd->CommonCfg.TDLS_bAPSDAC_BE;
+sta/tdls_tlv.c:			QosInfo.UAPSD_AC_BK = pAd->CommonCfg.TDLS_bAPSDAC_BK;
+sta/tdls_tlv.c:			QosInfo.UAPSD_AC_VI = pAd->CommonCfg.TDLS_bAPSDAC_VI;
+sta/tdls_tlv.c:			QosInfo.UAPSD_AC_VO = pAd->CommonCfg.TDLS_bAPSDAC_VO;
+sta/tdls_tlv.c:			QosInfo.MaxSPLength = pAd->CommonCfg.TDLS_MaxSPLength;
+sta/tdls_tlv.c:					pAd->CommonCfg.TDLS_bAPSDAC_BE,
+sta/tdls_tlv.c:					pAd->CommonCfg.TDLS_bAPSDAC_BK,
+sta/tdls_tlv.c:					pAd->CommonCfg.TDLS_bAPSDAC_VI,
+sta/tdls_tlv.c:					pAd->CommonCfg.TDLS_bAPSDAC_VO,
+sta/tdls_tlv.c:					pAd->CommonCfg.TDLS_MaxSPLength));
+sta/tdls_tlv.c:								   ((UCHAR)pAd->CommonCfg.APEdcaParm.bACM[idx] << 4) 	+	  // b4 is ACM
+sta/tdls_tlv.c:								   (pAd->CommonCfg.APEdcaParm.Aifsn[idx] & 0x0f);			  // b0-3 is AIFSN
+sta/tdls_tlv.c:			WmeParmIe[11+ (idx*4)] = (pAd->CommonCfg.APEdcaParm.Cwmax[idx] << 4)		+	  // b5-8 is CWMAX
+sta/tdls_tlv.c:								   (pAd->CommonCfg.APEdcaParm.Cwmin[idx] & 0x0f);			  // b0-3 is CWMIN
+sta/tdls_tlv.c:			WmeParmIe[12+ (idx*4)] = (UCHAR)(pAd->CommonCfg.APEdcaParm.Txop[idx] & 0xff);	  // low byte of TXOP
+sta/tdls_tlv.c:			WmeParmIe[13+ (idx*4)] = (UCHAR)(pAd->CommonCfg.APEdcaParm.Txop[idx] >> 8);	  // high byte of TXOP
+sta/tdls_tlv.c:	if (WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+sta/tdls_tlv.c:		NdisMoveMemory(&HtCapabilityTmp, &pAd->CommonCfg.HtCapability, HtLen);
+sta/tdls_tlv.c:		HtCapabilityTmp.HtCapInfo.ChannelWidth = pAd->CommonCfg.RegTransmitSetting.field.BW;
+sta/tdls_tlv.c:		NdisMoveMemory(&HtCapabilityTmp, &pAd->CommonCfg.HtCapability, HtLen);
+sta/tdls_tlv.c:		HtCapabilityTmp.HtCapInfo.ChannelWidth = pAd->CommonCfg.RegTransmitSetting.field.BW;
+sta/tdls_tlv.c:	//if (pAd->CommonCfg.BACapability.field.b2040CoexistScanSup == 1)
+sta/tdls_tlv.c:	if ((pAd->CommonCfg.bBssCoexEnable == TRUE) && 
+sta/tdls_tlv.c:		(pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) &&
+sta/tdls_tlv.c:		(pAd->CommonCfg.Channel <= 14))
+sta/tdls_tlv.c:	if (pAd->StaCfg.TdlsInfo.TdlsChSwitchSupp)
+sta/tdls_tlv.c:	if (pAd->StaCfg.UapsdInfo.bAPSDCapable)
+sta/tdls_tlv.c:	regclass = TDLS_GetRegulatoryClass(pAd, pAd->CommonCfg.RegTransmitSetting.field.BW, pAd->CommonCfg.Channel);
+sta/p2pcli_sync.c:	RTMPInitTimer(pAd, &pAd->ApCliMlmeAux.ProbeTimer, GET_TIMER_FUNCTION(ApCliProbeTimeout), pAd, FALSE);
+sta/p2pcli_sync.c:		pAd->ApCfg.ApCliTab[i].SyncCurrState = APCLI_SYNC_IDLE;
+sta/p2pcli_sync.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].SyncCurrState;
+sta/p2pcli_sync.c:	RTMPCancelTimer(&pAd->ApCliMlmeAux.ProbeTimer, &Cancelled);
+sta/p2pcli_sync.c:	pAd->ApCliMlmeAux.Rssi = -9999;
+sta/p2pcli_sync.c:	pAd->ApCliMlmeAux.Channel = pAd->CommonCfg.Channel;
+sta/p2pcli_sync.c:	pAd->ApCliMlmeAux.SupRateLen = pAd->CommonCfg.SupRateLen;
+sta/p2pcli_sync.c:	NdisMoveMemory(pAd->ApCliMlmeAux.SupRate, pAd->CommonCfg.SupRate, pAd->CommonCfg.SupRateLen);
+sta/p2pcli_sync.c:	pAd->ApCliMlmeAux.ExtRateLen = pAd->CommonCfg.ExtRateLen;
+sta/p2pcli_sync.c:	NdisMoveMemory(pAd->ApCliMlmeAux.ExtRate, pAd->CommonCfg.ExtRate, pAd->CommonCfg.ExtRateLen);
+sta/p2pcli_sync.c:	RTMPSetTimer(&pAd->ApCliMlmeAux.ProbeTimer, PROBE_TIMEOUT);
+sta/p2pcli_sync.c:	DBGPRINT(RT_DEBUG_TRACE, ("ApCli SYNC - Start Probe the SSID %s on channel =%d\n", pAd->ApCliMlmeAux.Ssid, pAd->ApCliMlmeAux.Channel));
+sta/p2pcli_sync.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].SyncCurrState;
+sta/p2pcli_sync.c:				Bssidx = BssTableSearch(&pAd->ScanTab, ie_list->Bssid, ie_list->Channel);
+sta/p2pcli_sync.c:					Bssidx = BssTableSetEntry(pAd, &pAd->ScanTab, ie_list, -127, LenVIE, pVIE);
+sta/p2pcli_sync.c:					NdisMoveMemory(pAd->ScanTab.BssEntry[Bssidx].PTSF, &Elem->Msg[24], 4);
+sta/p2pcli_sync.c:					NdisMoveMemory(&pAd->ScanTab.BssEntry[Bssidx].TTSF[0], &Elem->TimeStamp.u.LowPart, 4);
+sta/p2pcli_sync.c:					NdisMoveMemory(&pAd->ScanTab.BssEntry[Bssidx].TTSF[4], &Elem->TimeStamp.u.LowPart, 4);
+sta/p2pcli_sync.c:					pAd->ScanTab.BssEntry[Bssidx].MinSNR = Elem->Signal % 10;
+sta/p2pcli_sync.c:					if (pAd->ScanTab.BssEntry[Bssidx].MinSNR == 0)
+sta/p2pcli_sync.c:						pAd->ScanTab.BssEntry[Bssidx].MinSNR = -5;
+sta/p2pcli_sync.c:					NdisMoveMemory(pAd->ScanTab.BssEntry[Bssidx].MacAddr, ie_list->Addr2, MAC_ADDR_LEN);
+sta/p2pcli_sync.c:		pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli_sync.c:                && ((pAd->ApCfg.ApCliTab[ifIndex].WscControl.WscConfMode == WSC_DISABLE) || 
+sta/p2pcli_sync.c:                	(pAd->ApCfg.ApCliTab[ifIndex].WscControl.bWscTrigger == FALSE))
+sta/p2pcli_sync.c:				&& ! (pAd->ApCfg.ApCliTab[MAIN_MBSSID].WpaSupplicantUP & WPA_SUPPLICANT_ENABLE_WPS)
+sta/p2pcli_sync.c:					pAd->ApCliMlmeAux.VarIELen = LenVIE;
+sta/p2pcli_sync.c:					NdisMoveMemory(pAd->ApCliMlmeAux.VarIEs, pVIE, pAd->ApCliMlmeAux.VarIELen);
+sta/p2pcli_sync.c:					pAd->ApCliMlmeAux.VarIELen = 0;
+sta/p2pcli_sync.c:                    && ((pAd->ApCfg.ApCliTab[ifIndex].WscControl.WscConfMode == WSC_DISABLE) || 
+sta/p2pcli_sync.c:                		(pAd->ApCfg.ApCliTab[ifIndex].WscControl.bWscTrigger == FALSE))
+sta/p2pcli_sync.c:				pAd->ApCliMlmeAux.VarIELen = 0;
+sta/p2pcli_sync.c:				DBGPRINT(RT_DEBUG_TRACE, ("SYNC - previous Rssi = %ld current Rssi=%ld\n", pAd->ApCliMlmeAux.Rssi, (LONG)RealRssi));
+sta/p2pcli_sync.c:				if (pAd->ApCliMlmeAux.Rssi > (LONG)RealRssi)
+sta/p2pcli_sync.c:					pAd->ApCliMlmeAux.Rssi = RealRssi;
+sta/p2pcli_sync.c:				RTMPCancelTimer(&pAd->ApCliMlmeAux.ProbeTimer, &Cancelled);
+sta/p2pcli_sync.c:				RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &Cancelled);
+sta/p2pcli_sync.c:				pAd->MlmeAux.Channel = 0;
+sta/p2pcli_sync.c:			NdisMoveMemory(pAd->ApCliMlmeAux.Ssid, ie_list->Ssid, ie_list->SsidLen);
+sta/p2pcli_sync.c:			pAd->ApCliMlmeAux.SsidLen = ie_list->SsidLen;
+sta/p2pcli_sync.c:			NdisMoveMemory(pAd->ApCliMlmeAux.Bssid, ie_list->Bssid, MAC_ADDR_LEN);			
+sta/p2pcli_sync.c:			pAd->ApCliMlmeAux.CapabilityInfo = ie_list->CapabilityInfo & SUPPORTED_CAPABILITY_INFO;
+sta/p2pcli_sync.c:			pAd->ApCliMlmeAux.BssType = ie_list->BssType;
+sta/p2pcli_sync.c:			pAd->ApCliMlmeAux.BeaconPeriod = ie_list->BeaconPeriod;
+sta/p2pcli_sync.c:			pAd->ApCliMlmeAux.Channel = ie_list->Channel;
+sta/p2pcli_sync.c:			pAd->ApCliMlmeAux.AtimWin = ie_list->AtimWin;
+sta/p2pcli_sync.c:			pAd->ApCliMlmeAux.CfpPeriod = ie_list->CfParm.CfpPeriod;
+sta/p2pcli_sync.c:			pAd->ApCliMlmeAux.CfpMaxDuration = ie_list->CfParm.CfpMaxDuration;
+sta/p2pcli_sync.c:			pAd->ApCliMlmeAux.APRalinkIe = ie_list->RalinkIe;
+sta/p2pcli_sync.c:			pAd->ApCliMlmeAux.SupRateLen = ie_list->SupRateLen;
+sta/p2pcli_sync.c:			NdisMoveMemory(pAd->ApCliMlmeAux.SupRate, ie_list->SupRate, ie_list->SupRateLen);
+sta/p2pcli_sync.c:			RTMPCheckRates(pAd, pAd->ApCliMlmeAux.SupRate, &pAd->ApCliMlmeAux.SupRateLen);
+sta/p2pcli_sync.c:			pAd->ApCliMlmeAux.ExtRateLen = ie_list->ExtRateLen;
+sta/p2pcli_sync.c:			NdisMoveMemory(pAd->ApCliMlmeAux.ExtRate, ie_list->ExtRate, ie_list->ExtRateLen);
+sta/p2pcli_sync.c:			RTMPCheckRates(pAd, pAd->ApCliMlmeAux.ExtRate, &pAd->ApCliMlmeAux.ExtRateLen);
+sta/p2pcli_sync.c:			NdisZeroMemory(pAd->ApCfg.ApCliTab[ifIndex].RxMcsSet,sizeof(pAd->ApCfg.ApCliTab[ifIndex].RxMcsSet));
+sta/p2pcli_sync.c:				WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+sta/p2pcli_sync.c:				RTMPZeroMemory(&pAd->ApCliMlmeAux.HtCapability, SIZE_HT_CAP_IE);
+sta/p2pcli_sync.c:				pAd->ApCliMlmeAux.NewExtChannelOffset = ie_list->NewExtChannelOffset;
+sta/p2pcli_sync.c:				pAd->ApCliMlmeAux.HtCapabilityLen = ie_list->HtCapabilityLen;
+sta/p2pcli_sync.c:				RTMPMoveMemory(&pAd->ApCliMlmeAux.AddHtInfo, &ie_list->AddHtInfo, SIZE_ADD_HT_INFO_IE);
+sta/p2pcli_sync.c:				if (INFRA_ON(pAd) && (pAd->CommonCfg.CentralChannel != CentralChannel) && (pAd->StaActive.SupportedHtPhy.ChannelWidth == BW_40))
+sta/p2pcli_sync.c:								pAd->MlmeAux.CentralChannel, CentralChannel));
+sta/p2pcli_sync.c:				pAd->ApCliMlmeAux.CentralChannel = CentralChannel;
+sta/p2pcli_sync.c:				if (pAd->ApCliMlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40)
+sta/p2pcli_sync.c:											pAd->ApCliMlmeAux.Channel,
+sta/p2pcli_sync.c:											pAd->ApCliMlmeAux.CentralChannel);
+sta/p2pcli_sync.c:					pAd->ApCliMlmeAux.HtCapability.HtCapInfo.ChannelWidth = BW_20;
+sta/p2pcli_sync.c:					pAd->ApCliMlmeAux.CentralChannel = pAd->ApCliMlmeAux.Channel;
+sta/p2pcli_sync.c:					pAd->ApCliMlmeAux.bBwFallBack = TRUE;
+sta/p2pcli_sync.c:					pAd->ApCliMlmeAux.bBwFallBack = FALSE;
+sta/p2pcli_sync.c:				pAd->ApCliMlmeAux.ConCurrentCentralChannel = pAd->CommonCfg.CentralChannel;
+sta/p2pcli_sync.c:				RTMPZeroMemory(&pAd->ApCliMlmeAux.HtCapability, SIZE_HT_CAP_IE);
+sta/p2pcli_sync.c:				RTMPZeroMemory(&pAd->ApCliMlmeAux.AddHtInfo, SIZE_ADD_HT_INFO_IE);
+sta/p2pcli_sync.c:				pAd->ApCliMlmeAux.HtCapabilityLen = 0;
+sta/p2pcli_sync.c:			if (WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+sta/p2pcli_sync.c:				NdisMoveMemory(&pAd->ApCliMlmeAux.APEdcaParm, &ie_list->EdcaParm, sizeof(EDCA_PARM));
+sta/p2pcli_sync.c:				NdisMoveMemory(&pAd->ApCliMlmeAux.APQbssLoad, &ie_list->QbssLoad, sizeof(QBSS_LOAD_PARM));
+sta/p2pcli_sync.c:				NdisMoveMemory(&pAd->ApCliMlmeAux.APQosCapability, &ie_list->QosCapability, sizeof(QOS_CAPABILITY_PARM));
+sta/p2pcli_sync.c:				NdisZeroMemory(&pAd->ApCliMlmeAux.APEdcaParm, sizeof(EDCA_PARM));
+sta/p2pcli_sync.c:				NdisZeroMemory(&pAd->ApCliMlmeAux.APQbssLoad, sizeof(QBSS_LOAD_PARM));
+sta/p2pcli_sync.c:				NdisZeroMemory(&pAd->ApCliMlmeAux.APQosCapability, sizeof(QOS_CAPABILITY_PARM));
+sta/p2pcli_sync.c:				pAd->ApCliMlmeAux.SupRateLen, pAd->ApCliMlmeAux.ExtRateLen));
+sta/p2pcli_sync.c:				pAd->CommonCfg.TxPowerPercentage = pAd->CommonCfg.TxPowerDefault;
+sta/p2pcli_sync.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].SyncCurrState;
+sta/p2pcli_sync.c:				pAd->ApCliMlmeAux.Bssid[0],
+sta/p2pcli_sync.c:				pAd->ApCliMlmeAux.Bssid[1],
+sta/p2pcli_sync.c:				pAd->ApCliMlmeAux.Bssid[2],
+sta/p2pcli_sync.c:				pAd->ApCliMlmeAux.Bssid[3],
+sta/p2pcli_sync.c:				pAd->ApCliMlmeAux.Bssid[4],
+sta/p2pcli_sync.c:				pAd->ApCliMlmeAux.Bssid[5]));
+sta/p2pcli_sync.c:	if(!MAC_ADDR_EQUAL(pAd->ApCliMlmeAux.Bssid, ZERO_MAC_ADDR))
+sta/p2pcli_sync.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].SyncCurrState;
+sta/p2pcli_sync.c:		if(MAC_ADDR_EQUAL(pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid, ZERO_MAC_ADDR))
+sta/p2pcli_sync.c:				pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid, pAd->ApCfg.ApCliTab[ifIndex].CfgApCliBssid, ifIndex);
+sta/p2pcli_sync.c:			1,								&pAd->ApCliMlmeAux.SupRateLen,
+sta/p2pcli_sync.c:			pAd->ApCliMlmeAux.SupRateLen,		pAd->ApCliMlmeAux.SupRate,
+sta/p2pcli_sync.c:		if (pAd->ApCliMlmeAux.ExtRateLen != 0)
+sta/p2pcli_sync.c:				1,                        &pAd->ApCliMlmeAux.ExtRateLen,
+sta/p2pcli_sync.c:				pAd->ApCliMlmeAux.ExtRateLen,  pAd->ApCliMlmeAux.ExtRate,                           
+sta/p2pcli_sync.c:	return (pAd->ApCfg.ApCliTab[ifIndex].SyncCurrState == APCLI_JOIN_WAIT_PROBE_RSP) ?
+sta/p2pcli_sync.c:		if (ie_list->Channel != pAd->MlmeAux.Channel
+sta/p2pcli_sync.c:			&& (pAd->CommonCfg.bOverlapScanning == FALSE)
+sta/p2pcli_sync.c:		if (ie_list->Channel == pAd->CommonCfg.Channel)
+sta/p2pcli_sync.c:        Idx = BssTableSearch(&pAd->ScanTab, ie_list->Bssid, ie_list->Channel);
+sta/p2pcli_sync.c:            Rssi = pAd->ScanTab.BssEntry[Idx].Rssi;
+sta/p2pcli_sync.c:        if ((RealRssi + pAd->BbpRssiToDbmDelta) > Rssi)
+sta/p2pcli_sync.c:            Rssi = RealRssi + pAd->BbpRssiToDbmDelta;
+sta/p2pcli_sync.c:		Idx = BssTableSetEntry(pAd, &pAd->ScanTab, ie_list, -Rssi, LenVIE, pVIE);
+sta/p2pcli_sync.c:			NdisMoveMemory(pAd->ScanTab.BssEntry[Idx].PTSF, &Elem->Msg[24], 4);
+sta/p2pcli_sync.c:			NdisMoveMemory(&pAd->ScanTab.BssEntry[Idx].TTSF[0], &Elem->TimeStamp.u.LowPart, 4);
+sta/p2pcli_sync.c:			NdisMoveMemory(&pAd->ScanTab.BssEntry[Idx].TTSF[4], &Elem->TimeStamp.u.LowPart, 4);
+sta/p2pcli_sync.c:	if (ie_list->Channel == pAd->ApCfg.AutoChannel_Channel)
+sta/p2pcli_sync.c:			pAd->pChannelInfo->ApCnt[pAd->ApCfg.current_channel_index]++;
+sta/rtmp_ckipmic.c:    RTMPMicUpdate(&mic_ctx, pAd->StaCfg.TxSEQ, 4);   /* MIC <-- TxSEQ */
+sta/tdls.c:	NdisAllocateSpinLock(pAd, &pAd->StaCfg.TdlsInfo.TDLSEntryLock);
+sta/tdls.c:		pTDLS = &pAd->StaCfg.TdlsInfo.TDLSEntry[idx];
+sta/tdls.c:	NdisFreeSpinLock(&pAd->StaCfg.TdlsInfo.TDLSEntryLock);
+sta/tdls.c:		pTDLS = &pAd->StaCfg.TdlsInfo.TDLSEntry[idx];
+sta/tdls.c:	for (i = 0; i < pAd->ChannelListNum; i++)
+sta/tdls.c:		if (pAd->ChannelList[i].Channel == channel)
+sta/tdls.c:	if (i == pAd->ChannelListNum)
+sta/tdls.c:	PLIST_HEADER pTdlsDiscoveryEnList = &pAd->StaCfg.TdlsInfo.TdlsDiscovPeerList;
+sta/tdls.c:			if (RTMP_TIME_AFTER(now_time, pPeerEntry->InitRefTime + (pAd->StaCfg.TdlsInfo.TdlsRssiMeasurementPeriod * ((1000 * OS_HZ)/1000))))
+sta/tdls.c:							pAd->StaCfg.TdlsInfo.TDLSEntry[idx].Valid	= FALSE;
+sta/tdls.c:							pAd->StaCfg.TdlsInfo.TDLSEntry[idx].Status	= TDLS_MODE_NONE;
+sta/tdls.c:							TDLS_MlmeParmFill(pAd, &MlmeTdlsReq, &pAd->StaCfg.TdlsInfo.TDLSEntry[idx], Reason, FALSE);
+sta/tdls.c:					RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls.c:					RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls.c:					RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls.c:					RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls.c:				RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls.c:				RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls.c:						PLIST_HEADER	pTdlsBlackEnList = &pAd->StaCfg.TdlsInfo.TdlsBlackList;
+sta/tdls.c:						RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls.c:						RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls.c:						RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls.c:						RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls.c:			if (RTMP_TIME_AFTER(now_time, pBlackEntry->InitRefTime + (pAd->StaCfg.TdlsInfo.TdlsAutoDiscoveryPeriod * ((1000 * OS_HZ)/1000))))
+sta/tdls.c:				RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls.c:										pAd->StaCfg.TdlsInfo.TdlsAutoDiscoveryPeriod,
+sta/tdls.c:				RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls.c:			if (RTMP_TIME_AFTER(now_time, pBlackEntry->InitRefTime + (pAd->StaCfg.TdlsInfo.TdlsDisabledPeriodByTeardown * ((1000 * OS_HZ)/1000))))
+sta/tdls.c:				RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls.c:										pAd->StaCfg.TdlsInfo.TdlsDisabledPeriodByTeardown,
+sta/tdls.c:				RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls.c:		pTDLS = &pAd->StaCfg.TdlsInfo.TDLSEntry[idIdx];
+sta/tdls.c:	PLIST_HEADER pTdlsBlackEnList = &pAd->StaCfg.TdlsInfo.TdlsBlackList;
+sta/tdls.c:	PLIST_HEADER pTdlsDiscoveryEnList = &pAd->StaCfg.TdlsInfo.TdlsDiscovPeerList;
+sta/tdls.c:	RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls.c:	RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls.c:	RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls.c:	RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls.c:		RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls.c:		RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls.c:	POS_COOKIE	pObj= (POS_COOKIE)pAd->OS_Cookie;
+sta/tdls.c:	if (!bTdlsCapable && pAd->StaCfg.TdlsInfo.bTDLSCapable)
+sta/tdls.c:	pAd->StaCfg.TdlsInfo.bTDLSCapable = bTdlsCapable;
+sta/tdls.c:		pObj->ioctl_if, pAd->StaCfg.TdlsInfo.bTDLSCapable));
+sta/tdls.c:		if (pAd->StaActive.ExtCapInfo.TDLSProhibited == TRUE)
+sta/tdls.c:			pAd->StaCfg.TdlsInfo.TDLSEntry[idx].Valid	= FALSE;
+sta/tdls.c:			pAd->StaCfg.TdlsInfo.TDLSEntry[idx].Status	= TDLS_MODE_NONE;
+sta/tdls.c:			TDLS_MlmeParmFill(pAd, &MlmeTdlsReq, &pAd->StaCfg.TdlsInfo.TDLSEntry[idx], Reason, FALSE);
+sta/tdls.c:	POS_COOKIE	pObj= (POS_COOKIE)pAd->OS_Cookie;
+sta/tdls.c:	pAd->StaCfg.TdlsInfo.TdlsKeyLifeTime = keyLifeTime;
+sta/tdls.c:		pObj->ioctl_if, pAd->StaCfg.TdlsInfo.TdlsKeyLifeTime));
+sta/tdls.c:	POS_COOKIE	pObj= (POS_COOKIE)pAd->OS_Cookie;
+sta/tdls.c:	pAd->StaCfg.TdlsInfo.TdlsAutoLink = bTdlsAutoLink;
+sta/tdls.c:		pObj->ioctl_if, pAd->StaCfg.TdlsInfo.TdlsAutoLink));
+sta/tdls.c:	POS_COOKIE	pObj= (POS_COOKIE)pAd->OS_Cookie;
+sta/tdls.c:	pAd->StaCfg.TdlsInfo.TdlsRssiMeasurementPeriod = RssiMeasurementPeriod;
+sta/tdls.c:		pObj->ioctl_if, pAd->StaCfg.TdlsInfo.TdlsRssiMeasurementPeriod));
+sta/tdls.c:	POS_COOKIE	pObj= (POS_COOKIE)pAd->OS_Cookie;
+sta/tdls.c:	pAd->StaCfg.TdlsInfo.TdlsAutoDiscoveryPeriod = AutoDiscoveryPeriod;
+sta/tdls.c:		pObj->ioctl_if, pAd->StaCfg.TdlsInfo.TdlsAutoDiscoveryPeriod));
+sta/tdls.c:	POS_COOKIE	pObj= (POS_COOKIE)pAd->OS_Cookie;
+sta/tdls.c:	pAd->StaCfg.TdlsInfo.TdlsAutoSetupRssiThreshold = AutoSetupRssiThreshold;
+sta/tdls.c:		pObj->ioctl_if, pAd->StaCfg.TdlsInfo.TdlsAutoSetupRssiThreshold));
+sta/tdls.c:	POS_COOKIE	pObj= (POS_COOKIE)pAd->OS_Cookie;
+sta/tdls.c:	pAd->StaCfg.TdlsInfo.TdlsDisabledPeriodByTeardown = DisabledPeriodByTeardown;
+sta/tdls.c:		pObj->ioctl_if, pAd->StaCfg.TdlsInfo.TdlsDisabledPeriodByTeardown));
+sta/tdls.c:	POS_COOKIE	pObj= (POS_COOKIE)pAd->OS_Cookie;
+sta/tdls.c:	pAd->StaCfg.TdlsInfo.TdlsAutoTeardownRssiThreshold = AutoTeardownRssiThreshold;
+sta/tdls.c:		pObj->ioctl_if, pAd->StaCfg.TdlsInfo.TdlsAutoTeardownRssiThreshold));
+sta/tdls.c:	pEntry->MaxSupportedRate = min(pAd->CommonCfg.MaxDesiredRate, MaxSupportedRate);
+sta/tdls.c:	if ((HtCapabilityLen != 0) && WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+sta/tdls.c:			(pAd->CommonCfg.DesiredHtPhy.GF) &&
+sta/tdls.c:			(pAd->StaActive.SupportedHtPhy.GF))
+sta/tdls.c:			pAd->MacTab.fAnyStationNonGF = TRUE;
+sta/tdls.c:			pAd->CommonCfg.AddHTInfo.AddHtInfo2.NonGfPresent = 1;
+sta/tdls.c:			(pAd->CommonCfg.DesiredHtPhy.ChannelWidth))
+sta/tdls.c:			pEntry->MaxHTPhyMode.field.ShortGI = ((pAd->CommonCfg.DesiredHtPhy.ShortGIfor40)&(pHtCapability->HtCapInfo.ShortGIfor40));
+sta/tdls.c:			pEntry->MaxHTPhyMode.field.ShortGI = ((pAd->CommonCfg.DesiredHtPhy.ShortGIfor20)&(pHtCapability->HtCapInfo.ShortGIfor20));
+sta/tdls.c:			pAd->MacTab.fAnyStation20Only = TRUE;
+sta/tdls.c:			if ( (pAd->StaCfg.DesiredHtPhyInfo.MCSSet[j]&bitmask) && (pHtCapability->MCSSet[j]&bitmask))
+sta/tdls.c:		if (pAd->StaCfg.DesiredTransmitSetting.field.MCS != MCS_AUTO)
+sta/tdls.c:			set_ht_fixed_mcs(pAd, pEntry, pAd->StaCfg.DesiredTransmitSetting.field.MCS, pAd->StaCfg.HTPhyMode.field.MCS);
+sta/tdls.c:		pEntry->MaxHTPhyMode.field.STBC = (pHtCapability->HtCapInfo.RxSTBC & (pAd->CommonCfg.DesiredHtPhy.TxSTBC));
+sta/tdls.c:		if (pAd->CommonCfg.bRdg && pHtCapability->ExtHtCapInfo.RDGSupport)				
+sta/tdls.c:		(pAd->CommonCfg.DesiredHtPhy.ChannelWidth) &&
+sta/tdls.c:		(pAd->StaActive.SupportedHtPhy.ChannelWidth))
+sta/tdls.c:	if (pAd->StaCfg.bAutoTxRateSwitch == TRUE)
+sta/tdls.c:		pEntry->HTPhyMode.field.MODE	= pAd->StaCfg.HTPhyMode.field.MODE;
+sta/tdls.c:		pEntry->HTPhyMode.field.MCS	= pAd->StaCfg.HTPhyMode.field.MCS;
+sta/tdls.c:		RTMPUpdateLegacyTxSetting((UCHAR)pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode, pEntry);
+sta/tdls.c:				if (!pAd->StaCfg.TdlsInfo.TDLSEntry[i].Valid)
+sta/tdls.c:					NdisMoveMemory(&pAd->StaCfg.TdlsInfo.TDLSEntry[i], pTDLS, sizeof(RT_802_11_TDLS_UI));
+sta/tdls.c:					TDLS_MlmeParmFill(pAd, &MlmeTdlsReq, &pAd->StaCfg.TdlsInfo.TDLSEntry[i], Reason, FALSE);
+sta/tdls.c:				if ((pAd->StaCfg.TdlsInfo.TDLSEntry[i].Valid) &&(pAd->StaCfg.TdlsInfo.TDLSEntry[i].Status < TDLS_MODE_CONNECTED))
+sta/tdls.c:					RTMPCancelTimer(&pAd->StaCfg.TdlsInfo.TDLSEntry[i].Timer, &TimerCancelled);
+sta/tdls.c:					NdisMoveMemory(&pAd->StaCfg.TdlsInfo.TDLSEntry[i], pTDLS, sizeof(RT_802_11_TDLS_UI));
+sta/tdls.c:					TDLS_MlmeParmFill(pAd, &MlmeTdlsReq, &pAd->StaCfg.TdlsInfo.TDLSEntry[i], Reason, FALSE);
+sta/tdls.c:		if ((!pTDLS->Valid) && (pAd->StaCfg.TdlsInfo.TDLSEntry[Idx].Status >= TDLS_MODE_CONNECTED))
+sta/tdls.c:			pAd->StaCfg.TdlsInfo.TDLSEntry[Idx].Valid	= FALSE;
+sta/tdls.c:			pAd->StaCfg.TdlsInfo.TDLSEntry[Idx].Status	= TDLS_MODE_NONE;
+sta/tdls.c:			TDLS_MlmeParmFill(pAd, &MlmeTdlsReq, &pAd->StaCfg.TdlsInfo.TDLSEntry[Idx], Reason, FALSE);
+sta/tdls.c:		else if ((pTDLS->Valid) && (pAd->StaCfg.TdlsInfo.TDLSEntry[Idx].Status >= TDLS_MODE_CONNECTED)) 
+sta/tdls.c:			pAd->StaCfg.TdlsInfo.TDLSEntry[Idx].Valid	= FALSE;
+sta/tdls.c:			pAd->StaCfg.TdlsInfo.TDLSEntry[Idx].Status	= TDLS_MODE_NONE;
+sta/tdls.c:			TDLS_MlmeParmFill(pAd, &MlmeTdlsReq, &pAd->StaCfg.TdlsInfo.TDLSEntry[Idx], Reason, FALSE);
+sta/tdls.c:			RTMPCancelTimer(&pAd->StaCfg.TdlsInfo.TDLSEntry[Idx].Timer, &TimerCancelled);
+sta/tdls.c:			NdisMoveMemory(&pAd->StaCfg.TdlsInfo.TDLSEntry[Idx], pTDLS, sizeof(RT_802_11_TDLS_UI));
+sta/tdls.c:			TDLS_MlmeParmFill(pAd, &MlmeTdlsReq, &pAd->StaCfg.TdlsInfo.TDLSEntry[Idx], Reason, FALSE);
+sta/tdls.c:				Idx, pAd->StaCfg.TdlsInfo.TDLSEntry[Idx].Valid, pAd->StaCfg.TdlsInfo.TDLSEntry[Idx].Status));
+sta/tdls.c:		pTDLS = &pAd->StaCfg.TdlsInfo.TDLSEntry[i];
+sta/tdls.c:				if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
+sta/tdls.c:		if (!MAC_ADDR_EQUAL(pLinkIdent->BSSID, pAd->CommonCfg.Bssid))
+sta/tdls.c:		else if (!MAC_ADDR_EQUAL(pLinkIdent->ResponderAddr, pAd->CurrentAddress))
+sta/tdls.c:				if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
+sta/tdls.c:		if (!MAC_ADDR_EQUAL(pLinkIdent->BSSID, pAd->CommonCfg.Bssid))
+sta/tdls.c:		else if (!MAC_ADDR_EQUAL(pLinkIdent->InitiatorAddr, pAd->CurrentAddress))
+sta/tdls.c:		if (!MAC_ADDR_EQUAL(pLinkIdent->BSSID, pAd->CommonCfg.Bssid))
+sta/tdls.c:		else if (!MAC_ADDR_EQUAL(pLinkIdent->ResponderAddr, pAd->CurrentAddress))
+sta/tdls.c:		if (!MAC_ADDR_EQUAL(pLinkIdent->BSSID, pAd->CommonCfg.Bssid))
+sta/tdls.c:		if (!MAC_ADDR_EQUAL(pAd->CurrentAddress, pLinkIdent->InitiatorAddr))
+sta/tdls.c:			if (!MAC_ADDR_EQUAL(pAd->CurrentAddress, pLinkIdent->ResponderAddr))
+sta/tdls.c:	if (!MAC_ADDR_EQUAL(Ptr+2, pAd->CommonCfg.Bssid))
+sta/tdls.c:	else if (!MAC_ADDR_EQUAL(Ptr+14, pAd->CurrentAddress))
+sta/tdls.c:				if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
+sta/tdls.c:		if (!MAC_ADDR_EQUAL(pLinkIdent->BSSID, pAd->CommonCfg.Bssid))
+sta/tdls.c:		else if (!MAC_ADDR_EQUAL(pLinkIdent->InitiatorAddr, pAd->CurrentAddress))
+sta/tdls.c:	if (!MAC_ADDR_EQUAL(Ptr+2, pAd->CommonCfg.Bssid))
+sta/tdls.c:		if (!MAC_ADDR_EQUAL(Ptr+14, pAd->CurrentAddress))
+sta/tdls.c:		if (!MAC_ADDR_EQUAL(Ptr+8, pAd->CurrentAddress))
+sta/tdls.c:    if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) || 
+sta/tdls.c:         (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+sta/tdls.c:         (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) || 
+sta/tdls.c:         (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+sta/tdls.c:			  || (pAd->StaCfg.IEEE8021X == TRUE)		
+sta/tdls.c:		  || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAICERT)
+sta/tdls.c:		  || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAIPSK)
+sta/tdls.c:       (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED)) 
+sta/tdls.c:		pTDLS = (PRT_802_11_TDLS)&pAd->StaCfg.TdlsInfo.TDLSEntry[idx];
+sta/tdls.c:			COPY_MAC_ADDR(pHeader_802_11->Addr2, pAd->CurrentAddress);
+sta/tdls.c:			COPY_MAC_ADDR(pHeader_802_11->Addr3, pAd->CommonCfg.Bssid);
+sta/tdls.c:			if (pAd->CommonCfg.bAPSDForcePowerSave)
+sta/tdls.c:			pHeader_802_11->Duration = pAd->CommonCfg.Dsifs + RTMPCalcDuration(pAd, TxRate, 14);
+sta/tdls.c:			pAd->Sequence++;
+sta/tdls.c:			pHeader_802_11->Sequence = pAd->Sequence;
+sta/tdls.c:	PLIST_HEADER	pTdlsBlackEnList = &pAd->StaCfg.TdlsInfo.TdlsBlackList;
+sta/tdls.c:		pTDLS = (PRT_802_11_TDLS)&pAd->StaCfg.TdlsInfo.TDLSEntry[idx];
+sta/tdls.c:			PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[wcid];
+sta/tdls.c:			if (pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled)
+sta/tdls.c:				NdisAcquireSpinLock(&pAd->MacTabLock);
+sta/tdls.c:				NdisReleaseSpinLock(&pAd->MacTabLock);
+sta/tdls.c:					PLIST_HEADER	pTdlsDiscovryEnList = &pAd->StaCfg.TdlsInfo.TdlsDiscovPeerList;
+sta/tdls.c:					NdisAcquireSpinLock(&pAd->StaCfg.TdlsInfo.TDLSEntryLock);
+sta/tdls.c:					NdisReleaseSpinLock(&pAd->StaCfg.TdlsInfo.TDLSEntryLock);
+sta/tdls.c:			NdisAcquireSpinLock(&pAd->MacTabLock);
+sta/tdls.c:			NdisReleaseSpinLock(&pAd->MacTabLock);
+sta/tdls.c:		if ((pAd->StaCfg.TdlsInfo.TDLSEntry[i].Valid) && (pAd->StaCfg.TdlsInfo.TDLSEntry[i].Status == TDLS_MODE_CONNECTED))
+sta/tdls.c:			PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[pAd->StaCfg.TdlsInfo.TDLSEntry[i].MacTabMatchWCID];
+sta/tdls.c:				PRINT_MAC(pAd->StaCfg.TdlsInfo.TDLSEntry[i].MacAddr)));
+sta/tdls.c:	if ((pAd->CommonCfg.CentralChannel > pAd->CommonCfg.Channel) &&
+sta/tdls.c:		rf_channel = pAd->CommonCfg.CentralChannel;
+sta/tdls.c:	else if ((pAd->CommonCfg.CentralChannel < pAd->CommonCfg.Channel) &&
+sta/tdls.c:		rf_channel = pAd->CommonCfg.CentralChannel;
+sta/tdls.c:		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
+sta/tdls.c:		rf_channel = pAd->CommonCfg.Channel;
+sta/tdls.c:				pAd->CommonCfg.Channel, pAd->CommonCfg.CentralChannel));
+sta/tdls_chswitch_mng.c:				pAd->StaCfg.TdlsCurrentChannelBW = EXTCHA_ABOVE;
+sta/tdls_chswitch_mng.c:				pAd->StaCfg.TdlsCurrentChannelBW = EXTCHA_BELOW;
+sta/tdls_chswitch_mng.c:				UCHAR Dir = pAd->CommonCfg.RegTransmitSetting.field.EXTCHA;
+sta/tdls_chswitch_mng.c:					pAd->StaCfg.TdlsCurrentChannelBW = Dir;
+sta/tdls_chswitch_mng.c:					pAd->StaCfg.TdlsCurrentChannelBW = Dir;
+sta/tdls_chswitch_mng.c:		pAd->StaCfg.TdlsCurrentChannelBW = EXTCHA_NONE;
+sta/tdls_chswitch_mng.c:	pTDLS = (PRT_802_11_TDLS)&pAd->StaCfg.TdlsInfo.TDLSEntry[LinkId];
+sta/tdls_chswitch_mng.c:		TDLS_InsertLinkIdentifierIE(pAd, (pFrameBuf + *pFrameLen), pFrameLen, pPeerAddr, pAd->CurrentAddress);
+sta/tdls_chswitch_mng.c:		TDLS_InsertLinkIdentifierIE(pAd, (pFrameBuf + *pFrameLen), pFrameLen, pAd->CurrentAddress, pPeerAddr);
+sta/tdls_chswitch_mng.c:		TDLS_InsertLinkIdentifierIE(pAd, (pFrameBuf + *pFrameLen), pFrameLen, pTDLS->MacAddr, pAd->CurrentAddress);
+sta/tdls_chswitch_mng.c:		TDLS_InsertLinkIdentifierIE(pAd, (pFrameBuf + *pFrameLen), pFrameLen, pAd->CurrentAddress, pTDLS->MacAddr);
+sta/tdls_chswitch_mng.c:	UINT16	SwitchTime = pAd->StaCfg.TdlsInfo.TdlsSwitchTime; //micro seconds
+sta/tdls_chswitch_mng.c:	UINT16	SwitchTimeout = pAd->StaCfg.TdlsInfo.TdlsSwitchTimeout; // micro seconds
+sta/tdls_chswitch_mng.c:	MAKE_802_3_HEADER(Header802_3, pChSwitchReq->PeerMacAddr, pAd->CurrentAddress, TDLS_ETHERTYPE);
+sta/tdls_chswitch_mng.c:		if (pChSwitchReq->TargetChannel != pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:		pAd->StaCfg.TdlsCurrentChannel = pChSwitchReq->TargetChannel;
+sta/tdls_chswitch_mng.c:		pAd->StaCfg.TdlsCurrentChannelBW = pChSwitchReq->TargetChannelBW;
+sta/tdls_chswitch_mng.c:	MAKE_802_3_HEADER(Header802_3, pTDLS->MacAddr, pAd->CurrentAddress, TDLS_ETHERTYPE);
+sta/tdls_chswitch_mng.c:	RTMPToWirelessSta(pAd, &pAd->MacTab.Content[pTDLS->MacTabMatchWCID], Header802_3,
+sta/tdls_chswitch_mng.c:	if (pAd->StaActive.ExtCapInfo.TDLSChSwitchProhibited == TRUE)
+sta/tdls_chswitch_mng.c:		pAd->StaCfg.TdlsForcePowerSaveWithAP = TRUE;
+sta/tdls_chswitch_mng.c:		if (pAd->StaCfg.bTdlsNoticeAPPowerSave == FALSE)
+sta/tdls_chswitch_mng.c:			pAd->StaCfg.TdlsSendNullFrameCount = 0;
+sta/tdls_chswitch_mng.c:			pAd->StaCfg.bTdlsNoticeAPPowerSave = TRUE;
+sta/tdls_chswitch_mng.c:			RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE, TRUE);
+sta/tdls_chswitch_mng.c:			pAd->StaCfg.TdlsSendNullFrameCount++;
+sta/tdls_chswitch_mng.c:			if (pAd->StaCfg.TdlsSendNullFrameCount >= 200)
+sta/tdls_chswitch_mng.c:				pAd->StaCfg.bTdlsNoticeAPPowerSave = FALSE;
+sta/tdls_chswitch_mng.c:			pAd->StaCfg.TdlsChannelSwitchPairCount++;
+sta/tdls_chswitch_mng.c:		pTdls = &pAd->StaCfg.TdlsInfo.TDLSEntry[LinkId];
+sta/tdls_chswitch_mng.c:			NdisGetSystemUpTime(&pAd->StaCfg.TdlsGoBackStartTime);
+sta/tdls_chswitch_mng.c:			if (pAd->CommonCfg.CentralChannel > pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:				TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_ABOVE);
+sta/tdls_chswitch_mng.c:			else if (pAd->CommonCfg.CentralChannel < pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:				TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_BELOW);
+sta/tdls_chswitch_mng.c:				TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_NONE);
+sta/tdls_chswitch_mng.c:	UINT16				SwitchTime = pAd->StaCfg.TdlsInfo.TdlsSwitchTime; //micro seconds
+sta/tdls_chswitch_mng.c:	UINT16				SwitchTimeout = pAd->StaCfg.TdlsInfo.TdlsSwitchTimeout; // micro seconds
+sta/tdls_chswitch_mng.c:	if (pAd->StaActive.ExtCapInfo.TDLSChSwitchProhibited == TRUE)
+sta/tdls_chswitch_mng.c:	if (pAd->StaCfg.bChannelSwitchInitiator == FALSE)
+sta/tdls_chswitch_mng.c:		pAd->StaCfg.TdlsForcePowerSaveWithAP = TRUE;
+sta/tdls_chswitch_mng.c:		if (pAd->StaCfg.bTdlsNoticeAPPowerSave == FALSE)
+sta/tdls_chswitch_mng.c:			pAd->StaCfg.TdlsSendNullFrameCount = 0;
+sta/tdls_chswitch_mng.c:			pAd->StaCfg.bTdlsNoticeAPPowerSave = TRUE;
+sta/tdls_chswitch_mng.c:			RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE, TRUE);
+sta/tdls_chswitch_mng.c:			pAd->StaCfg.TdlsSendNullFrameCount++;
+sta/tdls_chswitch_mng.c:			if (pAd->StaCfg.TdlsSendNullFrameCount >= 200)
+sta/tdls_chswitch_mng.c:				pAd->StaCfg.bTdlsNoticeAPPowerSave = FALSE;
+sta/tdls_chswitch_mng.c:	pTDLS = &pAd->StaCfg.TdlsInfo.TDLSEntry[LinkId];
+sta/tdls_chswitch_mng.c:		TDLS_SendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE, 0);
+sta/tdls_chswitch_mng.c:		if  (TargetChannel != pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:			if  (TargetChannel != pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:				pAd->StaCfg.TdlsCurrentChannel = TargetChannel;
+sta/tdls_chswitch_mng.c:					pAd->StaCfg.TdlsCurrentChannelBW = NewExtChannelOffset;
+sta/tdls_chswitch_mng.c:					pAd->StaCfg.TdlsCurrentChannelBW = EXTCHA_NONE;
+sta/tdls_chswitch_mng.c:				pAd->StaCfg.TdlsGlobalSwitchTime = PeerChSwitchTime;
+sta/tdls_chswitch_mng.c:				pAd->StaCfg.TdlsGlobalSwitchTimeOut = PeerChSwitchTimeOut;
+sta/tdls_chswitch_mng.c:				RTMPCancelTimer(&pAd->StaCfg.TdlsDisableChannelSwitchTimer, &TimerCancelled);
+sta/tdls_chswitch_mng.c:				pAd->StaCfg.bTdlsCurrentDoingChannelSwitchWaitSuccess = TRUE;
+sta/tdls_chswitch_mng.c:				pAd->StaCfg.bDoingPeriodChannelSwitch = TRUE;
+sta/tdls_chswitch_mng.c:				TDLS_InitChannelRelatedValue(pAd, pAd->StaCfg.TdlsCurrentChannel, pAd->StaCfg.TdlsCurrentChannelBW);
+sta/tdls_chswitch_mng.c:				pAd->StaCfg.bDoingPeriodChannelSwitch = FALSE;
+sta/tdls_chswitch_mng.c:				pAd->StaCfg.TdlsForcePowerSaveWithAP = FALSE;
+sta/tdls_chswitch_mng.c:				pAd->StaCfg.bTdlsNoticeAPPowerSave = FALSE;
+sta/tdls_chswitch_mng.c:				if (pAd->CommonCfg.CentralChannel > pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:					TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_ABOVE);
+sta/tdls_chswitch_mng.c:				else if (pAd->CommonCfg.CentralChannel < pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:					TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_BELOW);
+sta/tdls_chswitch_mng.c:					TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_NONE);
+sta/tdls_chswitch_mng.c:				RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE, FALSE);
+sta/tdls_chswitch_mng.c:	pTDLS = &pAd->StaCfg.TdlsInfo.TDLSEntry[LinkId];
+sta/tdls_chswitch_mng.c:		if ((pAd->StaCfg.TdlsChannelSwitchRetryCount > 0) &&
+sta/tdls_chswitch_mng.c:			(pAd->StaCfg.bDoingPeriodChannelSwitch))
+sta/tdls_chswitch_mng.c:			pAd->StaCfg.TdlsChannelSwitchRetryCount--;
+sta/tdls_chswitch_mng.c:			pAd->StaCfg.bDoingPeriodChannelSwitch = FALSE;
+sta/tdls_chswitch_mng.c:			pAd->StaCfg.bTdlsNoticeAPPowerSave = FALSE;
+sta/tdls_chswitch_mng.c:			pAd->StaCfg.TdlsForcePowerSaveWithAP = FALSE;
+sta/tdls_chswitch_mng.c:			RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE, FALSE);
+sta/tdls_chswitch_mng.c:			if (pAd->StaCfg.bChannelSwitchInitiator == FALSE)
+sta/tdls_chswitch_mng.c:				RTMPCancelTimer(&pAd->StaCfg.TdlsResponderGoBackBaseChTimer, &TimerCancelled);
+sta/tdls_chswitch_mng.c:				RTMPCancelTimer(&pAd->StaCfg.TdlsPeriodGoBackBaseChTimer, &TimerCancelled);
+sta/tdls_chswitch_mng.c:			if (pAd->StaCfg.TdlsCurrentOperateChannel != pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:				NdisGetSystemUpTime(&pAd->StaCfg.TdlsGoBackStartTime);
+sta/tdls_chswitch_mng.c:				if (pAd->CommonCfg.CentralChannel > pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:					TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_ABOVE);
+sta/tdls_chswitch_mng.c:				else if (pAd->CommonCfg.CentralChannel < pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:					TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_BELOW);
+sta/tdls_chswitch_mng.c:					TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_NONE);
+sta/tdls_chswitch_mng.c:			if (pAd->StaCfg.TdlsCurrentChannel != pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:				if (pAd->StaCfg.bChannelSwitchInitiator)
+sta/tdls_chswitch_mng.c:					UINT16 SwitchTime = pAd->StaCfg.TdlsInfo.TdlsSwitchTime; //micro seconds
+sta/tdls_chswitch_mng.c:					UINT16 SwitchTimeout = pAd->StaCfg.TdlsInfo.TdlsSwitchTimeout; // micro seconds
+sta/tdls_chswitch_mng.c:					pAd->StaCfg.TdlsChannelSwitchPairCount--;
+sta/tdls_chswitch_mng.c:					pAd->StaCfg.TdlsChannelSwitchRetryCount = 10;
+sta/tdls_chswitch_mng.c:					//pAd->StaCfg.bDoingPeriodChannelSwitch = TRUE;
+sta/tdls_chswitch_mng.c:					pAd->StaCfg.TdlsGlobalSwitchTime = PeerChSwitchTime;
+sta/tdls_chswitch_mng.c:					pAd->StaCfg.TdlsGlobalSwitchTimeOut = PeerChSwitchTimeOut;
+sta/tdls_chswitch_mng.c:					TDLS_SetChannelSwitchTimer(pAd,  ((PeerChSwitchTime + pAd->StaCfg.TdlsOffChannelDelay) / 1000));
+sta/tdls_chswitch_mng.c:					RTMPSetTimer(&pTDLS->ChannelSwitchTimer, ((PeerChSwitchTime + pAd->StaCfg.TdlsOffChannelDelay) / 1000));
+sta/tdls_chswitch_mng.c:					TDLS_InitChannelRelatedValue(pAd, pAd->StaCfg.TdlsCurrentChannel, pAd->StaCfg.TdlsCurrentChannelBW);
+sta/tdls_chswitch_mng.c:				pAd->StaCfg.bDoingPeriodChannelSwitch = FALSE;
+sta/tdls_chswitch_mng.c:				pAd->StaCfg.TdlsForcePowerSaveWithAP = FALSE;
+sta/tdls_chswitch_mng.c:				pAd->StaCfg.bTdlsNoticeAPPowerSave = FALSE;
+sta/tdls_chswitch_mng.c:				if (pAd->StaCfg.bChannelSwitchInitiator == FALSE)
+sta/tdls_chswitch_mng.c:					RTMPCancelTimer(&pAd->StaCfg.TdlsDisableChannelSwitchTimer, &TimerCancelled);
+sta/tdls_chswitch_mng.c:					pAd->StaCfg.bChannelSwitchInitiator = FALSE;
+sta/tdls_chswitch_mng.c:				if (pAd->StaCfg.TdlsCurrentOperateChannel != pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:					if (pAd->CommonCfg.CentralChannel > pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:						TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_ABOVE);
+sta/tdls_chswitch_mng.c:					else if (pAd->CommonCfg.CentralChannel < pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:						TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_BELOW);
+sta/tdls_chswitch_mng.c:						TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_NONE);
+sta/tdls_chswitch_mng.c:				RTMPSendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE, FALSE);
+sta/tdls_chswitch_mng.c:		TDLS_SendNullFrame(pAd, pAd->CommonCfg.TxRate, TRUE, RTMP_TDLS_SPECIFIC_NULL_FRAME);
+sta/tdls_chswitch_mng.c:			NdisGetSystemUpTime(&pAd->StaCfg.TdlsGoBackStartTime);
+sta/tdls_chswitch_mng.c:			if (pAd->CommonCfg.CentralChannel > pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:				TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_ABOVE);
+sta/tdls_chswitch_mng.c:			else if (pAd->CommonCfg.CentralChannel < pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:				TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_BELOW);
+sta/tdls_chswitch_mng.c:				TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_NONE);
+sta/tdls_chswitch_mng.c:	RTMPCancelTimer(&pAd->StaCfg.TdlsResponderGoBackBaseChTimer, &TimerCancelled);
+sta/tdls_chswitch_mng.c:	pAd->StaCfg.bTdlsCurrentDoingChannelSwitchWaitSuccess = FALSE;
+sta/tdls_chswitch_mng.c:	pAd->StaCfg.bDoingPeriodChannelSwitch = FALSE;
+sta/tdls_chswitch_mng.c:	NdisGetSystemUpTime(&pAd->StaCfg.TdlsGoBackStartTime);
+sta/tdls_chswitch_mng.c:	if (pAd->CommonCfg.CentralChannel > pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:		TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_ABOVE);
+sta/tdls_chswitch_mng.c:	else if (pAd->CommonCfg.CentralChannel < pAd->CommonCfg.Channel)
+sta/tdls_chswitch_mng.c:		TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_BELOW);
+sta/tdls_chswitch_mng.c:		TDLS_InitChannelRelatedValue(pAd, pAd->CommonCfg.Channel, EXTCHA_NONE);
+sta/tdls_link_mng.c:		pAd->StaCfg.TdlsInfo.TDLSEntry[i].pAd = pAd;
+sta/tdls_link_mng.c:		RTMPInitTimer(pAd, &pAd->StaCfg.TdlsInfo.TDLSEntry[i].Timer, GET_TIMER_FUNCTION(TDLS_TimeoutAction),
+sta/tdls_link_mng.c:						&pAd->StaCfg.TdlsInfo.TDLSEntry[i], FALSE);
+sta/tdls_link_mng.c:	pAd->StaCfg.TdlsInfo.TdlsDialogToken++;
+sta/tdls_link_mng.c:	if (pAd->StaCfg.TdlsInfo.TdlsDialogToken == 0)
+sta/tdls_link_mng.c:		pAd->StaCfg.TdlsInfo.TdlsDialogToken++;
+sta/tdls_link_mng.c:	pTDLS->Token = pAd->StaCfg.TdlsInfo.TdlsDialogToken;
+sta/tdls_link_mng.c:	if (pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled)
+sta/tdls_link_mng.c:	if (pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled)
+sta/tdls_link_mng.c:		UINT32			KeyLifetime = pAd->StaCfg.TdlsInfo.TdlsKeyLifeTime;	// sec
+sta/tdls_link_mng.c:		GenRandom(pAd, pAd->CurrentAddress, FtIe.SNonce);
+sta/tdls_link_mng.c:	TDLS_InsertLinkIdentifierIE(pAd, (pFrameBuf + *pFrameLen), pFrameLen, pAd->CurrentAddress, pTDLS->MacAddr);
+sta/tdls_link_mng.c:		if (pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled)
+sta/tdls_link_mng.c:		if (pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled)
+sta/tdls_link_mng.c:			GenRandom(pAd, pAd->CurrentAddress, ft->ANonce);
+sta/tdls_link_mng.c:					pAd->CurrentAddress, /* I am Responder */
+sta/tdls_link_mng.c:					pAd->CommonCfg.Bssid,
+sta/tdls_link_mng.c:				NdisMoveMemory(&LinkIdentifier[2], pAd->CommonCfg.Bssid, 6);
+sta/tdls_link_mng.c:				NdisMoveMemory(&LinkIdentifier[14], pAd->CurrentAddress, 6);
+sta/tdls_link_mng.c:			                      MAC_ADDR_LEN,				pAd->CurrentAddress,
+sta/tdls_link_mng.c:		TDLS_InsertLinkIdentifierIE(pAd, (pFrameBuf + *pFrameLen), pFrameLen, pTDLS->MacAddr, pAd->CurrentAddress);
+sta/tdls_link_mng.c:	if (pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled)
+sta/tdls_link_mng.c:			NdisMoveMemory(&LinkIdentifier[2], pAd->CommonCfg.Bssid, 6);
+sta/tdls_link_mng.c:			NdisMoveMemory(&LinkIdentifier[8], pAd->CurrentAddress, 6);
+sta/tdls_link_mng.c:								MAC_ADDR_LEN,			pAd->CurrentAddress,
+sta/tdls_link_mng.c:	TDLS_InsertLinkIdentifierIE(pAd, (pFrameBuf + *pFrameLen), pFrameLen, pAd->CurrentAddress, pTDLS->MacAddr);
+sta/tdls_link_mng.c:	if (pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled)
+sta/tdls_link_mng.c:		NdisMoveMemory(&LinkIdentifier[2], pAd->CommonCfg.Bssid, 6);
+sta/tdls_link_mng.c:			NdisMoveMemory(&LinkIdentifier[14], pAd->CurrentAddress, 6);
+sta/tdls_link_mng.c:			NdisMoveMemory(&LinkIdentifier[8], pAd->CurrentAddress, 6);
+sta/tdls_link_mng.c:		TDLS_InsertLinkIdentifierIE(pAd, (pFrameBuf + *pFrameLen), pFrameLen, pTDLS->MacAddr, pAd->CurrentAddress);
+sta/tdls_link_mng.c:		TDLS_InsertLinkIdentifierIE(pAd, (pFrameBuf + *pFrameLen), pFrameLen, pAd->CurrentAddress, pTDLS->MacAddr);
+sta/tdls_link_mng.c:	UINT32	keyLifeTime = pAd->StaCfg.TdlsInfo.TdlsKeyLifeTime;
+sta/tdls_link_mng.c:			pAd->CurrentAddress, /* I am Initiator */
+sta/tdls_link_mng.c:			pAd->CommonCfg.Bssid,
+sta/tdls_link_mng.c:	NdisMoveMemory(&LinkIdentifier[2], pAd->CommonCfg.Bssid, 6);
+sta/tdls_link_mng.c:	NdisMoveMemory(&LinkIdentifier[8], pAd->CurrentAddress, 6);
+sta/tdls_link_mng.c:	                      MAC_ADDR_LEN,				pAd->CurrentAddress,
+sta/tdls_link_mng.c:	NdisMoveMemory(&LinkIdentifier[2], pAd->CommonCfg.Bssid, 6);
+sta/tdls_link_mng.c:	NdisMoveMemory(&LinkIdentifier[14], pAd->CurrentAddress, 6);
+sta/tdls_link_mng.c:	                      MAC_ADDR_LEN,				pAd->CurrentAddress,
+sta/tdls_link_mng.c:	MAKE_802_3_HEADER(Header802_3, pMacAddr, pAd->CurrentAddress, TDLS_ETHERTYPE);
+sta/tdls_link_mng.c:	pAd->StaCfg.TdlsInfo.TdlsDialogToken++;
+sta/tdls_link_mng.c:	if (pAd->StaCfg.TdlsInfo.TdlsDialogToken == 0)
+sta/tdls_link_mng.c:		pAd->StaCfg.TdlsInfo.TdlsDialogToken++;
+sta/tdls_link_mng.c:	TDLS_InsertDialogToken(pAd, (pOutBuffer + FrameLen), &FrameLen, pAd->StaCfg.TdlsInfo.TdlsDialogToken);
+sta/tdls_link_mng.c:	TDLS_InsertLinkIdentifierIE(pAd, (pOutBuffer + FrameLen), &FrameLen, pAd->CurrentAddress, pMacAddr);
+sta/tdls_link_mng.c:	RTMPToWirelessSta(pAd, &pAd->MacTab.Content[BSSID_WCID], Header802_3,
+sta/tdls_link_mng.c:	ActHeaderInit(pAd, &Frame.Hdr, pPeerMac, pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+sta/tdls_link_mng.c:	if (pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled)
+sta/tdls_link_mng.c:	if (pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled)
+sta/tdls_link_mng.c:		ULONG			KeyLifetime = pAd->StaCfg.TdlsInfo.TdlsKeyLifeTime;	// sec
+sta/tdls_link_mng.c:		GenRandom(pAd, pAd->CurrentAddress, FtIe.SNonce);
+sta/tdls_link_mng.c:	TDLS_InsertLinkIdentifierIE(pAd, (pOutBuffer + FrameLen), &FrameLen, pPeerMac, pAd->CurrentAddress);
+sta/tdls_link_mng.c:	MAKE_802_3_HEADER(Header802_3, pTDLS->MacAddr, pAd->CurrentAddress, TDLS_ETHERTYPE);
+sta/tdls_link_mng.c:	RTMPToWirelessSta(pAd, &pAd->MacTab.Content[BSSID_WCID], Header802_3,
+sta/tdls_link_mng.c:	MAKE_802_3_HEADER(Header802_3, pTDLS->MacAddr, pAd->CurrentAddress, TDLS_ETHERTYPE);
+sta/tdls_link_mng.c:	RTMPToWirelessSta(pAd, &pAd->MacTab.Content[BSSID_WCID], Header802_3,
+sta/tdls_link_mng.c:	MAKE_802_3_HEADER(Header802_3, pTDLS->MacAddr, pAd->CurrentAddress, TDLS_ETHERTYPE);
+sta/tdls_link_mng.c:	RTMPToWirelessSta(pAd, &pAd->MacTab.Content[BSSID_WCID], Header802_3,
+sta/tdls_link_mng.c:		pTDLS = &pAd->StaCfg.TdlsInfo.TDLSEntry[idx];
+sta/tdls_link_mng.c:			if (pAd->StaCfg.bRadio == TRUE)
+sta/tdls_link_mng.c:	RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls_link_mng.c:	TDLS_ClearEntryList(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerList);
+sta/tdls_link_mng.c:	RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls_link_mng.c:	RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls_link_mng.c:	TDLS_ClearEntryList(&pAd->StaCfg.TdlsInfo.TdlsBlackList);
+sta/tdls_link_mng.c:	RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls_link_mng.c:		pTDLS = &pAd->StaCfg.TdlsInfo.TDLSEntry[EntryIdx];
+sta/tdls_link_mng.c:	MAKE_802_3_HEADER(Header802_3, pTDLS->MacAddr, pAd->CurrentAddress, TDLS_ETHERTYPE);
+sta/tdls_link_mng.c:	RTMPToWirelessSta(pAd, &pAd->MacTab.Content[idx], Header802_3,
+sta/tdls_link_mng.c:	PLIST_HEADER pTdlsDiscoveryEnList = &pAd->StaCfg.TdlsInfo.TdlsDiscovPeerList;
+sta/tdls_link_mng.c:			RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls_link_mng.c:			RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls_link_mng.c:	if (!MAC_ADDR_EQUAL(Ptr+2, pAd->CommonCfg.Bssid))
+sta/tdls_link_mng.c:	else if (!MAC_ADDR_EQUAL(Ptr+14, pAd->CurrentAddress))
+sta/tdls_link_mng.c:		if (pAd->StaCfg.TdlsInfo.TdlsAutoLink)
+sta/tdls_link_mng.c:			PLIST_HEADER	pTdlsDiscovryEnList = &pAd->StaCfg.TdlsInfo.TdlsDiscovPeerList;
+sta/tdls_link_mng.c:				PLIST_HEADER	pTdlsDiscovEnList = &pAd->StaCfg.TdlsInfo.TdlsDiscovPeerList;
+sta/tdls_link_mng.c:							if ((Rssi < pAd->StaCfg.TdlsInfo.TdlsAutoTeardownRssiThreshold) &&
+sta/tdls_link_mng.c:								(pTdlsPeer->AvgRssi0 < pAd->StaCfg.TdlsInfo.TdlsAutoTeardownRssiThreshold))
+sta/tdls_link_mng.c:										pAd->StaCfg.TdlsInfo.TDLSEntry[idx].Valid	= FALSE;
+sta/tdls_link_mng.c:										pAd->StaCfg.TdlsInfo.TDLSEntry[idx].Status	= TDLS_MODE_NONE;
+sta/tdls_link_mng.c:										TDLS_MlmeParmFill(pAd, &MlmeTdlsReq, &pAd->StaCfg.TdlsInfo.TDLSEntry[idx], Reason, FALSE);
+sta/tdls_link_mng.c:								RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls_link_mng.c:								RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls_link_mng.c:							if (Rssi < pAd->StaCfg.TdlsInfo.TdlsAutoTeardownRssiThreshold)
+sta/tdls_link_mng.c:										pAd->StaCfg.TdlsInfo.TDLSEntry[idx].Valid	= FALSE;
+sta/tdls_link_mng.c:										pAd->StaCfg.TdlsInfo.TDLSEntry[idx].Status	= TDLS_MODE_NONE;
+sta/tdls_link_mng.c:										TDLS_MlmeParmFill(pAd, &MlmeTdlsReq, &pAd->StaCfg.TdlsInfo.TDLSEntry[idx], Reason, FALSE);
+sta/tdls_link_mng.c:								RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls_link_mng.c:								RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls_link_mng.c:						if ((pTdlsPeer->AvgRssi0 > pAd->StaCfg.TdlsInfo.TdlsAutoSetupRssiThreshold) &&
+sta/tdls_link_mng.c:							(Rssi > pAd->StaCfg.TdlsInfo.TdlsAutoSetupRssiThreshold))
+sta/tdls_link_mng.c:									PLIST_HEADER	pTdlsDiscovEnList = &pAd->StaCfg.TdlsInfo.TdlsDiscovPeerList;
+sta/tdls_link_mng.c:									PLIST_HEADER	pTdlsBlackEnList = &pAd->StaCfg.TdlsInfo.TdlsBlackList;
+sta/tdls_link_mng.c:									RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls_link_mng.c:									RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls_link_mng.c:									RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls_link_mng.c:									RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls_link_mng.c:	if (pAd->StaActive.ExtCapInfo.TDLSProhibited == TRUE)
+sta/tdls_link_mng.c:	if (pAd->StaActive.ExtCapInfo.TDLSProhibited == TRUE)
+sta/tdls_link_mng.c:	if ((pAd->StaCfg.WepStatus != Ndis802_11WEPDisabled) && (RsnLen == 0))
+sta/tdls_link_mng.c:	if (pAd->StaCfg.TdlsInfo.TdlsAutoLink)
+sta/tdls_link_mng.c:		PLIST_HEADER	pTdlsBlackEnList = &pAd->StaCfg.TdlsInfo.TdlsBlackList;
+sta/tdls_link_mng.c:		RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls_link_mng.c:		RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls_link_mng.c:			pTDLS = &pAd->StaCfg.TdlsInfo.TDLSEntry[idx];
+sta/tdls_link_mng.c:					if (RTMPCompareMemory(PeerAddr, pAd->CurrentAddress, MAC_ADDR_LEN) == 2)
+sta/tdls_link_mng.c:			pTDLS = &pAd->StaCfg.TdlsInfo.TDLSEntry[idx];
+sta/tdls_link_mng.c:				pTDLS = &pAd->StaCfg.TdlsInfo.TDLSEntry[idx];
+sta/tdls_link_mng.c:			if (pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled)
+sta/tdls_link_mng.c:			if ((HtCapLen > 0) && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED))
+sta/tdls_link_mng.c:	pTDLS = (PRT_802_11_TDLS)&pAd->StaCfg.TdlsInfo.TDLSEntry[LinkId];
+sta/tdls_link_mng.c:		if (pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled)
+sta/tdls_link_mng.c:			if ((HtCapLen > 0) && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED))
+sta/tdls_link_mng.c:			if (pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled)
+sta/tdls_link_mng.c:			pMacEntry->AuthMode = pAd->StaCfg.AuthMode;
+sta/tdls_link_mng.c:			pMacEntry->WepStatus = pAd->StaCfg.WepStatus;
+sta/tdls_link_mng.c:							pAd->StaCfg.UapsdInfo.bAPSDCapable);
+sta/tdls_link_mng.c:			DBGPRINT(RT_DEBUG_ERROR, ("MacTableInsertTDlsEntry - allocate entry #%d, Total= %d\n",pMacEntry->Aid, pAd->MacTab.Size));
+sta/tdls_link_mng.c:			if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) || (pAd->CommonCfg.bWmmCapable))
+sta/tdls_link_mng.c:			if (pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled)
+sta/tdls_link_mng.c:		pTDLS->ChSwitchTime = pAd->StaCfg.TdlsInfo.TdlsSwitchTime;
+sta/tdls_link_mng.c:		pTDLS->ChSwitchTimeout = pAd->StaCfg.TdlsInfo.TdlsSwitchTimeout;
+sta/tdls_link_mng.c:		if (pAd->StaCfg.TdlsInfo.TdlsAutoLink)
+sta/tdls_link_mng.c:			PLIST_HEADER	pTdlsDiscovEnList = &pAd->StaCfg.TdlsInfo.TdlsDiscovPeerList;
+sta/tdls_link_mng.c:			PLIST_HEADER	pTdlsBlackEnList = &pAd->StaCfg.TdlsInfo.TdlsBlackList;
+sta/tdls_link_mng.c:			RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls_link_mng.c:			RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls_link_mng.c:			RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls_link_mng.c:			RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls_link_mng.c:	//pAd->StaCfg.TdlsCurrentOperateChannel = pAd->CommonCfg.Channel;
+sta/tdls_link_mng.c:	pTDLS = (PRT_802_11_TDLS)&pAd->StaCfg.TdlsInfo.TDLSEntry[LinkId];
+sta/tdls_link_mng.c:		if (pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled)
+sta/tdls_link_mng.c:			if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) || (pAd->CommonCfg.bWmmCapable))
+sta/tdls_link_mng.c:			if (pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled)
+sta/tdls_link_mng.c:			pMacEntry->AuthMode = pAd->StaCfg.AuthMode;
+sta/tdls_link_mng.c:			pMacEntry->WepStatus = pAd->StaCfg.WepStatus;
+sta/tdls_link_mng.c:							pAd->StaCfg.UapsdInfo.bAPSDCapable);
+sta/tdls_link_mng.c:			DBGPRINT(RT_DEBUG_ERROR, ("MacTableInsertTDlsEntry - allocate entry #%d, Total= %d\n",pMacEntry->Aid, pAd->MacTab.Size));
+sta/tdls_link_mng.c:			if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) || (pAd->CommonCfg.bWmmCapable))
+sta/tdls_link_mng.c:			if (pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled)
+sta/tdls_link_mng.c:			pTDLS->ChSwitchTime = pAd->StaCfg.TdlsInfo.TdlsSwitchTime;
+sta/tdls_link_mng.c:			pTDLS->ChSwitchTimeout = pAd->StaCfg.TdlsInfo.TdlsSwitchTimeout;
+sta/tdls_link_mng.c:			if (pAd->StaCfg.TdlsInfo.TdlsAutoLink)
+sta/tdls_link_mng.c:				PLIST_HEADER	pTdlsDiscovEnList = &pAd->StaCfg.TdlsInfo.TdlsDiscovPeerList;
+sta/tdls_link_mng.c:				PLIST_HEADER	pTdlsBlackEnList = &pAd->StaCfg.TdlsInfo.TdlsBlackList;
+sta/tdls_link_mng.c:				RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls_link_mng.c:				RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls_link_mng.c:				RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls_link_mng.c:				RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls_link_mng.c:	pAd->StaCfg.TdlsInfo.TdlsDialogToken = Token;
+sta/tdls_link_mng.c:	//pAd->StaCfg.TdlsCurrentOperateChannel = pAd->CommonCfg.Channel;
+sta/tdls_link_mng.c:	pTDLS = &pAd->StaCfg.TdlsInfo.TDLSEntry[LinkId];
+sta/tdls_link_mng.c:		PLIST_HEADER	pTdlsBlackEnList = &pAd->StaCfg.TdlsInfo.TdlsBlackList;
+sta/tdls_link_mng.c:		PLIST_HEADER	pTdlsDiscoveryEnList = &pAd->StaCfg.TdlsInfo.TdlsDiscovPeerList;
+sta/tdls_link_mng.c:		RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls_link_mng.c:		RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsBlackListSemLock);
+sta/tdls_link_mng.c:		RTMP_SEM_LOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/tdls_link_mng.c:		RTMP_SEM_UNLOCK(&pAd->StaCfg.TdlsInfo.TdlsDiscovPeerListSemLock);
+sta/p2pcli.c:    6. ApCli index (0) of IOCTL command is put in pAd->OS_Cookie->ioctl_if
+sta/p2pcli.c:			if(	MAC_ADDR_EQUAL(pAd->ApCfg.ApCliTab[i].CurrentAddress, pAddr))
+sta/p2pcli.c: *  \pre the station has the following information in the pAd->UserCfg
+sta/p2pcli.c:    COPY_MAC_ADDR(pHdr80211->Addr2, pAd->ApCfg.ApCliTab[ifIndex].CurrentAddress);
+sta/p2pcli.c:		FALSE if pAd->CommonCfg.SupportedHtPhy doesn't accept the pHtCapability.  (AP Mode)
+sta/p2pcli.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[IfIndex];
+sta/p2pcli.c:	if (pAd->CommonCfg.DesiredHtPhy.AmsduEnable && (pAd->CommonCfg.REGBACapability.field.AutoBA == FALSE))
+sta/p2pcli.c:	if (pAd->CommonCfg.bRdg && pHtCapability->ExtHtCapInfo.RDGSupport)
+sta/p2pcli.c:	if ((pAd->OpMode == OPMODE_STA))
+sta/p2pcli.c:	pAd->ApCliMlmeAux.HtCapability.MCSSet[0] = 0xff;
+sta/p2pcli.c:	pAd->ApCliMlmeAux.HtCapability.MCSSet[4] = 0x1;
+sta/p2pcli.c:	 switch (pAd->CommonCfg.RxStream)
+sta/p2pcli.c:			pAd->ApCliMlmeAux.HtCapability.MCSSet[0] = 0xff;
+sta/p2pcli.c:			pAd->ApCliMlmeAux.HtCapability.MCSSet[1] = 0x00;
+sta/p2pcli.c:            pAd->ApCliMlmeAux.HtCapability.MCSSet[2] = 0x00;
+sta/p2pcli.c:            pAd->ApCliMlmeAux.HtCapability.MCSSet[3] = 0x00;
+sta/p2pcli.c:			pAd->ApCliMlmeAux.HtCapability.MCSSet[0] = 0xff;
+sta/p2pcli.c:			pAd->ApCliMlmeAux.HtCapability.MCSSet[1] = 0xff;
+sta/p2pcli.c:            pAd->ApCliMlmeAux.HtCapability.MCSSet[2] = 0x00;
+sta/p2pcli.c:            pAd->ApCliMlmeAux.HtCapability.MCSSet[3] = 0x00;
+sta/p2pcli.c:			pAd->ApCliMlmeAux.HtCapability.MCSSet[0] = 0xff;
+sta/p2pcli.c:			pAd->ApCliMlmeAux.HtCapability.MCSSet[1] = 0xff;
+sta/p2pcli.c:            pAd->ApCliMlmeAux.HtCapability.MCSSet[2] = 0xff;
+sta/p2pcli.c:            pAd->ApCliMlmeAux.HtCapability.MCSSet[3] = 0x00;
+sta/p2pcli.c:	if (pAd->Antenna.field.TxPath == 2)	// 2: 2Tx   1: 1Tx
+sta/p2pcli.c:		pAd->MlmeAux.HtCapability.MCSSet[1] = 0xff;
+sta/p2pcli.c:		pAd->MlmeAux.HtCapability.MCSSet[1] = 0x00;
+sta/p2pcli.c:	pAd->ApCliMlmeAux.HtCapability.HtCapInfo.ChannelWidth = pAddHtInfo->AddHtInfo.RecomWidth & pAd->CommonCfg.DesiredHtPhy.ChannelWidth;
+sta/p2pcli.c:	pAd->ApCliMlmeAux.HtCapability.HtCapInfo.GF =  pHtCapability->HtCapInfo.GF &pAd->CommonCfg.DesiredHtPhy.GF;
+sta/p2pcli.c:	pAd->ApCliMlmeAux.HtCapability.HtCapInfo.AMsduSize =  pAd->CommonCfg.DesiredHtPhy.AmsduSize;
+sta/p2pcli.c:	pAd->ApCliMlmeAux.HtCapability.HtCapInfo.MimoPs = pHtCapability->HtCapInfo.MimoPs;
+sta/p2pcli.c:	pAd->ApCliMlmeAux.HtCapability.HtCapInfo.ShortGIfor20 =  (pAd->CommonCfg.DesiredHtPhy.ShortGIfor20) & (pHtCapability->HtCapInfo.ShortGIfor20);
+sta/p2pcli.c:	pAd->ApCliMlmeAux.HtCapability.HtCapInfo.ShortGIfor40 =  (pAd->CommonCfg.DesiredHtPhy.ShortGIfor40) & (pHtCapability->HtCapInfo.ShortGIfor40);
+sta/p2pcli.c:	pAd->ApCliMlmeAux.HtCapability.HtCapInfo.TxSTBC =  (pAd->CommonCfg.DesiredHtPhy.TxSTBC)&(pHtCapability->HtCapInfo.RxSTBC);
+sta/p2pcli.c:	pAd->ApCliMlmeAux.HtCapability.HtCapInfo.RxSTBC =  (pAd->CommonCfg.DesiredHtPhy.RxSTBC)&(pHtCapability->HtCapInfo.TxSTBC);
+sta/p2pcli.c:	pAd->ApCliMlmeAux.HtCapability.HtCapParm.MaxRAmpduFactor = pAd->CommonCfg.DesiredHtPhy.MaxRAmpduFactor;
+sta/p2pcli.c:	pAd->ApCliMlmeAux.HtCapability.HtCapParm.MpduDensity = pHtCapability->HtCapParm.MpduDensity;
+sta/p2pcli.c:	pAd->ApCliMlmeAux.HtCapability.ExtHtCapInfo.PlusHTC = pHtCapability->ExtHtCapInfo.PlusHTC;
+sta/p2pcli.c:	if (pAd->CommonCfg.bRdg)
+sta/p2pcli.c:		pAd->ApCliMlmeAux.HtCapability.ExtHtCapInfo.RDGSupport = pHtCapability->ExtHtCapInfo.RDGSupport;
+sta/p2pcli.c:	pApCliEntry->PsPollFrame.Aid = pAd->ApCliMlmeAux.Aid | 0xC000;
+sta/p2pcli.c:	COPY_MAC_ADDR(pApCliEntry->PsPollFrame.Bssid, pAd->ApCliMlmeAux.Bssid);
+sta/p2pcli.c:	COPY_MAC_ADDR(pApCliEntry->NullFrame.Addr1, pAd->ApCliMlmeAux.Bssid);
+sta/p2pcli.c:	COPY_MAC_ADDR(pApCliEntry->NullFrame.Addr3, pAd->ApCliMlmeAux.Bssid);
+sta/p2pcli.c:										pAd->ApCfg.ApCliTab[ifIndex].AuthMode, GetAuthMode(pAd->ApCfg.ApCliTab[ifIndex].AuthMode),
+sta/p2pcli.c:										pAd->ApCfg.ApCliTab[ifIndex].WepStatus, GetEncryptType(pAd->ApCfg.ApCliTab[ifIndex].WepStatus)));			
+sta/p2pcli.c:		pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli.c:		/*pMacEntry = MacTableInsertApCliEntry(pAd, (PUCHAR)(pAd->MlmeAux.Bssid)); */
+sta/p2pcli.c:		pMacEntry = MacTableInsertEntry(pAd, (PUCHAR)(pAd->ApCliMlmeAux.Bssid),
+sta/p2pcli.c:        		if (CFG80211_checkScanResInKernelCache(pAd, pAd->P2pCfg.Bssid, pApCliEntry->CfgSsid, pApCliEntry->CfgSsidLen))
+sta/p2pcli.c:                        	__FUNCTION__, pAd->CommonCfg.Channel));
+sta/p2pcli.c:                                        PRINT_MAC(pAd->ApCliMlmeAux.Bssid), PRINT_MAC(pAd->P2pCfg.Bssid)));
+sta/p2pcli.c:				DBGPRINT(RT_DEBUG_TRACE, ("\n++++++++ %s::  Delete BssSearch Table on Channel = %d. ++++++++\n", __FUNCTION__, pAd->CommonCfg.Channel));
+sta/p2pcli.c:				DBGPRINT(RT_DEBUG_TRACE, ("                   BSSID = [%02x:%02x:%02x:%02x:%02x:%02x].  p2p_bssid = [%02x:%02x:%02x:%02x:%02x:%02x].\n", PRINT_MAC(pAd->ApCliMlmeAux.Bssid), PRINT_MAC(pAd->P2pCfg.Bssid)));
+sta/p2pcli.c:				BssTableDeleteEntry(&pAd->ScanTab,
+sta/p2pcli.c:					    /*pAd->ApCliMlmeAux.Bssid*/pAd->P2pCfg.Bssid,
+sta/p2pcli.c:					    pAd->CommonCfg.Channel);
+sta/p2pcli.c:			COPY_MAC_ADDR(APCLI_ROOT_BSSID_GET(pAd, pApCliEntry->MacTabWCID), pAd->ApCliMlmeAux.Bssid);
+sta/p2pcli.c:			pApCliEntry->SsidLen = pAd->ApCliMlmeAux.SsidLen;
+sta/p2pcli.c:			NdisMoveMemory(pApCliEntry->Ssid, pAd->ApCliMlmeAux.Ssid, pApCliEntry->SsidLen);
+sta/p2pcli.c:			if ((pMacEntry->AuthMode >= Ndis802_11AuthModeWPA) && (pAd->ApCliMlmeAux.VarIELen != 0))
+sta/p2pcli.c:				pVIE = pAd->ApCliMlmeAux.VarIEs;
+sta/p2pcli.c:				len	 = pAd->ApCliMlmeAux.VarIELen;
+sta/p2pcli.c:			SupportRate(pAd->ApCliMlmeAux.SupRate, pAd->ApCliMlmeAux.SupRateLen, pAd->ApCliMlmeAux.ExtRate,
+sta/p2pcli.c:				pAd->ApCliMlmeAux.ExtRateLen, &pRates, &RatesLen, &MaxSupportedRate);
+sta/p2pcli.c:			pMacEntry->MaxSupportedRate = min(pAd->CommonCfg.MaxTxRate, MaxSupportedRate);
+sta/p2pcli.c:			pMacEntry->CapabilityInfo = pAd->ApCliMlmeAux.CapabilityInfo;
+sta/p2pcli.c:				BssIdx = pAd->ApCfg.BssidNum + MAX_MESH_NUM + ifIndex;
+sta/p2pcli.c:			if (pAd->ApCliMlmeAux.HtCapabilityLen != 0)
+sta/p2pcli.c:				PHT_CAPABILITY_IE pHtCapability = (PHT_CAPABILITY_IE)&pAd->ApCliMlmeAux.HtCapability;
+sta/p2pcli.c:				if ((pAd->ApCliMlmeAux.HtCapability.HtCapInfo.GF) && (pAd->CommonCfg.DesiredHtPhy.GF))
+sta/p2pcli.c:					pAd->MacTab.fAnyStationNonGF = TRUE;
+sta/p2pcli.c:					pAd->CommonCfg.AddHTInfo.AddHtInfo2.NonGfPresent = 1;
+sta/p2pcli.c:				if ((pHtCapability->HtCapInfo.ChannelWidth) && (pAd->CommonCfg.DesiredHtPhy.ChannelWidth))
+sta/p2pcli.c:					pMacEntry->MaxHTPhyMode.field.ShortGI = ((pAd->CommonCfg.DesiredHtPhy.ShortGIfor40)&(pHtCapability->HtCapInfo.ShortGIfor40));
+sta/p2pcli.c:					pMacEntry->MaxHTPhyMode.field.ShortGI = ((pAd->CommonCfg.DesiredHtPhy.ShortGIfor20)&(pHtCapability->HtCapInfo.ShortGIfor20));
+sta/p2pcli.c:					pAd->MacTab.fAnyStation20Only = TRUE;
+sta/p2pcli.c:				pMacEntry->MaxHTPhyMode.field.MCS = get_ht_max_mcs(pAd, &pAd->ApCfg.ApCliTab[ifIndex].DesiredHtPhyInfo.MCSSet[0],
+sta/p2pcli.c:				if (pAd->ApCfg.ApCliTab[ifIndex].DesiredTransmitSetting.field.MCS != MCS_AUTO)
+sta/p2pcli.c:						pAd->ApCfg.ApCliTab[ifIndex].DesiredTransmitSetting.field.MCS));
+sta/p2pcli.c:					set_ht_fixed_mcs(pAd, pMacEntry, pAd->ApCfg.ApCliTab[ifIndex].DesiredTransmitSetting.field.MCS, pAd->ApCfg.ApCliTab[ifIndex].HTPhyMode.field.MCS);
+sta/p2pcli.c:				pMacEntry->MaxHTPhyMode.field.STBC = (pHtCapability->HtCapInfo.RxSTBC & (pAd->CommonCfg.DesiredHtPhy.TxSTBC));
+sta/p2pcli.c:				if (pAd->CommonCfg.DesiredHtPhy.AmsduEnable && (pAd->CommonCfg.REGBACapability.field.AutoBA == FALSE))
+sta/p2pcli.c:				if (pAd->CommonCfg.bRdg && pHtCapability->ExtHtCapInfo.RDGSupport)				
+sta/p2pcli.c:				NdisMoveMemory(&pMacEntry->HTCapability, &pAd->ApCliMlmeAux.HtCapability, sizeof(HT_CAPABILITY_IE));
+sta/p2pcli.c:				pAd->MacTab.fAnyStationIsLegacy = TRUE;
+sta/p2pcli.c:			if (pAd->ApCfg.ApCliTab[ifIndex].bAutoTxRateSwitch == FALSE)
+sta/p2pcli.c:				RTMPUpdateLegacyTxSetting((UCHAR)pAd->ApCfg.ApCliTab[ifIndex].DesiredTransmitSetting.field.FixedTxMode, pMacEntry);	
+sta/p2pcli.c:				NdisMoveMemory(&(pAd->CommonCfg.APEdcaParm), &(pAd->ApCliMlmeAux.APEdcaParm), sizeof(EDCA_PARM));
+sta/p2pcli.c:				AsicSetEdcaParm(pAd, &pAd->CommonCfg.APEdcaParm);
+sta/p2pcli.c:			if ((pAd->ApCliMlmeAux.APEdcaParm.bValid)
+sta/p2pcli.c:			if (pAd->CommonCfg.bAggregationCapable)
+sta/p2pcli.c:				if ((pAd->CommonCfg.bPiggyBackCapable) && (pAd->ApCliMlmeAux.APRalinkIe & 0x00000003) == 3)
+sta/p2pcli.c:				else if (pAd->ApCliMlmeAux.APRalinkIe & 0x00000001)
+sta/p2pcli.c:			pApCliEntry->ApCliBeaconPeriod = pAd->ApCliMlmeAux.BeaconPeriod;
+sta/p2pcli.c:			pAd->ApCfg.ApCliInfRunned++;
+sta/p2pcli.c:					pAd->ApCliMlmeAux.SupRate,
+sta/p2pcli.c:					pAd->ApCliMlmeAux.SupRateLen,
+sta/p2pcli.c:					pAd->ApCliMlmeAux.ExtRate,
+sta/p2pcli.c:					pAd->ApCliMlmeAux.ExtRateLen,
+sta/p2pcli.c:					pAd->ApCliMlmeAux.vht_cap_len,
+sta/p2pcli.c:					&pAd->ApCliMlmeAux.vht_cap,
+sta/p2pcli.c:					&pAd->ApCliMlmeAux.HtCapability,
+sta/p2pcli.c:					pAd->ApCliMlmeAux.HtCapabilityLen);
+sta/p2pcli.c:		(pAd->ApCfg.ApCliTab[ifIndex].WscControl.WscConfMode == WSC_ENROLLEE) &&
+sta/p2pcli.c:		(pAd->ApCfg.ApCliTab[ifIndex].WscControl.bWscTrigger == TRUE))
+sta/p2pcli.c:		pAd->ApCfg.ApCliTab[ifIndex].WscControl.WscState = WSC_STATE_LINK_UP;
+sta/p2pcli.c:		pAd->ApCfg.ApCliTab[ifIndex].WscControl.WscStatus = WSC_STATE_LINK_UP;
+sta/p2pcli.c:		pAd->ApCfg.ApCliTab[ifIndex].WscControl.WscConfStatus = WSC_SCSTATE_UNCONFIGURED;
+sta/p2pcli.c:		NdisZeroMemory(pAd->ApCfg.ApCliTab[ifIndex].WscControl.EntryAddr, MAC_ADDR_LEN);        
+sta/p2pcli.c:		NdisMoveMemory(pAd->ApCfg.ApCliTab[ifIndex].WscControl.EntryAddr, pAd->ApCliMlmeAux.Bssid, MAC_ADDR_LEN);
+sta/p2pcli.c:		WscStop(pAd, TRUE, &pAd->ApCfg.ApCliTab[ifIndex].WscControl);
+sta/p2pcli.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli.c:		NdisZeroMemory(pAd->ApCfg.ApCliTab[0].CfgApCliBssid, MAC_ADDR_LEN);
+sta/p2pcli.c:		pEntry = &pAd->MacTab.Content[pApCliEntry->MacTabWCID];
+sta/p2pcli.c:			pAd->P2pTable.Client[P2pIdx].P2pClientState = P2PSTATE_DISCOVERY;
+sta/p2pcli.c:			if (pAd->P2pCfg.bP2pCliReConnect == FALSE)
+sta/p2pcli.c:				pAd->P2pCfg.bP2pCliReConnectTimerRunning = TRUE;
+sta/p2pcli.c:				RTMPSetTimer(&pAd->P2pCfg.P2pCliReConnectTimer, P2P_CHECK_CLIENT_TIMER);
+sta/p2pcli.c:	if ((INFRA_ON(pAd)) && (pAd->StaActive.SupportedHtPhy.ChannelWidth == BW_40))
+sta/p2pcli.c:	pAd->ApCfg.ApCliInfRunned--;
+sta/p2pcli.c:	if (CFG80211_checkScanResInKernelCache(pAd, pAd->P2pCfg.Bssid, pApCliEntry->CfgSsid, pApCliEntry->CfgSsidLen))
+sta/p2pcli.c:                        __FUNCTION__, pAd->CommonCfg.Channel));
+sta/p2pcli.c:                                        PRINT_MAC(pAd->ApCliMlmeAux.Bssid), PRINT_MAC(pAd->P2pCfg.Bssid)));
+sta/p2pcli.c:			__FUNCTION__, pAd->CommonCfg.Channel));
+sta/p2pcli.c:					PRINT_MAC(pAd->ApCliMlmeAux.Bssid), PRINT_MAC(pAd->P2pCfg.Bssid)));
+sta/p2pcli.c:		BssTableDeleteEntry(&pAd->ScanTab,
+sta/p2pcli.c:			    /*pAd->ApCliMlmeAux.Bssid*/pAd->P2pCfg.Bssid,
+sta/p2pcli.c:			    pAd->CommonCfg.Channel);
+sta/p2pcli.c:	if (pAd->flg_apcli_init != TRUE)
+sta/p2pcli.c:	if (pAd->FlgCfg80211Connecting != TRUE &&
+sta/p2pcli.c:	   pAd->ApCfg.ApCliTab[MAIN_MBSSID].Valid == FALSE)	
+sta/p2pcli.c:		pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli.c:			COPY_MAC_ADDR(pApCliEntry->CfgApCliBssid, pAd->P2pCfg.Bssid);
+sta/p2pcli.c:			if (pAd->ApCfg.ApCliTab[0].CtrlCurrState == APCLI_CTRL_DISCONNECTED)
+sta/p2pcli.c:		pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli.c:	if (pAd->flg_apcli_init != TRUE)
+sta/p2pcli.c:		pApCliEntry = &pAd->ApCfg.ApCliTab[index];
+sta/p2pcli.c:			&& (RTMP_TIME_AFTER(pAd->Mlme.Now32 , (pApCliEntry->ApCliRcvBeaconTime + (4 * OS_HZ)))))
+sta/p2pcli.c:        if (pEntry && IS_ENTRY_APCLI(pEntry) && pAd->ApCfg.ApCliTab[pEntry->apidx].WscControl.WscConfMode == WSC_ENROLLEE)
+sta/p2pcli.c:	NdisAcquireSpinLock(&pAd->MacTabLock);
+sta/p2pcli.c:		pCurEntry = &pAd->MacTab.Content[wcid];
+sta/p2pcli.c:		if (pAd->ApCfg.ApCliTab[ApCliIndex].Valid != TRUE)
+sta/p2pcli.c:	NdisReleaseSpinLock(&pAd->MacTabLock);
+sta/p2pcli.c:		pApCliEntry = (APCLI_STRUCT *)&pAd->ApCfg.ApCliTab[apCliIdx];
+sta/p2pcli.c:		pMacEntry = &pAd->MacTab.Content[pApCliEntry->MacTabWCID];
+sta/p2pcli.c:		/*DBGPRINT(RT_DEBUG_TRACE, ("ApCliAllowToSendPacket(): Set the WCID as %d!\n", pAd->ApCfg.ApCliTab[apCliIdx].MacTabWCID)); */
+sta/p2pcli.c:		*pWcid = pAd->ApCfg.ApCliTab[apCliIdx].MacTabWCID;
+sta/p2pcli.c:		/*RTMP_SET_PACKET_WCID(pPacket, pAd->ApCfg.ApCliTab[apCliIdx].MacTabWCID); *//* to ApClient links. */
+sta/p2pcli.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[idx];
+sta/p2pcli.c:	pApCliEntry	= &pAd->ApCfg.ApCliTab[pEntry->MatchAPCLITabIdx];																											
+sta/p2pcli.c:	BssIdx = pAd->ApCfg.BssidNum + MAX_MESH_NUM + IfIdx;
+sta/p2pcli.c:	if (pAd->ApCfg.ApCliTab[IfIdx].GroupCipher == Ndis802_11Encryption2Enabled && KeyLen >= LEN_TKIP_GTK)
+sta/p2pcli.c:	else if (pAd->ApCfg.ApCliTab[IfIdx].GroupCipher == Ndis802_11Encryption3Enabled && 
+sta/p2pcli.c:								__FUNCTION__, pAd->ApCfg.ApCliTab[IfIdx].GroupCipher, KeyLen));		
+sta/p2pcli.c:	NdisMoveMemory(pAd->ApCfg.ApCliTab[IfIdx].GTK, pKey, GTK_len);
+sta/p2pcli.c:	pAd->ApCfg.ApCliTab[IfIdx].DefaultKeyId = DefaultKeyIdx;
+sta/p2pcli.c:	NdisZeroMemory(&pAd->ApCfg.ApCliTab[IfIdx].SharedKey[DefaultKeyIdx], sizeof(CIPHER_KEY));  
+sta/p2pcli.c:	pAd->ApCfg.ApCliTab[IfIdx].SharedKey[DefaultKeyIdx].KeyLen = GTK_len;
+sta/p2pcli.c:	NdisMoveMemory(pAd->ApCfg.ApCliTab[IfIdx].SharedKey[DefaultKeyIdx].Key, pKey, LEN_TK);
+sta/p2pcli.c:		NdisMoveMemory(pAd->ApCfg.ApCliTab[IfIdx].SharedKey[DefaultKeyIdx].RxMic, pKey + 16, LEN_TKIP_MIC);
+sta/p2pcli.c:		NdisMoveMemory(pAd->ApCfg.ApCliTab[IfIdx].SharedKey[DefaultKeyIdx].TxMic, pKey + 24, LEN_TKIP_MIC);
+sta/p2pcli.c:	pAd->ApCfg.ApCliTab[IfIdx].SharedKey[DefaultKeyIdx].CipherAlg = CIPHER_NONE;
+sta/p2pcli.c:	if (pAd->ApCfg.ApCliTab[IfIdx].GroupCipher == Ndis802_11Encryption2Enabled)
+sta/p2pcli.c:		pAd->ApCfg.ApCliTab[IfIdx].SharedKey[DefaultKeyIdx].CipherAlg = CIPHER_TKIP;
+sta/p2pcli.c:	else if (pAd->ApCfg.ApCliTab[IfIdx].GroupCipher == Ndis802_11Encryption3Enabled)
+sta/p2pcli.c:		pAd->ApCfg.ApCliTab[IfIdx].SharedKey[DefaultKeyIdx].CipherAlg = CIPHER_AES;
+sta/p2pcli.c:	if (pAd->flg_apcli_init != FALSE)
+sta/p2pcli.c:		pAd->ApCfg.ApCliTab[apcli_index].dev = NULL;
+sta/p2pcli.c:		MC_RowID = pAd->MC_RowID;
+sta/p2pcli.c:		IoctlIF = pAd->IoctlIF;
+sta/p2pcli.c:		pAd->IoctlIF = IoctlIF;
+sta/p2pcli.c:		pApCliEntry = &pAd->ApCfg.ApCliTab[apcli_index];
+sta/p2pcli.c:		COPY_MAC_ADDR(pApCliEntry->CurrentAddress, pAd->CurrentAddress);
+sta/p2pcli.c:		if (pAd->chipCap.MBSSIDMode == MBSSID_MODE1)
+sta/p2pcli.c:		if (pAd->ApCfg.BssidNum > 0 || MAX_MESH_NUM > 0) 
+sta/p2pcli.c:			pApCliEntry->CurrentAddress[0] += (((pAd->ApCfg.BssidNum + MAX_MESH_NUM) - 1) << 2);
+sta/p2pcli.c:			(pApCliEntry->CurrentAddress[ETH_LENGTH_OF_ADDRESS - 1] + pAd->ApCfg.BssidNum + MAX_MESH_NUM) & 0xFF;
+sta/p2pcli.c:		RtmpOSNetDevAttach(pAd->OpMode, new_dev_p, pNetDevOps);
+sta/p2pcli.c:	pAd->flg_apcli_init = TRUE;
+sta/p2pcli.c:		if (pAd->ApCfg.ApCliTab[index].dev)
+sta/p2pcli.c:			RtmpOSNetDevDetach(pAd->ApCfg.ApCliTab[index].dev);
+sta/p2pcli.c:			RtmpOSNetDevFree(pAd->ApCfg.ApCliTab[index].dev);
+sta/p2pcli.c:			pAd->flg_apcli_init = FALSE;
+sta/p2pcli.c:			pAd->ApCfg.ApCliTab[index].dev = NULL;
+sta/p2pcli.c:		if (pAd->ApCfg.ApCliTab[ifIndex].dev == dev_p)
+sta/p2pcli.c:		if (pAd->ApCfg.ApCliTab[ifIndex].dev == dev_p)
+sta/p2pcli.c:			if (pAd->ApCfg.ApCliTab[ifIndex].Enable)
+sta/p2pcli.c:	pApCli = (PAPCLI_STRUCT)&pAd->ApCfg.ApCliTab;
+sta/p2pcli.c:			pAd->RalinkCounters.PendingNdisPacketCount ++;
+sta/p2pcli.c:			SET_OS_PKT_NETDEV(skb_p, pAd->net_dev);
+sta/wpa.c:	if (pAd->StaCfg.MicErrCnt == 0)
+sta/wpa.c:		pAd->StaCfg.MicErrCnt++;
+sta/wpa.c:		pAd->StaCfg.LastMicErrorTime = Now;
+sta/wpa.c:        NdisZeroMemory(pAd->StaCfg.ReplayCounter, 8);        
+sta/wpa.c:	else if (pAd->StaCfg.MicErrCnt == 1)
+sta/wpa.c:		if ((pAd->StaCfg.LastMicErrorTime + (60 * OS_HZ)) < Now)
+sta/wpa.c:			pAd->StaCfg.LastMicErrorTime = Now; 		
+sta/wpa.c:				RTMPSendWirelessEvent(pAd, IW_COUNTER_MEASURES_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0); 
+sta/wpa.c:			pAd->StaCfg.LastMicErrorTime = Now; 		
+sta/wpa.c:			pAd->StaCfg.MicErrCnt++;
+sta/wpa.c:			 if pAd->StaCfg.MicErrCnt greater than 2.
+sta/wpa.c:    if (pAd->StaCfg.MicErrCnt == 2)
+sta/wpa.c:        RTMPSetTimer(&pAd->StaCfg.WpaDisassocAndBlockAssocTimer, 100);
+sta/wpa.c:	pAd->Sequence = ((pAd->Sequence) + 1) & (MAX_SEQ_NUMBER);
+sta/wpa.c:	MAKE_802_3_HEADER(Header802_3, pAd->CommonCfg.Bssid, pAd->CurrentAddress, EAPOL);	
+sta/wpa.c:	if(pAd->StaCfg.WepStatus  == Ndis802_11Encryption3Enabled)
+sta/wpa.c:	NdisMoveMemory(pPacket->KeyDesc.ReplayCounter, pAd->StaCfg.ReplayCounter, LEN_KEY_DESC_REPLAY);
+sta/wpa.c:    inc_byte_array(pAd->StaCfg.ReplayCounter, 8);
+sta/wpa.c:	if(pAd->StaCfg.WepStatus  == Ndis802_11Encryption3Enabled)
+sta/wpa.c:		RT_HMAC_SHA1(pAd->StaCfg.PTK, LEN_PTK_KCK, pOutBuffer, FrameLen, digest, SHA1_DIGEST_SIZE);
+sta/wpa.c:		RT_HMAC_MD5(pAd->StaCfg.PTK, LEN_PTK_KCK, pOutBuffer, FrameLen, Mic, MD5_DIGEST_SIZE);
+sta/wpa.c:	RTMPToWirelessSta(pAd, &pAd->MacTab.Content[BSSID_WCID],
+sta/wpa.c:	DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid, REASON_MIC_FAILURE);
+sta/wpa.c:	pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+sta/wpa.c:	pAd->StaCfg.bBlockAssoc = TRUE;
+sta/wpa.c:	pEntry = &pAd->MacTab.Content[BSSID_WCID];
+sta/wpa.c:	pSharedKey = &pAd->SharedKey[BSS0][0];
+sta/wpa.c:	NdisMoveMemory(pAd->StaCfg.PTK, pEntry->PTK, LEN_PTK);
+sta/wpa.c:    NdisMoveMemory(pSharedKey->Key, &pAd->StaCfg.PTK[32], LEN_TK);
+sta/wpa.c:	NdisMoveMemory(pSharedKey->RxMic, &pAd->StaCfg.PTK[48], LEN_TKIP_MIC);
+sta/wpa.c:	NdisMoveMemory(pSharedKey->TxMic, &pAd->StaCfg.PTK[48+LEN_TKIP_MIC], LEN_TKIP_MIC);            
+sta/wpa.c:	if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
+sta/wpa.c:	else if (pAd->StaCfg.PairCipher == Ndis802_11Encryption3Enabled)
+sta/wpa.c:	NdisMoveMemory(pEntry->PairwiseKey.Key, &pAd->StaCfg.PTK[32], LEN_TK);
+sta/wpa.c:	NdisMoveMemory(pEntry->PairwiseKey.RxMic, &pAd->StaCfg.PTK[48], LEN_TKIP_MIC);
+sta/wpa.c:	NdisMoveMemory(pEntry->PairwiseKey.TxMic, &pAd->StaCfg.PTK[48+LEN_TKIP_MIC], LEN_TKIP_MIC);            
+sta/wpa.c:	pSharedKey = &pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId];
+sta/wpa.c:	NdisMoveMemory(pSharedKey->Key, pAd->StaCfg.GTK, LEN_TK);
+sta/wpa.c:	NdisMoveMemory(pSharedKey->RxMic, &pAd->StaCfg.GTK[16], LEN_TKIP_MIC);
+sta/wpa.c:	NdisMoveMemory(pSharedKey->TxMic, &pAd->StaCfg.GTK[24], LEN_TKIP_MIC);
+sta/wpa.c:	if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption2Enabled)
+sta/wpa.c:	else if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption3Enabled)
+sta/wpa.c:	else if (pAd->StaCfg.GroupCipher == Ndis802_11GroupWEP40Enabled)
+sta/wpa.c:	else if (pAd->StaCfg.GroupCipher == Ndis802_11GroupWEP104Enabled)
+sta/wpa.c:						  	pAd->StaCfg.DefaultKeyId, 
+sta/wpa.c:	MAKE_802_3_HEADER(Header802_3, pBssid, &pAd->CurrentAddress[0], EAPOL);
+sta/wpa.c:	RTMPToWirelessSta((PRTMP_ADAPTER)pAd, &pAd->MacTab.Content[BSSID_WCID],
+sta/p2pcli_ctrl.c:		pAd->ApCfg.ApCliTab[i].CtrlCurrState = APCLI_CTRL_DISCONNECTED;
+sta/p2pcli_ctrl.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].CtrlCurrState;
+sta/p2pcli_ctrl.c:	PWSC_CTRL	pWpsCtrl = &pAd->ApCfg.ApCliTab[ifIndex].WscControl;
+sta/p2pcli_ctrl.c:	if (pAd->FlgCfg80211Scanning == TRUE)
+sta/p2pcli_ctrl.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli_ctrl.c:        JoinReq.SsidLen = pAd->ApCfg.ApCliTab[ifIndex].WscControl.WscSsid.SsidLength;
+sta/p2pcli_ctrl.c:		NdisMoveMemory(JoinReq.Ssid, pAd->ApCfg.ApCliTab[ifIndex].WscControl.WscSsid.Ssid, JoinReq.SsidLen);
+sta/p2pcli_ctrl.c:			bss_idx = BssSsidTableSearch(&pAd->ScanTab, pAd->P2pCfg.Bssid, (PCHAR)JoinReq.Ssid, JoinReq.SsidLen, pAd->CommonCfg.Channel);
+sta/p2pcli_ctrl.c:				UCHAR channel = pAd->CommonCfg.Channel, RootApChannel = pAd->ScanTab.BssEntry[bss_idx].Channel;
+sta/p2pcli_ctrl.c:				UCHAR RootApCentralChannel = pAd->ScanTab.BssEntry[bss_idx].CentralChannel;
+sta/p2pcli_ctrl.c:				ApHtInfo = pAd->CommonCfg.AddHTInfo.AddHtInfo;
+sta/p2pcli_ctrl.c:				RootApHtInfo = pAd->ScanTab.BssEntry[bss_idx].AddHtInfo.AddHtInfo;
+sta/p2pcli_ctrl.c:				if (INFRA_ON(pAd) && (pAd->StaActive.SupportedHtPhy.ExtChanOffset != RootApHtInfo.ExtChanOffset) && (pAd->StaActive.SupportedHtPhy.ChannelWidth == BW_40))
+sta/p2pcli_ctrl.c:								__FUNCTION__, pAd->MlmeAux.CentralChannel, RootApCentralChannel));
+sta/p2pcli_ctrl.c:					 (pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40) && 
+sta/p2pcli_ctrl.c:					if (pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40)
+sta/p2pcli_ctrl.c:					sprintf(ChStr, "%d", pAd->ScanTab.BssEntry[bss_idx].Channel);
+sta/p2pcli_ctrl.c:					pAd->CommonCfg.Channel = pAd->ScanTab.BssEntry[bss_idx].Channel;
+sta/p2pcli_ctrl.c:					AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+sta/p2pcli_ctrl.c:					AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+sta/p2pcli_ctrl.c:		bss_idx = BssSsidTableSearch(&pAd->ScanTab, JoinReq.Bssid, (PCHAR)pApCliEntry->CfgSsid, pApCliEntry->CfgSsidLen, pAd->CommonCfg.Channel);
+sta/p2pcli_ctrl.c:			bss_idx = BssSsidTableSearch(&pAd->ScanTab, JoinReq.Bssid, 
+sta/p2pcli_ctrl.c:					(PCHAR)pApCliEntry->CfgSsid, pApCliEntry->CfgSsidLen, pAd->CommonCfg.Channel);
+sta/p2pcli_ctrl.c:		DBGPRINT(RT_DEBUG_TRACE, ("%s::  find SSID[%ld][%s] channel[%d-%d] in ScanTab.\n", __FUNCTION__, bss_idx, pApCliEntry->CfgSsid, pAd->ScanTab.BssEntry[bss_idx].Channel, pAd->ScanTab.BssEntry[bss_idx].CentralChannel));
+sta/p2pcli_ctrl.c:		pAd->CommonCfg.Channel = pAd->ScanTab.BssEntry[bss_idx].Channel;
+sta/p2pcli_ctrl.c:		AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+sta/p2pcli_ctrl.c:		AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+sta/p2pcli_ctrl.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].CtrlCurrState;
+sta/p2pcli_ctrl.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli_ctrl.c:    if ((pAd->ApCfg.ApCliTab[ifIndex].WscControl.WscConfMode != WSC_DISABLE) &&
+sta/p2pcli_ctrl.c:		(pAd->ApCfg.ApCliTab[ifIndex].WscControl.bWscTrigger == TRUE))
+sta/p2pcli_ctrl.c:		bss_idx = BssSsidTableSearchBySSID(&pAd->ScanTab, (PCHAR)JoinReq.Ssid, JoinReq.SsidLen);
+sta/p2pcli_ctrl.c:        JoinReq.SsidLen = pAd->ApCfg.ApCliTab[ifIndex].WscControl.WscSsid.SsidLength;
+sta/p2pcli_ctrl.c:		NdisMoveMemory(JoinReq.Ssid, pAd->ApCfg.ApCliTab[ifIndex].WscControl.WscSsid.Ssid, JoinReq.SsidLen);
+sta/p2pcli_ctrl.c:		bss_idx = BssSsidTableSearchBySSID(&pAd->ScanTab, (PCHAR)pApCliEntry->CfgSsid, pApCliEntry->CfgSsidLen);
+sta/p2pcli_ctrl.c:			DBGPRINT(RT_DEBUG_TRACE, ("%s::  find SSID[%ld][%s] channel[%d-%d] in ScanTab.\n", __FUNCTION__, bss_idx, pApCliEntry->CfgSsid, pAd->ScanTab.BssEntry[bss_idx].Channel, pAd->ScanTab.BssEntry[bss_idx].CentralChannel));
+sta/p2pcli_ctrl.c:			pAd->CommonCfg.Channel = pAd->ScanTab.BssEntry[bss_idx].Channel;
+sta/p2pcli_ctrl.c:			AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+sta/p2pcli_ctrl.c:			AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+sta/p2pcli_ctrl.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].CtrlCurrState;
+sta/p2pcli_ctrl.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli_ctrl.c:			pAd->ApCliMlmeAux.Bssid[0],
+sta/p2pcli_ctrl.c:			pAd->ApCliMlmeAux.Bssid[1],
+sta/p2pcli_ctrl.c:			pAd->ApCliMlmeAux.Bssid[2],
+sta/p2pcli_ctrl.c:			pAd->ApCliMlmeAux.Bssid[3],
+sta/p2pcli_ctrl.c:			pAd->ApCliMlmeAux.Bssid[4],
+sta/p2pcli_ctrl.c:			pAd->ApCliMlmeAux.Bssid[5]));
+sta/p2pcli_ctrl.c:		COPY_MAC_ADDR(AuthReq.Addr, pAd->ApCliMlmeAux.Bssid);
+sta/p2pcli_ctrl.c:		if ((pAd->ApCfg.ApCliTab[ifIndex].AuthMode == Ndis802_11AuthModeShared) ||
+sta/p2pcli_ctrl.c:				(pAd->ApCfg.ApCliTab[ifIndex].AuthMode == Ndis802_11AuthModeAutoSwitch))
+sta/p2pcli_ctrl.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].CtrlCurrState;
+sta/p2pcli_ctrl.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli_ctrl.c:		AssocParmFill(pAd, &AssocReq, pAd->ApCliMlmeAux.Bssid, pAd->ApCliMlmeAux.CapabilityInfo,
+sta/p2pcli_ctrl.c:			ASSOC_TIMEOUT, /*pAd->PortCfg.DefaultListenCount*/5);
+sta/p2pcli_ctrl.c:			COPY_MAC_ADDR(AuthReq.Addr, pAd->ApCliMlmeAux.Bssid);
+sta/p2pcli_ctrl.c:			NdisZeroMemory(pAd->ApCliMlmeAux.Bssid, MAC_ADDR_LEN);
+sta/p2pcli_ctrl.c:			NdisZeroMemory(pAd->ApCliMlmeAux.Ssid, MAX_LEN_OF_SSID);
+sta/p2pcli_ctrl.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].CtrlCurrState;
+sta/p2pcli_ctrl.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli_ctrl.c:		AssocParmFill(pAd, &AssocReq, pAd->ApCliMlmeAux.Bssid, pAd->ApCliMlmeAux.CapabilityInfo,
+sta/p2pcli_ctrl.c:			ASSOC_TIMEOUT, /*pAd->PortCfg.DefaultListenCount*/5);
+sta/p2pcli_ctrl.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].CtrlCurrState;
+sta/p2pcli_ctrl.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli_ctrl.c:		NdisZeroMemory(pAd->ApCliMlmeAux.Bssid, MAC_ADDR_LEN);
+sta/p2pcli_ctrl.c:		NdisZeroMemory(pAd->ApCliMlmeAux.Ssid, MAX_LEN_OF_SSID);
+sta/p2pcli_ctrl.c:	COPY_MAC_ADDR(AuthReq.Addr, pAd->ApCliMlmeAux.Bssid);
+sta/p2pcli_ctrl.c:	AuthReq.Alg = pAd->ApCliMlmeAux.Alg; /* Ndis802_11AuthModeOpen; */
+sta/p2pcli_ctrl.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].CtrlCurrState;
+sta/p2pcli_ctrl.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli_ctrl.c:			RT_CFG80211_P2P_CLI_CONN_RESULT_INFORM(pAd, pAd->ApCliMlmeAux.Bssid,
+sta/p2pcli_ctrl.c:				pAd->ApCfg.ApCliTab[MAIN_MBSSID].ReqVarIEs, pAd->ApCfg.ApCliTab[MAIN_MBSSID].ReqVarIELen,	
+sta/p2pcli_ctrl.c:				pAd->ApCfg.ApCliTab[MAIN_MBSSID].ResVarIEs, pAd->ApCfg.ApCliTab[MAIN_MBSSID].ResVarIELen, 1);
+sta/p2pcli_ctrl.c:			RT_CFG80211_P2P_CLI_CONN_RESULT_INFORM(pAd, pAd->ApCliMlmeAux.Bssid,
+sta/p2pcli_ctrl.c:		RT_CFG80211_P2P_CLI_CONN_RESULT_INFORM(pAd, pAd->ApCliMlmeAux.Bssid,
+sta/p2pcli_ctrl.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].CtrlCurrState;
+sta/p2pcli_ctrl.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli_ctrl.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].CtrlCurrState;
+sta/p2pcli_ctrl.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli_ctrl.c:		NdisZeroMemory(pAd->ApCliMlmeAux.Bssid, MAC_ADDR_LEN);
+sta/p2pcli_ctrl.c:		NdisZeroMemory(pAd->ApCliMlmeAux.Ssid, MAX_LEN_OF_SSID);
+sta/p2pcli_ctrl.c:	AssocParmFill(pAd, &AssocReq, pAd->ApCliMlmeAux.Bssid, pAd->ApCliMlmeAux.CapabilityInfo,
+sta/p2pcli_ctrl.c:		ASSOC_TIMEOUT, /*pAd->PortCfg.DefaultListenCount*/5);
+sta/p2pcli_ctrl.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].CtrlCurrState;
+sta/p2pcli_ctrl.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli_ctrl.c:	NdisZeroMemory(pAd->ApCliMlmeAux.Bssid, MAC_ADDR_LEN);
+sta/p2pcli_ctrl.c:	pAd->ApCliMlmeAux.SsidLen = 0;
+sta/p2pcli_ctrl.c:	NdisZeroMemory(pAd->ApCliMlmeAux.Ssid, MAX_LEN_OF_SSID);
+sta/p2pcli_ctrl.c:	pAd->ApCliMlmeAux.Rssi = 0;
+sta/p2pcli_ctrl.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].CtrlCurrState;
+sta/p2pcli_ctrl.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli_ctrl.c:	NdisZeroMemory(pAd->ApCliMlmeAux.Bssid, MAC_ADDR_LEN);
+sta/p2pcli_ctrl.c:	pAd->ApCliMlmeAux.SsidLen = 0;
+sta/p2pcli_ctrl.c:	NdisZeroMemory(pAd->ApCliMlmeAux.Ssid, MAX_LEN_OF_SSID);
+sta/p2pcli_ctrl.c:	pAd->ApCliMlmeAux.Rssi = 0;
+sta/p2pcli_ctrl.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].CtrlCurrState;
+sta/p2pcli_ctrl.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli_ctrl.c:	DisassocParmFill(pAd, &DisassocReq, pAd->ApCliMlmeAux.Bssid, REASON_DISASSOC_STA_LEAVING);
+sta/p2pcli_ctrl.c:	NdisZeroMemory(pAd->ApCliMlmeAux.Bssid, MAC_ADDR_LEN);
+sta/p2pcli_ctrl.c:	pAd->ApCliMlmeAux.SsidLen = 0;
+sta/p2pcli_ctrl.c:	NdisZeroMemory(pAd->ApCliMlmeAux.Ssid, MAX_LEN_OF_SSID);
+sta/p2pcli_ctrl.c:	pAd->ApCliMlmeAux.Rssi = 0;
+sta/p2pcli_ctrl.c:	PULONG pCurrState = &pAd->ApCfg.ApCliTab[ifIndex].CtrlCurrState;
+sta/p2pcli_ctrl.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[ifIndex];
+sta/p2pcli_ctrl.c:	COPY_MAC_ADDR(DeAuthFrame.Addr, pAd->ApCliMlmeAux.Bssid);
+sta/p2pcli_ctrl.c:	NdisZeroMemory(pAd->ApCliMlmeAux.Bssid, MAC_ADDR_LEN);
+sta/p2pcli_ctrl.c:	pAd->ApCliMlmeAux.SsidLen = 0;
+sta/p2pcli_ctrl.c:	NdisZeroMemory(pAd->ApCliMlmeAux.Ssid, MAX_LEN_OF_SSID);
+sta/p2pcli_ctrl.c:	pAd->ApCliMlmeAux.Rssi = 0;
+sta/sta_cfg.c:	pAd->MlmeAux.AutoReconnectSsidLen= 32;
+sta/sta_cfg.c:	NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen);
+sta/sta_cfg.c:			pAd->StaCfg.BssType = BSS_INFRA;	
+sta/sta_cfg.c:			pAd->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
+sta/sta_cfg.c:	        pAd->StaCfg.WepStatus  = Ndis802_11EncryptionDisabled;		    
+sta/sta_cfg.c:        if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("CFG80211_MLME !!! MLME busy, reset MLME state machine !!! ORI ==> %d\n", pAd->Mlme.CntlMachine.CurrState));
+sta/sta_cfg.c:		if ((pAd->StaCfg.WpaPassPhraseLen >= 8) &&
+sta/sta_cfg.c:			(pAd->StaCfg.WpaPassPhraseLen <= 64))
+sta/sta_cfg.c:			RTMPZeroMemory(pAd->StaCfg.PMK, 32);
+sta/sta_cfg.c:			if (pAd->StaCfg.WpaPassPhraseLen == 64)
+sta/sta_cfg.c:			    AtoH((PSTRING) pAd->StaCfg.WpaPassPhrase, pAd->StaCfg.PMK, 32);
+sta/sta_cfg.c:			    RtmpPasswordHash((PSTRING) pAd->StaCfg.WpaPassPhrase, Ssid.Ssid, Ssid.SsidLength, keyMaterial);
+sta/sta_cfg.c:			    NdisMoveMemory(pAd->StaCfg.PMK, keyMaterial, 32);		
+sta/sta_cfg.c:		NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
+sta/sta_cfg.c:		NdisMoveMemory(pAd->MlmeAux.Ssid, Ssid.Ssid, Ssid.SsidLength);
+sta/sta_cfg.c:		pAd->MlmeAux.SsidLen = (UCHAR)Ssid.SsidLength;
+sta/sta_cfg.c:		NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid, Ssid.Ssid, Ssid.SsidLength);
+sta/sta_cfg.c:		pAd->MlmeAux.AutoReconnectSsidLen = (UCHAR)Ssid.SsidLength;
+sta/sta_cfg.c:        pAd->MlmeAux.CurrReqIsFromNdis = TRUE;
+sta/sta_cfg.c:        pAd->StaCfg.bSkipAutoScanConn = FALSE;
+sta/sta_cfg.c:		pAd->bConfigChanged = TRUE;
+sta/sta_cfg.c:        pAd->StaCfg.bNotFirstScan = FALSE;     
+sta/sta_cfg.c:		&& (pAd->NumberOfPipes >= 5)
+sta/sta_cfg.c:		pAd->CommonCfg.bWmmCapable = TRUE;
+sta/sta_cfg.c:		pAd->CommonCfg.bWmmCapable = FALSE;
+sta/sta_cfg.c:		pAd->CommonCfg.bWmmCapable));
+sta/sta_cfg.c:		if (pAd->StaCfg.BssType != BSS_ADHOC)
+sta/sta_cfg.c:			pAd->bConfigChanged = TRUE;
+sta/sta_cfg.c:                pAd->StaCfg.bAutoReconnect = TRUE;
+sta/sta_cfg.c:				pAd->MlmeAux.AutoReconnectSsidLen= 32;
+sta/sta_cfg.c:				NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen);		
+sta/sta_cfg.c:		pAd->StaCfg.BssType = BSS_ADHOC;
+sta/sta_cfg.c:		RTMP_OS_NETDEV_SET_TYPE(pAd->net_dev, pAd->StaCfg.OriDevType);
+sta/sta_cfg.c:		if (pAd->StaCfg.BssType != BSS_INFRA)
+sta/sta_cfg.c:			pAd->bConfigChanged = TRUE;
+sta/sta_cfg.c:                pAd->StaCfg.bAutoReconnect = TRUE;
+sta/sta_cfg.c:				pAd->MlmeAux.AutoReconnectSsidLen= 32;
+sta/sta_cfg.c:				NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen);			
+sta/sta_cfg.c:		pAd->StaCfg.BssType = BSS_INFRA;
+sta/sta_cfg.c:		RTMP_OS_NETDEV_SET_TYPE(pAd->net_dev, pAd->StaCfg.OriDevType);
+sta/sta_cfg.c:			pAd->StaCfg.BssMonitorFlag |= MONITOR_FLAG_11N_SNIFFER;
+sta/sta_cfg.c:		pAd->StaCfg.bAutoReconnect = FALSE;
+sta/sta_cfg.c:		if (pAd->CommonCfg.CentralChannel == 0)
+sta/sta_cfg.c:			if (WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_A | WMODE_AN))
+sta/sta_cfg.c:				pAd->CommonCfg.CentralChannel = 36;
+sta/sta_cfg.c:				pAd->CommonCfg.CentralChannel = 6;
+sta/sta_cfg.c:		if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) &&
+sta/sta_cfg.c:			pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40 &&
+sta/sta_cfg.c:			pAd->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_ABOVE)
+sta/sta_cfg.c:			pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel + 2;
+sta/sta_cfg.c:			rf_channel = pAd->CommonCfg.CentralChannel;
+sta/sta_cfg.c:		else if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) &&
+sta/sta_cfg.c:	                 pAd->CommonCfg.RegTransmitSetting.field.BW == BW_40 &&
+sta/sta_cfg.c:		              pAd->CommonCfg.RegTransmitSetting.field.EXTCHA == EXTCHA_BELOW)
+sta/sta_cfg.c:			pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel - 2;
+sta/sta_cfg.c:			rf_channel = pAd->CommonCfg.CentralChannel;
+sta/sta_cfg.c:			rf_channel = pAd->CommonCfg.Channel;
+sta/sta_cfg.c:					pAd->CommonCfg.Channel,
+sta/sta_cfg.c:					pAd->CommonCfg.CentralChannel));
+sta/sta_cfg.c:		pAd->StaCfg.BssType = BSS_MONITOR;
+sta/sta_cfg.c:		RTMP_OS_NETDEV_SET_TYPE_MONITOR(pAd->net_dev);
+sta/sta_cfg.c:    pAd->StaCfg.WpaState = SS_NOTUSE;
+sta/sta_cfg.c:    DBGPRINT(RT_DEBUG_TRACE, ("Set_NetworkType_Proc::(NetworkType=%d)\n", pAd->StaCfg.BssType));
+sta/sta_cfg.c:        pAd->StaCfg.AuthMode = Ndis802_11AuthModeAutoSwitch;
+sta/sta_cfg.c:        pAd->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
+sta/sta_cfg.c:        pAd->StaCfg.AuthMode = Ndis802_11AuthModeShared;
+sta/sta_cfg.c:        pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPAPSK;
+sta/sta_cfg.c:        pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPANone;
+sta/sta_cfg.c:        pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPA2PSK;    
+sta/sta_cfg.c:        pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPA;    
+sta/sta_cfg.c:        pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPA2;
+sta/sta_cfg.c:        pAd->StaCfg.AuthMode = Ndis802_11AuthModeWAICERT;    
+sta/sta_cfg.c:        pAd->StaCfg.AuthMode = Ndis802_11AuthModeWAIPSK;
+sta/sta_cfg.c:    pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+sta/sta_cfg.c:    DBGPRINT(RT_DEBUG_TRACE, ("Set_AuthMode_Proc::(AuthMode=%d)\n", pAd->StaCfg.AuthMode));
+sta/sta_cfg.c:        if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)
+sta/sta_cfg.c:        pAd->StaCfg.WepStatus     = Ndis802_11WEPDisabled;
+sta/sta_cfg.c:        pAd->StaCfg.PairCipher    = Ndis802_11WEPDisabled;
+sta/sta_cfg.c:	    pAd->StaCfg.GroupCipher   = Ndis802_11WEPDisabled;
+sta/sta_cfg.c:        if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)
+sta/sta_cfg.c:        pAd->StaCfg.WepStatus     = Ndis802_11WEPEnabled;
+sta/sta_cfg.c:        pAd->StaCfg.PairCipher    = Ndis802_11WEPEnabled;
+sta/sta_cfg.c:	    pAd->StaCfg.GroupCipher   = Ndis802_11WEPEnabled;		
+sta/sta_cfg.c:        if (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA)
+sta/sta_cfg.c:        pAd->StaCfg.WepStatus     = Ndis802_11Encryption2Enabled;
+sta/sta_cfg.c:        pAd->StaCfg.PairCipher    = Ndis802_11Encryption2Enabled;
+sta/sta_cfg.c:	    pAd->StaCfg.GroupCipher   = Ndis802_11Encryption2Enabled;
+sta/sta_cfg.c:        if (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA)
+sta/sta_cfg.c:        pAd->StaCfg.WepStatus     = Ndis802_11Encryption3Enabled;
+sta/sta_cfg.c:        pAd->StaCfg.PairCipher    = Ndis802_11Encryption3Enabled;
+sta/sta_cfg.c:	    pAd->StaCfg.GroupCipher   = Ndis802_11Encryption3Enabled;
+sta/sta_cfg.c:        if ((pAd->StaCfg.AuthMode != Ndis802_11AuthModeWAICERT) &&
+sta/sta_cfg.c:			(pAd->StaCfg.AuthMode != Ndis802_11AuthModeWAIPSK))
+sta/sta_cfg.c:        pAd->StaCfg.WepStatus     = Ndis802_11EncryptionSMS4Enabled;
+sta/sta_cfg.c:        pAd->StaCfg.PairCipher    = Ndis802_11EncryptionSMS4Enabled;
+sta/sta_cfg.c:	    pAd->StaCfg.GroupCipher   = Ndis802_11EncryptionSMS4Enabled;
+sta/sta_cfg.c:	if (pAd->StaCfg.BssType == BSS_ADHOC)
+sta/sta_cfg.c:		RTMPSetPhyMode(pAd, pAd->CommonCfg.cfg_wmode);
+sta/sta_cfg.c:    DBGPRINT(RT_DEBUG_TRACE, ("Set_EncrypType_Proc::(EncrypType=%d)\n", pAd->StaCfg.WepStatus));
+sta/sta_cfg.c:    if ((pAd->StaCfg.AuthMode != Ndis802_11AuthModeWPAPSK) && 
+sta/sta_cfg.c:        (pAd->StaCfg.AuthMode != Ndis802_11AuthModeWPA2PSK) &&
+sta/sta_cfg.c:	    (pAd->StaCfg.AuthMode != Ndis802_11AuthModeWPANone)
+sta/sta_cfg.c:		 && (pAd->StaCfg.AuthMode != Ndis802_11AuthModeWAICERT)
+sta/sta_cfg.c:		 && (pAd->StaCfg.AuthMode != Ndis802_11AuthModeWAIPSK)
+sta/sta_cfg.c:	status = RT_CfgSetWPAPSKKey(pAd, arg, strlen(arg), pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen, pAd->StaCfg.PMK);
+sta/sta_cfg.c:	NdisZeroMemory(pAd->StaCfg.WpaPassPhrase, 64);
+sta/sta_cfg.c:    NdisMoveMemory(pAd->StaCfg.WpaPassPhrase, arg, strlen(arg));
+sta/sta_cfg.c:    pAd->StaCfg.WpaPassPhraseLen = (UINT)strlen(arg);
+sta/sta_cfg.c:    NdisZeroMemory(pAd->StaCfg.WscControl.WpaPsk, 64);
+sta/sta_cfg.c:    pAd->StaCfg.WscControl.WpaPskLen = 0;    
+sta/sta_cfg.c:    NdisMoveMemory(pAd->StaCfg.WscControl.WpaPsk, arg, strlen(arg));
+sta/sta_cfg.c:    pAd->StaCfg.WscControl.WpaPskLen = (INT)strlen(arg);
+sta/sta_cfg.c:	NdisZeroMemory(pAd->StaCfg.WAPIPassPhrase, 64);
+sta/sta_cfg.c:    pAd->StaCfg.WAPIPassPhraseLen = 0;    
+sta/sta_cfg.c:    NdisMoveMemory(pAd->StaCfg.WAPIPassPhrase, arg, strlen(arg));
+sta/sta_cfg.c:    pAd->StaCfg.WAPIPassPhraseLen = (UINT)strlen(arg);
+sta/sta_cfg.c:    if(pAd->StaCfg.BssType == BSS_ADHOC &&
+sta/sta_cfg.c:       pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
+sta/sta_cfg.c:        pAd->StaCfg.WpaState = SS_NOTUSE;     
+sta/sta_cfg.c:        pAd->StaCfg.WpaState = SS_START;
+sta/sta_cfg.c:        pAd->StaCfg.WpaSupplicantUP = WPA_SUPPLICANT_DISABLE;
+sta/sta_cfg.c:        pAd->StaCfg.WpaSupplicantUP = WPA_SUPPLICANT_ENABLE;
+sta/sta_cfg.c:        pAd->StaCfg.WpaSupplicantUP = WPA_SUPPLICANT_ENABLE_WITH_WEB_UI;
+sta/sta_cfg.c:        pAd->StaCfg.WpaSupplicantUP = WPA_SUPPLICANT_DISABLE;
+sta/sta_cfg.c:    DBGPRINT(RT_DEBUG_TRACE, ("Set_Wpa_Support::(WpaSupplicantUP=%d)\n", pAd->StaCfg.WpaSupplicantUP));
+sta/sta_cfg.c:	pWscControl = &pAd->StaCfg.WscControl;
+sta/sta_cfg.c:	if (pAd->StaCfg.BssType == BSS_ADHOC)
+sta/sta_cfg.c:		PIWSC_INFO pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/sta_cfg.c:        pAd->StaCfg.WscControl.WscConfStatus = IsAPConfigured;
+sta/sta_cfg.c:        DBGPRINT(RT_DEBUG_TRACE, ("Set_WscConfStatus_Proc:: WscConfStatus is not changed (%d) \n", pAd->StaCfg.WscControl.WscConfStatus));
+sta/sta_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_WscConfStatus_Proc::(WscConfStatus=%d)\n", pAd->StaCfg.WscControl.WscConfStatus));
+sta/sta_cfg.c:	pWscControl = &pAd->StaCfg.WscControl;
+sta/sta_cfg.c:		//add SSID into pAd->MlmeAux.Ssid
+sta/sta_cfg.c:        NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
+sta/sta_cfg.c:        NdisMoveMemory(pAd->MlmeAux.Ssid, arg, strlen(arg));
+sta/sta_cfg.c:        pAd->MlmeAux.SsidLen = strlen(arg);
+sta/sta_cfg.c:			NdisMoveMemory(pWscControl->WscBssid, pAd->ScanTab.BssEntry[ApIdx].Bssid,MAC_ADDR_LEN);
+sta/sta_cfg.c:			pAd->MlmeAux.Channel = pAd->ScanTab.BssEntry[ApIdx].Channel;
+sta/sta_cfg.c:	RTMPZeroMemory(pAd->StaCfg.WscControl.WscBssid, MAC_ADDR_LEN);
+sta/sta_cfg.c:	RTMPMoveMemory(pAd->StaCfg.WscControl.WscBssid, MacAddr, MAC_ADDR_LEN);
+sta/sta_cfg.c:	pWscControl = &pAd->StaCfg.WscControl;
+sta/sta_cfg.c:		(pAd->StaCfg.BssType == BSS_INFRA))
+sta/sta_cfg.c:	pWscControl = &pAd->StaCfg.WscControl;
+sta/sta_cfg.c:			if ((pAd->StaCfg.BssType == BSS_ADHOC) &&
+sta/sta_cfg.c:    	pWscControl = &pAd->StaCfg.WscControl;
+sta/sta_cfg.c:	if (pAd->StaCfg.BssType == BSS_ADHOC)
+sta/sta_cfg.c:		if (pAd->StaCfg.WscControl.bWscTrigger)
+sta/sta_cfg.c:			(pAd->StaCfg.IWscInfo.IpMethod == IWSC_IPV4_ASSIGNMENT) &&
+sta/sta_cfg.c:			(pAd->StaCfg.IWscInfo.RegDepth != 0) &&
+sta/sta_cfg.c:			(pAd->StaCfg.IWscInfo.AvaSubMaskListCount == 0))
+sta/sta_cfg.c:			pAd->StaCfg.WscControl.WscStatus = STATUS_WSC_EMPTY_IPV4_SUBMASK_LIST;
+sta/sta_cfg.c:    pWscControl = &pAd->StaCfg.WscControl;
+sta/sta_cfg.c:	pAd->StaCfg.WscControl.WscState = WSC_STATE_INIT;
+sta/sta_cfg.c:		if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+sta/sta_cfg.c:		pAd->MlmeAux.CurrReqIsFromNdis = TRUE;
+sta/sta_cfg.c:		DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
+sta/sta_cfg.c:		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+sta/sta_cfg.c:		pAd->MlmeAux.AutoReconnectSsidLen= 32;
+sta/sta_cfg.c:		NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen);
+sta/sta_cfg.c:		pAd->MlmeAux.AutoReconnectSsidLen= 32;
+sta/sta_cfg.c:		NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen);			
+sta/sta_cfg.c:		if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+sta/sta_cfg.c:		pAd->StaCfg.bSkipAutoScanConn = TRUE;
+sta/sta_cfg.c:		pAd->MlmeAux.AutoReconnectSsidLen= 0;
+sta/sta_cfg.c:		pAd->bConfigChanged = TRUE;
+sta/sta_cfg.c:					pAd->StaCfg.WscControl.WscBssid, 0);
+sta/sta_cfg.c:		/*WscSendUPnPConfReqMsg(pAd, apidx, pAd->ApCfg.MBSSID[apidx].Ssid, pAd->ApCfg.MBSSID[apidx].Bssid, 3, 0); */
+sta/sta_cfg.c:		if ((pAd->StaCfg.BssType == BSS_INFRA) ||
+sta/sta_cfg.c:	pAd->LedCntl.MCULedCntl.word &= 0x80;
+sta/sta_cfg.c:	pAd->LedCntl.MCULedCntl.word |= WPS_LED_MODE_SHARE;
+sta/sta_cfg.c:	PWSC_V2_INFO pWscV2Info = &pAd->StaCfg.WscControl.WscV2Info;
+sta/sta_cfg.c:	pWscControl = &pAd->StaCfg.WscControl;
+sta/sta_cfg.c:		pAd->StaCfg.IWscInfo.bLimitedUI = FALSE;
+sta/sta_cfg.c:		pAd->StaCfg.IWscInfo.bLimitedUI = TRUE;    
+sta/sta_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_IWscLimitedUI_Proc::(bLimitedUI=%d)\n",  pAd->StaCfg.IWscInfo.bLimitedUI));
+sta/sta_cfg.c:	pWscControl = &pAd->StaCfg.WscControl;
+sta/sta_cfg.c:		pAd->StaCfg.IWscInfo.IWscDefaultSecurity = TmpValue;
+sta/sta_cfg.c:		DBGPRINT(RT_DEBUG_TRACE, ("%s::(IWscDefaultSecurity=%d)\n", __FUNCTION__, pAd->StaCfg.IWscInfo.IWscDefaultSecurity));
+sta/sta_cfg.c:	pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/sta_cfg.c:	pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/sta_cfg.c:	pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/sta_cfg.c:			MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[i];
+sta/sta_cfg.c:        if (pAd->MacTab.Size == 0)
+sta/sta_cfg.c:			pAd->IndicateMediaState = NdisMediaStateDisconnected;
+sta/sta_cfg.c:	if (pAd->StaCfg.BssType != BSS_ADHOC)
+sta/sta_cfg.c:			pAd->MlmeAux.AutoReconnectSsidLen= 32;
+sta/sta_cfg.c:			NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen);		
+sta/sta_cfg.c:		pAd->StaCfg.BssType = BSS_ADHOC;
+sta/sta_cfg.c:	pWscControl = &pAd->StaCfg.WscControl;
+sta/sta_cfg.c:	NdisZeroMemory(pAd->StaCfg.WpaPassPhrase, 64);
+sta/sta_cfg.c:	NdisMoveMemory(pAd->StaCfg.WpaPassPhrase, pWscControl->WpaPsk, pWscControl->WpaPskLen);
+sta/sta_cfg.c:	pAd->StaCfg.WpaPassPhraseLen = pWscControl->WpaPskLen;
+sta/sta_cfg.c:	pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPA2PSK;
+sta/sta_cfg.c:	pAd->StaCfg.WepStatus = Ndis802_11Encryption3Enabled;
+sta/sta_cfg.c:	if ((pAd->StaCfg.WpaPassPhraseLen >= 8) &&
+sta/sta_cfg.c:		(pAd->StaCfg.WpaPassPhraseLen <= 64))
+sta/sta_cfg.c:		RTMPZeroMemory(pAd->StaCfg.PMK, 32);
+sta/sta_cfg.c:		if (pAd->StaCfg.WpaPassPhraseLen == 64)
+sta/sta_cfg.c:		    AtoH((PSTRING) pAd->StaCfg.WpaPassPhrase, pAd->StaCfg.PMK, 32);
+sta/sta_cfg.c:		    RtmpPasswordHash((PSTRING) pAd->StaCfg.WpaPassPhrase, Ssid.Ssid, Ssid.SsidLength, keyMaterial);
+sta/sta_cfg.c:		    NdisMoveMemory(pAd->StaCfg.PMK, keyMaterial, 32);		
+sta/sta_cfg.c:	pAd->MlmeAux.CurrReqIsFromNdis = TRUE;
+sta/sta_cfg.c:	pAd->bConfigChanged = TRUE;
+sta/sta_cfg.c:	pAd->StaCfg.IWscInfo.bDoNotChangeBSSID = FALSE;
+sta/sta_cfg.c:	pWscControl = &pAd->StaCfg.WscControl;
+sta/sta_cfg.c:		pAd->StaCfg.IWscInfo.bSinglePIN = FALSE;
+sta/sta_cfg.c:		pAd->StaCfg.IWscInfo.bSinglePIN = TRUE;    
+sta/sta_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("Set_IWscSinglePIN_Proc::(bSinglePIN=%d)\n",  pAd->StaCfg.IWscInfo.bSinglePIN));
+sta/sta_cfg.c:        pAd->StaCfg.bTGnWifiTest = FALSE;
+sta/sta_cfg.c:        pAd->StaCfg.bTGnWifiTest = TRUE;
+sta/sta_cfg.c:    DBGPRINT(RT_DEBUG_TRACE, ("IF Set_TGnWifiTest_Proc::(bTGnWifiTest=%d)\n", pAd->StaCfg.bTGnWifiTest));
+sta/sta_cfg.c:        pAd->CommonCfg.CarrierDetect.Enable = FALSE;
+sta/sta_cfg.c:        pAd->CommonCfg.CarrierDetect.Enable = TRUE;
+sta/sta_cfg.c:    DBGPRINT(RT_DEBUG_TRACE, ("IF Set_StaCarrierDetect_Proc::(CarrierDetect.Enable=%d)\n", pAd->CommonCfg.CarrierDetect.Enable));
+sta/sta_cfg.c:	sprintf(extra, "%sHT Operating Mode : %d\n", extra, pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode);
+sta/sta_cfg.c:		PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[i];
+sta/sta_cfg.c:		pAd->StaCfg.BeaconLostTime = (ltmp * OS_HZ);
+sta/sta_cfg.c:    DBGPRINT(RT_DEBUG_TRACE, ("IF Set_BeaconLostTime_Proc::(BeaconLostTime=%ld)\n", pAd->StaCfg.BeaconLostTime));
+sta/sta_cfg.c:        pAd->StaCfg.bAutoRoaming = FALSE;
+sta/sta_cfg.c:        pAd->StaCfg.bAutoRoaming = TRUE;
+sta/sta_cfg.c:    DBGPRINT(RT_DEBUG_TRACE, ("IF Set_AutoRoaming_Proc::(bAutoRoaming=%d)\n", pAd->StaCfg.bAutoRoaming));
+sta/sta_cfg.c:        pAd->StaCfg.bForceTxBurst = FALSE;
+sta/sta_cfg.c:        pAd->StaCfg.bForceTxBurst = TRUE;
+sta/sta_cfg.c:    DBGPRINT(RT_DEBUG_TRACE, ("IF Set_ForceTxBurst_Proc::(bForceTxBurst=%d)\n", pAd->StaCfg.bForceTxBurst));
+sta/sta_cfg.c:        pAd->StaCfg.PSPXlink = 0;
+sta/sta_cfg.c:        pAd->StaCfg.PSPXlink = 1;
+sta/sta_cfg.c:	if (pAd->StaCfg.PSPXlink)
+sta/sta_cfg.c:    DBGPRINT(RT_DEBUG_TRACE, ("IF Set_XlinkMode_Proc::(PSPXlink=%d)\n", pAd->StaCfg.PSPXlink));
+sta/sta_cfg.c:	if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)
+sta/sta_cfg.c:		    if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
+sta/sta_cfg.c:                NdisZeroMemory(pAd->StaCfg.PMK, 32);
+sta/sta_cfg.c:                NdisMoveMemory(pAd->StaCfg.PMK, pKey->KeyMaterial, pKey->KeyLength);
+sta/sta_cfg.c:		    NdisZeroMemory(&pAd->SharedKey[BSS0][0], sizeof(CIPHER_KEY));  
+sta/sta_cfg.c:            pAd->SharedKey[BSS0][0].KeyLen = LEN_TK;
+sta/sta_cfg.c:            NdisMoveMemory(pAd->SharedKey[BSS0][0].Key, pKey->KeyMaterial, LEN_TK);
+sta/sta_cfg.c:            if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
+sta/sta_cfg.c:                NdisMoveMemory(pAd->SharedKey[BSS0][0].RxMic, pKey->KeyMaterial + LEN_TK, LEN_TKIP_MIC);            
+sta/sta_cfg.c:                NdisMoveMemory(pAd->SharedKey[BSS0][0].TxMic, pKey->KeyMaterial + LEN_TK + LEN_TKIP_MIC, LEN_TKIP_MIC);
+sta/sta_cfg.c:            	NdisMoveMemory(pAd->SharedKey[BSS0][0].TxMic, pKey->KeyMaterial + LEN_TK, LEN_TKIP_MIC);            
+sta/sta_cfg.c:                NdisMoveMemory(pAd->SharedKey[BSS0][0].RxMic, pKey->KeyMaterial + LEN_TK + LEN_TKIP_MIC, LEN_TKIP_MIC);
+sta/sta_cfg.c:        	if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
+sta/sta_cfg.c:        		pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_TKIP;
+sta/sta_cfg.c:        	else if (pAd->StaCfg.PairCipher == Ndis802_11Encryption3Enabled)
+sta/sta_cfg.c:        		pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_AES;
+sta/sta_cfg.c:        		pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_NONE; 
+sta/sta_cfg.c:        	pEntry = &pAd->MacTab.Content[BSSID_WCID];
+sta/sta_cfg.c:            NdisMoveMemory(pEntry->PairwiseKey.Key, pAd->SharedKey[BSS0][0].Key, LEN_TK);            
+sta/sta_cfg.c:        	NdisMoveMemory(pEntry->PairwiseKey.RxMic, pAd->SharedKey[BSS0][0].RxMic, LEN_TKIP_MIC);
+sta/sta_cfg.c:        	NdisMoveMemory(pEntry->PairwiseKey.TxMic, pAd->SharedKey[BSS0][0].TxMic, LEN_TKIP_MIC);
+sta/sta_cfg.c:        	pEntry->PairwiseKey.CipherAlg = pAd->SharedKey[BSS0][0].CipherAlg;
+sta/sta_cfg.c:        						  &pAd->SharedKey[BSS0][0]);
+sta/sta_cfg.c:        							  pAd->SharedKey[BSS0][0].CipherAlg, 
+sta/sta_cfg.c:            if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA2)
+sta/sta_cfg.c:            pAd->StaCfg.DefaultKeyId = (pKey->KeyIndex & 0xFF);
+sta/sta_cfg.c:            NdisZeroMemory(&pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId], sizeof(CIPHER_KEY));  
+sta/sta_cfg.c:            pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].KeyLen = LEN_TK;
+sta/sta_cfg.c:            NdisMoveMemory(pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].Key, pKey->KeyMaterial, LEN_TK);
+sta/sta_cfg.c:            if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption2Enabled)
+sta/sta_cfg.c:                NdisMoveMemory(pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].RxMic, pKey->KeyMaterial + LEN_TK, LEN_TKIP_MIC);            
+sta/sta_cfg.c:                NdisMoveMemory(pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].TxMic, pKey->KeyMaterial + LEN_TK + LEN_TKIP_MIC, LEN_TKIP_MIC);        	
+sta/sta_cfg.c:            	NdisMoveMemory(pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].TxMic, pKey->KeyMaterial + LEN_TK, LEN_TKIP_MIC);            
+sta/sta_cfg.c:                NdisMoveMemory(pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].RxMic, pKey->KeyMaterial + LEN_TK + LEN_TKIP_MIC, LEN_TKIP_MIC);        	
+sta/sta_cfg.c:    		pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].CipherAlg = CIPHER_NONE;
+sta/sta_cfg.c:    		if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption2Enabled)
+sta/sta_cfg.c:    			pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].CipherAlg = CIPHER_TKIP;
+sta/sta_cfg.c:    		else if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption3Enabled)
+sta/sta_cfg.c:    			pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].CipherAlg = CIPHER_AES;
+sta/sta_cfg.c:        						  pAd->StaCfg.DefaultKeyId, 
+sta/sta_cfg.c:        						  &pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId]);
+sta/sta_cfg.c:				pAd->StaCfg.DefaultKeyId = (UCHAR) KeyIdx;
+sta/sta_cfg.c:				pAd->SharedKey[BSS0][KeyIdx].KeyLen = (UCHAR) pKey->KeyLength;
+sta/sta_cfg.c:				NdisMoveMemory(pAd->SharedKey[BSS0][KeyIdx].Key, &pKey->KeyMaterial, pKey->KeyLength);
+sta/sta_cfg.c:					pAd->SharedKey[BSS0][KeyIdx].CipherAlg = CIPHER_WEP64;
+sta/sta_cfg.c:					pAd->SharedKey[BSS0][KeyIdx].CipherAlg = CIPHER_WEP128;
+sta/sta_cfg.c:    			CipherAlg = pAd->SharedKey[BSS0][KeyIdx].CipherAlg;
+sta/sta_cfg.c:    			Key = pAd->SharedKey[BSS0][KeyIdx].Key;
+sta/sta_cfg.c:    			AsicAddSharedKeyEntry(pAd, BSS0, KeyIdx, &pAd->SharedKey[BSS0][KeyIdx]);
+sta/sta_cfg.c:		pAd->StaCfg.bImprovedScan = TRUE;
+sta/sta_cfg.c:		pAd->StaCfg.ScanChannelCnt = 0;	/* reset channel counter to 0 */
+sta/sta_cfg.c:		pAd->StaCfg.bImprovedScan = FALSE;
+sta/sta_cfg.c:	if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+sta/sta_cfg.c:	NdisGetSystemUpTime(&pAd->StaCfg.LastScanTime);
+sta/sta_cfg.c:	pAd->P2pCfg.bPeriodicListen = FALSE;
+sta/sta_cfg.c:        pAd->StaCfg.bAutoReconnect = FALSE;
+sta/sta_cfg.c:		pAd->StaCfg.bAutoReconnect = TRUE;
+sta/sta_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("IF Set_AutoReconnect_Proc::(bAutoReconnect=%d)\n", pAd->StaCfg.bAutoReconnect));
+sta/sta_cfg.c:        pAd->StaCfg.bAdhocN = FALSE;
+sta/sta_cfg.c:		pAd->StaCfg.bAdhocN = TRUE;
+sta/sta_cfg.c:	DBGPRINT(RT_DEBUG_TRACE, ("IF Set_AdhocN_Proc::(bAdhocN=%d)\n", pAd->StaCfg.bAdhocN));
+sta/sta_cfg.c:	UINT8 Pin = pAd->WOW_Cfg.nSelectedGPIO;	
+sta/sta_cfg.c:	pAd->WOW_Cfg.bEnable = (BOOLEAN)Value;
+sta/sta_cfg.c:	DBGPRINT(RT_DEBUG_ERROR, ("WOW_Enable = %d, GPIO = %x\n", pAd->WOW_Cfg.bEnable, Val));
+sta/sta_cfg.c:	pAd->WOW_Cfg.nSelectedGPIO = (UINT8)Value;
+sta/sta_cfg.c:	DBGPRINT(RT_DEBUG_ERROR, ("WOW_GPIO = %d\n", pAd->WOW_Cfg.nSelectedGPIO));
+sta/sta_cfg.c:	pAd->WOW_Cfg.nDelay = (UINT8)Value;
+sta/sta_cfg.c:	DBGPRINT(RT_DEBUG_ERROR, ("WOW_Delay = %d, equal to %d sec\n", pAd->WOW_Cfg.nDelay, (pAd->WOW_Cfg.nDelay+1)*3));
+sta/sta_cfg.c:	pAd->WOW_Cfg.nHoldTime = (UINT8)Value;
+sta/sta_cfg.c:	DBGPRINT(RT_DEBUG_ERROR, ("WOW_Hold = %d, equal to %d ms\n", pAd->WOW_Cfg.nHoldTime, (pAd->WOW_Cfg.nHoldTime)*10));
+sta/sta_cfg.c:	POS_COOKIE	pObj = (POS_COOKIE) pAd->OS_Cookie;
+sta/sta_cfg.c:            else if (!(pAd->CommonCfg.CountryRegion & 0x80) && !(pAd->CommonCfg.CountryRegionForABand & 0x80))
+sta/sta_cfg.c:				pAd->CommonCfg.CountryRegion = (UCHAR)(Country & 0x000000FF);
+sta/sta_cfg.c:				pAd->CommonCfg.CountryRegionForABand = (UCHAR)((Country >> 8) & 0x000000FF);
+sta/sta_cfg.c:				RTMPSetPhyMode(pAd, pAd->CommonCfg.PhyMode);
+sta/sta_cfg.c:				DBGPRINT(RT_DEBUG_TRACE, ("Set::RT_OID_802_11_COUNTRY_REGION (A:%d  B/G:%d)\n", pAd->CommonCfg.CountryRegionForABand,
+sta/sta_cfg.c:				    pAd->CommonCfg.CountryRegion));
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Set::OID_802_11_BSSID_LIST_SCAN, TxCnt = %d \n", pAd->RalinkCounters.LastOneSecTotalTxCount));
+sta/sta_cfg.c:			if (pAd->RalinkCounters.LastOneSecTotalTxCount > 100)
+sta/sta_cfg.c:				((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) || 
+sta/sta_cfg.c:				(pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+sta/sta_cfg.c:				(pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
+sta/sta_cfg.c:				(pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)) &&
+sta/sta_cfg.c:                (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED))
+sta/sta_cfg.c:			if ((pAd->StaCfg.WscControl.WscConfMode != WSC_DISABLE) &&
+sta/sta_cfg.c:				(pAd->StaCfg.WscControl.WscState >= WSC_STATE_LINK_UP))
+sta/sta_cfg.c:	 					NdisZeroMemory(pAd->StaCfg.WpaPassPhrase, 64);
+sta/sta_cfg.c:	    				NdisMoveMemory(pAd->StaCfg.WpaPassPhrase, &ppassphrase->KeyMaterial, ppassphrase->KeyLength);
+sta/sta_cfg.c:	   					pAd->StaCfg.WpaPassPhraseLen = ppassphrase->KeyLength;
+sta/sta_cfg.c:						hex_dump("pAd->StaCfg.WpaPassPhrase", pAd->StaCfg.WpaPassPhrase, 64);
+sta/sta_cfg.c:						printk("WpaPassPhrase=%s\n",pAd->StaCfg.WpaPassPhrase);
+sta/sta_cfg.c:                pAd->MlmeAux.CurrReqIsFromNdis = FALSE; 
+sta/sta_cfg.c:				pAd->MlmeAux.AutoReconnectSsidLen= 32;
+sta/sta_cfg.c:                if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+sta/sta_cfg.c:                if (pAd->StaCfg.bSwRadio != RadioState)
+sta/sta_cfg.c:                    pAd->StaCfg.bSwRadio = RadioState;
+sta/sta_cfg.c:                    if (pAd->StaCfg.bRadio != (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio))
+sta/sta_cfg.c:                        pAd->StaCfg.bRadio = (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio);
+sta/sta_cfg.c:                        if (pAd->StaCfg.bRadio == TRUE)
+sta/sta_cfg.c:							pAd->ExtraInfo = EXTRA_INFO_CLEAR;
+sta/sta_cfg.c:				                if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+sta/sta_cfg.c:							pAd->ExtraInfo = SW_RADIO_OFF;
+sta/sta_cfg.c:				pAd->CommonCfg.cfg_wmode = PhyMode;
+sta/sta_cfg.c:                pAd->CommonCfg.bEnableTxBurst = StaConfig.EnableTxBurst;
+sta/sta_cfg.c:                pAd->CommonCfg.UseBGProtection = StaConfig.UseBGProtection;
+sta/sta_cfg.c:                pAd->CommonCfg.bUseShortSlotTime = 1; /* 2003-10-30 always SHORT SLOT capable */
+sta/sta_cfg.c:                if ((pAd->CommonCfg.PhyMode != StaConfig.AdhocMode) &&
+sta/sta_cfg.c:                    if (pAd->StaCfg.BssType == BSS_ADHOC)
+sta/sta_cfg.c:                                        pAd->CommonCfg.bEnableTxBurst,
+sta/sta_cfg.c:                                        pAd->CommonCfg.UseBGProtection,
+sta/sta_cfg.c:                                        pAd->CommonCfg.bUseShortSlotTime));
+sta/sta_cfg.c:				if (pAd->StaCfg.PSPXlink)
+sta/sta_cfg.c:                NdisZeroMemory(pAd->CommonCfg.DesireRate, MAX_LEN_OF_SUPPORTED_RATES);
+sta/sta_cfg.c:                NdisMoveMemory(pAd->CommonCfg.DesireRate, &aryRates, sizeof(NDIS_802_11_RATES));
+sta/sta_cfg.c:                    pAd->CommonCfg.DesireRate[0],pAd->CommonCfg.DesireRate[1],
+sta/sta_cfg.c:                    pAd->CommonCfg.DesireRate[2],pAd->CommonCfg.DesireRate[3],
+sta/sta_cfg.c:                    pAd->CommonCfg.DesireRate[4],pAd->CommonCfg.DesireRate[5],
+sta/sta_cfg.c:                    pAd->CommonCfg.DesireRate[6],pAd->CommonCfg.DesireRate[7] ));
+sta/sta_cfg.c:                    pAd->CommonCfg.TxPreamble = Preamble;
+sta/sta_cfg.c:                    pAd->CommonCfg.TxPreamble = Preamble;
+sta/sta_cfg.c:                    if (pAd->StaCfg.WepStatus != WepStatus)
+sta/sta_cfg.c:                        pAd->bConfigChanged = TRUE;
+sta/sta_cfg.c:                    pAd->StaCfg.WepStatus     = WepStatus;
+sta/sta_cfg.c:                    pAd->StaCfg.PairCipher    = WepStatus;
+sta/sta_cfg.c:                	pAd->StaCfg.GroupCipher   = WepStatus;
+sta/sta_cfg.c:			if (pAd->StaCfg.BssType == BSS_ADHOC)
+sta/sta_cfg.c:				RTMPSetPhyMode(pAd, pAd->CommonCfg.cfg_wmode);
+sta/sta_cfg.c:                    if (pAd->StaCfg.AuthMode != AuthMode)
+sta/sta_cfg.c:                        pAd->bConfigChanged = TRUE;
+sta/sta_cfg.c:                    pAd->StaCfg.AuthMode = AuthMode;
+sta/sta_cfg.c:                pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+sta/sta_cfg.c:                DBGPRINT(RT_DEBUG_TRACE, ("Set::OID_802_11_AUTHENTICATION_MODE (=%d) \n",pAd->StaCfg.AuthMode));
+sta/sta_cfg.c:						pAd->SharedKey[BSS0][KeyIdx].KeyLen = 0;
+sta/sta_cfg.c:						pAd->SharedKey[BSS0][KeyIdx].CipherAlg = CIPHER_NONE;
+sta/sta_cfg.c:            NdisZeroMemory(&pAd->WlanCounters, sizeof(COUNTER_802_11));
+sta/sta_cfg.c:            NdisZeroMemory(&pAd->Counters8023, sizeof(COUNTER_802_3));
+sta/sta_cfg.c:            NdisZeroMemory(&pAd->RalinkCounters, sizeof(COUNTER_RALINK));
+sta/sta_cfg.c:            pAd->Counters8023.RxNoBuffer   = 0;
+sta/sta_cfg.c:			pAd->Counters8023.GoodReceives = 0;
+sta/sta_cfg.c:			pAd->Counters8023.RxNoBuffer   = 0;
+sta/sta_cfg.c:			pAd->BulkOutComplete	= 0;
+sta/sta_cfg.c:			pAd->BulkOutCompleteOther= 0;
+sta/sta_cfg.c:			pAd->BulkOutCompleteCancel = 0;
+sta/sta_cfg.c:			pAd->BulkOutReq = 0;
+sta/sta_cfg.c:			pAd->BulkInReq= 0;
+sta/sta_cfg.c:			pAd->BulkInComplete = 0;
+sta/sta_cfg.c:			pAd->BulkInCompleteFail = 0;
+sta/sta_cfg.c:			if (pAd->chipCap.FlgHwTxBfCap)
+sta/sta_cfg.c:					NdisZeroMemory(&pAd->MacTab.Content[i].TxBFCounters, sizeof(pAd->MacTab.Content[i].TxBFCounters));		
+sta/sta_cfg.c:                    pAd->CommonCfg.RtsThreshold = (USHORT)RtsThresh;
+sta/sta_cfg.c:                pAd->CommonCfg.bUseZeroToDisableFragment = FALSE;
+sta/sta_cfg.c:                        pAd->CommonCfg.FragmentThreshold = MAX_FRAG_THRESHOLD;
+sta/sta_cfg.c:                        pAd->CommonCfg.bUseZeroToDisableFragment = TRUE;
+sta/sta_cfg.c:                    pAd->CommonCfg.FragmentThreshold = (USHORT)FragThresh;
+sta/sta_cfg.c:				pAd->CommonCfg.TxPowerDefault = PowerTemp; /*keep current setting. */
+sta/sta_cfg.c:				pAd->CommonCfg.TxPowerPercentage = pAd->CommonCfg.TxPowerDefault;			
+sta/sta_cfg.c:                DBGPRINT(RT_DEBUG_TRACE, ("Set::RT_OID_802_11_TX_POWER_LEVEL_1 (=%ld)\n", pAd->CommonCfg.TxPowerPercentage));
+sta/sta_cfg.c:                if ((pAd->StaCfg.AuthMode != Ndis802_11AuthModeWPAPSK) &&
+sta/sta_cfg.c:				    (pAd->StaCfg.AuthMode != Ndis802_11AuthModeWPA2PSK) &&
+sta/sta_cfg.c:				    (pAd->StaCfg.AuthMode != Ndis802_11AuthModeWPANone) )
+sta/sta_cfg.c:                else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+sta/sta_cfg.c:						 (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK) ||
+sta/sta_cfg.c:						 (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone) )     /* Only for WPA PSK mode */
+sta/sta_cfg.c:                    NdisMoveMemory(pAd->StaCfg.PMK, &pKey->KeyMaterial, pKey->KeyLength);
+sta/sta_cfg.c:                    if (pAd->StaCfg.AuthMode != Ndis802_11AuthModeWPANone)
+sta/sta_cfg.c:                        pAd->StaCfg.WpaState = SS_START;
+sta/sta_cfg.c:                    pAd->StaCfg.WpaState = SS_NOTUSE;
+sta/sta_cfg.c:                if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)
+sta/sta_cfg.c:                            pAd->SharedKey[BSS0][KeyIdx].KeyLen = 0;
+sta/sta_cfg.c:                            pAd->SharedKey[BSS0][KeyIdx].CipherAlg = CIPHER_NONE;
+sta/sta_cfg.c:	                     pAd->CommonCfg.BeaconPeriod = (USHORT) pConfig->BeaconPeriod;
+sta/sta_cfg.c:	                pAd->StaActive.AtimWin = (USHORT) pConfig->ATIMWindow;
+sta/sta_cfg.c:	                MAP_KHZ_TO_CHANNEL_ID(pConfig->DSConfig, pAd->CommonCfg.Channel);
+sta/sta_cfg.c:					pAd->MlmeAux.Channel = pAd->CommonCfg.Channel;
+sta/sta_cfg.c:	                    pConfig->BeaconPeriod, pConfig->ATIMWindow, pAd->CommonCfg.Channel));
+sta/sta_cfg.c:	                pAd->bConfigChanged = TRUE;
+sta/sta_cfg.c:				if (WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+sta/sta_cfg.c:				pAd->StaCfg.HTPhyMode.field.MCS, pAd->StaCfg.HTPhyMode.field.BW, pAd->StaCfg.HTPhyMode.field.ShortGI,
+sta/sta_cfg.c:				pAd->StaCfg.HTPhyMode.field.STBC));
+sta/sta_cfg.c:				pAd->StaCfg.UapsdInfo.bAPSDCapable = (apsd & 0x00000001) ? TRUE :	FALSE;
+sta/sta_cfg.c:				pAd->CommonCfg.bAPSDAC_BE = ((apsd	& 0x00000002) >> 1)	? TRUE : FALSE;
+sta/sta_cfg.c:				pAd->CommonCfg.bAPSDAC_BK = ((apsd	& 0x00000004) >> 2)	? TRUE : FALSE;
+sta/sta_cfg.c:				pAd->CommonCfg.bAPSDAC_VI = ((apsd	& 0x00000008) >> 3)	? TRUE : FALSE;
+sta/sta_cfg.c:				pAd->CommonCfg.bAPSDAC_VO = ((apsd	& 0x00000010) >> 4)	? TRUE : FALSE;
+sta/sta_cfg.c:				pAd->CommonCfg.MaxSPLength	= (UCHAR)((apsd	& 0x00000060) >> 5);
+sta/sta_cfg.c:				DBGPRINT(RT_DEBUG_TRACE, ("Set::RT_OID_802_11_SET_APSD_SETTING (apsd=0x%lx, APSDCap=%d, [BE,BK,VI,VO]=[%d/%d/%d/%d],	MaxSPLen=%d)\n", apsd, pAd->StaCfg.UapsdInfo.bAPSDCapable,
+sta/sta_cfg.c:					pAd->CommonCfg.bAPSDAC_BE,	pAd->CommonCfg.bAPSDAC_BK,	pAd->CommonCfg.bAPSDAC_VI,	pAd->CommonCfg.bAPSDAC_VO,	pAd->CommonCfg.MaxSPLength));
+sta/sta_cfg.c:				Status = copy_from_user(&pAd->CommonCfg.bAPSDForcePowerSave, wrq->u.data.pointer, wrq->u.data.length);
+sta/sta_cfg.c:				if (pAd->CommonCfg.bAPSDForcePowerSave	!= pAd->StaCfg.Psm)
+sta/sta_cfg.c:					RTMP_SET_PSM_BIT(pAd,	pAd->CommonCfg.bAPSDForcePowerSave);
+sta/sta_cfg.c:					RTMPSendNullFrame(pAd,	pAd->CommonCfg.TxRate, TRUE, pAd->CommonCfg.bAPSDForcePowerSave ? PWR_SAVE : pAd->StaCfg.Psm);
+sta/sta_cfg.c:				DBGPRINT(RT_DEBUG_TRACE, ("Set::RT_OID_802_11_SET_APSD_PSM (bAPSDForcePowerSave:%d)\n",	pAd->CommonCfg.bAPSDForcePowerSave));
+sta/sta_cfg.c:				BOOLEAN	oldvalue = pAd->CommonCfg.bDLSCapable;
+sta/sta_cfg.c:				Status = copy_from_user(&pAd->CommonCfg.bDLSCapable, wrq->u.data.pointer, wrq->u.data.length);
+sta/sta_cfg.c:				if (oldvalue &&	!pAd->CommonCfg.bDLSCapable)
+sta/sta_cfg.c:						if (pAd->StaCfg.DLSEntry[i].Valid && (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH))
+sta/sta_cfg.c:							pAd->StaCfg.DLSEntry[i].Status	= DLS_NONE;
+sta/sta_cfg.c:							pAd->StaCfg.DLSEntry[i].Valid	= FALSE;
+sta/sta_cfg.c:							RTMPSendDLSTearDownFrame(pAd, pAd->StaCfg.DLSEntry[i].MacAddr);
+sta/sta_cfg.c:						if (pAd->StaCfg.DLSEntry[i].Valid && (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH))
+sta/sta_cfg.c:							pAd->StaCfg.DLSEntry[i].Status	= DLS_NONE;
+sta/sta_cfg.c:							pAd->StaCfg.DLSEntry[i].Valid	= FALSE;
+sta/sta_cfg.c:							RTMPSendDLSTearDownFrame(pAd, pAd->StaCfg.DLSEntry[i].MacAddr);
+sta/sta_cfg.c:				DBGPRINT(RT_DEBUG_TRACE,("Set::RT_OID_802_11_SET_DLS (=%d)\n", pAd->CommonCfg.bDLSCapable));
+sta/sta_cfg.c:				BOOLEAN	oldvalue = pAd->StaCfg.TdlsInfo.bTDLSCapable;
+sta/sta_cfg.c:				Status = copy_from_user(&pAd->StaCfg.TdlsInfo.bTDLSCapable, wrq->u.data.pointer, wrq->u.data.length);
+sta/sta_cfg.c:				if (oldvalue &&	!pAd->StaCfg.TdlsInfo.bTDLSCapable)
+sta/sta_cfg.c:				DBGPRINT(RT_DEBUG_TRACE,("Set::RT_OID_802_11_SET_DLS (=%d)\n", pAd->CommonCfg.bDLSCapable));
+sta/sta_cfg.c:				Status = copy_from_user(&pAd->CommonCfg.bWmmCapable, wrq->u.data.pointer, wrq->u.data.length);
+sta/sta_cfg.c:				DBGPRINT(RT_DEBUG_TRACE, ("Set::RT_OID_802_11_SET_WMM (=%d)	\n", pAd->CommonCfg.bWmmCapable));
+sta/sta_cfg.c:			pAd->CommonCfg.NdisRadioStateOff =	TRUE;
+sta/sta_cfg.c:			pAd->MlmeAux.CurrReqIsFromNdis	= TRUE;			
+sta/sta_cfg.c:			if (pAd->StaCfg.WscControl.bSkipWPSTurnOffLED == FALSE)
+sta/sta_cfg.c:				RTMPCancelTimer(&pAd->StaCfg.WscControl.WscLEDTimer, &Cancelled);
+sta/sta_cfg.c:				if (pAd->Mlme.CntlMachine.CurrState !=	CNTL_IDLE)
+sta/sta_cfg.c:						pAd->CommonCfg.BACapability.field.Policy = BA_NOTUSE;
+sta/sta_cfg.c:						pAd->CommonCfg.BACapability.field.MpduDensity = Orde.MpduDensity;
+sta/sta_cfg.c:						pAd->CommonCfg.DesiredHtPhy.MpduDensity = Orde.MpduDensity;
+sta/sta_cfg.c:						pAd->CommonCfg.DesiredHtPhy.AmsduEnable = Orde.AmsduEnable;
+sta/sta_cfg.c:						pAd->CommonCfg.DesiredHtPhy.AmsduSize= Orde.AmsduSize;
+sta/sta_cfg.c:						pAd->CommonCfg.DesiredHtPhy.MimoPs= Orde.MMPSmode;
+sta/sta_cfg.c:						pAd->CommonCfg.BACapability.field.MMPSmode = Orde.MMPSmode;
+sta/sta_cfg.c:						pAd->CommonCfg.HtCapability.HtCapInfo.MimoPs = Orde.MMPSmode;
+sta/sta_cfg.c:						pAd->CommonCfg.HtCapability.HtCapInfo.AMsduSize = Orde.AmsduSize;
+sta/sta_cfg.c:						pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity = Orde.MpduDensity;
+sta/sta_cfg.c:                        pAd->CommonCfg.BACapability.field.AutoBA = Orde.AutoBA;
+sta/sta_cfg.c:						pAd->CommonCfg.BACapability.field.Policy = IMMED_BA; /* we only support immediate BA. */
+sta/sta_cfg.c:						pAd->CommonCfg.BACapability.field.MpduDensity = Orde.MpduDensity;
+sta/sta_cfg.c:						pAd->CommonCfg.DesiredHtPhy.MpduDensity = Orde.MpduDensity;
+sta/sta_cfg.c:						pAd->CommonCfg.DesiredHtPhy.AmsduEnable = Orde.AmsduEnable;
+sta/sta_cfg.c:						pAd->CommonCfg.DesiredHtPhy.AmsduSize= Orde.AmsduSize;
+sta/sta_cfg.c:						pAd->CommonCfg.DesiredHtPhy.MimoPs = Orde.MMPSmode;
+sta/sta_cfg.c:						pAd->CommonCfg.BACapability.field.MMPSmode = Orde.MMPSmode;
+sta/sta_cfg.c:						pAd->CommonCfg.HtCapability.HtCapInfo.MimoPs = Orde.MMPSmode;
+sta/sta_cfg.c:						pAd->CommonCfg.HtCapability.HtCapInfo.AMsduSize = Orde.AmsduSize;
+sta/sta_cfg.c:						pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity = Orde.MpduDensity;
+sta/sta_cfg.c:						if (pAd->CommonCfg.BACapability.field.RxBAWinLimit > MAX_RX_REORDERBUF)
+sta/sta_cfg.c:							pAd->CommonCfg.BACapability.field.RxBAWinLimit = MAX_RX_REORDERBUF;
+sta/sta_cfg.c:					pAd->CommonCfg.REGBACapability.word = pAd->CommonCfg.BACapability.word;
+sta/sta_cfg.c:					DBGPRINT(RT_DEBUG_TRACE, ("Set::(Orde.AutoBA = %d) (Policy=%d)(ReBAWinLimit=%d)(TxBAWinLimit=%d)(AutoMode=%d)\n",Orde.AutoBA, pAd->CommonCfg.BACapability.field.Policy,
+sta/sta_cfg.c:						pAd->CommonCfg.BACapability.field.RxBAWinLimit,pAd->CommonCfg.BACapability.field.TxBAWinLimit, pAd->CommonCfg.BACapability.field.AutoBA));
+sta/sta_cfg.c:					DBGPRINT(RT_DEBUG_TRACE, ("Set::(MimoPs = %d)(AmsduEnable = %d) (AmsduSize=%d)(MpduDensity=%d)\n",pAd->CommonCfg.DesiredHtPhy.MimoPs, pAd->CommonCfg.DesiredHtPhy.AmsduEnable,
+sta/sta_cfg.c:						pAd->CommonCfg.DesiredHtPhy.AmsduSize, pAd->CommonCfg.DesiredHtPhy.MpduDensity));
+sta/sta_cfg.c:							pAd->CommonCfg.BACapability.field.RxBAWinLimit = 0x10;
+sta/sta_cfg.c:					NdisZeroMemory(&pAd->SharedKey[BSS0][KeyIdx], sizeof(CIPHER_KEY));
+sta/sta_cfg.c:                    pAd->SharedKey[BSS0][KeyIdx].KeyLen = (UCHAR) pWepKey->KeyLength;
+sta/sta_cfg.c:                    NdisMoveMemory(pAd->SharedKey[BSS0][KeyIdx].Key, &pWepKey->KeyMaterial, pWepKey->KeyLength);
+sta/sta_cfg.c:                    pAd->SharedKey[BSS0][KeyIdx].CipherAlg = CipherAlg;
+sta/sta_cfg.c:                        NdisZeroMemory(&pAd->StaCfg.DesireSharedKey[KeyIdx], sizeof(CIPHER_KEY));
+sta/sta_cfg.c:                        pAd->StaCfg.DesireSharedKey[KeyIdx].KeyLen = (UCHAR) pWepKey->KeyLength;
+sta/sta_cfg.c:                        NdisMoveMemory(pAd->StaCfg.DesireSharedKey[KeyIdx].Key, &pWepKey->KeyMaterial, pWepKey->KeyLength);
+sta/sta_cfg.c:                        pAd->StaCfg.DesireSharedKeyId = KeyIdx;
+sta/sta_cfg.c:                        pAd->StaCfg.DesireSharedKey[KeyIdx].CipherAlg = CipherAlg;
+sta/sta_cfg.c:                        pAd->StaCfg.DefaultKeyId = (UCHAR) KeyIdx;
+sta/sta_cfg.c:					if ((pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE) &&
+sta/sta_cfg.c:						(pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA))
+sta/sta_cfg.c:    					AsicAddSharedKeyEntry(pAd, BSS0, KeyIdx, &pAd->SharedKey[BSS0][KeyIdx]);
+sta/sta_cfg.c:                    else if (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_SECURED)
+sta/sta_cfg.c:                        Key = pAd->SharedKey[BSS0][KeyIdx].Key;
+sta/sta_cfg.c:        				AsicAddSharedKeyEntry(pAd, BSS0, KeyIdx, &pAd->SharedKey[BSS0][KeyIdx]);	
+sta/sta_cfg.c:					DBGPRINT(RT_DEBUG_TRACE, ("Set::OID_802_11_ADD_WEP (id=0x%x, Len=%d-byte), %s\n", pWepKey->KeyIndex, pWepKey->KeyLength, (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_SECURED) ? "Port Secured":"Port NOT Secured"));
+sta/sta_cfg.c:                    pAd->StaCfg.bBlockAssoc = TRUE;
+sta/sta_cfg.c:                    pAd->StaCfg.bBlockAssoc = FALSE;
+sta/sta_cfg.c:                DBGPRINT(RT_DEBUG_TRACE, ("Set::OID_SET_COUNTERMEASURES bBlockAssoc=%s\n", pAd->StaCfg.bBlockAssoc ? "TRUE":"FALSE"));
+sta/sta_cfg.c:					pAd->StaCfg.WpaSupplicantUP |= WPA_SUPPLICANT_ENABLE_WPS;
+sta/sta_cfg.c:					pAd->StaCfg.WpaSupplicantUP = wpa_supplicant_enable;
+sta/sta_cfg.c:					pAd->StaCfg.WpaSupplicantUP &= 0x7F;
+sta/sta_cfg.c:				DBGPRINT(RT_DEBUG_TRACE, ("Set::RT_OID_WPA_SUPPLICANT_SUPPORT (=0x%02X)\n", pAd->StaCfg.WpaSupplicantUP));
+sta/sta_cfg.c:                    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/sta_cfg.c:                    pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+sta/sta_cfg.c:                    pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+sta/sta_cfg.c:				NdisAcquireSpinLock(&pAd->MacTabLock);
+sta/sta_cfg.c:				pAd->MacTab.Content[BSSID_WCID].PortSecured = pAd->StaCfg.PortSecured;
+sta/sta_cfg.c:				NdisReleaseSpinLock(&pAd->MacTabLock);
+sta/sta_cfg.c:		        pAd->StaCfg.IEEE8021X = IEEE8021xState;
+sta/sta_cfg.c:				pAd->StaCfg.IEEE8021x_required_keys = IEEE8021x_required_keys;				
+sta/sta_cfg.c:                NdisZeroMemory(pAd->StaCfg.SavedPMK, sizeof(BSSID_INFO)*PMKID_NO);
+sta/sta_cfg.c:			        for (CachedIdx = 0; CachedIdx < pAd->StaCfg.SavedPMKNum; CachedIdx++)
+sta/sta_cfg.c:				        if (NdisEqualMemory(pBssIdInfo->BSSID, pAd->StaCfg.SavedPMK[CachedIdx].BSSID, sizeof(NDIS_802_11_MAC_ADDRESS)))
+sta/sta_cfg.c:				        NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx], pBssIdInfo, sizeof(BSSID_INFO));
+sta/sta_cfg.c:				        pAd->StaCfg.SavedPMKNum++;
+sta/sta_cfg.c:				        NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx], pBssIdInfo, sizeof(BSSID_INFO));
+sta/sta_cfg.c:			if (pAd->StaCfg.pWpsProbeReqIe)
+sta/sta_cfg.c:/*				kfree(pAd->StaCfg.pWpsProbeReqIe); */
+sta/sta_cfg.c:				os_free_mem(NULL, pAd->StaCfg.pWpsProbeReqIe);
+sta/sta_cfg.c:				pAd->StaCfg.pWpsProbeReqIe = NULL;
+sta/sta_cfg.c:			pAd->StaCfg.WpsProbeReqIeLen = 0;
+sta/sta_cfg.c:/*			pAd->StaCfg.pWpsProbeReqIe = kmalloc(wrq->u.data.length, MEM_ALLOC_FLAG); */
+sta/sta_cfg.c:			os_alloc_mem(pAd, (UCHAR **)&(pAd->StaCfg.pWpsProbeReqIe), wrq->u.data.length);
+sta/sta_cfg.c:			if (pAd->StaCfg.pWpsProbeReqIe)
+sta/sta_cfg.c:				Status = copy_from_user(pAd->StaCfg.pWpsProbeReqIe, wrq->u.data.pointer, wrq->u.data.length);
+sta/sta_cfg.c:					if (pAd->StaCfg.pWpsProbeReqIe)
+sta/sta_cfg.c:/*						kfree(pAd->StaCfg.pWpsProbeReqIe); */
+sta/sta_cfg.c:						os_free_mem(NULL, pAd->StaCfg.pWpsProbeReqIe);
+sta/sta_cfg.c:						pAd->StaCfg.pWpsProbeReqIe = NULL;
+sta/sta_cfg.c:					pAd->StaCfg.WpsProbeReqIeLen = 0;
+sta/sta_cfg.c:					pAd->StaCfg.WpsProbeReqIeLen = wrq->u.data.length;
+sta/sta_cfg.c:					hex_dump("WpsProbeReqIe", pAd->StaCfg.pWpsProbeReqIe, pAd->StaCfg.WpsProbeReqIeLen);
+sta/sta_cfg.c:								pAd->StaCfg.WpsProbeReqIeLen));
+sta/sta_cfg.c:                PWSC_PROFILE pWscProfile = &pAd->StaCfg.WscControl.WscProfile;
+sta/sta_cfg.c:                PWSC_CTRL   pWscControl = &pAd->StaCfg.WscControl;
+sta/sta_cfg.c:                    RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+sta/sta_cfg.c:                    RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+sta/sta_cfg.c:                    pAd->MlmeAux.CurrReqIsFromNdis = TRUE;
+sta/sta_cfg.c:                Status = copy_from_user(&pAd->StaCfg.WscControl.WscDriverAutoConnect, wrq->u.data.pointer, wrq->u.data.length);
+sta/sta_cfg.c:                                            pAd->StaCfg.WscControl.WscDriverAutoConnect));
+sta/sta_cfg.c:                Status = copy_from_user(pAd->StaCfg.WscControl.WpaPsk, wrq->u.data.pointer, wrq->u.data.length);
+sta/sta_cfg.c:                NdisZeroMemory(pAd->StaCfg.WscControl.WpaPsk, 64);
+sta/sta_cfg.c:                pAd->StaCfg.WscControl.WpaPskLen = wrq->u.data.length;
+sta/sta_cfg.c:                DBGPRINT(RT_DEBUG_TRACE, ("RT_OID_WSC_SET_PASSPHRASE::KeyLen(%d)\n", pAd->StaCfg.WscControl.WpaPskLen));
+sta/sta_cfg.c:			if(!(pAd->StaCfg.bRadio) ||
+sta/sta_cfg.c:				pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].KeyLen = (UCHAR) pKey->KeyLength;
+sta/sta_cfg.c:				NdisMoveMemory(&pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].Key, &pKey->KeyMaterial, pKey->KeyLength);
+sta/sta_cfg.c:					pAd->StaCfg.DefaultKeyId = (UCHAR) KeyIdx;
+sta/sta_cfg.c:				Status = copy_from_user(&pAd->StaCfg.DefaultKeyId, wrq->u.data.pointer, wrq->u.data.length);
+sta/sta_cfg.c:						if (NdisEqualMemory(pAd->MlmeAux.Bssid, wapi_port.Addr, MAC_ADDR_LEN))
+sta/sta_cfg.c:									pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+sta/sta_cfg.c:									pAd->StaCfg.PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
+sta/sta_cfg.c:									pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+sta/sta_cfg.c:									pAd->StaCfg.PrivacyFilter = Ndis802_11PrivFilter8021xWEP;
+sta/sta_cfg.c:						if (NdisEqualMemory(pAd->MlmeAux.Bssid, wapi_ukey.Addr, MAC_ADDR_LEN))
+sta/sta_cfg.c:							pEntry = &pAd->MacTab.Content[BSSID_WCID];
+sta/sta_cfg.c:							NdisMoveMemory(pAd->StaCfg.PTK, wapi_ukey.PTK, 64);	
+sta/sta_cfg.c:							hex_dump("WAPI UCAST KEY", pAd->StaCfg.PTK, 64);
+sta/sta_cfg.c:                	pAd->StaCfg.DefaultKeyId = wapi_mkey.key_id;
+sta/sta_cfg.c:                	/*NdisMoveMemory(pAd->StaCfg.rx_iv, wapi_mkey.m_tx_iv, LEN_WAPI_TSC); */
+sta/sta_cfg.c:                	NdisMoveMemory(pAd->StaCfg.NMK, wapi_mkey.NMK, 16);
+sta/sta_cfg.c:					RTMPDeriveWapiGTK(pAd->StaCfg.NMK, pAd->StaCfg.GTK);
+sta/sta_cfg.c:										 pAd->StaCfg.GroupCipher, 
+sta/sta_cfg.c:										 pAd->StaCfg.DefaultKeyId, 
+sta/sta_cfg.c:										 pAd->StaCfg.GTK);
+sta/sta_cfg.c:                Status = copy_from_user(&pAd->StaCfg.PSPXlink, wrq->u.data.pointer, wrq->u.data.length);
+sta/sta_cfg.c:				/*if (pAd->StaCfg.PSPXlink)
+sta/sta_cfg.c:				DBGPRINT(RT_DEBUG_TRACE,("Set::RT_OID_802_11_SET_PSPXLINK_MODE(=%d) \n", pAd->StaCfg.PSPXlink));
+sta/sta_cfg.c:				PRT_P2P_CONFIG	pP2PCtrl; /* = &pAd->P2pCfg; */
+sta/sta_cfg.c:            wrq->u.data.length = sizeof(pAd->nickname);
+sta/sta_cfg.c:            Status = copy_to_user(wrq->u.data.pointer, pAd->nickname, wrq->u.data.length);
+sta/sta_cfg.c:			if ((pAd->StaCfg.WpaSupplicantUP & 0x7F) == WPA_SUPPLICANT_ENABLE)
+sta/sta_cfg.c:				pAd->StaCfg.WpaSupplicantScanCount = 0;
+sta/sta_cfg.c:            DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_BSSID_LIST (%d BSS returned)\n",pAd->ScanTab.BssNr));
+sta/sta_cfg.c:			pAd->StaCfg.bSkipAutoScanConn = FALSE;
+sta/sta_cfg.c:            for (i = 0; i < pAd->ScanTab.BssNr; i++) 
+sta/sta_cfg.c:                /*Padding = 4 - (pAd->ScanTab.BssEntry[i].VarIELen & 0x0003); */
+sta/sta_cfg.c:                BssBufSize += (sizeof(NDIS_WLAN_BSSID_EX) - 1 + sizeof(NDIS_802_11_FIXED_IEs) + pAd->ScanTab.BssEntry[i].VarIELen + Padding);
+sta/sta_cfg.c:            pBssidList->NumberOfItems = pAd->ScanTab.BssNr;
+sta/sta_cfg.c:            for (i = 0; i < pAd->ScanTab.BssNr; i++) 
+sta/sta_cfg.c:                NdisMoveMemory(&pBss->MacAddress, &pAd->ScanTab.BssEntry[i].Bssid, MAC_ADDR_LEN);
+sta/sta_cfg.c:                if ((pAd->ScanTab.BssEntry[i].Hidden == 1) && (pAd->StaCfg.bShowHiddenSSID == FALSE))
+sta/sta_cfg.c:					if ((pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) && (pAd->StaCfg.PortSecured != WPA_802_1X_PORT_SECURED))
+sta/sta_cfg.c:						pBss->Ssid.SsidLength = pAd->ScanTab.BssEntry[i].SsidLen;
+sta/sta_cfg.c:						NdisMoveMemory(pBss->Ssid.Ssid, pAd->ScanTab.BssEntry[i].Ssid, pAd->ScanTab.BssEntry[i].SsidLen);
+sta/sta_cfg.c:                    pBss->Ssid.SsidLength = pAd->ScanTab.BssEntry[i].SsidLen;
+sta/sta_cfg.c:                    NdisMoveMemory(pBss->Ssid.Ssid, pAd->ScanTab.BssEntry[i].Ssid, pAd->ScanTab.BssEntry[i].SsidLen);
+sta/sta_cfg.c:                pBss->Privacy = pAd->ScanTab.BssEntry[i].Privacy;
+sta/sta_cfg.c:                pBss->Rssi = pAd->ScanTab.BssEntry[i].Rssi - pAd->BbpRssiToDbmDelta;
+sta/sta_cfg.c:				pBss->MinSNR = pAd->ScanTab.BssEntry[i].MinSNR;
+sta/sta_cfg.c:                pBss->NetworkTypeInUse = NetworkTypeInUseSanity(&pAd->ScanTab.BssEntry[i]);
+sta/sta_cfg.c:                pBss->Configuration.BeaconPeriod = pAd->ScanTab.BssEntry[i].BeaconPeriod;  
+sta/sta_cfg.c:                pBss->Configuration.ATIMWindow = pAd->ScanTab.BssEntry[i].AtimWin;
+sta/sta_cfg.c:				/*NdisMoveMemory(&pBss->QBssLoad, &pAd->ScanTab.BssEntry[i].QbssLoad, sizeof(QBSS_LOAD_UI)); */
+sta/sta_cfg.c:                MAP_CHANNEL_ID_TO_KHZ(pAd->ScanTab.BssEntry[i].Channel, pBss->Configuration.DSConfig);
+sta/sta_cfg.c:                if (pAd->ScanTab.BssEntry[i].BssType == BSS_INFRA) 
+sta/sta_cfg.c:                NdisMoveMemory(pBss->SupportedRates, pAd->ScanTab.BssEntry[i].SupRate, pAd->ScanTab.BssEntry[i].SupRateLen);
+sta/sta_cfg.c:                NdisMoveMemory(pBss->SupportedRates + pAd->ScanTab.BssEntry[i].SupRateLen,
+sta/sta_cfg.c:                               pAd->ScanTab.BssEntry[i].ExtRate,
+sta/sta_cfg.c:                               pAd->ScanTab.BssEntry[i].ExtRateLen);
+sta/sta_cfg.c:                if (pAd->ScanTab.BssEntry[i].VarIELen == 0)
+sta/sta_cfg.c:                    NdisMoveMemory(pBss->IEs, &pAd->ScanTab.BssEntry[i].FixIEs, sizeof(NDIS_802_11_FIXED_IEs));
+sta/sta_cfg.c:                    pBss->IELength = (ULONG)(sizeof(NDIS_802_11_FIXED_IEs) + pAd->ScanTab.BssEntry[i].VarIELen);
+sta/sta_cfg.c:                    NdisMoveMemory(pBss->IEs, &pAd->ScanTab.BssEntry[i].FixIEs, sizeof(NDIS_802_11_FIXED_IEs));
+sta/sta_cfg.c:                    NdisMoveMemory(pBss->IEs + sizeof(NDIS_802_11_FIXED_IEs), pAd->ScanTab.BssEntry[i].VarIEs, pAd->ScanTab.BssEntry[i].VarIELen);
+sta/sta_cfg.c:                    pPtr += pAd->ScanTab.BssEntry[i].VarIELen;
+sta/sta_cfg.c:                pBss->Length = (ULONG)(sizeof(NDIS_WLAN_BSSID_EX) - 1 + sizeof(NDIS_802_11_FIXED_IEs) + pAd->ScanTab.BssEntry[i].VarIELen + Padding);
+sta/sta_cfg.c:            Status = copy_to_user(wrq->u.data.pointer, &pAd->CurrentAddress, wrq->u.data.length);
+sta/sta_cfg.c:            if (pAd->IndicateMediaState == NdisMediaStateConnected)
+sta/sta_cfg.c:                Status = copy_to_user(wrq->u.data.pointer, &pAd->CommonCfg.Bssid, sizeof(NDIS_802_11_MAC_ADDRESS));
+sta/sta_cfg.c:            Ssid.SsidLength = pAd->CommonCfg.SsidLen;
+sta/sta_cfg.c:			memcpy(Ssid.Ssid, pAd->CommonCfg.Ssid,	Ssid.SsidLength);
+sta/sta_cfg.c:                pLinkStatus->CurrTxRate = RateIdTo500Kbps[pAd->CommonCfg.TxRate];   /* unit : 500 kbps */
+sta/sta_cfg.c:                pLinkStatus->ChannelQuality = pAd->Mlme.ChannelQuality;
+sta/sta_cfg.c:                pLinkStatus->RxByteCount = pAd->RalinkCounters.ReceivedByteCount;
+sta/sta_cfg.c:                pLinkStatus->TxByteCount = pAd->RalinkCounters.TransmittedByteCount;
+sta/sta_cfg.c:        		pLinkStatus->CentralChannel = pAd->CommonCfg.CentralChannel;
+sta/sta_cfg.c:                pConfiguration->BeaconPeriod = pAd->CommonCfg.BeaconPeriod;
+sta/sta_cfg.c:                pConfiguration->ATIMWindow = pAd->StaActive.AtimWin;
+sta/sta_cfg.c:                MAP_CHANNEL_ID_TO_KHZ(pAd->CommonCfg.Channel, pConfiguration->DSConfig);
+sta/sta_cfg.c:                                        pConfiguration->BeaconPeriod, pConfiguration->ATIMWindow, pAd->CommonCfg.Channel));
+sta/sta_cfg.c:			if ((pAd->StaCfg.LastSNR0 > 0))
+sta/sta_cfg.c:				ulInfo = ConvertToSnr(pAd, pAd->StaCfg.LastSNR0);
+sta/sta_cfg.c:			if ((pAd->Antenna.field.RxPath	> 1) && 
+sta/sta_cfg.c:                (pAd->StaCfg.LastSNR1 > 0))
+sta/sta_cfg.c:				ulInfo = ConvertToSnr(pAd, pAd->StaCfg.LastSNR1);
+sta/sta_cfg.c:            DBGPRINT(RT_DEBUG_TRACE,("Query::RT_OID_802_11_SNR_1(pAd->StaCfg.LastSNR1=%d)\n",pAd->StaCfg.LastSNR1));
+sta/sta_cfg.c:			if ((pAd->Antenna.field.RxPath	> 2) && 
+sta/sta_cfg.c:                (pAd->StaCfg.LastSNR2 > 0))
+sta/sta_cfg.c:				ulInfo = ConvertToSnr(pAd, pAd->StaCfg.LastSNR2);
+sta/sta_cfg.c:            DBGPRINT(RT_DEBUG_TRACE,("Query::RT_OID_802_11_SNR_2(pAd->StaCfg.LastSNR2=%d)\n",pAd->StaCfg.LastSNR2));
+sta/sta_cfg.c:            ulInfo = pAd->StaCfg.RssiSample.LastRssi0 - pAd->BbpRssiToDbmDelta;
+sta/sta_cfg.c:			ulInfo = pAd->StaCfg.RssiSample.LastRssi0;
+sta/sta_cfg.c:            ulInfo = pAd->StaCfg.RssiSample.LastRssi1;
+sta/sta_cfg.c:            ulInfo = pAd->StaCfg.RssiSample.LastRssi2;
+sta/sta_cfg.c:                if (pAd->WlanCounters.TransmittedFragmentCount.QuadPart < pAd->WlanCounters.RetryCount.QuadPart)
+sta/sta_cfg.c:                    pAd->WlanCounters.TransmittedFragmentCount.QuadPart = pAd->WlanCounters.RetryCount.QuadPart;
+sta/sta_cfg.c:		pStatistics->TransmittedFragmentCount.QuadPart = pAd->WlanCounters.TransmittedFragmentCount.QuadPart + pAd->WlanCounters.MulticastTransmittedFrameCount.QuadPart;;
+sta/sta_cfg.c:                pStatistics->MulticastTransmittedFrameCount.QuadPart = pAd->WlanCounters.MulticastTransmittedFrameCount.QuadPart;
+sta/sta_cfg.c:                pStatistics->FailedCount.QuadPart = pAd->WlanCounters.FailedCount.QuadPart;
+sta/sta_cfg.c:                pStatistics->RetryCount.QuadPart = pAd->WlanCounters.RetryCount.QuadPart;
+sta/sta_cfg.c:                pStatistics->MultipleRetryCount.QuadPart = pAd->WlanCounters.MultipleRetryCount.QuadPart;
+sta/sta_cfg.c:                pStatistics->RTSSuccessCount.QuadPart = pAd->WlanCounters.RTSSuccessCount.QuadPart;
+sta/sta_cfg.c:                pStatistics->RTSFailureCount.QuadPart = pAd->WlanCounters.RTSFailureCount.QuadPart;
+sta/sta_cfg.c:                pStatistics->ACKFailureCount.QuadPart = pAd->WlanCounters.ACKFailureCount.QuadPart;
+sta/sta_cfg.c:                pStatistics->FrameDuplicateCount.QuadPart = pAd->WlanCounters.FrameDuplicateCount.QuadPart;
+sta/sta_cfg.c:                pStatistics->ReceivedFragmentCount.QuadPart = pAd->WlanCounters.ReceivedFragmentCount.QuadPart;
+sta/sta_cfg.c:                pStatistics->MulticastReceivedFrameCount.QuadPart = pAd->WlanCounters.MulticastReceivedFrameCount.QuadPart;
+sta/sta_cfg.c:                pStatistics->FCSErrorCount = pAd->RalinkCounters.RealFcsErrCount;
+sta/sta_cfg.c:                pStatistics->FCSErrorCount.QuadPart = pAd->WlanCounters.FCSErrorCount.QuadPart;
+sta/sta_cfg.c:                pStatistics->FrameDuplicateCount.u.LowPart = pAd->WlanCounters.FrameDuplicateCount.u.LowPart / 100;
+sta/sta_cfg.c:			pStatistics->TransmittedFrameCount.QuadPart = pAd->WlanCounters.TransmittedFragmentCount.QuadPart;
+sta/sta_cfg.c:			pStatistics->WEPUndecryptableCount.QuadPart = pAd->WlanCounters.WEPUndecryptableCount.QuadPart;
+sta/sta_cfg.c:		if (pAd->chipCap.FlgHwTxBfCap)
+sta/sta_cfg.c:					if (IS_ENTRY_CLIENT(&pAd->MacTab.Content[i]) && (pAd->MacTab.Content[i].Sst == SST_ASSOC))
+sta/sta_cfg.c:						NdisMoveMemory(&pMacTab->Entry[pMacTab->Num], &pAd->MacTab.Content[i].TxBFCounters, sizeof(RT_COUNTER_TXBF));
+sta/sta_cfg.c:            ulInfo = pAd->Counters8023.GoodReceives;
+sta/sta_cfg.c:            ulInfo = pAd->Counters8023.RxNoBuffer;
+sta/sta_cfg.c:            ulInfo = (ULONG)pAd->CommonCfg.PhyMode;
+sta/sta_cfg.c:                pStaConfig->EnableTxBurst = pAd->CommonCfg.bEnableTxBurst;
+sta/sta_cfg.c:                pStaConfig->UseBGProtection = pAd->CommonCfg.UseBGProtection;
+sta/sta_cfg.c:                pStaConfig->UseShortSlotTime = pAd->CommonCfg.bUseShortSlotTime;
+sta/sta_cfg.c:                /*pStaConfig->AdhocMode = pAd->StaCfg.AdhocMode; */
+sta/sta_cfg.c:                pStaConfig->HwRadioStatus = (pAd->StaCfg.bHwRadio == TRUE) ? 1 : 0;
+sta/sta_cfg.c:                pStaConfig->SystemErrorBitmap = pAd->SystemErrorBitmap;
+sta/sta_cfg.c:            RtsThresh = pAd->CommonCfg.RtsThreshold;
+sta/sta_cfg.c:            FragThresh = pAd->CommonCfg.FragmentThreshold;
+sta/sta_cfg.c:            if (pAd->CommonCfg.bUseZeroToDisableFragment == TRUE)
+sta/sta_cfg.c:            PowerMode = pAd->StaCfg.WindowsPowerMode;
+sta/sta_cfg.c:            RadioState = (BOOLEAN) pAd->StaCfg.bSwRadio;
+sta/sta_cfg.c:            if (pAd->StaCfg.BssType == BSS_ADHOC)
+sta/sta_cfg.c:            else if (pAd->StaCfg.BssType == BSS_INFRA)
+sta/sta_cfg.c:            else if (pAd->StaCfg.BssType == BSS_MONITOR)
+sta/sta_cfg.c:            PreamType = pAd->CommonCfg.TxPreamble;
+sta/sta_cfg.c:            AuthMode = pAd->StaCfg.AuthMode;
+sta/sta_cfg.c:            WepStatus = pAd->StaCfg.WepStatus;
+sta/sta_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->CommonCfg.TxPower, wrq->u.data.length);
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_TX_POWER_LEVEL %x\n",pAd->CommonCfg.TxPower));
+sta/sta_cfg.c:            Status = copy_to_user(wrq->u.data.pointer, &pAd->CommonCfg.TxPowerPercentage, wrq->u.data.length);
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::RT_OID_802_11_TX_POWER_LEVEL_1 (=%ld)\n", pAd->CommonCfg.TxPowerPercentage));
+sta/sta_cfg.c:			if ((pAd->RfIcType == RFIC_2850) ||
+sta/sta_cfg.c:				(pAd->RfIcType == RFIC_2750) ||
+sta/sta_cfg.c:				(pAd->RfIcType == RFIC_3052) ||
+sta/sta_cfg.c:				(pAd->RfIcType == RFIC_3053) || 
+sta/sta_cfg.c:				(pAd->RfIcType == RFIC_2853) || 
+sta/sta_cfg.c:				(pAd->RfIcType == RFIC_3853) ||
+sta/sta_cfg.c:				(pAd->RfIcType == RFIC_5592))
+sta/sta_cfg.c:			if (WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_A))
+sta/sta_cfg.c:			else if (WMODE_EQUAL(pAd->CommonCfg.PhyMode, (WMODE_G | WMODE_B)) ||
+sta/sta_cfg.c:					WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_G))
+sta/sta_cfg.c:            		ulInfo = (ULONG)pAd->LastRxRate;
+sta/sta_cfg.c:			ulInfo = (ULONG)pAd->LastTxRate;
+sta/sta_cfg.c:			HTPhyMode.word =(USHORT) pAd->LastRxRate;
+sta/sta_cfg.c:			HTPhyMode.word = (USHORT)pAd->LastTxRate;
+sta/sta_cfg.c:			ulInfo = (ULONG)pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word;
+sta/sta_cfg.c:            Status = copy_to_user(wrq->u.data.pointer, &pAd->EepromVersion, wrq->u.data.length);
+sta/sta_cfg.c:            Status = copy_to_user(wrq->u.data.pointer, &pAd->FirmwareVersion, wrq->u.data.length);
+sta/sta_cfg.c:			UCHAR noise = RTMPMaxRssi(pAd, pAd->StaCfg.RssiSample.AvgRssi0,
+sta/sta_cfg.c:										pAd->StaCfg.RssiSample.AvgRssi1,
+sta/sta_cfg.c:										pAd->StaCfg.RssiSample.AvgRssi2) - 
+sta/sta_cfg.c:										RTMPMinSnr(pAd, pAd->StaCfg.RssiSample.AvgSnr0, 
+sta/sta_cfg.c:										pAd->StaCfg.RssiSample.AvgSnr1);
+sta/sta_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->ExtraInfo, wrq->u.data.length);
+sta/sta_cfg.c:	        DBGPRINT(RT_DEBUG_TRACE, ("Query::RT_OID_802_11_EXTRA_INFO (=%ld)\n", pAd->ExtraInfo));
+sta/sta_cfg.c:			apsd = (pAd->StaCfg.UapsdInfo.bAPSDCapable | (pAd->CommonCfg.bAPSDAC_BE << 1) | (pAd->CommonCfg.bAPSDAC_BK << 2)
+sta/sta_cfg.c:				| (pAd->CommonCfg.bAPSDAC_VI << 3)	| (pAd->CommonCfg.bAPSDAC_VO << 4)	| (pAd->CommonCfg.MaxSPLength << 5));
+sta/sta_cfg.c:				apsd,pAd->StaCfg.UapsdInfo.bAPSDCapable,pAd->CommonCfg.bAPSDAC_BE,pAd->CommonCfg.bAPSDAC_BK,pAd->CommonCfg.bAPSDAC_VI,pAd->CommonCfg.bAPSDAC_VO,pAd->CommonCfg.MaxSPLength));
+sta/sta_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->CommonCfg.bAPSDForcePowerSave, wrq->u.data.length);
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::RT_OID_802_11_QUERY_APSD_PSM (=%d)\n", pAd->CommonCfg.bAPSDForcePowerSave));			
+sta/sta_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->CommonCfg.bWmmCapable, wrq->u.data.length);
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::RT_OID_802_11_QUERY_WMM (=%d)\n",	pAd->CommonCfg.bWmmCapable));
+sta/sta_cfg.c:	        Status = copy_to_user(wrq->u.data.pointer, &pAd->StaCfg.WpaSupplicantUP, wrq->u.data.length);
+sta/sta_cfg.c:            DBGPRINT(RT_DEBUG_TRACE, ("Query::RT_OID_WPA_SUPPLICANT_SUPPORT (=%d)\n", pAd->StaCfg.WpaSupplicantUP));
+sta/sta_cfg.c:			if (copy_to_user(wrq->u.data.pointer, &pAd->StaCfg.WscControl.WscStatus, wrq->u.data.length))
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::RT_OID_WSC_QUERY_STATUS (=%d)\n", pAd->StaCfg.WscControl.WscStatus));
+sta/sta_cfg.c:			WscPinCode = pAd->StaCfg.WscControl.WscEnrolleePinCode;
+sta/sta_cfg.c:            WscCreateProfileFromCfg(pAd, STA_MODE, &pAd->StaCfg.WscControl, pProfile);
+sta/sta_cfg.c:			NdisMoveMemory(pProfile, &pAd->StaCfg.WscControl.WscProfile, sizeof(WSC_PROFILE));
+sta/sta_cfg.c:			if (copy_to_user(wrq->u.data.pointer, &pAd->StaCfg.WscControl.Wsc_Uuid_Str[0], UUID_LEN_STR))
+sta/sta_cfg.c:			if (copy_to_user(wrq->u.data.pointer, pAd->CurrentAddress, wrq->u.data.length))
+sta/sta_cfg.c:			if (copy_to_user(wrq->u.data.pointer, pAd->StaCfg.dev_name, wrq->u.data.length))
+sta/sta_cfg.c:			pHTPhyMode->PhyMode = pAd->CommonCfg.PhyMode;
+sta/sta_cfg.c:			pHTPhyMode->HtMode = (UCHAR)pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE;
+sta/sta_cfg.c:			pHTPhyMode->BW = (UCHAR)pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.BW;
+sta/sta_cfg.c:			pHTPhyMode->MCS= (UCHAR)pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MCS;
+sta/sta_cfg.c:			pHTPhyMode->SHORTGI= (UCHAR)pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.ShortGI;
+sta/sta_cfg.c:			pHTPhyMode->STBC= (UCHAR)pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.STBC;
+sta/sta_cfg.c:			pHTPhyMode->ExtOffset = ((pAd->CommonCfg.CentralChannel < pAd->CommonCfg.Channel) ? (EXTCHA_BELOW) : (EXTCHA_ABOVE));
+sta/sta_cfg.c:					__FUNCTION__, pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word));
+sta/sta_cfg.c:            ulInfo = pAd->CommonCfg.CountryRegionForABand;
+sta/sta_cfg.c:            ulInfo = (ulInfo << 8)|(pAd->CommonCfg.CountryRegion);
+sta/sta_cfg.c:                pHTPhyMode->PhyMode = wmode_2_cfgmode(pAd->CommonCfg.PhyMode);
+sta/sta_cfg.c:    			pHTPhyMode->HtMode = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.HTMODE;
+sta/sta_cfg.c:    			pHTPhyMode->BW = (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.BW;
+sta/sta_cfg.c:    			pHTPhyMode->MCS= (UCHAR)pAd->StaCfg.DesiredTransmitSetting.field.MCS;
+sta/sta_cfg.c:    			pHTPhyMode->SHORTGI= (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.ShortGI;
+sta/sta_cfg.c:    			pHTPhyMode->STBC= (UCHAR)pAd->CommonCfg.RegTransmitSetting.field.STBC;
+sta/sta_cfg.c:						__FUNCTION__, pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word));
+sta/sta_cfg.c:            Status = copy_to_user(wrq->u.data.pointer, &pAd->CurrentAddress, wrq->u.data.length);
+sta/sta_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->CurrentAddress, wrq->u.data.length);
+sta/sta_cfg.c:			if (pAd->StaCfg.Psm == PSMP_ACTION)
+sta/sta_cfg.c:			valueLen = pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].KeyLen;
+sta/sta_cfg.c:						   &pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].Key,
+sta/sta_cfg.c:										pAd->StaCfg.DefaultKeyId, 
+sta/sta_cfg.c:										pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].KeyLen,
+sta/sta_cfg.c:										pAd->SharedKey[BSS0][0].Key[0],
+sta/sta_cfg.c:										pAd->SharedKey[BSS0][1].Key[0],
+sta/sta_cfg.c:										pAd->SharedKey[BSS0][2].Key[0],
+sta/sta_cfg.c:										pAd->SharedKey[BSS0][3].Key[0]));
+sta/sta_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->StaCfg.DefaultKeyId, wrq->u.data.length);
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("DefaultKeyId =%d \n", pAd->StaCfg.DefaultKeyId));
+sta/sta_cfg.c:									&pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].KeyLen,
+sta/sta_cfg.c:						RtmpOsGetUsbDevVendorID(((POS_COOKIE)pAd->OS_Cookie)->pUsb_Dev),
+sta/sta_cfg.c:						RtmpOsGetUsbDevProductID(((POS_COOKIE)pAd->OS_Cookie)->pUsb_Dev));
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("sizeof UCHAR=%d, channel=%d \n", sizeof(UCHAR), pAd->CommonCfg.Channel));
+sta/sta_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->CommonCfg.Channel, wrq->u.data.length);
+sta/sta_cfg.c:				if (pAd->ChannelListNum == 0)
+sta/sta_cfg.c:				pChListBuf->ChannelListNum = pAd->ChannelListNum;
+sta/sta_cfg.c:					pChListBuf->ChannelList[i] = pAd->ChannelList[i].Channel;
+sta/sta_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->CommonCfg.CountryCode, 2);
+sta/sta_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->CommonCfg.Geography, 1);
+sta/sta_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->P2pCfg.Rule, wrq->u.data.length);
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_MODE (Len=%d, Rule=%s)\n", sizeof(char),pAd->P2pCfg.Rule));
+sta/sta_cfg.c:			wrq->u.data.length = pAd->P2pCfg.DeviceNameLen;
+sta/sta_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, pAd->P2pCfg.DeviceName, pAd->P2pCfg.DeviceNameLen);
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_DEVICE_NAME (Len=%d, DeviceName=%s)\n", pAd->P2pCfg.DeviceNameLen,pAd->P2pCfg.DeviceName));
+sta/sta_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->P2pCfg.ListenChannel, wrq->u.data.length);
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_LISTEN_CHANNEL (Len=%d, Listen_Ch=%d)\n", sizeof(char),pAd->P2pCfg.ListenChannel));
+sta/sta_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->P2pCfg.GroupChannel, wrq->u.data.length);
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_OPERATION_CHANNEL (Len=%d, Op_Ch=%d)\n", sizeof(char),pAd->P2pCfg.GroupOpChannel));
+sta/sta_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, pAd->P2pCfg.Bssid, wrq->u.data.length);
+sta/sta_cfg.c:			/*DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_MAC_ADDR (Len=%d, Rule=%s)\n", sizeof(char),pAd->P2pCfg.GroupOpChannel)); */
+sta/sta_cfg.c:			pP2PCtrl = &pAd->P2pCfg;
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_MODE (Len=%d, DeviceName=%s)\n", pAd->P2pCfg.DeviceNameLen,pAd->P2pCfg.DeviceName));
+sta/sta_cfg.c:			pP2PCtrl = &pAd->P2pCfg;
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_MODE (Len=%d, DeviceName=%s)\n", pAd->P2pCfg.DeviceNameLen,pAd->P2pCfg.DeviceName));
+sta/sta_cfg.c:			pP2PCtrl = &pAd->P2pCfg;
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_MODE (Len=%d, DeviceName=%s)\n", pAd->P2pCfg.DeviceNameLen,pAd->P2pCfg.DeviceName));
+sta/sta_cfg.c:				pP2pTable = &pAd->P2pTable;
+sta/sta_cfg.c:				pUI_table->ClientNumber = pAd->P2pTable.ClientNumber;
+sta/sta_cfg.c:				for (i=0; i < pAd->P2pTable.ClientNumber; i++)
+sta/sta_cfg.c:				DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_P2P_SCAN_LIST (Len=%d, Rule=%s)\n", sizeof(char),pAd->P2pCfg.GroupOpChannel));
+sta/sta_cfg.c:			WscPinCode = pAd->ApCfg.ApCliTab[0].WscControl.WscEnrolleePinCode;
+sta/sta_cfg.c:			Status = copy_to_user(wrq->u.data.pointer, &pAd->CommonCfg.bDLSCapable, wrq->u.data.length);
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::RT_OID_802_11_QUERY_DLS(=%d)\n", pAd->CommonCfg.bDLSCapable));
+sta/sta_cfg.c:					RTMPMoveMemory(&pDlsInfo->Entry[i], &pAd->StaCfg.DLSEntry[i], sizeof(RT_802_11_DLS_UI));
+sta/sta_cfg.c:				pEntry = &pAd->MacTab.Content[BSSID_WCID];
+sta/sta_cfg.c:            Status = copy_to_user(wrq->u.data.pointer, &pAd->StaCfg.PSPXlink, wrq->u.data.length);
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_TRACE, ("Query::OID_802_11_SET_PSPXLINK_MODE(=%d)\n", pAd->StaCfg.PSPXlink));
+sta/sta_cfg.c:            	Status = copy_to_user(wrq->u.data.pointer, &pAd->StaCfg.IWscInfo.SelfIpv4Addr, sizeof(UINT32));
+sta/sta_cfg.c:					pAd->StaCfg.IWscInfo.SelfIpv4Addr, Status));
+sta/sta_cfg.c:            	Status = copy_to_user(wrq->u.data.pointer, &pAd->StaCfg.IWscInfo.RegIpv4Addr, sizeof(UINT32));
+sta/sta_cfg.c:					pAd->StaCfg.IWscInfo.RegIpv4Addr, Status));
+sta/sta_cfg.c:            	Status = copy_to_user(wrq->u.data.pointer, &pAd->StaCfg.IWscInfo.SmpbcEnrolleeCount, sizeof(UINT8));
+sta/sta_cfg.c:					pAd->StaCfg.IWscInfo.SmpbcEnrolleeCount, Status));
+sta/sta_cfg.c:					pAd->BbpTuning.bEnable = TRUE;
+sta/sta_cfg.c:					pAd->BbpTuning.bEnable = FALSE;
+sta/sta_cfg.c:				if (bbpId <= pAd->chipCap.MaxNumOfBbpId)
+sta/sta_cfg.c:				if (bbpId <= pAd->chipCap.MaxNumOfBbpId)
+sta/sta_cfg.c:		for (bbpId = 0; bbpId <= pAd->chipCap.MaxNumOfBbpId; bbpId++)
+sta/sta_cfg.c:		PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[i];
+sta/sta_cfg.c:					pRecBAEntry =&pAd->BATable.BARecEntry[pEntry->BARecWcidArray[j]];
+sta/sta_cfg.c:					pOriBAEntry =&pAd->BATable.BAOriEntry[pEntry->BAOriWcidArray[j]];
+sta/sta_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+sta/sta_cfg.c:                if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) &&
+sta/sta_cfg.c:                    pAd->CommonCfg.RegTransmitSetting.field.BW)
+sta/sta_cfg.c:                    snprintf(extra, size, "Monitor Mode(CentralChannel %d)\n", pAd->CommonCfg.CentralChannel);
+sta/sta_cfg.c:                    snprintf(extra, size, "Monitor Mode(Channel %d)\n", pAd->CommonCfg.Channel);
+sta/sta_cfg.c:                if (pAd->IndicateMediaState == NdisMediaStateConnected)
+sta/sta_cfg.c:                                    pAd->CommonCfg.Ssid, 
+sta/sta_cfg.c:                                    pAd->CommonCfg.Bssid[0],
+sta/sta_cfg.c:                                    pAd->CommonCfg.Bssid[1],
+sta/sta_cfg.c:                                    pAd->CommonCfg.Bssid[2],
+sta/sta_cfg.c:                                    pAd->CommonCfg.Bssid[3],
+sta/sta_cfg.c:                                    pAd->CommonCfg.Bssid[4],
+sta/sta_cfg.c:                                    pAd->CommonCfg.Bssid[5]);
+sta/sta_cfg.c:            		DBGPRINT(RT_DEBUG_TRACE ,("Ssid=%s ,Ssidlen = %d\n",pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen));
+sta/sta_cfg.c:						COPY_MAC_ADDR(&DisReq.Addr, pAd->CommonCfg.Bssid);
+sta/sta_cfg.c:                if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+sta/sta_cfg.c:            pAd->StaCfg.bSwRadio = FALSE;
+sta/sta_cfg.c:            if (pAd->StaCfg.bRadio != (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio))
+sta/sta_cfg.c:                pAd->StaCfg.bRadio = (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio);
+sta/sta_cfg.c:                if (pAd->StaCfg.bRadio == FALSE)
+sta/sta_cfg.c:			pAd->ExtraInfo = SW_RADIO_OFF;
+sta/sta_cfg.c:            pAd->StaCfg.bSwRadio = TRUE;
+sta/sta_cfg.c:            /*if (pAd->StaCfg.bRadio != (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio)) */
+sta/sta_cfg.c:                pAd->StaCfg.bRadio = (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio);
+sta/sta_cfg.c:                if (pAd->StaCfg.bRadio == TRUE)
+sta/sta_cfg.c:					pAd->ExtraInfo = EXTRA_INFO_CLEAR;
+sta/sta_cfg.c:	pAd->CommonCfg.Channel = chan;
+sta/sta_cfg.c:		pAd->MlmeAux.Channel = pAd->CommonCfg.Channel;
+sta/sta_cfg.c:		pAd->StaCfg.ConnectinfoChannel = pAd->CommonCfg.Channel;	
+sta/sta_cfg.c:	DBGPRINT(RT_DEBUG_ERROR, ("==>rt_ioctl_siwfreq::SIOCSIWFREQ(Channel=%d)\n", pAd->CommonCfg.Channel));
+sta/sta_cfg.c:		ch = pAd->CommonCfg.Channel;
+sta/sta_cfg.c:	pAd->StaCfg.WpaState = SS_NOTUSE;
+sta/sta_cfg.c:	if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)
+sta/sta_cfg.c:	pAd->MlmeAux.CurrReqIsFromNdis = FALSE; 
+sta/sta_cfg.c:	pAd->MlmeAux.AutoReconnectSsidLen= 32;
+sta/sta_cfg.c:		NdisMoveMemory(pData, pAd->CommonCfg.Bssid, MAC_ADDR_LEN);
+sta/sta_cfg.c:	else if (pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE)
+sta/sta_cfg.c:		NdisMoveMemory(pData, pAd->MlmeAux.Bssid, MAC_ADDR_LEN);
+sta/sta_cfg.c:		RtmpOSWrielessEventSend(pAd->net_dev, RT_WLAN_EVENT_SCAN, -1, NULL, NULL, 0);
+sta/sta_cfg.c:	if ((pAd->StaCfg.WpaSupplicantUP & 0x7F) == WPA_SUPPLICANT_ENABLE)
+sta/sta_cfg.c:		pAd->StaCfg.WpaSupplicantScanCount++;
+sta/sta_cfg.c:    pAd->StaCfg.bSkipAutoScanConn = TRUE;
+sta/sta_cfg.c:			((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) || 
+sta/sta_cfg.c:				(pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+sta/sta_cfg.c:				(pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
+sta/sta_cfg.c:				(pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)) &&	
+sta/sta_cfg.c:			(pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED))
+sta/sta_cfg.c:	if ((pAd->StaCfg.WpaSupplicantUP & 0x7F) == WPA_SUPPLICANT_ENABLE)
+sta/sta_cfg.c:		pAd->StaCfg.WpaSupplicantScanCount = 0;
+sta/sta_cfg.c:	pIoctlScan->BssNr = pAd->ScanTab.BssNr;
+sta/sta_cfg.c:				pAd->ScanTab.BssNr * sizeof(RT_CMD_STA_IOCTL_BSS_TABLE));
+sta/sta_cfg.c:	for(IdBss=0; IdBss<pAd->ScanTab.BssNr; IdBss++)
+sta/sta_cfg.c:		HT_CAP_INFO capInfo = pAd->ScanTab.BssEntry[IdBss].HtCapability.HtCapInfo;
+sta/sta_cfg.c:		pBssEntry = &pAd->ScanTab.BssEntry[IdBss];
+sta/sta_cfg.c:	memcpy(pIoctlScan->MainSharedKey[0], pAd->SharedKey[BSS0][0].Key, 16);
+sta/sta_cfg.c:	memcpy(pIoctlScan->MainSharedKey[1], pAd->SharedKey[BSS0][1].Key, 16);
+sta/sta_cfg.c:	memcpy(pIoctlScan->MainSharedKey[2], pAd->SharedKey[BSS0][2].Key, 16);
+sta/sta_cfg.c:	memcpy(pIoctlScan->MainSharedKey[3], pAd->SharedKey[BSS0][3].Key, 16);
+sta/sta_cfg.c:		pSsid->SsidLen = pAd->CommonCfg.SsidLen;
+sta/sta_cfg.c:		memcpy(pSsid->pSsid, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen);
+sta/sta_cfg.c:	else if (pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE)
+sta/sta_cfg.c:		pSsid->SsidLen = pAd->CommonCfg.SsidLen;
+sta/sta_cfg.c:		memcpy(pSsid->pSsid, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen);
+sta/sta_cfg.c:	memset(pAd->nickname, 0, IW_ESSID_MAX_SIZE + 1);
+sta/sta_cfg.c:	memcpy(pAd->nickname, pData, Data);
+sta/sta_cfg.c:	if (IoctlName->NameLen > strlen((PSTRING) pAd->nickname) + 1)
+sta/sta_cfg.c:		IoctlName->NameLen = strlen((PSTRING) pAd->nickname) + 1;
+sta/sta_cfg.c:		memcpy(IoctlName->pName, pAd->nickname, IoctlName->NameLen-1);
+sta/sta_cfg.c:	pAd->CommonCfg.RtsThreshold = Data;
+sta/sta_cfg.c:	*(USHORT *)pData = pAd->CommonCfg.RtsThreshold;
+sta/sta_cfg.c:	pAd->CommonCfg.FragmentThreshold = Data;
+sta/sta_cfg.c:	*(USHORT *)pData = pAd->CommonCfg.FragmentThreshold;
+sta/sta_cfg.c:		pAd->StaCfg.PairCipher = Ndis802_11WEPDisabled;
+sta/sta_cfg.c:		pAd->StaCfg.GroupCipher = Ndis802_11WEPDisabled;
+sta/sta_cfg.c:		pAd->StaCfg.WepStatus = Ndis802_11WEPDisabled;
+sta/sta_cfg.c:        pAd->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
+sta/sta_cfg.c:		pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+sta/sta_cfg.c:		pAd->StaCfg.PairCipher = Ndis802_11WEPEnabled;
+sta/sta_cfg.c:		pAd->StaCfg.GroupCipher = Ndis802_11WEPEnabled;
+sta/sta_cfg.c:		pAd->StaCfg.WepStatus = Ndis802_11WEPEnabled;
+sta/sta_cfg.c:			pAd->StaCfg.AuthMode = Ndis802_11AuthModeShared;
+sta/sta_cfg.c:			pAd->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
+sta/sta_cfg.c:                                        keyIdx, pAd->StaCfg.DefaultKeyId));
+sta/sta_cfg.c:			keyIdx = pAd->StaCfg.DefaultKeyId;   
+sta/sta_cfg.c:			pAd->StaCfg.DefaultKeyId = keyIdx;
+sta/sta_cfg.c:        NdisZeroMemory(pAd->SharedKey[BSS0][keyIdx].Key,  16);
+sta/sta_cfg.c:			pAd->SharedKey[BSS0][keyIdx].KeyLen = MAX_WEP_KEY_SIZE;
+sta/sta_cfg.c:            pAd->SharedKey[BSS0][keyIdx].CipherAlg = CIPHER_WEP128;
+sta/sta_cfg.c:            pAd->SharedKey[BSS0][keyIdx].KeyLen = MIN_WEP_KEY_SIZE;
+sta/sta_cfg.c:            pAd->SharedKey[BSS0][keyIdx].CipherAlg = CIPHER_WEP64;
+sta/sta_cfg.c:			pAd->SharedKey[BSS0][keyIdx].KeyLen = 0;
+sta/sta_cfg.c:			NdisMoveMemory(pAd->SharedKey[BSS0][keyIdx].Key, pIoctlSec->pData, pIoctlSec->length);
+sta/sta_cfg.c:			pAd->StaCfg.DefaultKeyId = index;
+sta/sta_cfg.c:	DBGPRINT(RT_DEBUG_TRACE ,("==>rt_ioctl_siwencode::AuthMode=%x\n",pAd->StaCfg.AuthMode));
+sta/sta_cfg.c:	DBGPRINT(RT_DEBUG_TRACE ,("==>rt_ioctl_siwencode::DefaultKeyId=%x, KeyLen = %d\n",pAd->StaCfg.DefaultKeyId , pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].KeyLen));
+sta/sta_cfg.c:	DBGPRINT(RT_DEBUG_TRACE ,("==>rt_ioctl_siwencode::WepStatus=%x\n",pAd->StaCfg.WepStatus));
+sta/sta_cfg.c:	if (pAd->StaCfg.WepStatus == Ndis802_11WEPDisabled)
+sta/sta_cfg.c:		if (pIoctlSec->length > pAd->SharedKey[BSS0][kid-1].KeyLen)
+sta/sta_cfg.c:			pIoctlSec->length = pAd->SharedKey[BSS0][kid-1].KeyLen;
+sta/sta_cfg.c:		memcpy(pIoctlSec->pData, pAd->SharedKey[BSS0][kid-1].Key, pIoctlSec->length);
+sta/sta_cfg.c:		if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeShared)
+sta/sta_cfg.c:		if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeShared)
+sta/sta_cfg.c:		pIoctlSec->length = pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].KeyLen;
+sta/sta_cfg.c:		memcpy(pIoctlSec->pData, pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].Key, pIoctlSec->length);
+sta/sta_cfg.c:		if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeShared)
+sta/sta_cfg.c:		pIoctlSec->KeyIdx = pAd->StaCfg.DefaultKeyId + 1;			/* NB: base 1 */
+sta/sta_cfg.c:			COPY_MAC_ADDR(DeAuthReq.Addr, pAd->CommonCfg.Bssid);
+sta/sta_cfg.c:			    pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/sta_cfg.c:			NdisZeroMemory(pAd->StaCfg.ConnectinfoSsid, MAX_LEN_OF_SSID);
+sta/sta_cfg.c:			NdisZeroMemory(pAd->StaCfg.ConnectinfoBssid, MAC_ADDR_LEN);
+sta/sta_cfg.c:			pAd->StaCfg.ConnectinfoSsidLen  = 0;
+sta/sta_cfg.c:			pAd->StaCfg.ConnectinfoBssType  = 1;
+sta/sta_cfg.c:			pAd->StaCfg.ConnectinfoChannel = 0;
+sta/sta_cfg.c:			COPY_MAC_ADDR(DisAssocReq.Addr, pAd->CommonCfg.Bssid);
+sta/sta_cfg.c:			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_DISASSOC;
+sta/sta_cfg.c:                pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPAPSK;
+sta/sta_cfg.c:				if (pAd->StaCfg.BssType == BSS_ADHOC)
+sta/sta_cfg.c:					pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPANone;
+sta/sta_cfg.c:                pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPA2PSK;
+sta/sta_cfg.c:                pAd->StaCfg.WepStatus = Ndis802_11WEPDisabled;
+sta/sta_cfg.c:                pAd->StaCfg.PairCipher = Ndis802_11WEPDisabled;
+sta/sta_cfg.c:                pAd->StaCfg.WepStatus = Ndis802_11WEPEnabled;
+sta/sta_cfg.c:                pAd->StaCfg.PairCipher = Ndis802_11WEPEnabled;
+sta/sta_cfg.c:                pAd->StaCfg.IEEE8021X = FALSE;
+sta/sta_cfg.c:                pAd->StaCfg.WepStatus = Ndis802_11Encryption2Enabled;
+sta/sta_cfg.c:                pAd->StaCfg.PairCipher = Ndis802_11Encryption2Enabled;
+sta/sta_cfg.c:                pAd->StaCfg.WepStatus = Ndis802_11Encryption3Enabled;
+sta/sta_cfg.c:                pAd->StaCfg.PairCipher = Ndis802_11Encryption3Enabled;
+sta/sta_cfg.c:                pAd->StaCfg.GroupCipher = Ndis802_11WEPDisabled;
+sta/sta_cfg.c:                pAd->StaCfg.GroupCipher = Ndis802_11GroupWEP40Enabled;
+sta/sta_cfg.c:				pAd->StaCfg.GroupCipher = Ndis802_11GroupWEP104Enabled;
+sta/sta_cfg.c:                pAd->StaCfg.GroupCipher = Ndis802_11Encryption2Enabled;
+sta/sta_cfg.c:                pAd->StaCfg.GroupCipher = Ndis802_11Encryption3Enabled;
+sta/sta_cfg.c:			//pAd->StaCfg.WpaSupplicantUP &= 0x7F;
+sta/sta_cfg.c:                if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK)
+sta/sta_cfg.c:                    pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPA;
+sta/sta_cfg.c:                    pAd->StaCfg.IEEE8021X = FALSE;
+sta/sta_cfg.c:                else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+sta/sta_cfg.c:                    pAd->StaCfg.AuthMode = Ndis802_11AuthModeWPA2;
+sta/sta_cfg.c:                    pAd->StaCfg.IEEE8021X = FALSE;
+sta/sta_cfg.c:                    pAd->StaCfg.IEEE8021X = TRUE;
+sta/sta_cfg.c:				pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+sta/sta_cfg.c:                pAd->StaCfg.AuthMode = Ndis802_11AuthModeOpen;
+sta/sta_cfg.c:                pAd->StaCfg.WepStatus = Ndis802_11WEPDisabled;
+sta/sta_cfg.c:                pAd->StaCfg.PairCipher = Ndis802_11WEPDisabled;
+sta/sta_cfg.c:        	    pAd->StaCfg.GroupCipher = Ndis802_11WEPDisabled;
+sta/sta_cfg.c:                pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
+sta/sta_cfg.c:				pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+sta/sta_cfg.c:				pAd->StaCfg.AuthMode = Ndis802_11AuthModeAutoSwitch;
+sta/sta_cfg.c:			pAd->StaCfg.bBlockAssoc = TRUE;
+sta/sta_cfg.c:			pAd->StaCfg.bBlockAssoc = FALSE;
+sta/sta_cfg.c:        pIoctlWpa->value = (pAd->StaCfg.WepStatus == Ndis802_11WEPDisabled) ? 0 : 1;
+sta/sta_cfg.c:        pIoctlWpa->value = (pAd->StaCfg.AuthMode == Ndis802_11AuthModeShared) ? 0 : 1;
+sta/sta_cfg.c:		pIoctlWpa->value = (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) ? 1 : 0;
+sta/sta_cfg.c:    NdisZeroMemory(&pAd->SharedKey[BSS0][keyIdx], sizeof(CIPHER_KEY));
+sta/sta_cfg.c:    pAd->SharedKey[BSS0][keyIdx].KeyLen = LEN_TK;
+sta/sta_cfg.c:    NdisMoveMemory(pAd->SharedKey[BSS0][keyIdx].Key, pKey, LEN_TK);
+sta/sta_cfg.c:    NdisMoveMemory(pAd->SharedKey[BSS0][keyIdx].TxMic, pKey + LEN_TK, LEN_TKIP_MIC);
+sta/sta_cfg.c:    NdisMoveMemory(pAd->SharedKey[BSS0][keyIdx].RxMic, pKey + LEN_TK + LEN_TKIP_MIC, LEN_TKIP_MIC);
+sta/sta_cfg.c:    pAd->SharedKey[BSS0][keyIdx].CipherAlg = CipherAlg;
+sta/sta_cfg.c:						  &pAd->SharedKey[BSS0][keyIdx]);
+sta/sta_cfg.c:	    						pAd->SharedKey[BSS0][keyIdx].CipherAlg, 
+sta/sta_cfg.c:        pAd->SharedKey[BSS0][keyIdx].KeyLen = 0;
+sta/sta_cfg.c:		pAd->SharedKey[BSS0][keyIdx].CipherAlg = CIPHER_NONE;
+sta/sta_cfg.c:        NdisZeroMemory(&pAd->SharedKey[BSS0][keyIdx], sizeof(CIPHER_KEY));
+sta/sta_cfg.c:            pAd->StaCfg.DefaultKeyId = keyIdx;
+sta/sta_cfg.c:            DBGPRINT(RT_DEBUG_TRACE, ("%s::DefaultKeyId = %d\n", __FUNCTION__, pAd->StaCfg.DefaultKeyId));
+sta/sta_cfg.c:        			pAd->SharedKey[BSS0][keyIdx].KeyLen = MAX_WEP_KEY_SIZE;
+sta/sta_cfg.c:                    pAd->SharedKey[BSS0][keyIdx].CipherAlg = CIPHER_WEP128;
+sta/sta_cfg.c:                    pAd->SharedKey[BSS0][keyIdx].KeyLen = MIN_WEP_KEY_SIZE;
+sta/sta_cfg.c:                    pAd->SharedKey[BSS0][keyIdx].CipherAlg = CIPHER_WEP64;
+sta/sta_cfg.c:                NdisZeroMemory(pAd->SharedKey[BSS0][keyIdx].Key,  16);
+sta/sta_cfg.c:			    NdisMoveMemory(pAd->SharedKey[BSS0][keyIdx].Key, pIoctlSec->pData, pIoctlSec->length);
+sta/sta_cfg.c:				if ((pAd->StaCfg.GroupCipher == Ndis802_11GroupWEP40Enabled) ||
+sta/sta_cfg.c:					(pAd->StaCfg.GroupCipher == Ndis802_11GroupWEP104Enabled))				
+sta/sta_cfg.c:					AsicAddSharedKeyEntry(pAd, BSS0, keyIdx, &pAd->SharedKey[BSS0][keyIdx]);										
+sta/sta_cfg.c:										 	pAd->SharedKey[BSS0][keyIdx].CipherAlg, 												 
+sta/sta_cfg.c:                	if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
+sta/sta_cfg.c:                		RTMPZeroMemory(pAd->StaCfg.PMK, LEN_PMK);
+sta/sta_cfg.c:                		RTMPMoveMemory(pAd->StaCfg.PMK, pIoctlSec->pData, pIoctlSec->length);
+sta/sta_cfg.c:	                        if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA2)
+sta/sta_cfg.c:				if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
+sta/sta_cfg.c:            		RTMPZeroMemory(pAd->StaCfg.PMK, LEN_PMK);
+sta/sta_cfg.c:            		RTMPMoveMemory(pAd->StaCfg.PMK, pIoctlSec->pData, pIoctlSec->length);
+sta/sta_cfg.c:	                    if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA2)
+sta/sta_cfg.c:		if ((pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled) ||
+sta/sta_cfg.c:			(pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled))
+sta/sta_cfg.c:			if (idx != pAd->StaCfg.DefaultKeyId)
+sta/sta_cfg.c:		idx = pAd->StaCfg.DefaultKeyId;
+sta/sta_cfg.c:	switch(pAd->StaCfg.WepStatus) {
+sta/sta_cfg.c:			if (pAd->SharedKey[BSS0][idx].KeyLen > pIoctlSec->MaxKeyLen)
+sta/sta_cfg.c:				pIoctlSec->length = pAd->SharedKey[BSS0][idx].KeyLen;				
+sta/sta_cfg.c:				pIoctlSec->pData = (PCHAR)&(pAd->SharedKey[BSS0][idx].Key[0]);
+sta/sta_cfg.c:			if (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled)
+sta/sta_cfg.c:				pIoctlSec->pData = (PCHAR)&pAd->StaCfg.PMK[0];
+sta/sta_cfg.c:	if (pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE)
+sta/sta_cfg.c:		pAd->StaCfg.bRSN_IE_FromWpaSupplicant = FALSE;
+sta/sta_cfg.c:		pAd->StaCfg.WpaSupplicantUP &= ~WPA_SUPPLICANT_ENABLE_WPS;
+sta/sta_cfg.c:			if (pAd->StaCfg.pWpaAssocIe)
+sta/sta_cfg.c:				os_free_mem(NULL, pAd->StaCfg.pWpaAssocIe);
+sta/sta_cfg.c:				pAd->StaCfg.pWpaAssocIe = NULL;
+sta/sta_cfg.c:/*			pAd->StaCfg.pWpaAssocIe = kmalloc(wrqu->data.length, MEM_ALLOC_FLAG); */
+sta/sta_cfg.c:			os_alloc_mem(NULL, (UCHAR **)&pAd->StaCfg.pWpaAssocIe, length);
+sta/sta_cfg.c:			if (pAd->StaCfg.pWpaAssocIe)
+sta/sta_cfg.c:				pAd->StaCfg.WpaAssocIeLen = length;
+sta/sta_cfg.c:				NdisMoveMemory(pAd->StaCfg.pWpaAssocIe, pData, pAd->StaCfg.WpaAssocIeLen);
+sta/sta_cfg.c:				pAd->StaCfg.bRSN_IE_FromWpaSupplicant = TRUE;
+sta/sta_cfg.c:				eid_ptr = pAd->StaCfg.pWpaAssocIe;
+sta/sta_cfg.c:				while (((UCHAR *)eid_ptr + eid_ptr->Len + 1) < ((UCHAR *)pAd->StaCfg.pWpaAssocIe + pAd->StaCfg.WpaAssocIeLen))
+sta/sta_cfg.c:							pAd->StaCfg.WpaSupplicantUP |= WPA_SUPPLICANT_ENABLE_WPS;
+sta/sta_cfg.c:				pAd->StaCfg.WpaAssocIeLen = 0;
+sta/sta_cfg.c:	if ((pAd->StaCfg.RSNIE_Len == 0) ||
+sta/sta_cfg.c:		(pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA))
+sta/sta_cfg.c:	if ((pAd->StaCfg.WpaSupplicantUP & 0x7F) == WPA_SUPPLICANT_ENABLE &&
+sta/sta_cfg.c:		(pAd->StaCfg.WpaAssocIeLen > 0))
+sta/sta_cfg.c:		if (IoctlRsnIe->length < pAd->StaCfg.WpaAssocIeLen)
+sta/sta_cfg.c:		IoctlRsnIe->length = pAd->StaCfg.WpaAssocIeLen;
+sta/sta_cfg.c:		memcpy(IoctlRsnIe->pRsnIe, pAd->StaCfg.pWpaAssocIe, pAd->StaCfg.WpaAssocIeLen);
+sta/sta_cfg.c:		if (IoctlRsnIe->length < (pAd->StaCfg.RSNIE_Len + 2)) /* ID, Len */
+sta/sta_cfg.c:		IoctlRsnIe->length = pAd->StaCfg.RSNIE_Len + 2;
+sta/sta_cfg.c:		if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK) ||
+sta/sta_cfg.c:            (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2))
+sta/sta_cfg.c:		IoctlRsnIe->pRsnIe[1] = pAd->StaCfg.RSNIE_Len;
+sta/sta_cfg.c:		memcpy(IoctlRsnIe->pRsnIe+2, &pAd->StaCfg.RSN_IE[0], pAd->StaCfg.RSNIE_Len);
+sta/sta_cfg.c:			NdisZeroMemory(pAd->StaCfg.SavedPMK, sizeof(BSSID_INFO)*PMKID_NO);
+sta/sta_cfg.c:			for (CachedIdx = 0; CachedIdx < pAd->StaCfg.SavedPMKNum; CachedIdx++)
+sta/sta_cfg.c:		        if (NdisEqualMemory(pIoctlPmaSa->pBssid, pAd->StaCfg.SavedPMK[CachedIdx].BSSID, MAC_ADDR_LEN))
+sta/sta_cfg.c:		        	NdisZeroMemory(pAd->StaCfg.SavedPMK[CachedIdx].BSSID, MAC_ADDR_LEN);
+sta/sta_cfg.c:					NdisZeroMemory(pAd->StaCfg.SavedPMK[CachedIdx].PMKID, 16);
+sta/sta_cfg.c:					for (idx = CachedIdx; idx < (pAd->StaCfg.SavedPMKNum - 1); idx++)
+sta/sta_cfg.c:						NdisMoveMemory(&pAd->StaCfg.SavedPMK[idx].BSSID[0], &pAd->StaCfg.SavedPMK[idx+1].BSSID[0], MAC_ADDR_LEN);
+sta/sta_cfg.c:						NdisMoveMemory(&pAd->StaCfg.SavedPMK[idx].PMKID[0], &pAd->StaCfg.SavedPMK[idx+1].PMKID[0], 16);
+sta/sta_cfg.c:					pAd->StaCfg.SavedPMKNum--;
+sta/sta_cfg.c:			for (CachedIdx = 0; CachedIdx < pAd->StaCfg.SavedPMKNum; CachedIdx++)
+sta/sta_cfg.c:		        if (NdisEqualMemory(pIoctlPmaSa->pBssid, pAd->StaCfg.SavedPMK[CachedIdx].BSSID, MAC_ADDR_LEN))
+sta/sta_cfg.c:		        NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx].BSSID[0], pIoctlPmaSa->pBssid, MAC_ADDR_LEN);
+sta/sta_cfg.c:				NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx].PMKID[0], pIoctlPmaSa->pPmkid, 16);
+sta/sta_cfg.c:		        pAd->StaCfg.SavedPMKNum++;
+sta/sta_cfg.c:		        NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx].BSSID[0], pIoctlPmaSa->pBssid, MAC_ADDR_LEN);
+sta/sta_cfg.c:				NdisMoveMemory(&pAd->StaCfg.SavedPMK[CachedIdx].PMKID[0], pIoctlPmaSa->pPmkid, 16);
+sta/sta_cfg.c:        pAd->StaCfg.DesiredTransmitSetting.field.MCS = MCS_AUTO;	
+sta/sta_cfg.c:		pAd->StaCfg.bAutoTxRateSwitch = TRUE;
+sta/sta_cfg.c:		if ((!WMODE_CAP_N(pAd->CommonCfg.PhyMode)) ||
+sta/sta_cfg.c:			(pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE <= MODE_OFDM))
+sta/sta_cfg.c:			pAd->StaCfg.bAutoTxRateSwitch = FALSE;
+sta/sta_cfg.c:			if ((!WMODE_CAP_N(pAd->CommonCfg.PhyMode)) ||
+sta/sta_cfg.c:				(pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE <= MODE_OFDM))
+sta/sta_cfg.c:				pAd->StaCfg.DesiredTransmitSetting.field.MCS = MCS_AUTO;
+sta/sta_cfg.c:					("rt_ioctl_siwrate::(HtMcs=%d)\n",pAd->StaCfg.DesiredTransmitSetting.field.MCS));
+sta/sta_cfg.c:    if ((pAd->StaCfg.bAutoTxRateSwitch == FALSE) &&
+sta/sta_cfg.c:        ((!WMODE_CAP_N(pAd->CommonCfg.PhyMode)) || (pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.MODE <= MODE_OFDM)))
+sta/sta_cfg.c:        ht_setting.word = pAd->StaCfg.HTPhyMode.word;
+sta/sta_cfg.c:        ht_setting.word = pAd->MacTab.Content[BSSID_WCID].HTPhyMode.word;
+sta/sta_cfg.c:	memcpy(pData, pAd->CurrentAddress, ETH_ALEN);
+sta/sta_cfg.c:        (*(CHAR *)pData) =  pAd->StaCfg.RssiSample.AvgRssi0;
+sta/sta_cfg.c:	pObj = (POS_COOKIE) pAd->OS_Cookie;
+sta/sta_cfg.c:	pWscProfile = &pAd->StaCfg.WscControl.WscProfile;
+sta/sta_cfg.c:                WscWriteConfToPortCfg(pAd, &pAd->StaCfg.WscControl, &pAd->StaCfg.WscControl.WscProfile.Profile[value], TRUE);
+sta/sta_cfg.c:                pAd->MlmeAux.CurrReqIsFromNdis = TRUE;
+sta/sta_cfg.c:                pAd->StaCfg.WscControl.WscDriverAutoConnect = value;
+sta/sta_cfg.c:                 (pAd->StaCfg.WscControl.bWscTrigger == TRUE) && 
+sta/sta_cfg.c:                 (pAd->StaCfg.WscControl.WscConfMode != WSC_DISABLE) )
+sta/sta_cfg.c:        		pAd->MlmeAux.CurrReqIsFromNdis = TRUE;
+sta/sta_cfg.c:        		DisassocParmFill(pAd, &DisReq, pAd->CommonCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
+sta/sta_cfg.c:        		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
+sta/sta_cfg.c:			if (pAd->StaCfg.BssType == BSS_ADHOC)
+sta/sta_cfg.c:				pAd->StaCfg.WscControl.WscConfMode = WSC_DISABLE;
+sta/sta_cfg.c:				pAd->StaCfg.WscControl.WscState = WSC_STATE_INIT;
+sta/sta_cfg.c:				pAd->StaCfg.WscControl.WscStatus = STATUS_WSC_IDLE;
+sta/sta_cfg.c:				if (pAd->StaCfg.WscControl.bWscTrigger)
+sta/sta_cfg.c:	        			&pAd->StaCfg.WscControl);
+sta/sta_cfg.c:	            pAd->StaCfg.WscControl.WscConfMode = WSC_DISABLE;
+sta/sta_cfg.c:				BssTableDeleteEntry(&pAd->MlmeAux.SsidBssTab, pAd->MlmeAux.Bssid, pAd->MlmeAux.Channel);
+sta/sta_cfg.c:				pAd->StaCfg.WscControl.WpsApBand= value;
+sta/sta_cfg.c:	pWscProfile = &pAd->StaCfg.WscControl.WscProfile;
+sta/sta_cfg.c:		txCount = pAd->ate.TxDoneCount;
+sta/sta_cfg.c:		txCount = (ULONG)pAd->WlanCounters.TransmittedFragmentCount.u.LowPart;
+sta/sta_cfg.c:	per = txCount==0? 0: 1000*(pAd->WlanCounters.RetryCount.u.LowPart+pAd->WlanCounters.FailedCount.u.LowPart)/(pAd->WlanCounters.RetryCount.u.LowPart+pAd->WlanCounters.FailedCount.u.LowPart+txCount);
+sta/sta_cfg.c:									(ULONG)pAd->WlanCounters.RetryCount.u.LowPart,
+sta/sta_cfg.c:	plr = txCount==0? 0: 10000*pAd->WlanCounters.FailedCount.u.LowPart/(pAd->WlanCounters.FailedCount.u.LowPart+txCount);
+sta/sta_cfg.c:									(ULONG)pAd->WlanCounters.FailedCount.u.LowPart, plr/100, plr%100);
+sta/sta_cfg.c:    sprintf(extra+strlen(extra), "Tx retry count          		  = %lu\n", (ULONG)pAd->WlanCounters.RetryCount.u.LowPart);
+sta/sta_cfg.c:    sprintf(extra+strlen(extra), "Tx fail to Rcv ACK after retry  = %lu\n", (ULONG)pAd->WlanCounters.FailedCount.u.LowPart);
+sta/sta_cfg.c:    sprintf(extra+strlen(extra), "RTS Success Rcv CTS             = %lu\n", (ULONG)pAd->WlanCounters.RTSSuccessCount.u.LowPart);
+sta/sta_cfg.c:    sprintf(extra+strlen(extra), "RTS Fail Rcv CTS                = %lu\n", (ULONG)pAd->WlanCounters.RTSFailureCount.u.LowPart);
+sta/sta_cfg.c:    sprintf(extra+strlen(extra), "Rx success                      = %lu\n", (ULONG)pAd->WlanCounters.ReceivedFragmentCount.QuadPart);
+sta/sta_cfg.c:	per = pAd->WlanCounters.ReceivedFragmentCount.u.LowPart==0? 0: 1000*(pAd->WlanCounters.FCSErrorCount.u.LowPart)/(pAd->WlanCounters.FCSErrorCount.u.LowPart+pAd->WlanCounters.ReceivedFragmentCount.u.LowPart);
+sta/sta_cfg.c:										(ULONG)pAd->WlanCounters.FCSErrorCount.u.LowPart, per/10, per % 10);
+sta/sta_cfg.c:    sprintf(extra+strlen(extra), "Rx drop due to out of resource  = %lu\n", (ULONG)pAd->Counters8023.RxNoBuffer);
+sta/sta_cfg.c:    sprintf(extra+strlen(extra), "Rx duplicate frame              = %lu\n", (ULONG)pAd->WlanCounters.FrameDuplicateCount.u.LowPart);
+sta/sta_cfg.c:    sprintf(extra+strlen(extra), "False CCA                       = %lu\n", (ULONG)pAd->RalinkCounters.FalseCCACnt);
+sta/sta_cfg.c:    sprintf(extra+strlen(extra), "Rx with CRC                     = %lu\n", (ULONG)pAd->WlanCounters.FCSErrorCount.u.LowPart);
+sta/sta_cfg.c:    sprintf(extra+strlen(extra), "Rx drop due to out of resource  = %lu\n", (ULONG)pAd->Counters8023.RxNoBuffer);
+sta/sta_cfg.c:    sprintf(extra+strlen(extra), "Rx duplicate frame              = %lu\n", (ULONG)pAd->WlanCounters.FrameDuplicateCount.u.LowPart);
+sta/sta_cfg.c:    sprintf(extra+strlen(extra), "False CCA (one second)          = %lu\n", (ULONG)pAd->RalinkCounters.OneSecFalseCCACnt);
+sta/sta_cfg.c:		if (pAd->ate.RxAntennaSel == 0)
+sta/sta_cfg.c:    		sprintf(extra+strlen(extra), "RSSI-A                          = %ld\n", (LONG)(pAd->ate.LastRssi0 - pAd->BbpRssiToDbmDelta));
+sta/sta_cfg.c:			sprintf(extra+strlen(extra), "RSSI-B (if available)           = %ld\n", (LONG)(pAd->ate.LastRssi1 - pAd->BbpRssiToDbmDelta));
+sta/sta_cfg.c:			sprintf(extra+strlen(extra), "RSSI-C (if available)           = %ld\n\n", (LONG)(pAd->ate.LastRssi2 - pAd->BbpRssiToDbmDelta));
+sta/sta_cfg.c:    		sprintf(extra+strlen(extra), "RSSI                            = %ld\n", (LONG)(pAd->ate.LastRssi0 - pAd->BbpRssiToDbmDelta));
+sta/sta_cfg.c:				(LONG)(pAd->StaCfg.RssiSample.LastRssi0 - pAd->BbpRssiToDbmDelta),
+sta/sta_cfg.c:				(LONG)(pAd->StaCfg.RssiSample.LastRssi1 - pAd->BbpRssiToDbmDelta),
+sta/sta_cfg.c:				(LONG)(pAd->StaCfg.RssiSample.LastRssi2 - pAd->BbpRssiToDbmDelta));
+sta/sta_cfg.c:		if (pAd->MacTab.Size > 0)
+sta/sta_cfg.c:				PMAC_TABLE_ENTRY pEntry = &(pAd->MacTab.Content[i]);
+sta/sta_cfg.c:		sprintf(extra+strlen(extra), "RSSI-A                          = %ld\n", (LONG)(pAd->StaCfg.RssiSample.AvgRssi0 - pAd->BbpRssiToDbmDelta));
+sta/sta_cfg.c:		sprintf(extra+strlen(extra), "RSSI-B (if available)           = %ld\n", (LONG)(pAd->StaCfg.RssiSample.AvgRssi1 - pAd->BbpRssiToDbmDelta));
+sta/sta_cfg.c:        	sprintf(extra+strlen(extra), "RSSI-C (if available)           = %ld\n\n", (LONG)(pAd->StaCfg.RssiSample.AvgRssi2 - pAd->BbpRssiToDbmDelta));
+sta/sta_cfg.c:		sprintf(extra+strlen(extra), "SNR-A                          = %ld\n", (LONG)(pAd->StaCfg.RssiSample.AvgSnr0));
+sta/sta_cfg.c:        	sprintf(extra+strlen(extra), "SNR-B (if available)           = %ld\n\n", (LONG)(pAd->StaCfg.RssiSample.AvgSnr1));
+sta/sta_cfg.c:    sprintf(extra+strlen(extra), "WpaSupplicantUP                 = %d\n\n", pAd->StaCfg.WpaSupplicantUP);
+sta/sta_cfg.c:	if (pAd->StaCfg.WscControl.WscEnrolleePinCodeLen == 8)	
+sta/sta_cfg.c:		sprintf(extra+strlen(extra), "RT2860 Linux STA PinCode\t%08u\n", pAd->StaCfg.WscControl.WscEnrolleePinCode);
+sta/sta_cfg.c:		sprintf(extra+strlen(extra), "RT2860 Linux STA PinCode\t%04u\n", pAd->StaCfg.WscControl.WscEnrolleePinCode);
+sta/sta_cfg.c:	wps_state = pAd->StaCfg.WscControl.WscState;
+sta/sta_cfg.c:	wps_status = pAd->StaCfg.WscControl.WscStatus;
+sta/sta_cfg.c:	if (pAd->StaCfg.WscControl.WscMode == WSC_PIN_MODE)
+sta/sta_cfg.c:	                                                  pAd->StaCfg.WscControl.WscDriverAutoConnect ? "Enabled":"Disabled",
+sta/sta_cfg.c:	                                                  pAd->StaCfg.WscControl.WscDriverAutoConnect);
+sta/sta_cfg.c:	/*sprintf(extra+strlen(extra), "RT2860 Linux STA PinCode\t%08u\n", pAd->StaCfg.WscControl.WscEnrolleePinCode); */
+sta/sta_cfg.c:    sprintf(extra+strlen(extra), "WPS Profile Count               = %d\n", pAd->StaCfg.WscControl.WscProfile.ProfileCnt);
+sta/sta_cfg.c:    for (idx = 0; idx < pAd->StaCfg.WscControl.WscProfile.ProfileCnt ; idx++)
+sta/sta_cfg.c:        PWSC_CREDENTIAL pCredential = &pAd->StaCfg.WscControl.WscProfile.Profile[idx];
+sta/sta_cfg.c:		if (pAd->StaCfg.BssType == BSS_ADHOC)
+sta/sta_cfg.c:			PIWSC_INFO	pIWscInfo = &pAd->StaCfg.IWscInfo;
+sta/sta_cfg.c:	POS_COOKIE pObj = (POS_COOKIE)pAd->OS_Cookie;
+sta/sta_cfg.c:			pAd->StaCfg.OriDevType = Data;
+sta/sta_cfg.c:	NdisAllocateSpinLock(pAd, &pAd->StaCtIf.Lock);
+sta/sta_cfg.c:				pAd->StaCfg.bSkipAutoScanConn = TRUE;
+sta/sta_cfg.c:			if (pAd->StaCfg.bImprovedScan)
+sta/sta_cfg.c:				pAd->StaCfg.bSkipAutoScanConn = TRUE;
+sta/sta_cfg.c:		    pAd->StaCfg.bSkipAutoScanConn = FALSE;
+sta/sta_cfg.c:			DBGPRINT(RT_DEBUG_ERROR ,("===>rt_ioctl_giwscan. %d(%d) BSS returned, data->length = %ld\n",pAd->ScanTab.BssNr , pAd->ScanTab.BssNr, Data));
+sta/sta_cfg.c:			pBssList->BssNum = pAd->ScanTab.BssNr;
+sta/sta_cfg.c:				if (i >=  pAd->ScanTab.BssNr)
+sta/sta_cfg.c:				set_quality(pList, &pAd->ScanTab.BssEntry[i]);
+sta/tdls_uapsd.c:	NdisAllocateSpinLock(pAd, &pAd->StaCfg.TdlsInfo.TDLSUapsdLock);
+sta/tdls_uapsd.c:	NdisFreeSpinLock(&pAd->StaCfg.TdlsInfo.TDLSUapsdLock);
+sta/tdls_uapsd.c:		pTDLS = (PRT_802_11_TDLS)&pAd->StaCfg.TdlsInfo.TDLSEntry[IdEntry];
+sta/tdls_uapsd.c:			PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[Wcid];
+sta/tdls_uapsd.c:    if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) || 
+sta/tdls_uapsd.c:         (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+sta/tdls_uapsd.c:         (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) || 
+sta/tdls_uapsd.c:         (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+sta/tdls_uapsd.c:			  || (pAd->StaCfg.IEEE8021X == TRUE)		
+sta/tdls_uapsd.c:		  || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAICERT)
+sta/tdls_uapsd.c:		  || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAIPSK)
+sta/tdls_uapsd.c:       (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED)) 
+sta/tdls_uapsd.c:		pTDLS = (RT_802_11_TDLS *) &pAd->StaCfg.TdlsInfo.TDLSEntry[IdTdls];
+sta/tdls_uapsd.c:									pAd->CommonCfg.TxRate, pMacEntry->Aid,
+sta/tdls_uapsd.c:	if (pAd->CommonCfg.MaxSPLength != 0)
+sta/tdls_uapsd.c:				pAd->CommonCfg.MaxSPLength, pAd->CommonCfg.MaxSPLength<<1);
+sta/tdls_uapsd.c:			pAd->CommonCfg.bACMAPSDTr[0],
+sta/tdls_uapsd.c:			pAd->CommonCfg.bAPSDAC_BE,
+sta/tdls_uapsd.c:			pAd->CommonCfg.bACMAPSDTr[1],
+sta/tdls_uapsd.c:			pAd->CommonCfg.bAPSDAC_BK,
+sta/tdls_uapsd.c:			pAd->CommonCfg.bACMAPSDTr[2],
+sta/tdls_uapsd.c:			pAd->CommonCfg.bAPSDAC_VI,
+sta/tdls_uapsd.c:			pAd->CommonCfg.bACMAPSDTr[3],
+sta/tdls_uapsd.c:			pAd->CommonCfg.bAPSDAC_VO);
+sta/tdls_uapsd.c:			pAd->CommonCfg.TDLS_bAPSDAC_BE,
+sta/tdls_uapsd.c:			pAd->CommonCfg.TDLS_bAPSDAC_BE,
+sta/tdls_uapsd.c:			pAd->CommonCfg.TDLS_bAPSDAC_BK,
+sta/tdls_uapsd.c:			pAd->CommonCfg.TDLS_bAPSDAC_BK,
+sta/tdls_uapsd.c:			pAd->CommonCfg.TDLS_bAPSDAC_VI,
+sta/tdls_uapsd.c:			pAd->CommonCfg.TDLS_bAPSDAC_VI,
+sta/tdls_uapsd.c:			pAd->CommonCfg.TDLS_bAPSDAC_VO,
+sta/tdls_uapsd.c:			pAd->CommonCfg.TDLS_bAPSDAC_VO);
+sta/tdls_uapsd.c:	pAd->CommonCfg.TDLS_bAPSDAC_BE = TDLS_UAPSD_CmdUtilNumGet(&pArgv);
+sta/tdls_uapsd.c:	pAd->CommonCfg.TDLS_bAPSDAC_BK = TDLS_UAPSD_CmdUtilNumGet(&pArgv);
+sta/tdls_uapsd.c:	pAd->CommonCfg.TDLS_bAPSDAC_VI = TDLS_UAPSD_CmdUtilNumGet(&pArgv);
+sta/tdls_uapsd.c:	pAd->CommonCfg.TDLS_bAPSDAC_VO = TDLS_UAPSD_CmdUtilNumGet(&pArgv);
+sta/tdls_uapsd.c:	pAd->CommonCfg.TDLS_MaxSPLength = TDLS_UAPSD_CmdUtilNumGet(&pArgv);
+sta/tdls_uapsd.c:			pAd->CommonCfg.TDLS_bAPSDAC_BE,
+sta/tdls_uapsd.c:			pAd->CommonCfg.TDLS_bAPSDAC_BK,
+sta/tdls_uapsd.c:			pAd->CommonCfg.TDLS_bAPSDAC_VI,
+sta/tdls_uapsd.c:			pAd->CommonCfg.TDLS_bAPSDAC_VO,
+sta/tdls_uapsd.c:			pAd->CommonCfg.TDLS_MaxSPLength));
+sta/tdls_uapsd.c:			pAd->Mlme.ChannelQuality = 0;
+sta/tdls_uapsd.c:			if (pAd->StaCfg.bAutoConnectByBssid)
+sta/tdls_uapsd.c:			   pAd->StaCfg.bAutoConnectByBssid = FALSE;
+sta/tdls_uapsd.c:			pAd->MlmeAux.CurrReqIsFromNdis = FALSE;
+sta/tdls_uapsd.c:						pAd->CurrentAddress, TDLS_ETHERTYPE);
+sta/tdls_uapsd.c:									pTDLS->MacAddr, pAd->CurrentAddress);
+sta/tdls_uapsd.c:									pAd->CurrentAddress, pTDLS->MacAddr);
+sta/tdls_uapsd.c:						pAd->CurrentAddress, TDLS_ETHERTYPE);
+sta/tdls_uapsd.c:									pTDLS->MacAddr, pAd->CurrentAddress);
+sta/tdls_uapsd.c:									pAd->CurrentAddress, pTDLS->MacAddr);
+sta/tdls_uapsd.c:	pTDLS = (PRT_802_11_TDLS)&pAd->StaCfg.TdlsInfo.TDLSEntry[LinkId];
+sta/tdls_uapsd.c:	pTDLS = (PRT_802_11_TDLS)&pAd->StaCfg.TdlsInfo.TDLSEntry[LinkId];
+sta/tdls_uapsd.c:		if (!pAd->StaCfg.TdlsInfo.TDLSEntry[IdTdls].Valid)
+sta/tdls_uapsd.c:			NdisMoveMemory(&pAd->StaCfg.TdlsInfo.TDLSEntry[IdTdls],
+sta/tdls_uapsd.c:						pAd->CurrentAddress, TDLS_ETHERTYPE);
+sta/tdls_uapsd.c:								pTDLS->MacAddr, pAd->CurrentAddress);
+sta/tdls_uapsd.c:		pAd->StaCfg.Psm = PWR_ACTIVE;
+sta/tdls_uapsd.c:		pAd->StaCfg.Psm = PWR_SAVE;
+Binary file sta/connect.o matches
+sta/dls.c:		pAd->StaCfg.DLSEntry[i].pAd = pAd;
+sta/dls.c:		RTMPInitTimer(pAd, &pAd->StaCfg.DLSEntry[i].Timer,
+sta/dls.c:	ActHeaderInit(pAd, &DlsReqHdr, pAd->CommonCfg.Bssid,
+sta/dls.c:		      pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+sta/dls.c:			  6, pAd->CurrentAddress,
+sta/dls.c:			  2, &pAd->StaActive.CapabilityInfo,
+sta/dls.c:			  1, &pAd->MlmeAux.SupRateLen,
+sta/dls.c:			  pAd->MlmeAux.SupRateLen, pAd->MlmeAux.SupRate,
+sta/dls.c:	if (pAd->MlmeAux.ExtRateLen != 0) {
+sta/dls.c:				  1, &pAd->MlmeAux.ExtRateLen,
+sta/dls.c:				  pAd->MlmeAux.ExtRateLen, pAd->MlmeAux.ExtRate,
+sta/dls.c:	if (WMODE_CAP_N(pAd->CommonCfg.PhyMode)) {
+sta/dls.c:				  HtLen, &pAd->CommonCfg.HtCapability,
+sta/dls.c:		NdisMoveMemory(&HtCapabilityTmp, &pAd->CommonCfg.HtCapability, HtLen);
+sta/dls.c:	} else if (!pAd->CommonCfg.bWmmCapable) {
+sta/dls.c:	} else if (!pAd->CommonCfg.bDLSCapable) {
+sta/dls.c:			if (pAd->StaCfg.DLSEntry[i].Valid
+sta/dls.c:					      pAd->StaCfg.DLSEntry[i].
+sta/dls.c:				if (pAd->StaCfg.AuthMode >=
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].Status =
+sta/dls.c:					RTMPCancelTimer(&pAd->StaCfg.
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].Status =
+sta/dls.c:				pAd->StaCfg.DLSEntry[i].Sequence = 0;
+sta/dls.c:				pAd->StaCfg.DLSEntry[i].TimeOut = DLSTimeOut;
+sta/dls.c:				pAd->StaCfg.DLSEntry[i].CountDownTimer =
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].bHTCap = TRUE;
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].bHTCap = FALSE;
+sta/dls.c:				pDLS = &pAd->StaCfg.DLSEntry[i];
+sta/dls.c:				if (!pAd->StaCfg.DLSEntry[i].Valid) {
+sta/dls.c:					if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) {
+sta/dls.c:						pAd->StaCfg.DLSEntry[i].Status = DLS_WAIT_KEY;
+sta/dls.c:						RTMPCancelTimer(&pAd->StaCfg.DLSEntry[i].Timer, &TimerCancelled);
+sta/dls.c:						pAd->StaCfg.DLSEntry[i].Status = DLS_FINISH;
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].Sequence = 0;
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].Valid = TRUE;
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].TimeOut = DLSTimeOut;
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].CountDownTimer = DLSTimeOut;
+sta/dls.c:					NdisMoveMemory(pAd->StaCfg.DLSEntry[i].MacAddr, SA, MAC_ADDR_LEN);
+sta/dls.c:						pAd->StaCfg.DLSEntry[i].bHTCap = TRUE;
+sta/dls.c:						pAd->StaCfg.DLSEntry[i].bHTCap = FALSE;
+sta/dls.c:					pDLS = &pAd->StaCfg.DLSEntry[i];
+sta/dls.c:					pEntry->MaxSupportedRate = min(pAd->CommonCfg.MaxTxRate, MaxSupportedRate);
+sta/dls.c:					if ((HtCapabilityLen != 0) && WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+sta/dls.c:						ht_mode_adjust(pAd, pEntry, &HtCapability, &pAd->CommonCfg.DesiredHtPhy);
+sta/dls.c:						pEntry->MaxHTPhyMode.field.MCS = get_ht_max_mcs(pAd, &pAd->StaCfg.DesiredHtPhyInfo.MCSSet[0], &HtCapability.MCSSet[0]);
+sta/dls.c:						if (pAd->StaCfg.DesiredTransmitSetting.field.MCS != MCS_AUTO) {
+sta/dls.c:								 ("@@@ pAd->CommonCfg.RegTransmitSetting.field.MCS = %d\n",
+sta/dls.c:								  pAd->StaCfg.DesiredTransmitSetting.field.MCS));
+sta/dls.c:							set_ht_fixed_mcs(pAd, pEntry, pAd->StaCfg.DesiredTransmitSetting.field.MCS, pAd->StaCfg.HTPhyMode.field.MCS);
+sta/dls.c:						pEntry->MaxHTPhyMode.field.STBC = (HtCapability.HtCapInfo.RxSTBC & (pAd->CommonCfg.DesiredHtPhy.TxSTBC));
+sta/dls.c:						if (pAd->CommonCfg.bRdg
+sta/dls.c:					if (pAd->StaCfg.bAutoTxRateSwitch == TRUE) {
+sta/dls.c:						pEntry->HTPhyMode.field.MODE = pAd->StaCfg.HTPhyMode.field.MODE;
+sta/dls.c:						pEntry->HTPhyMode.field.MCS = pAd->StaCfg.HTPhyMode.field.MCS;
+sta/dls.c:						RTMPUpdateLegacyTxSetting((UCHAR) pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode, pEntry);
+sta/dls.c:	ActHeaderInit(pAd, &DlsRspHdr, pAd->CommonCfg.Bssid,
+sta/dls.c:		      pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+sta/dls.c:				  6, pAd->CurrentAddress,
+sta/dls.c:				  2, &pAd->StaActive.CapabilityInfo,
+sta/dls.c:				  1, &pAd->MlmeAux.SupRateLen,
+sta/dls.c:				  pAd->MlmeAux.SupRateLen, pAd->MlmeAux.SupRate,
+sta/dls.c:		if (pAd->MlmeAux.ExtRateLen != 0) {
+sta/dls.c:					  1, &pAd->MlmeAux.ExtRateLen,
+sta/dls.c:					  pAd->MlmeAux.ExtRateLen,
+sta/dls.c:					  pAd->MlmeAux.ExtRate, END_OF_ARGS);
+sta/dls.c:		if (WMODE_CAP_N(pAd->CommonCfg.PhyMode)) {
+sta/dls.c:					  HtLen, &pAd->CommonCfg.HtCapability,
+sta/dls.c:			NdisMoveMemory(&HtCapabilityTmp, &pAd->CommonCfg.HtCapability, HtLen);
+sta/dls.c:				  6, SA, 6, pAd->CurrentAddress, END_OF_ARGS);
+sta/dls.c:	if (!pAd->CommonCfg.bDLSCapable)
+sta/dls.c:		if (pAd->StaCfg.DLSEntry[i].Valid
+sta/dls.c:		    && MAC_ADDR_EQUAL(SA, pAd->StaCfg.DLSEntry[i].MacAddr)) {
+sta/dls.c:				pEntry->MaxSupportedRate = min(pAd->CommonCfg.MaxTxRate, MaxSupportedRate);
+sta/dls.c:				if ((HtCapabilityLen != 0) && WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+sta/dls.c:					ht_mode_adjust(pAd, pEntry, &HtCapability, &pAd->CommonCfg.DesiredHtPhy);
+sta/dls.c:					pEntry->MaxHTPhyMode.field.MCS = get_ht_max_mcs(pAd, &pAd->StaCfg.DesiredHtPhyInfo.MCSSet[0], &HtCapability.MCSSet[0]);
+sta/dls.c:					if (pAd->StaCfg.DesiredTransmitSetting.field.MCS != MCS_AUTO)
+sta/dls.c:						set_ht_fixed_mcs(pAd, pEntry, pAd->StaCfg.DesiredTransmitSetting.field.MCS, pAd->StaCfg.HTPhyMode.field.MCS);
+sta/dls.c:					pEntry->MaxHTPhyMode.field.STBC = (HtCapability.HtCapInfo.RxSTBC & (pAd->CommonCfg.DesiredHtPhy.TxSTBC));
+sta/dls.c:					if (pAd->CommonCfg.bRdg
+sta/dls.c:				if (pAd->StaCfg.bAutoTxRateSwitch == TRUE) {
+sta/dls.c:					pEntry->HTPhyMode.field.MODE = pAd->StaCfg.HTPhyMode.field.MODE;
+sta/dls.c:					pEntry->HTPhyMode.field.MCS = pAd->StaCfg.HTPhyMode.field.MCS;
+sta/dls.c:					RTMPUpdateLegacyTxSetting((UCHAR) pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode,
+sta/dls.c:				if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) {
+sta/dls.c:					     pAd->StaCfg.DLSEntry[i].MacAddr) != NDIS_STATUS_SUCCESS) {
+sta/dls.c:							    &pAd->StaCfg.DLSEntry[i],
+sta/dls.c:						pAd->StaCfg.DLSEntry[i].Status =DLS_NONE;
+sta/dls.c:						pAd->StaCfg.DLSEntry[i].Valid =FALSE;
+sta/dls.c:						pAd->StaCfg.DLSEntry[i].Status = DLS_WAIT_KEY;
+sta/dls.c:					RTMPCancelTimer(&pAd->StaCfg.DLSEntry[i].Timer, &TimerCancelled);
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].Status = DLS_FINISH;
+sta/dls.c:				pAd->StaCfg.DLSEntry[i].Sequence = 0;
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].bHTCap = TRUE;
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].bHTCap = FALSE;
+sta/dls.c:				pAd->StaCfg.DLSEntry[i].Status = DLS_NONE;
+sta/dls.c:				pAd->StaCfg.DLSEntry[i].Valid = FALSE;
+sta/dls.c:				RTMPCancelTimer(&pAd->StaCfg.DLSEntry[i].Timer,
+sta/dls.c:			if (pAd->StaCfg.DLSEntry[i].Valid
+sta/dls.c:			    && MAC_ADDR_EQUAL(SA, pAd->StaCfg.DLSEntry[i].MacAddr)) {
+sta/dls.c:					pEntry->MaxSupportedRate = min(pAd->CommonCfg.MaxTxRate, MaxSupportedRate);
+sta/dls.c:					if ((HtCapabilityLen != 0) && WMODE_CAP_N(pAd->CommonCfg.PhyMode)) {
+sta/dls.c:						if ((HtCapability.HtCapInfo.GF) && (pAd->CommonCfg.DesiredHtPhy.GF)) {
+sta/dls.c:							pAd->MacTab.fAnyStationNonGF = TRUE;
+sta/dls.c:							pAd->CommonCfg.AddHTInfo.AddHtInfo2.NonGfPresent = 1;
+sta/dls.c:						if ((HtCapability.HtCapInfo.ChannelWidth) && (pAd->CommonCfg.DesiredHtPhy.ChannelWidth)) {
+sta/dls.c:							pEntry->MaxHTPhyMode.field.ShortGI = ((pAd->CommonCfg.DesiredHtPhy.ShortGIfor40) & (HtCapability.HtCapInfo.ShortGIfor40));
+sta/dls.c:							pEntry->MaxHTPhyMode.field.ShortGI = ((pAd->CommonCfg.DesiredHtPhy.ShortGIfor20) & (HtCapability.HtCapInfo.ShortGIfor20));
+sta/dls.c:							pAd->MacTab.fAnyStation20Only = TRUE;
+sta/dls.c:						pEntry->MaxHTPhyMode.field.MCS = get_ht_max_mcs(pAd, &pAd->StaCfg.DesiredHtPhyInfo.MCSSet[0], &HtCapability.MCSSet[0]);
+sta/dls.c:						if (pAd->StaCfg.DesiredTransmitSetting.field.MCS != MCS_AUTO) {
+sta/dls.c:								 ("@@@ pAd->CommonCfg.RegTransmitSetting.field.MCS = %d\n",
+sta/dls.c:								  pAd->StaCfg.DesiredTransmitSetting.field.MCS));
+sta/dls.c:								set_ht_fixed_mcs(pAd, pEntry, pAd->StaCfg.DesiredTransmitSetting.field.MCS, pAd->StaCfg.HTPhyMode.field.MCS);
+sta/dls.c:						pEntry->MaxHTPhyMode.field.STBC = (HtCapability.HtCapInfo.RxSTBC & (pAd->CommonCfg.DesiredHtPhy.TxSTBC));
+sta/dls.c:						if (pAd->CommonCfg.bRdg && HtCapability.ExtHtCapInfo.RDGSupport)
+sta/dls.c:					if (pAd->StaCfg.bAutoTxRateSwitch == TRUE) {
+sta/dls.c:						pEntry->HTPhyMode.field.MODE = pAd->StaCfg.HTPhyMode.field.MODE;
+sta/dls.c:						pEntry->HTPhyMode.field.MCS = pAd->StaCfg.HTPhyMode.field.MCS;
+sta/dls.c:						RTMPUpdateLegacyTxSetting((UCHAR) pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode, pEntry);
+sta/dls.c:					if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) {
+sta/dls.c:						    (pAd, pAd->StaCfg.DLSEntry[i].MacAddr) != NDIS_STATUS_SUCCESS) {
+sta/dls.c:								    &pAd->StaCfg.DLSEntry[i],
+sta/dls.c:							pAd->StaCfg.DLSEntry[i].Status = DLS_NONE;
+sta/dls.c:							pAd->StaCfg.DLSEntry[i].Valid = FALSE;
+sta/dls.c:							pAd->StaCfg.DLSEntry[i].Status = DLS_WAIT_KEY;
+sta/dls.c:						RTMPCancelTimer(&pAd->StaCfg.DLSEntry[i].Timer, &TimerCancelled);
+sta/dls.c:						pAd->StaCfg.DLSEntry[i].Status = DLS_FINISH;
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].Sequence = 0;
+sta/dls.c:						pAd->StaCfg.DLSEntry[i].bHTCap = TRUE;
+sta/dls.c:						pAd->StaCfg.DLSEntry[i].bHTCap = FALSE;
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].Status = DLS_NONE;
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].Valid = FALSE;
+sta/dls.c:					RTMPCancelTimer(&pAd->StaCfg.DLSEntry[i].Timer, &TimerCancelled);
+sta/dls.c:	ActHeaderInit(pAd, &DlsTearDownHdr, pAd->CommonCfg.Bssid,
+sta/dls.c:		      pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+sta/dls.c:			  6, pAd->CurrentAddress, 2, &ReasonCode, END_OF_ARGS);
+sta/dls.c:		    (pDLS->MacAddr, pAd->StaCfg.DLSEntry[i].MacAddr)) {
+sta/dls.c:					       pAd->StaCfg.DLSEntry[i].MacTabMatchWCID,
+sta/dls.c:					       pAd->StaCfg.DLSEntry[i].MacAddr);
+sta/dls.c:		    (pDLS->MacAddr, pAd->StaCfg.DLSEntry[i].MacAddr)) {
+sta/dls.c:			pAd->StaCfg.DLSEntry[i].Status = DLS_NONE;
+sta/dls.c:			pAd->StaCfg.DLSEntry[i].Valid = FALSE;
+sta/dls.c:			RTMPCancelTimer(&pAd->StaCfg.DLSEntry[i].Timer,
+sta/dls.c:					       pAd->StaCfg.DLSEntry[i].MacTabMatchWCID,
+sta/dls.c:					       pAd->StaCfg.DLSEntry[i].MacAddr);
+sta/dls.c:	if (!pAd->CommonCfg.bDLSCapable)
+sta/dls.c:		if (pAd->StaCfg.DLSEntry[i].Valid
+sta/dls.c:		    && MAC_ADDR_EQUAL(SA, pAd->StaCfg.DLSEntry[i].MacAddr)) {
+sta/dls.c:			pAd->StaCfg.DLSEntry[i].Status = DLS_NONE;
+sta/dls.c:			pAd->StaCfg.DLSEntry[i].Valid = FALSE;
+sta/dls.c:			RTMPCancelTimer(&pAd->StaCfg.DLSEntry[i].Timer,
+sta/dls.c:			/*AsicDelWcidTab(pAd, pAd->StaCfg.DLSEntry[i].MacTabMatchWCID); */
+sta/dls.c:			/*AsicRemovePairwiseKeyEntry(pAd, pAd->StaCfg.DLSEntry[i].MacTabMatchWCID); */
+sta/dls.c:					       pAd->StaCfg.DLSEntry[i].MacTabMatchWCID,
+sta/dls.c:					       pAd->StaCfg.DLSEntry[i].MacAddr);
+sta/dls.c:		if (pAd->StaCfg.DLSEntry[i].Valid
+sta/dls.c:		    && MAC_ADDR_EQUAL(SA, pAd->StaCfg.DLSEntry[i].MacAddr)) {
+sta/dls.c:			pAd->StaCfg.DLSEntry[i].Status = DLS_NONE;
+sta/dls.c:			pAd->StaCfg.DLSEntry[i].Valid = FALSE;
+sta/dls.c:			RTMPCancelTimer(&pAd->StaCfg.DLSEntry[i].Timer,
+sta/dls.c:			/*AsicDelWcidTab(pAd, pAd->StaCfg.DLSEntry[i].MacTabMatchWCID); */
+sta/dls.c:			/*AsicRemovePairwiseKeyEntry(pAd, pAd->StaCfg.DLSEntry[i].MacTabMatchWCID); */
+sta/dls.c:					       pAd->StaCfg.DLSEntry[i].MacTabMatchWCID,
+sta/dls.c:					       pAd->StaCfg.DLSEntry[i].MacAddr);
+sta/dls.c:	if (!pAd->CommonCfg.bDLSCapable)
+sta/dls.c:		if ((pAd->StaCfg.DLSEntry[i].Valid)
+sta/dls.c:		    && (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH)
+sta/dls.c:		    && (pAd->StaCfg.DLSEntry[i].TimeOut != 0)) {
+sta/dls.c:			pAd->StaCfg.DLSEntry[i].CountDownTimer--;
+sta/dls.c:			if (pAd->StaCfg.DLSEntry[i].CountDownTimer == 0) {
+sta/dls.c:				pAd->StaCfg.DLSEntry[i].Valid = FALSE;
+sta/dls.c:				pAd->StaCfg.DLSEntry[i].Status = DLS_NONE;
+sta/dls.c:					    &pAd->StaCfg.DLSEntry[i], reason);
+sta/dls.c:		if ((pAd->StaCfg.DLSEntry[i].Valid)
+sta/dls.c:		    && (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH)
+sta/dls.c:		    && (pAd->StaCfg.DLSEntry[i].TimeOut != 0)) {
+sta/dls.c:			pAd->StaCfg.DLSEntry[i].CountDownTimer--;
+sta/dls.c:			if (pAd->StaCfg.DLSEntry[i].CountDownTimer == 0) {
+sta/dls.c:				pAd->StaCfg.DLSEntry[i].Valid = FALSE;
+sta/dls.c:				pAd->StaCfg.DLSEntry[i].Status = DLS_NONE;
+sta/dls.c:					    &pAd->StaCfg.DLSEntry[i], reason);
+sta/dls.c:	if (!pAd->CommonCfg.bDLSCapable)
+sta/dls.c:	    && (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)) {
+sta/dls.c:			      pAd->StaCfg.ReplayCounter,
+sta/dls.c:			/*RTMPMoveMemory(pAd->StaCfg.ReplayCounter, pEap->KeyDesc.ReplayCounter, LEN_KEY_DESC_REPLAY); */
+sta/dls.c:			RTMPMoveMemory(pAd->StaCfg.DlsReplayCounter,
+sta/dls.c:				  pAd->StaCfg.ReplayCounter[0],
+sta/dls.c:				  pAd->StaCfg.ReplayCounter[1],
+sta/dls.c:				  pAd->StaCfg.ReplayCounter[2],
+sta/dls.c:				  pAd->StaCfg.ReplayCounter[3],
+sta/dls.c:				  pAd->StaCfg.ReplayCounter[4],
+sta/dls.c:				  pAd->StaCfg.ReplayCounter[5],
+sta/dls.c:				  pAd->StaCfg.ReplayCounter[6],
+sta/dls.c:				  pAd->StaCfg.ReplayCounter[7], Len,
+sta/dls.c:			if (pAd->StaCfg.PortSecured ==
+sta/dls.c:			WpaDerivePTK(pAd, temp, temp, pAd->CommonCfg.Bssid,
+sta/dls.c:				     temp, pAd->CurrentAddress, DlsPTK, LEN_PTK);
+sta/dls.c:			if (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled) {
+sta/dls.c:			RTMPMoveMemory(pAd->StaCfg.DlsReplayCounter,
+sta/dls.c:				  pAd->StaCfg.ReplayCounter[0],
+sta/dls.c:				  pAd->StaCfg.ReplayCounter[1],
+sta/dls.c:				  pAd->StaCfg.ReplayCounter[2],
+sta/dls.c:				  pAd->StaCfg.ReplayCounter[3],
+sta/dls.c:				  pAd->StaCfg.ReplayCounter[4],
+sta/dls.c:				  pAd->StaCfg.ReplayCounter[5],
+sta/dls.c:				  pAd->StaCfg.ReplayCounter[6],
+sta/dls.c:				  pAd->StaCfg.ReplayCounter[7], Len,
+sta/dls.c:		if (pAd->StaCfg.DLSEntry[i].Valid
+sta/dls.c:		    && MAC_ADDR_EQUAL(pAddr, pAd->StaCfg.DLSEntry[i].MacAddr)) {
+sta/dls.c:				pAd->StaCfg.DLSEntry[i].Status = DLS_FINISH;
+sta/dls.c:				RTMPCancelTimer(&pAd->StaCfg.DLSEntry[i].Timer,
+sta/dls.c:				if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
+sta/dls.c:				else if (pAd->StaCfg.PairCipher == Ndis802_11Encryption3Enabled)
+sta/dls.c:							pAd->StaCfg.DLSEntry[i].MacAddr, TRUE);
+sta/dls.c:							     (UCHAR) pAd->StaCfg.DLSEntry[i].MacTabMatchWCID,
+sta/dls.c:						       (UCHAR) pAd->StaCfg.DLSEntry[i].MacTabMatchWCID,
+sta/dls.c:				RTMPSendSTAKeyHandShake(pAd, pAd->StaCfg.DLSEntry[i].MacAddr);
+sta/dls.c:				if (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH) {
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].CountDownTimer = pAd->StaCfg.DLSEntry[i].TimeOut;
+sta/dls.c:		if (pAd->StaCfg.DLSEntry[i].Valid
+sta/dls.c:		    && MAC_ADDR_EQUAL(pAddr, pAd->StaCfg.DLSEntry[i].MacAddr)) {
+sta/dls.c:				pAd->StaCfg.DLSEntry[i].Status = DLS_FINISH;
+sta/dls.c:				RTMPCancelTimer(&pAd->StaCfg.DLSEntry[i].Timer, &TimerCancelled);
+sta/dls.c:				/*PairwiseKey.CipherAlg = pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].CipherAlg; */
+sta/dls.c:				if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
+sta/dls.c:				else if (pAd->StaCfg.PairCipher == Ndis802_11Encryption3Enabled)
+sta/dls.c:							pAd->StaCfg.DLSEntry[i].MacAddr, TRUE);
+sta/dls.c:							     (UCHAR) pAd->StaCfg.DLSEntry[i].MacTabMatchWCID,
+sta/dls.c:						       (UCHAR) pAd->StaCfg.DLSEntry[i].MacTabMatchWCID,
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].Valid = FALSE;
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].Status = DLS_NONE;
+sta/dls.c:						    &pAd->StaCfg.DLSEntry[i],
+sta/dls.c:				if (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH) {
+sta/dls.c:					pAd->StaCfg.DLSEntry[i].CountDownTimer = pAd->StaCfg.DLSEntry[i].TimeOut;
+sta/dls.c:	if (!pAd->CommonCfg.bDLSCapable)
+sta/dls.c:			if (pAd->StaCfg.DLSEntry[i].Valid
+sta/dls.c:			    && (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH)
+sta/dls.c:			    && MAC_ADDR_EQUAL(pDA, pAd->StaCfg.DLSEntry[i].MacAddr)) {
+sta/dls.c:			if (pAd->StaCfg.DLSEntry[i].Valid
+sta/dls.c:			    && (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH)
+sta/dls.c:			    && MAC_ADDR_EQUAL(pDA, pAd->StaCfg.DLSEntry[i].MacAddr)) {
+sta/dls.c:	ActHeaderInit(pAd, &DlsTearDownHdr, pAd->CommonCfg.Bssid,
+sta/dls.c:		      pAd->CurrentAddress, pAd->CommonCfg.Bssid);
+sta/dls.c:			  pAd->CurrentAddress, 2, &Reason, END_OF_ARGS);
+sta/dls.c:		if (pAd->StaCfg.DLSEntry[i].Valid
+sta/dls.c:		    && (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH)
+sta/dls.c:		    && MAC_ADDR_EQUAL(pDA, pAd->StaCfg.DLSEntry[i].MacAddr)) {
+sta/dls.c:					       pAd->StaCfg.DLSEntry[i].MacTabMatchWCID,
+sta/dls.c:					       pAd->StaCfg.DLSEntry[i].MacAddr);
+sta/dls.c:		if (pAd->StaCfg.DLSEntry[i].Valid
+sta/dls.c:		    && (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH)
+sta/dls.c:		    && MAC_ADDR_EQUAL(pDA, pAd->StaCfg.DLSEntry[i].MacAddr)) {
+sta/dls.c:					       pAd->StaCfg.DLSEntry[i].MacTabMatchWCID,
+sta/dls.c:					       pAd->StaCfg.DLSEntry[i].MacAddr);
+sta/dls.c:	pAd->Sequence++;
+sta/dls.c:	MAKE_802_3_HEADER(Header802_3, pAd->CommonCfg.Bssid,
+sta/dls.c:			  pAd->CurrentAddress, EAPOL);
+sta/dls.c:	if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA)
+sta/dls.c:	    || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK)) {
+sta/dls.c:	} else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
+sta/dls.c:		   || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)) {
+sta/dls.c:	    (((pAd->StaCfg.PairCipher == Ndis802_11Encryption3Enabled)
+sta/dls.c:	      || (pAd->StaCfg.GroupCipher ==
+sta/dls.c:		       pAd->StaCfg.DlsReplayCounter, LEN_KEY_DESC_REPLAY);
+sta/dls.c:	WpaDerivePTK(pAd, temp, temp, pAd->CommonCfg.Bssid, temp,
+sta/dls.c:		     pAd->CurrentAddress, DlsPTK, LEN_PTK);
+sta/dls.c:	if (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled) {
+sta/dls.c:	pAd->Sequence++;
+sta/dls.c:	MAKE_802_3_HEADER(Header802_3, pAd->CommonCfg.Bssid,
+sta/dls.c:			  pAd->CurrentAddress, EAPOL);
+sta/dls.c:	if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA)
+sta/dls.c:	    || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK)) {
+sta/dls.c:	} else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
+sta/dls.c:		   || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)) {
+sta/dls.c:	    (((pAd->StaCfg.PairCipher == Ndis802_11Encryption3Enabled)
+sta/dls.c:	      || (pAd->StaCfg.GroupCipher ==
+sta/dls.c:		       pAd->StaCfg.DlsReplayCounter, LEN_KEY_DESC_REPLAY);
+sta/dls.c:	WpaDerivePTK(pAd, temp, temp, pAd->CommonCfg.Bssid, temp,
+sta/dls.c:		     pAd->CurrentAddress, DlsPTK, LEN_PTK);
+sta/dls.c:	if (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled) {
+sta/dls.c:Mesh entry also insert to pAd->MacTab.content[].
+sta/dls.c:	if (pAd->MacTab.Size >= MAX_LEN_OF_MAC_TABLE)
+sta/dls.c:			pAd->StaCfg.DLSEntry[DlsEntryIdx].MacTabMatchWCID = pEntry->Aid;
+sta/dls.c:			pEntry->AuthMode = pAd->StaCfg.AuthMode;
+sta/dls.c:			pEntry->WepStatus = pAd->StaCfg.WepStatus;
+sta/dls.c:				  pEntry->Aid, pAd->MacTab.Size));
+sta/dls.c:			    && (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled)) {
+sta/dls.c:				UCHAR KeyIdx = pAd->StaCfg.DefaultKeyId;
+sta/dls.c:				CipherAlg = pAd->SharedKey[BSS0][KeyIdx].CipherAlg;
+sta/dls.c:							pAd->StaCfg.DefaultKeyId,
+sta/dls.c:							pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].CipherAlg, pEntry->Aid,
+sta/dls.c:		Delete all Mesh Entry in pAd->MacTab
+sta/dls.c:	RTMP_SEM_LOCK(&pAd->MacTabLock);
+sta/dls.c:	pEntry = pAd->MacTab.Hash[HashIdx];
+sta/dls.c:	RTMP_SEM_UNLOCK(&pAd->MacTabLock);
+sta/dls.c:	RTMP_SEM_LOCK(&pAd->MacTabLock);
+sta/dls.c:		pCurEntry = &pAd->MacTab.Content[wcid];
+sta/dls.c:	RTMP_SEM_UNLOCK(&pAd->MacTabLock);
+sta/dls.c:		if ((pAd->StaCfg.DLSEntry[i].Valid)
+sta/dls.c:		    && (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH)) {
+sta/dls.c:			    &pAd->MacTab.Content[pAd->StaCfg.DLSEntry[i].MacTabMatchWCID];
+sta/dls.c:				  PRINT_MAC(pAd->StaCfg.DLSEntry[i].MacAddr)));
+sta/dls.c:				 ("%-8d\n", pAd->StaCfg.DLSEntry[i].TimeOut));
+sta/sync.c:	RTMPInitTimer(pAd, &pAd->MlmeAux.BeaconTimer, GET_TIMER_FUNCTION(BeaconTimeout), pAd, FALSE);
+sta/sync.c:	RTMPInitTimer(pAd, &pAd->MlmeAux.ScanTimer, GET_TIMER_FUNCTION(ScanTimeout), pAd, FALSE);
+sta/sync.c:	if ((pAd->CommonCfg.BBPCurrentBW == BW_40)
+sta/sync.c:		AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
+sta/sync.c:		AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
+sta/sync.c:									pAd->CommonCfg.CentralChannel, pAd->ScanTab.BssNr));
+sta/sync.c:		pAd->MlmeAux.Channel = 0;
+sta/sync.c:	POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+sta/sync.c:		(pAd->StaCfg.bRadio == TRUE) &&
+sta/sync.c:	RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &TimerCancelled);
+sta/sync.c:	RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &TimerCancelled);
+sta/sync.c:		RTMPZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
+sta/sync.c:		NdisMoveMemory(pAd->MlmeAux.Ssid, pAd->StaCfg.ConnectinfoSsid, pAd->StaCfg.ConnectinfoSsidLen);	
+sta/sync.c:		pAd->MlmeAux.SsidLen = pAd->StaCfg.ConnectinfoSsidLen;
+sta/sync.c:	pAd->MlmeAux.BssType = pAd->StaCfg.ConnectinfoBssType;
+sta/sync.c:	pAd->MlmeAux.Channel = pAd->StaCfg.ConnectinfoChannel;
+sta/sync.c:	AsicSetChannel(pAd, pAd->MlmeAux.Channel, BW_20, EXTCHA_NONE, FALSE);
+sta/sync.c:	RTMPSetTimer(&pAd->MlmeAux.BeaconTimer, JOIN_TIMEOUT);
+sta/sync.c:		if (pAd->MlmeAux.Channel <= 14)
+sta/sync.c:			pSupRate = pAd->CommonCfg.SupRate;
+sta/sync.c:			SupRateLen = pAd->CommonCfg.SupRateLen;
+sta/sync.c:			pExtRate = pAd->CommonCfg.ExtRate;
+sta/sync.c:			ExtRateLen = pAd->CommonCfg.ExtRateLen;
+sta/sync.c:		if ((pAd->MlmeAux.BssType == BSS_INFRA)  && (!MAC_ADDR_EQUAL(ZERO_MAC_ADDR, pAd->StaCfg.ConnectinfoBssid)))
+sta/sync.c:			COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pAd->StaCfg.ConnectinfoBssid);
+sta/sync.c:			MgtMacHeaderInit(pAd, &Hdr80211, SUBTYPE_PROBE_REQ, 0, pAd->MlmeAux.Bssid,
+sta/sync.c:                                                                pAd->CurrentAddress,
+sta/sync.c:								pAd->MlmeAux.Bssid);
+sta/sync.c:                                                                pAd->CurrentAddress,
+sta/sync.c:						  1,                        &pAd->MlmeAux.SsidLen,
+sta/sync.c:						  pAd->MlmeAux.SsidLen,	    pAd->MlmeAux.Ssid,
+sta/sync.c:		if ((pAd->OpMode == OPMODE_STA) &&
+sta/sync.c:			(pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE) &&
+sta/sync.c:			(pAd->StaCfg.WpsProbeReqIeLen != 0))
+sta/sync.c:							pAd->StaCfg.WpsProbeReqIeLen,	pAd->StaCfg.pWpsProbeReqIe,
+sta/sync.c:		pAd->StaCfg.ConnectinfoChannel, PRINT_MAC(pAd->StaCfg.ConnectinfoBssid)));
+sta/sync.c:	pAd->Mlme.SyncMachine.CurrState = JOIN_WAIT_BEACON;
+sta/sync.c:                if (pAd->ApCfg.ApCliTab[MAIN_MBSSID].Valid && RTMP_CFG80211_VIF_P2P_CLI_ON(pAd))
+sta/sync.c:							  pAd->CommonCfg.TxRate, 
+sta/sync.c:		pAd->StaCfg.LastScanTime = Now;
+sta/sync.c:		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &TimerCancelled);
+sta/sync.c:		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &TimerCancelled);
+sta/sync.c:		pAd->MlmeAux.BssType = BssType;
+sta/sync.c:		pAd->MlmeAux.ScanType = ScanType;
+sta/sync.c:		pAd->MlmeAux.SsidLen = SsidLen;
+sta/sync.c:       	 NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
+sta/sync.c:		NdisMoveMemory(pAd->MlmeAux.Ssid, Ssid, SsidLen);
+sta/sync.c:		if ((pAd->StaCfg.bImprovedScan) && (pAd->Mlme.SyncMachine.CurrState == SCAN_PENDING))
+sta/sync.c:			pAd->MlmeAux.Channel = pAd->StaCfg.LastScanChannel;
+sta/sync.c:			if (pAd->StaCfg.bFastConnect && (pAd->CommonCfg.Channel != 0) && !pAd->StaCfg.bNotFirstScan)
+sta/sync.c:		pAd->MlmeAux.Channel = pAd->CommonCfg.Channel;
+sta/sync.c:				pAd->MlmeAux.Channel = FirstChannel(pAd);
+sta/sync.c:		if(pAd->StaCfg.ConnectinfoChannel != 0)
+sta/sync.c:			pAd->MlmeAux.Channel = 0;
+sta/sync.c:		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_SCAN_FOR_CONNECT;
+sta/sync.c:		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+sta/sync.c:                if (pAd->ApCfg.ApCliTab[MAIN_MBSSID].Valid && RTMP_CFG80211_VIF_P2P_CLI_ON(pAd))
+sta/sync.c:							  pAd->CommonCfg.TxRate, 
+sta/sync.c:		pAd->StaCfg.LastScanTime = Now;
+sta/sync.c:		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &TimerCancelled);
+sta/sync.c:		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &TimerCancelled);
+sta/sync.c:		pAd->MlmeAux.BssType = BssType;
+sta/sync.c:		pAd->MlmeAux.ScanType = ScanType;
+sta/sync.c:		pAd->MlmeAux.SsidLen = SsidLen;
+sta/sync.c:		NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
+sta/sync.c:		NdisMoveMemory(pAd->MlmeAux.Ssid, Ssid, SsidLen);
+sta/sync.c:		if ((pAd->StaCfg.bImprovedScan) && (pAd->Mlme.SyncMachine.CurrState == SCAN_PENDING))
+sta/sync.c:			pAd->MlmeAux.Channel = pAd->StaCfg.LastScanChannel;
+sta/sync.c:		else if (pAd->P2pCfg.CtrlCurrentState == P2P_CTRL_DISCOVERY)
+sta/sync.c:			pAd->MlmeAux.Channel = 1;
+sta/sync.c:			if (pAd->StaCfg.bFastConnect && (pAd->CommonCfg.Channel != 0) && !pAd->StaCfg.bNotFirstScan)
+sta/sync.c:				pAd->MlmeAux.Channel = pAd->CommonCfg.Channel;
+sta/sync.c:					pAd->MlmeAux.Channel = FirstChannel(pAd);
+sta/sync.c:		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+sta/sync.c:	POS_COOKIE  pObj = (POS_COOKIE) pAd->OS_Cookie;
+sta/sync.c:		(pAd->StaCfg.bRadio == TRUE) &&
+sta/sync.c:	RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &TimerCancelled);
+sta/sync.c:	RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &TimerCancelled);
+sta/sync.c:	pBss = &pAd->MlmeAux.SsidBssTab.BssEntry[pInfo->BssIdx];
+sta/sync.c:	COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pBss->Bssid);
+sta/sync.c:		RTMPZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
+sta/sync.c:		NdisMoveMemory(pAd->MlmeAux.Ssid, pBss->Ssid, pBss->SsidLen);	
+sta/sync.c:		pAd->MlmeAux.SsidLen = pBss->SsidLen;
+sta/sync.c:	pAd->MlmeAux.BssType = pBss->BssType;
+sta/sync.c:	pAd->MlmeAux.Channel = pBss->Channel;
+sta/sync.c:	pAd->MlmeAux.CentralChannel = pBss->CentralChannel;
+sta/sync.c:	if ((pAd->StaCfg.IEEE80211dClientMode != Rt802_11_D_None) &&
+sta/sync.c:		NdisMoveMemory(&pAd->CommonCfg.CountryCode[0], &pBss->CountryString[0], 2);
+sta/sync.c:			pAd->CommonCfg.Geography = IDOR;
+sta/sync.c:			pAd->CommonCfg.Geography = ODOR;
+sta/sync.c:			pAd->CommonCfg.Geography = BOTH;
+sta/sync.c:	pApCliEntry = &pAd->ApCfg.ApCliTab[BSS0];
+sta/sync.c:	if ((P2P_GO_ON(pAd) || (pApCliEntry->Valid == TRUE)) && (pAd->CommonCfg.Channel != pAd->MlmeAux.Channel))
+sta/sync.c:		AsicSwitchChannel(pAd, pAd->MlmeAux.Channel, FALSE);
+sta/sync.c:		AsicLockChannel(pAd, pAd->MlmeAux.Channel);
+sta/sync.c:	if (pAd->MlmeAux.BssType == BSS_INFRA)
+sta/sync.c:	RTMPSetTimer(&pAd->MlmeAux.BeaconTimer, JOIN_TIMEOUT);
+sta/sync.c:		if (((pAd->CommonCfg.bIEEE80211H == 1) && 
+sta/sync.c:			(pAd->MlmeAux.Channel > 14) && 
+sta/sync.c:			RadarChannelCheck(pAd, pAd->MlmeAux.Channel))
+sta/sync.c:			|| (pAd->CommonCfg.CarrierDetect.Enable == TRUE)
+sta/sync.c:			if (pAd->MlmeAux.Channel <= 14)
+sta/sync.c:				pSupRate = pAd->CommonCfg.SupRate;
+sta/sync.c:				SupRateLen = pAd->CommonCfg.SupRateLen;
+sta/sync.c:				pExtRate = pAd->CommonCfg.ExtRate;
+sta/sync.c:				ExtRateLen = pAd->CommonCfg.ExtRateLen;
+sta/sync.c:			if (pAd->MlmeAux.BssType == BSS_INFRA)
+sta/sync.c:				MgtMacHeaderInit(pAd, &Hdr80211, SUBTYPE_PROBE_REQ, 0, pAd->MlmeAux.Bssid,
+sta/sync.c:									pAd->CurrentAddress,
+sta/sync.c:									pAd->MlmeAux.Bssid);
+sta/sync.c:									pAd->CurrentAddress,
+sta/sync.c:							  1,                        &pAd->MlmeAux.SsidLen,
+sta/sync.c:							  pAd->MlmeAux.SsidLen,	    pAd->MlmeAux.Ssid,
+sta/sync.c:			if ((pAd->StaCfg.WscControl.WscEnProbeReqIE) && 
+sta/sync.c:				(pAd->StaCfg.WscControl.WscConfMode != WSC_DISABLE) &&
+sta/sync.c:				(pAd->StaCfg.WscControl.bWscTrigger
+sta/sync.c:			else if ((pAd->StaCfg.WscControl.WscEnProbeReqIE) && 
+sta/sync.c:				(pAd->StaCfg.WscControl.WscV2Info.bEnableWpsV2))
+sta/sync.c:			if ((pAd->OpMode == OPMODE_STA) &&
+sta/sync.c:				(pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE) &&
+sta/sync.c:				(pAd->StaCfg.WpsProbeReqIeLen != 0))
+sta/sync.c:								pAd->StaCfg.WpsProbeReqIeLen,	pAd->StaCfg.pWpsProbeReqIe,
+sta/sync.c:	pAd->Mlme.SyncMachine.CurrState = JOIN_WAIT_BEACON;
+sta/sync.c:		(CHAN_PropertyCheck(pAd, pAd->MlmeAux.Channel, CHANNEL_NO_IBSS) == FALSE))
+sta/sync.c:		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &TimerCancelled);
+sta/sync.c:		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &TimerCancelled);
+sta/sync.c:		pAd->MlmeAux.BssType = BSS_ADHOC;
+sta/sync.c:		NdisMoveMemory(pAd->MlmeAux.Ssid, Ssid, SsidLen); 
+sta/sync.c:		pAd->MlmeAux.SsidLen = SsidLen;
+sta/sync.c:		if (pAd->StaCfg.IWscInfo.bDoNotChangeBSSID)
+sta/sync.c:			pAd->StaCfg.IWscInfo.bDoNotChangeBSSID = FALSE;
+sta/sync.c:			MacAddrRandomBssid(pAd, pAd->MlmeAux.Bssid);
+sta/sync.c:		Privacy = (pAd->StaCfg.WepStatus == Ndis802_11Encryption1Enabled) || 
+sta/sync.c:				  (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled) || 
+sta/sync.c:				  (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled);
+sta/sync.c:		pAd->MlmeAux.CapabilityInfo = CAP_GENERATE(0,1,Privacy, (pAd->CommonCfg.TxPreamble == Rt802_11PreambleShort), 1, 0);
+sta/sync.c:		pAd->MlmeAux.BeaconPeriod = pAd->CommonCfg.BeaconPeriod;
+sta/sync.c:		pAd->MlmeAux.AtimWin = pAd->StaCfg.AtimWin;
+sta/sync.c:		pAd->MlmeAux.Channel = pAd->CommonCfg.Channel;
+sta/sync.c:		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
+sta/sync.c:		pAd->MlmeAux.CentralChannel = pAd->CommonCfg.CentralChannel;
+sta/sync.c:		pAd->MlmeAux.SupRateLen= pAd->CommonCfg.SupRateLen;
+sta/sync.c:		NdisMoveMemory(pAd->MlmeAux.SupRate, pAd->CommonCfg.SupRate, MAX_LEN_OF_SUPPORTED_RATES);
+sta/sync.c:		RTMPCheckRates(pAd, pAd->MlmeAux.SupRate, &pAd->MlmeAux.SupRateLen);
+sta/sync.c:		pAd->MlmeAux.ExtRateLen = pAd->CommonCfg.ExtRateLen;
+sta/sync.c:		NdisMoveMemory(pAd->MlmeAux.ExtRate, pAd->CommonCfg.ExtRate, MAX_LEN_OF_SUPPORTED_RATES);
+sta/sync.c:		RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate, &pAd->MlmeAux.ExtRateLen);
+sta/sync.c:		if (WMODE_CAP_N(pAd->CommonCfg.PhyMode) && (pAd->StaCfg.bAdhocN == TRUE))
+sta/sync.c:			RTMPUpdateHTIE(&pAd->CommonCfg.DesiredHtPhy, &pAd->StaCfg.DesiredHtPhyInfo.MCSSet[0], &pAd->MlmeAux.HtCapability, &pAd->MlmeAux.AddHtInfo);
+sta/sync.c:			pAd->MlmeAux.HtCapabilityLen = sizeof(HT_CAPABILITY_IE);
+sta/sync.c:			/* Not turn pAd->StaActive.SupportedHtPhy.bHtEnable = TRUE here. */
+sta/sync.c:			DBGPRINT(RT_DEBUG_TRACE, ("SYNC -pAd->StaActive.SupportedHtPhy.bHtEnable = TRUE\n"));
+sta/sync.c:			if (WMODE_CAP_AC(pAd->CommonCfg.PhyMode) &&
+sta/sync.c:				(pAd->MlmeAux.Channel > 14))
+sta/sync.c:				build_vht_cap_ie(pAd, (UCHAR *)&pAd->MlmeAux.vht_cap);
+sta/sync.c:				pAd->MlmeAux.vht_cap_len = sizeof(VHT_CAP_IE);
+sta/sync.c:			pAd->MlmeAux.HtCapabilityLen = 0;
+sta/sync.c:			pAd->StaActive.SupportedPhyInfo.bHtEnable = FALSE;
+sta/sync.c:			NdisZeroMemory(&pAd->StaActive.SupportedPhyInfo.MCSSet[0], 16);
+sta/sync.c:		NdisZeroMemory(&pAd->MlmeAux.APEdcaParm, sizeof(EDCA_PARM));
+sta/sync.c:		NdisZeroMemory(&pAd->MlmeAux.APQbssLoad, sizeof(QBSS_LOAD_PARM));
+sta/sync.c:		NdisZeroMemory(&pAd->MlmeAux.APQosCapability, sizeof(QOS_CAPABILITY_PARM));
+sta/sync.c:		AsicSwitchChannel(pAd, pAd->MlmeAux.Channel, FALSE);
+sta/sync.c:		AsicLockChannel(pAd, pAd->MlmeAux.Channel);
+sta/sync.c:			pAd->MlmeAux.Channel, pAd->MlmeAux.SupRateLen, pAd->MlmeAux.ExtRateLen));
+sta/sync.c:		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+sta/sync.c:		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+sta/sync.c:		Idx = BssTableSearch(&pAd->ScanTab, &ie_list->Bssid[0], ie_list->Channel);
+sta/sync.c:			Rssi = pAd->ScanTab.BssEntry[Idx].Rssi;
+sta/sync.c:		Idx = BssTableSetEntry(pAd, &pAd->ScanTab, ie_list, Rssi, LenVIE, pVIE);
+sta/sync.c:			&& (pAd->CommonCfg.bBssCoexEnable == TRUE) 
+sta/sync.c:			for (chListIdx = 0; chListIdx < pAd->ChannelListNum; chListIdx++)
+sta/sync.c:				if (ie_list->Channel == pAd->ChannelList[chListIdx].Channel)
+sta/sync.c:			if (chListIdx < pAd->ChannelListNum)
+sta/sync.c:				if (pAd->ChannelList[chListIdx].bEffectedChannel == TRUE)
+sta/sync.c:					TriEventTableSetEntry(pAd, &pAd->CommonCfg.TriggerEventTab, &ie_list->Bssid[0], 
+sta/sync.c:			PBSS_ENTRY	pBssEntry = &pAd->ScanTab.BssEntry[Idx];
+sta/sync.c:			WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_G) &&
+sta/sync.c:		if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, &ie_list->Bssid[0])) 
+sta/sync.c:			RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &TimerCancelled);
+sta/sync.c:				pAd->MlmeAux.SsidLen = ie_list->SsidLen;
+sta/sync.c:				NdisMoveMemory(pAd->MlmeAux.Ssid, ie_list->Ssid, pAd->MlmeAux.SsidLen);
+sta/sync.c:					pAd->P2pTable.Client[p2pIdx].SsidLen = ie_list->SsidLen;
+sta/sync.c:					NdisMoveMemory(pAd->P2pTable.Client[p2pIdx].Ssid, ie_list->Ssid, pAd->P2pTable.Client[p2pIdx].SsidLen);
+sta/sync.c:			pAd->StaCfg.RssiSample.LastRssi0 = ConvertToRssi(pAd, Elem->Rssi0, RSSI_0, Elem->AntSel, BW_20);
+sta/sync.c:			pAd->StaCfg.RssiSample.LastRssi1 = ConvertToRssi(pAd, Elem->Rssi1, RSSI_1, Elem->AntSel, BW_20);
+sta/sync.c:			pAd->StaCfg.RssiSample.LastRssi2 = ConvertToRssi(pAd, Elem->Rssi2, RSSI_2, Elem->AntSel, BW_20);
+sta/sync.c:			pAd->StaCfg.RssiSample.AvgRssi0 = pAd->StaCfg.RssiSample.LastRssi0;
+sta/sync.c:			pAd->StaCfg.RssiSample.AvgRssi0X8	= pAd->StaCfg.RssiSample.AvgRssi0 << 3;
+sta/sync.c:			pAd->StaCfg.RssiSample.AvgRssi1 = pAd->StaCfg.RssiSample.LastRssi1;
+sta/sync.c:			pAd->StaCfg.RssiSample.AvgRssi1X8	= pAd->StaCfg.RssiSample.AvgRssi1 << 3;
+sta/sync.c:			pAd->StaCfg.RssiSample.AvgRssi2 = pAd->StaCfg.RssiSample.LastRssi2;
+sta/sync.c:			pAd->StaCfg.RssiSample.AvgRssi2X8	= pAd->StaCfg.RssiSample.AvgRssi2 << 3;
+sta/sync.c:			if (pAd->MlmeAux.SsidLen == 0)
+sta/sync.c:				NdisMoveMemory(pAd->MlmeAux.Ssid, ie_list->Ssid, ie_list->SsidLen);
+sta/sync.c:				pAd->MlmeAux.SsidLen = ie_list->SsidLen;
+sta/sync.c:				Idx = BssSsidTableSearch(&pAd->ScanTab, ie_list->Bssid,
+sta/sync.c:										pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen,
+sta/sync.c:					Idx = BssTableSetEntry(pAd, &pAd->ScanTab, ie_list, Rssi, LenVIE, pVIE);
+sta/sync.c:						NdisMoveMemory(pAd->ScanTab.BssEntry[Idx].PTSF, &Elem->Msg[24], 4);
+sta/sync.c:						NdisMoveMemory(&pAd->ScanTab.BssEntry[Idx].TTSF[0], &Elem->TimeStamp.u.LowPart, 4);
+sta/sync.c:						NdisMoveMemory(&pAd->ScanTab.BssEntry[Idx].TTSF[4], &Elem->TimeStamp.u.LowPart, 4);
+sta/sync.c:						ie_list->CapabilityInfo = pAd->ScanTab.BssEntry[Idx].CapabilityInfo;
+sta/sync.c:						pAd->ScanTab.BssEntry[Idx].MinSNR = Elem->Signal % 10;
+sta/sync.c:						if (pAd->ScanTab.BssEntry[Idx].MinSNR == 0)
+sta/sync.c:							pAd->ScanTab.BssEntry[Idx].MinSNR = -5;
+sta/sync.c:						NdisMoveMemory(pAd->ScanTab.BssEntry[Idx].MacAddr, ie_list->Addr2, MAC_ADDR_LEN);
+sta/sync.c:					if (pAd->StaCfg.WpaSupplicantUP & WPA_SUPPLICANT_ENABLE_WPS)
+sta/sync.c:					if ((pAd->StaCfg.WscControl.WscState != WSC_STATE_OFF)
+sta/sync.c:						if ((((pAd->StaCfg.WepStatus != Ndis802_11WEPDisabled) << 4) ^ ie_list->CapabilityInfo) & 0x0010)
+sta/sync.c:											pAd->StaCfg.WepStatus != Ndis802_11WEPDisabled));
+sta/sync.c:								ScanParmFill(pAd, &ScanReq, (PSTRING) pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen, BSS_ANY, SCAN_ACTIVE);
+sta/sync.c:								pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+sta/sync.c:								NdisGetSystemUpTime(&pAd->StaCfg.LastScanTime);
+sta/sync.c:					ie_list->CapabilityInfo = pAd->ScanTab.BssEntry[Idx].CapabilityInfo;
+sta/sync.c:			pAd->MlmeAux.CapabilityInfo = ie_list->CapabilityInfo & SUPPORTED_CAPABILITY_INFO;
+sta/sync.c:			pAd->MlmeAux.BssType = ie_list->BssType;
+sta/sync.c:			pAd->MlmeAux.BeaconPeriod = ie_list->BeaconPeriod;
+sta/sync.c:			if (pAd->MlmeAux.BeaconPeriod == 0)
+sta/sync.c:				pAd->MlmeAux.BeaconPeriod = 100;
+sta/sync.c:			pAd->MlmeAux.Channel = ie_list->Channel;
+sta/sync.c:			pAd->MlmeAux.AtimWin = ie_list->AtimWin;
+sta/sync.c:			pAd->MlmeAux.CfpPeriod = ie_list->CfParm.CfpPeriod;
+sta/sync.c:			pAd->MlmeAux.CfpMaxDuration = ie_list->CfParm.CfpMaxDuration;
+sta/sync.c:			pAd->MlmeAux.APRalinkIe = ie_list->RalinkIe;
+sta/sync.c:			pAd->MlmeAux.SupRateLen = ie_list->SupRateLen;
+sta/sync.c:			NdisMoveMemory(pAd->MlmeAux.SupRate, ie_list->SupRate, ie_list->SupRateLen);
+sta/sync.c:			RTMPCheckRates(pAd, pAd->MlmeAux.SupRate, &pAd->MlmeAux.SupRateLen);
+sta/sync.c:			pAd->MlmeAux.ExtRateLen = ie_list->ExtRateLen;
+sta/sync.c:			NdisMoveMemory(pAd->MlmeAux.ExtRate, ie_list->ExtRate, ie_list->ExtRateLen);
+sta/sync.c:			RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate, &pAd->MlmeAux.ExtRateLen);
+sta/sync.c:			NdisZeroMemory(pAd->StaActive.SupportedPhyInfo.MCSSet, 16);
+sta/sync.c:			NdisMoveMemory(&pAd->MlmeAux.ExtCapInfo, &ie_list->ExtCapInfo,sizeof(ie_list->ExtCapInfo));
+sta/sync.c:			DBGPRINT(RT_DEBUG_TRACE, ("MlmeAux.ExtCapInfo=%d\n", pAd->MlmeAux.ExtCapInfo.BssCoexistMgmtSupport));
+sta/sync.c:			if (pAd->CommonCfg.bBssCoexEnable == TRUE)
+sta/sync.c:				pAd->CommonCfg.ExtCapIE.BssCoexistMgmtSupport = 1;
+sta/sync.c:			if (((pAd->StaCfg.WepStatus != Ndis802_11WEPEnabled) && (pAd->StaCfg.WepStatus != Ndis802_11Encryption2Enabled))
+sta/sync.c:				|| (pAd->CommonCfg.HT_DisallowTKIP == FALSE))
+sta/sync.c:				if ((pAd->StaCfg.BssType == BSS_INFRA) || 
+sta/sync.c:					((pAd->StaCfg.BssType == BSS_ADHOC) && (pAd->StaCfg.bAdhocN == TRUE)))
+sta/sync.c:			pAd->MlmeAux.NewExtChannelOffset = ie_list->NewExtChannelOffset;
+sta/sync.c:			pAd->MlmeAux.HtCapabilityLen = ie_list->HtCapabilityLen;
+sta/sync.c:			RTMPZeroMemory(&pAd->MlmeAux.HtCapability, SIZE_HT_CAP_IE);
+sta/sync.c:				(pAd->StaCfg.DesiredHtPhyInfo.bHtEnable) &&
+sta/sync.c:				(WMODE_CAP_N(pAd->CommonCfg.PhyMode) && bAllowNrate))
+sta/sync.c:   				RTMPMoveMemory(&pAd->MlmeAux.AddHtInfo, &ie_list->AddHtInfo, SIZE_ADD_HT_INFO_IE);
+sta/sync.c:				NdisMoveMemory(pAd->StaActive.SupportedPhyInfo.MCSSet, ie_list->HtCapability.MCSSet, 16);
+sta/sync.c:				pAd->MlmeAux.NewExtChannelOffset = ie_list->NewExtChannelOffset;
+sta/sync.c:				pAd->MlmeAux.HtCapabilityLen = SIZE_HT_CAP_IE;
+sta/sync.c:				pAd->StaActive.SupportedPhyInfo.bHtEnable = TRUE;
+sta/sync.c:					pAd->StaActive.SupportedPhyInfo.bPreNHt = TRUE;
+sta/sync.c:							__FUNCTION__, pAd->StaActive.SupportedHtPhy.MpduDensity,
+sta/sync.c:							pAd->StaActive.SupportedHtPhy.MaxRAmpduFactor,
+sta/sync.c:				if (WMODE_CAP_AC(pAd->CommonCfg.PhyMode) &&
+sta/sync.c:					(pAd->MlmeAux.Channel > 14) &&
+sta/sync.c:					NdisMoveMemory(&pAd->MlmeAux.vht_cap, &ie_list->vht_cap_ie, ie_list->vht_cap_len);
+sta/sync.c:					pAd->MlmeAux.vht_cap_len = ie_list->vht_cap_len;
+sta/sync.c:					pAd->StaActive.SupportedPhyInfo.bVhtEnable = TRUE;
+sta/sync.c:						pAd->StaActive.SupportedPhyInfo.vht_bw = VHT_BW_80;
+sta/sync.c:					pAd->MlmeAux.CentralChannel = pAd->MlmeAux.Channel;
+sta/sync.c:				pAd->StaActive.SupportedPhyInfo.bHtEnable = FALSE;
+sta/sync.c:				pAd->StaActive.SupportedPhyInfo.bVhtEnable = FALSE;
+sta/sync.c:				pAd->StaActive.SupportedPhyInfo.vht_bw = VHT_BW_2040;
+sta/sync.c:				pAd->MlmeAux.NewExtChannelOffset = 0xff;
+sta/sync.c:				RTMPZeroMemory(&pAd->MlmeAux.HtCapability, SIZE_HT_CAP_IE);
+sta/sync.c:				pAd->MlmeAux.HtCapabilityLen = 0;
+sta/sync.c:				RTMPZeroMemory(&pAd->MlmeAux.AddHtInfo, SIZE_ADD_HT_INFO_IE);
+sta/sync.c:			pAd->MlmeAux.CentralChannel = CentralChannel;
+sta/sync.c:			DBGPRINT(RT_DEBUG_OFF, ("%s(): Set CentralChannel=%d\n", __FUNCTION__, pAd->MlmeAux.CentralChannel));
+sta/sync.c:			if ((pAd->CommonCfg.bWmmCapable)
+sta/sync.c:				 || WMODE_CAP_N(pAd->CommonCfg.PhyMode)
+sta/sync.c:				NdisMoveMemory(&pAd->MlmeAux.APEdcaParm, &ie_list->EdcaParm, sizeof(EDCA_PARM));
+sta/sync.c:				NdisMoveMemory(&pAd->MlmeAux.APQbssLoad, &ie_list->QbssLoad, sizeof(QBSS_LOAD_PARM));
+sta/sync.c:				NdisMoveMemory(&pAd->MlmeAux.APQosCapability, &ie_list->QosCapability, sizeof(QOS_CAPABILITY_PARM));
+sta/sync.c:				NdisZeroMemory(&pAd->MlmeAux.APEdcaParm, sizeof(EDCA_PARM));
+sta/sync.c:				NdisZeroMemory(&pAd->MlmeAux.APQbssLoad, sizeof(QBSS_LOAD_PARM));
+sta/sync.c:				NdisZeroMemory(&pAd->MlmeAux.APQosCapability, sizeof(QOS_CAPABILITY_PARM));
+sta/sync.c:								__FUNCTION__, pAd->MlmeAux.SupRateLen,
+sta/sync.c:								pAd->MlmeAux.ExtRateLen));
+sta/sync.c:				pAd->CommonCfg.TxPowerPercentage = pAd->CommonCfg.TxPowerDefault;
+sta/sync.c:			if (pAd->StaCfg.BssType == BSS_INFRA)
+sta/sync.c:				if (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40)
+sta/sync.c:											pAd->MlmeAux.Channel,
+sta/sync.c:											pAd->MlmeAux.CentralChannel);
+sta/sync.c:					pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth = BW_20;
+sta/sync.c:					pAd->MlmeAux.CentralChannel = pAd->MlmeAux.Channel;
+sta/sync.c:					pAd->MlmeAux.bBwFallBack = TRUE;
+sta/sync.c:					pAd->MlmeAux.bBwFallBack = FALSE;
+sta/sync.c:				pAd->MlmeAux.ConCurrentCentralChannel = pAd->CommonCfg.CentralChannel;
+sta/sync.c:			pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+sta/sync.c:		is_my_bssid = MAC_ADDR_EQUAL(ie_list->Bssid, pAd->CommonCfg.Bssid)? TRUE : FALSE;
+sta/sync.c:		is_my_ssid = SSID_EQUAL(ie_list->Ssid, ie_list->SsidLen, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen)? TRUE:FALSE;
+sta/sync.c:		if (pAd->Mlme.CntlMachine.CurrState == CNTL_WAIT_DISASSOC)
+sta/sync.c:		Bssidx = BssTableSearchWithSSID(&pAd->MlmeAux.SsidBssTab, ie_list->Bssid, ie_list->Ssid, ie_list->SsidLen, ie_list->Channel);
+sta/sync.c:			Bssidx = BssTableSetEntry(pAd, &pAd->MlmeAux.SsidBssTab, ie_list, RealRssi, LenVIE, pVIE);
+sta/sync.c:				PBSS_ENTRY	pBssEntry = &pAd->MlmeAux.SsidBssTab.BssEntry[Bssidx];
+sta/sync.c:		Bssidx = BssTableSearch(&pAd->ScanTab, ie_list->Bssid, ie_list->Channel);
+sta/sync.c:			Bssidx = BssTableSetEntry(pAd, &pAd->ScanTab, ie_list, RealRssi, LenVIE, pVIE);
+sta/sync.c:			NdisMoveMemory(pAd->ScanTab.BssEntry[Bssidx].PTSF, &Elem->Msg[24], 4);
+sta/sync.c:			NdisMoveMemory(&pAd->ScanTab.BssEntry[Bssidx].TTSF[0], &Elem->TimeStamp.u.LowPart, 4);
+sta/sync.c:			NdisMoveMemory(&pAd->ScanTab.BssEntry[Bssidx].TTSF[4], &Elem->TimeStamp.u.LowPart, 4);
+sta/sync.c:			pAd->ScanTab.BssEntry[Bssidx].MinSNR = Elem->Signal % 10;
+sta/sync.c:			if (pAd->ScanTab.BssEntry[Bssidx].MinSNR == 0)
+sta/sync.c:				pAd->ScanTab.BssEntry[Bssidx].MinSNR = -5;
+sta/sync.c:			NdisMoveMemory(pAd->ScanTab.BssEntry[Bssidx].MacAddr, ie_list->Addr2, MAC_ADDR_LEN);
+sta/sync.c:			if ((pAd->StaCfg.WscControl.WscConfMode != WSC_DISABLE) &&
+sta/sync.c:				(pAd->StaCfg.WscControl.bWscTrigger == TRUE))
+sta/sync.c:			if ((pAd->StaCfg.WepStatus != pAd->ScanTab.BssEntry[Bssidx].WepStatus) ||
+sta/sync.c:				(pAd->StaCfg.AuthMode != pAd->ScanTab.BssEntry[Bssidx].AuthMode))
+sta/sync.c:				if (ie_list->Bssid[i] > pAd->CommonCfg.Bssid[i])
+sta/sync.c:					COPY_MAC_ADDR(pAd->CommonCfg.Bssid, ie_list->Bssid);
+sta/sync.c:					AsicSetBssid(pAd, pAd->CommonCfg.Bssid); 
+sta/sync.c:				else if (ie_list->Bssid[i] < pAd->CommonCfg.Bssid[i])
+sta/sync.c:		pBss = &pAd->ScanTab.BssEntry[Bssidx];
+sta/sync.c:			UINT8 RXWISize = pAd->chipCap.RXWISize;
+sta/sync.c:				pAd->StaCfg.RegClass = RegClass;
+sta/sync.c:			pAd->StaCfg.DtimCount = ie_list->DtimCount;
+sta/sync.c:			pAd->StaCfg.DtimPeriod = ie_list->DtimPeriod;
+sta/sync.c:			pAd->StaCfg.LastBeaconRxTime = Now;
+sta/sync.c:				MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[BSSID_WCID];
+sta/sync.c:			Update_Rssi_Sample(pAd, &pAd->StaCfg.RssiSample, &RxWI);
+sta/sync.c:			if ((pAd->CommonCfg.bIEEE80211H == 1) &&
+sta/sync.c:				MlmeQueueInit(pAd, &pAd->Mlme.Queue);
+sta/sync.c:				BssTableInit(&pAd->ScanTab);
+sta/sync.c:				for (index = 0 ; index < pAd->ChannelListNum; index++)
+sta/sync.c:					if (pAd->ChannelList[index].Channel == ie_list->NewChannel)
+sta/sync.c:						pAd->ScanTab.BssEntry[Bssidx].Channel = ie_list->NewChannel;
+sta/sync.c:						pAd->CommonCfg.Channel = ie_list->NewChannel;
+sta/sync.c:						AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+sta/sync.c:						AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+sta/sync.c:				if (index >= pAd->ChannelListNum)
+sta/sync.c:					DBGPRINT_ERR(("PeerBeacon(can not find New Channel=%d in ChannelList[%d]\n", pAd->CommonCfg.Channel, pAd->ChannelListNum));
+sta/sync.c:			if (pAd->StaCfg.WpaSupplicantUP & WPA_SUPPLICANT_ENABLE_WPS) ;
+sta/sync.c:			if (pAd->StaCfg.WscControl.WscState == WSC_STATE_OFF)
+sta/sync.c:				if ((((pAd->StaCfg.WepStatus != Ndis802_11WEPDisabled) << 4) ^ ie_list->CapabilityInfo) & 0x0010)
+sta/sync.c:								pAd->StaCfg.WepStatus != Ndis802_11WEPDisabled));
+sta/sync.c:						BssTableInit(&pAd->ScanTab);
+sta/sync.c:				pAd->CommonCfg.TxPowerPercentage = pAd->CommonCfg.TxPowerDefault;	
+sta/sync.c:				PWSC_CTRL		pWpsCtrl = &pAd->StaCfg.WscControl;
+sta/sync.c:					hex_dump("Another adhoc joining - WscPeerMAC", pAd->StaCfg.WscControl.WscPeerMAC, 6);
+sta/sync.c:					if ((NdisEqualMemory(ie_list->Addr2, pAd->StaCfg.WscControl.WscPeerMAC, MAC_ADDR_LEN)) &&
+sta/sync.c:						(pAd->StaCfg.IWscInfo.bSendEapolStart == FALSE) &&
+sta/sync.c:						pAd->StaCfg.IWscInfo.bSendEapolStart = TRUE;
+sta/sync.c:                    if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK) 
+sta/sync.c:						&& ((pAd->StaCfg.WscControl.WscConfMode == WSC_DISABLE) ||
+sta/sync.c:							(pAd->StaCfg.WscControl.bWscTrigger == FALSE) ||
+sta/sync.c:							(NdisEqualMemory(pEntry->Addr, pAd->StaCfg.WscControl.WscPeerMAC, MAC_ADDR_LEN) == FALSE))
+sta/sync.c:						&& (pAd->StaCfg.IWscInfo.bBlockConnection == FALSE)
+sta/sync.c:							if (ie_list->Addr2[i] > pAd->CurrentAddress[i])
+sta/sync.c:							else if (ie_list->Addr2[i] < pAd->CurrentAddress[i])
+sta/sync.c:						hex_dump("PeerBeacon:: CurrentAddress", pAd->CurrentAddress, MAC_ADDR_LEN);
+sta/sync.c:						idx = pAd->StaCfg.DefaultKeyId;
+sta/sync.c:												   pAd->SharedKey[BSS0][idx].CipherAlg,
+sta/sync.c:	                pAd->ExtraInfo = GENERAL_LINK_UP;
+sta/sync.c:				if (pAd->StaCfg.IWscInfo.bSendEapolStart &&
+sta/sync.c:					(pAd->Mlme.IWscMachine.CurrState != IWSC_WAIT_PIN) &&
+sta/sync.c:					(pAd->StaCfg.WscControl.WscConfMode == WSC_ENROLLEE))
+sta/sync.c:					pAd->StaCfg.IWscInfo.bSendEapolStart = FALSE;
+sta/sync.c:				/* bUseShortSlot = pAd->CommonCfg.bUseShortSlotTime && CAP_IS_SHORT_SLOT(CapabilityInfo); */
+sta/sync.c:				bUseBGProtection = (pAd->CommonCfg.UseBGProtection == 1) ||    /* always use */
+sta/sync.c:								   ((pAd->CommonCfg.UseBGProtection == 0) && ERP_IS_USE_PROTECTION(ie_list->Erp));
+sta/sync.c:				if (pAd->CommonCfg.Channel > 14)  /* always no BG protection in A-band. falsely happened when switching A/G band to a dual-band AP */
+sta/sync.c:						AsicUpdateProtect(pAd, pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode,
+sta/sync.c:											FALSE,(pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent == 1));
+sta/sync.c:						AsicUpdateProtect(pAd, pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode,
+sta/sync.c:											(pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent == 1));
+sta/sync.c:					((ie_list->AddHtInfo.AddHtInfo2.OperaionMode != pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode) ||
+sta/sync.c:					(ie_list->AddHtInfo.AddHtInfo2.NonGfPresent != pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent)))
+sta/sync.c:					pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent = ie_list->AddHtInfo.AddHtInfo2.NonGfPresent;
+sta/sync.c:					pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode = ie_list->AddHtInfo.AddHtInfo2.OperaionMode;
+sta/sync.c:					if (pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent == 1)
+sta/sync.c:						AsicUpdateProtect(pAd, pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode, ALLN_SETPROTECT, FALSE, TRUE);
+sta/sync.c:						AsicUpdateProtect(pAd, pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode, ALLN_SETPROTECT, FALSE, FALSE);
+sta/sync.c:					DBGPRINT(RT_DEBUG_TRACE, ("SYNC - AP changed N OperaionMode to %d\n", pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode));
+sta/sync.c:					(ie_list->EdcaParm.EdcaUpdateCount != pAd->CommonCfg.APEdcaParm.EdcaUpdateCount))
+sta/sync.c:						pAd->CommonCfg.APEdcaParm.EdcaUpdateCount,
+sta/sync.c:				NdisMoveMemory(&pAd->CommonCfg.APQbssLoad, &ie_list->QbssLoad, sizeof(QBSS_LOAD_PARM));
+sta/sync.c:				NdisMoveMemory(&pAd->CommonCfg.APQosCapability, &ie_list->QosCapability, sizeof(QOS_CAPABILITY_PARM));
+sta/sync.c:				if ((ie_list->AddHtInfoLen != 0) && INFRA_ON(pAd) && pAd->CommonCfg.Channel <= 14)
+sta/sync.c:					pApCliEntry = &pAd->ApCfg.ApCliTab[BSS0];
+sta/sync.c:					if (pAd->CommonCfg.BBPCurrentBW == BW_40)
+sta/sync.c:							pAd->StaActive.SupportedHtPhy.ChannelWidth = BW_20;
+sta/sync.c:							pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.BW = 0;
+sta/sync.c:								pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
+sta/sync.c:															pAd->CommonCfg.Channel, pAd->CommonCfg.CentralChannel));
+sta/sync.c:								CntlChannelWidth(pAd, pAd->CommonCfg.Channel, pAd->CommonCfg.CentralChannel, BW_20, 0);
+sta/sync.c:					else if (((pAd->CommonCfg.BBPCurrentBW == BW_20) ||(ie_list->NewExtChannelOffset!=0x0)) &&
+sta/sync.c:							(pAd->CommonCfg.DesiredHtPhy.ChannelWidth != BW_20)
+sta/sync.c:								pAd->CommonCfg.CentralChannel = get_cent_ch_by_htinfo(pAd, 
+sta/sync.c:								if (pAd->CommonCfg.CentralChannel != ie_list->AddHtInfo.ControlChan)
+sta/sync.c:									pAd->CommonCfg.Channel = ie_list->AddHtInfo.ControlChan;
+sta/sync.c:										pAd->StaActive.SupportedHtPhy.ChannelWidth = BW_40;
+sta/sync.c:																pAd->CommonCfg.Channel, pAd->CommonCfg.CentralChannel));
+sta/sync.c:									CntlChannelWidth(pAd, pAd->CommonCfg.Channel, pAd->CommonCfg.CentralChannel, BW_40, ie_list->AddHtInfo.AddHtInfo.ExtChanOffset);
+sta/sync.c:									pAd->MacTab.Content[BSSID_WCID].HTPhyMode.field.BW = 1;
+sta/sync.c:						pAd->CommonCfg.BSSCoexist2040.word = 0;
+sta/sync.c:			if ((INFRA_ON(pAd) && (RtmpPktPmBitCheck(pAd) == TRUE)) || (pAd->CommonCfg.bAPSDForcePowerSave))
+sta/sync.c:						if (pAd->Antenna.field.RxPath > 1)
+sta/sync.c:							RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, pAd->StaCfg.BBPR3);
+sta/sync.c:					if (pAd->StaCfg.UapsdInfo.bAPSDCapable &&
+sta/sync.c:						pAd->CommonCfg.APEdcaParm.bAPSDCapable &&
+sta/sync.c:						pAd->CommonCfg.bAPSDAC_BE &&
+sta/sync.c:						pAd->CommonCfg.bAPSDAC_BK &&
+sta/sync.c:						pAd->CommonCfg.bAPSDAC_VI &&
+sta/sync.c:						pAd->CommonCfg.bAPSDAC_VO)
+sta/sync.c:						pAd->CommonCfg.bNeedSendTriggerFrame = TRUE;
+sta/sync.c:				  						pAd->CommonCfg.TxRate, 
+sta/sync.c:				  						pAd->CommonCfg.bAPSDForcePowerSave ? PWR_SAVE : pAd->StaCfg.Psm);
+sta/sync.c:						if (pAd->StaCfg.WindowsBatteryPowerMode == Ndis802_11PowerModeFast_PSP)
+sta/sync.c:											  pAd->CommonCfg.TxRate, 
+sta/sync.c:						if (pAd->Antenna.field.RxPath > 1)
+sta/sync.c:							RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, pAd->StaCfg.BBPR3);
+sta/sync.c:				else if ((pAd->TxSwQueue[QID_AC_BK].Number != 0)													||
+sta/sync.c:						(pAd->TxSwQueue[QID_AC_BE].Number != 0)														||
+sta/sync.c:						(pAd->TxSwQueue[QID_AC_VI].Number != 0)														||
+sta/sync.c:						(pAd->TxSwQueue[QID_AC_VO].Number != 0)														||
+sta/sync.c:						if (pAd->Antenna.field.RxPath > 1)
+sta/sync.c:							RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, pAd->StaCfg.BBPR3);
+sta/sync.c:					if ((pAd->CommonCfg.bACMAPSDTr[QID_AC_VO]) ||
+sta/sync.c:						(pAd->CommonCfg.bACMAPSDTr[QID_AC_VI]) ||
+sta/sync.c:						(pAd->CommonCfg.bACMAPSDTr[QID_AC_BK]) ||
+sta/sync.c:						(pAd->CommonCfg.bACMAPSDTr[QID_AC_BE])
+sta/sync.c:						|| (pAd->StaCfg.FlgPsmCanNotSleep == TRUE)||
+sta/sync.c:						TbttNumToNextWakeUp = pAd->StaCfg.DefaultListenCount;
+sta/sync.c:							pAd->ThisTbttNumToNextWakeUp = TbttNumToNextWakeUp;
+sta/sync.c:		                                        AsicSleepThenAutoWakeup(pAd, pAd->ThisTbttNumToNextWakeUp);
+sta/sync.c:/*	if ((pAd->P2pCfg.DiscCurrentState == P2P_DISC_LISTEN) && !(P2P_CLI_ON(pAd)))*/
+sta/sync.c:		if ((SsidLen == 0) || SSID_EQUAL(Ssid, SsidLen, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen))
+sta/sync.c:								pAd->CurrentAddress,
+sta/sync.c:								pAd->CommonCfg.Bssid);
+sta/sync.c:			Privacy = (pAd->StaCfg.WepStatus == Ndis802_11Encryption1Enabled) || 
+sta/sync.c:					  (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled) || 
+sta/sync.c:					  (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled);
+sta/sync.c:			CapabilityInfo = CAP_GENERATE(0, 1, Privacy, (pAd->CommonCfg.TxPreamble == Rt802_11PreambleShort), 0, 0);
+sta/sync.c:							  2,                            &pAd->CommonCfg.BeaconPeriod,
+sta/sync.c:							  1,                            &pAd->CommonCfg.SsidLen, 
+sta/sync.c:							  pAd->CommonCfg.SsidLen,       pAd->CommonCfg.Ssid,
+sta/sync.c:							  1,                            &pAd->StaActive.SupRateLen,
+sta/sync.c:							  pAd->StaActive.SupRateLen,    pAd->StaActive.SupRate, 
+sta/sync.c:							  1,                            &pAd->CommonCfg.Channel,
+sta/sync.c:							  2,                            &pAd->StaActive.AtimWin,
+sta/sync.c:			if (pAd->StaActive.ExtRateLen)
+sta/sync.c:								  1,                            &pAd->StaActive.ExtRateLen,
+sta/sync.c:								  pAd->StaActive.ExtRateLen,    &pAd->StaActive.ExtRate,
+sta/sync.c:        	if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
+sta/sync.c:                || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+sta/sync.c:                RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus, BSS0);
+sta/sync.c:            	if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+sta/sync.c:        						  1,                            	&pAd->StaCfg.RSNIE_Len,
+sta/sync.c:        						  pAd->StaCfg.RSNIE_Len,      		pAd->StaCfg.RSN_IE,
+sta/sync.c:			if (WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+sta/sync.c:				HtLen = sizeof(pAd->CommonCfg.HtCapability);
+sta/sync.c:				AddHtLen = sizeof(pAd->CommonCfg.AddHTInfo);
+sta/sync.c:				if (pAd->bBroadComHT == TRUE)
+sta/sync.c:					epigram_ie_len = pAd->MlmeAux.HtCapabilityLen + 4;
+sta/sync.c:								 pAd->MlmeAux.HtCapabilityLen,          &pAd->MlmeAux.HtCapability, 
+sta/sync.c:								 sizeof(HT_CAPABILITY_IE),          &pAd->CommonCfg.HtCapability, 
+sta/sync.c:								 sizeof(ADD_HT_INFO_IE),          &pAd->CommonCfg.AddHTInfo, 
+sta/sync.c:		    if (pAd->StaCfg.WpsIEProbeResp.ValueLen != 0)
+sta/sync.c:								  pAd->StaCfg.WpsIEProbeResp.ValueLen,		pAd->StaCfg.WpsIEProbeResp.Value,
+sta/sync.c:	pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+sta/sync.c:	if ((pAd->CommonCfg.Channel == pAd->MlmeAux.Channel) && 
+sta/sync.c:		(pAd->MlmeAux.ScanType == SCAN_ACTIVE) && 
+sta/sync.c:						  pAd->CommonCfg.TxRate, 
+sta/sync.c:	if (pAd->StaCfg.bFastConnect && !pAd->StaCfg.bNotFirstScan)
+sta/sync.c:		pAd->MlmeAux.Channel = 0;
+sta/sync.c:		pAd->StaCfg.bNotFirstScan = TRUE;
+sta/sync.c:		pAd->MlmeAux.Channel = NextChannel(pAd, pAd->MlmeAux.Channel);
+sta/sync.c:	if ((pAd->MlmeAux.ScanType == SCAN_CISCO_ACTIVE) || 
+sta/sync.c:		(pAd->MlmeAux.ScanType == SCAN_CISCO_PASSIVE) ||
+sta/sync.c:		(pAd->MlmeAux.ScanType == SCAN_CISCO_NOISE) ||
+sta/sync.c:		(pAd->MlmeAux.ScanType == SCAN_CISCO_CHANNEL_LOAD))
+sta/sync.c:		pAd->MlmeAux.Channel = 0;
+sta/sync.c:        if ( (pAd->pCfg80211ChanList != NULL) && (pAd->MlmeAux.Channel != 0))
+sta/sync.c:                for ( ChanId = 0 ; ChanId <pAd->Cfg80211ChanListLan ; ChanId++ )
+sta/sync.c:                        if ( pAd->pCfg80211ChanList[ChanId] >= pAd->MlmeAux.Channel )
+sta/sync.c:                        os_free_mem(NULL, pAd->pCfg80211ChanList);
+sta/sync.c:                        pAd->pCfg80211ChanList = NULL;
+sta/sync.c:                        pAd->Cfg80211ChanListLan = 0;
+sta/sync.c:                        pAd->MlmeAux.Channel = 0;
+sta/sync.c:	/* this routine will stop if pAd->MlmeAux.Channel == 0 */
+sta/sync.c:		DBGPRINT(RT_DEBUG_TRACE, ("AYNC - InvalidStateWhenScan(state=%ld). Reset SYNC machine\n", pAd->Mlme.SyncMachine.CurrState));
+sta/sync.c:		DBGPRINT(RT_DEBUG_TRACE, ("AYNC - Already in scanning, do nothing here.(state=%ld). \n", pAd->Mlme.SyncMachine.CurrState));
+sta/sync.c:		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+sta/sync.c:								pAd->Mlme.SyncMachine.CurrState,
+sta/sync.c:	pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+sta/sync.c:	DBGPRINT(RT_DEBUG_TRACE, ("InvalidStateWhenStart(state=%ld). Reset SYNC machine\n", pAd->Mlme.SyncMachine.CurrState));
+sta/sync.c:	pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
+sta/sync.c:	if (pAd->StaCfg.WindowsPowerMode == Ndis802_11PowerModeLegacy_PSP)
+sta/sync.c:    	pAd->PsPollFrame.FC.PwrMgmt = PWR_SAVE;
+sta/sync.c:	MiniportMMRequest(pAd, 0, (PUCHAR)&pAd->PsPollFrame, sizeof(PSPOLL_FRAME));
+sta/sync.c:	if (pAd->CountDowntoPsm == 0)
+sta/sync.c:		pAd->CountDowntoPsm = 2;	/* 100 ms; stay awake 200ms at most, average will be 1xx ms */
+sta/sync.c:							pAd->CurrentAddress,
+sta/sync.c:						  1,                              &pAd->CommonCfg.SsidLen,
+sta/sync.c:						  pAd->CommonCfg.SsidLen,		  pAd->CommonCfg.Ssid,
+sta/sync.c:						  1,                              &pAd->StaActive.SupRateLen,
+sta/sync.c:						  pAd->StaActive.SupRateLen,      pAd->StaActive.SupRate, 
+sta/sync.c:								pAd->CommonCfg.Channel, pAd->CommonCfg.CentralChannel, 
+sta/sync.c:								pAd->MlmeAux.AddHtInfo.ControlChan, 
+sta/sync.c:								pAd->MlmeAux.AddHtInfo.AddHtInfo.ExtChanOffset));
+sta/sync.c:		for (k = 0;k < pAd->ChannelListNum;k++)
+sta/sync.c:			if (pAd->ChannelList[k].Channel <=14 )
+sta/sync.c:			pAd->ChannelList[k].bEffectedChannel = TRUE;
+sta/sync.c:	if (pAd->CommonCfg.CentralChannel < pAd->CommonCfg.Channel)
+sta/sync.c:		UpperChannel = pAd->CommonCfg.Channel;
+sta/sync.c:		LowerChannel = pAd->CommonCfg.CentralChannel-2;
+sta/sync.c:	else if (pAd->CommonCfg.CentralChannel > pAd->CommonCfg.Channel)
+sta/sync.c:		UpperChannel = pAd->CommonCfg.CentralChannel+2;
+sta/sync.c:		LowerChannel = pAd->CommonCfg.Channel;
+sta/sync.c:		for (k = 0;k < pAd->ChannelListNum;k++)
+sta/sync.c:			if (pAd->ChannelList[k].Channel == EChannel[j])
+sta/sync.c:				pAd->ChannelList[k].bEffectedChannel = TRUE;
+sta/sync.c: 	for (i = 0; i < pAd->ChannelListNum; i++)		
+sta/sync.c:		pAd->ChannelList[i].bEffectedChannel = FALSE;
+sta/sync.c:		DBGPRINT(RT_DEBUG_TRACE, ("!!!40MHz Lower !!! Control Channel at Below. Central = %d \n", pAd->CommonCfg.CentralChannel ));
+sta/sync.c:		rtmp_bbp_get_agc(pAd, &pAd->BbpTuning.R66CurrentValue, RX_CHAIN_0);
+sta/sync.c:	RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &Cancelled);
+sta/sync.c:	pAd->MlmeAux.Channel = 0;
+sta/assoc.c:	RTMPInitTimer(pAd, &pAd->MlmeAux.AssocTimer,
+sta/assoc.c:	RTMPInitTimer(pAd, &pAd->MlmeAux.ReassocTimer,
+sta/assoc.c:	RTMPInitTimer(pAd, &pAd->MlmeAux.DisassocTimer,
+sta/assoc.c:	if (pAd->StaCfg.bBlockAssoc == TRUE) {
+sta/assoc.c:		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/assoc.c:		RTMPCancelTimer(&pAd->MlmeAux.AssocTimer, &TimerCancelled);
+sta/assoc.c:		COPY_MAC_ADDR(pAd->MlmeAux.Bssid, ApAddr);
+sta/assoc.c:			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/assoc.c:		pAd->StaCfg.AssocInfo.Length =
+sta/assoc.c:		pAd->StaCfg.AssocInfo.AvailableRequestFixedIEs =
+sta/assoc.c:		pAd->StaCfg.AssocInfo.RequestFixedIEs.Capabilities = CapabilityInfo;
+sta/assoc.c:		pAd->StaCfg.AssocInfo.RequestFixedIEs.ListenInterval = ListenIntv;
+sta/assoc.c:		/*COPY_MAC_ADDR(pAd->StaCfg.AssocInfo.RequestFixedIEs.CurrentAPAddress, ApAddr); */
+sta/assoc.c:		pAd->StaCfg.AssocInfo.OffsetRequestIEs = sizeof (NDIS_802_11_ASSOCIATION_INFORMATION);
+sta/assoc.c:		NdisZeroMemory(pAd->StaCfg.ReqVarIEs, MAX_VIE_LEN);
+sta/assoc.c:		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &SsidIe, 1);
+sta/assoc.c:		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &pAd->MlmeAux.SsidLen, 1);
+sta/assoc.c:		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
+sta/assoc.c:		VarIesOffset += pAd->MlmeAux.SsidLen;
+sta/assoc.c:		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &SupRateIe, 1);
+sta/assoc.c:		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &pAd->MlmeAux.SupRateLen, 1);
+sta/assoc.c:		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, pAd->MlmeAux.SupRate, pAd->MlmeAux.SupRateLen);
+sta/assoc.c:		VarIesOffset += pAd->MlmeAux.SupRateLen;
+sta/assoc.c:							pAd->CurrentAddress,
+sta/assoc.c:				  1, &pAd->MlmeAux.SsidLen,
+sta/assoc.c:				  pAd->MlmeAux.SsidLen, pAd->MlmeAux.Ssid,
+sta/assoc.c:				  1, &pAd->MlmeAux.SupRateLen,
+sta/assoc.c:				  pAd->MlmeAux.SupRateLen, pAd->MlmeAux.SupRate,
+sta/assoc.c:		if (pAd->MlmeAux.ExtRateLen != 0) {
+sta/assoc.c:					  1, &pAd->MlmeAux.ExtRateLen,
+sta/assoc.c:					  pAd->MlmeAux.ExtRateLen,
+sta/assoc.c:					  pAd->MlmeAux.ExtRate, END_OF_ARGS);
+sta/assoc.c:		if ((pAd->MlmeAux.HtCapabilityLen > 0)
+sta/assoc.c:		    && WMODE_CAP_N(pAd->CommonCfg.PhyMode)) {
+sta/assoc.c:			NdisMoveMemory(&HtCapabilityTmp, &pAd->MlmeAux.HtCapability, pAd->MlmeAux.HtCapabilityLen);
+sta/assoc.c:			pHtCapability = &pAd->MlmeAux.HtCapability;
+sta/assoc.c:			if (pAd->StaActive.SupportedPhyInfo.bPreNHt == TRUE) {
+sta/assoc.c:						  pAd->MlmeAux.HtCapabilityLen,
+sta/assoc.c:						  &pAd->MlmeAux.HtCapabilityLen,
+sta/assoc.c:						  pAd->MlmeAux.HtCapabilityLen,
+sta/assoc.c:			if (WMODE_CAP_AC(pAd->CommonCfg.PhyMode) &&
+sta/assoc.c:				(pAd->MlmeAux.Channel > 14) &&
+sta/assoc.c:				(pAd->MlmeAux.vht_cap_len)
+sta/assoc.c:			if ((pAd->CommonCfg.bBssCoexEnable == TRUE) &&
+sta/assoc.c:			    WMODE_CAP_N(pAd->CommonCfg.PhyMode)
+sta/assoc.c:			    && (pAd->CommonCfg.Channel <= 14)
+sta/assoc.c:				if (pAd->StaCfg.TdlsInfo.TdlsChSwitchSupp)
+sta/assoc.c:		if (pAd->CommonCfg.bAggregationCapable) {
+sta/assoc.c:			if ((pAd->CommonCfg.bPiggyBackCapable)
+sta/assoc.c:			    && ((pAd->MlmeAux.APRalinkIe & 0x00000003) == 3)) {
+sta/assoc.c:			} else if (pAd->MlmeAux.APRalinkIe & 0x00000001) {
+sta/assoc.c:		if (pAd->MlmeAux.APEdcaParm.bValid) {
+sta/assoc.c:			if (pAd->StaCfg.UapsdInfo.bAPSDCapable
+sta/assoc.c:			    && pAd->MlmeAux.APEdcaParm.bAPSDCapable) {
+sta/assoc.c:				QosInfo.UAPSD_AC_BE = pAd->CommonCfg.bAPSDAC_BE;
+sta/assoc.c:				QosInfo.UAPSD_AC_BK = pAd->CommonCfg.bAPSDAC_BK;
+sta/assoc.c:				QosInfo.UAPSD_AC_VI = pAd->CommonCfg.bAPSDAC_VI;
+sta/assoc.c:				QosInfo.UAPSD_AC_VO = pAd->CommonCfg.bAPSDAC_VO;
+sta/assoc.c:				QosInfo.MaxSPLength = pAd->CommonCfg.MaxSPLength;
+sta/assoc.c:				/* WmeIe[8] |= (pAd->MlmeAux.APEdcaParm.EdcaUpdateCount & 0x0f); */
+sta/assoc.c:		if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+sta/assoc.c:		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK) ||
+sta/assoc.c:		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
+sta/assoc.c:		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
+sta/assoc.c:		     || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAICERT)
+sta/assoc.c:		     || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAIPSK)
+sta/assoc.c:		    && ((pAd->StaCfg.WscControl.WscConfMode == WSC_DISABLE) ||
+sta/assoc.c:			((pAd->StaCfg.WscControl.WscConfMode != WSC_DISABLE) &&
+sta/assoc.c:			 !(pAd->StaCfg.WscControl.bWscTrigger
+sta/assoc.c:			if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+sta/assoc.c:			    || (pAd->StaCfg.AuthMode ==
+sta/assoc.c:			else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAICERT)
+sta/assoc.c:				 || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAIPSK)) {
+sta/assoc.c:			if (pAd->StaCfg.bRSN_IE_FromWpaSupplicant == FALSE)
+sta/assoc.c:				RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode,
+sta/assoc.c:					      pAd->StaCfg.WepStatus, BSS0);
+sta/assoc.c:				if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) {
+sta/assoc.c:						if (NdisEqualMemory(ApAddr, &pAd->StaCfg.SavedPMK[idx].BSSID, 6)) {
+sta/assoc.c:					if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
+sta/assoc.c:					    && (NdisEqualMemory(pAd->MlmeAux.Bssid, pAd->CommonCfg.LastBssid, MAC_ADDR_LEN))) {
+sta/assoc.c:						*(PUSHORT) & pAd->StaCfg.RSN_IE[pAd->StaCfg.RSNIE_Len] = 1;
+sta/assoc.c:						NdisMoveMemory(&pAd->StaCfg.RSN_IE[pAd->StaCfg.RSNIE_Len + 2],
+sta/assoc.c:							       &pAd->StaCfg.SavedPMK[idx].PMKID, 16);
+sta/assoc.c:						pAd->StaCfg.RSNIE_Len += 18;
+sta/assoc.c:			if ((pAd->StaCfg.WpaSupplicantUP & WPA_SUPPLICANT_ENABLE)
+sta/assoc.c:			    && (pAd->StaCfg.bRSN_IE_FromWpaSupplicant == TRUE)) {
+sta/assoc.c:						  1, &pAd->StaCfg.RSNIE_Len,
+sta/assoc.c:						  pAd->StaCfg.RSNIE_Len,
+sta/assoc.c:						  pAd->StaCfg.RSN_IE,
+sta/assoc.c:			if (((pAd->StaCfg.WpaSupplicantUP & 0x7F) !=
+sta/assoc.c:			    || (pAd->StaCfg.bRSN_IE_FromWpaSupplicant == FALSE))
+sta/assoc.c:				NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &RSNIe, 1);
+sta/assoc.c:				NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &pAd->StaCfg.RSNIE_Len, 1);
+sta/assoc.c:				NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, pAd->StaCfg.RSN_IE, pAd->StaCfg.RSNIE_Len);
+sta/assoc.c:				VarIesOffset += pAd->StaCfg.RSNIE_Len;
+sta/assoc.c:				pAd->StaCfg.ReqVarIELen = VarIesOffset;
+sta/assoc.c:		if ((pAd->StaCfg.WpaSupplicantUP & WPA_SUPPLICANT_ENABLE) &&
+sta/assoc.c:		    (pAd->StaCfg.bRSN_IE_FromWpaSupplicant == TRUE)) {
+sta/assoc.c:					  pAd->StaCfg.WpaAssocIeLen,
+sta/assoc.c:					  pAd->StaCfg.pWpaAssocIe, END_OF_ARGS);
+sta/assoc.c:			NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset,
+sta/assoc.c:				       pAd->StaCfg.pWpaAssocIe,
+sta/assoc.c:				       pAd->StaCfg.WpaAssocIeLen);
+sta/assoc.c:			VarIesOffset += pAd->StaCfg.WpaAssocIeLen;
+sta/assoc.c:			pAd->StaCfg.ReqVarIELen = VarIesOffset;
+sta/assoc.c:		if (pAd->P2pCfg.P2pManagedParm.TotalNumOfP2pAttribute > 0)
+sta/assoc.c:		if ((pAd->StaCfg.WscControl.WscEnAssociateIE) &&
+sta/assoc.c:		    (pAd->StaCfg.WscControl.WscConfMode != WSC_DISABLE) &&
+sta/assoc.c:		    (pAd->StaCfg.WscControl.bWscTrigger
+sta/assoc.c:				WscBuildAssocReqIE(&pAd->StaCfg.WscControl, pWscBuf, &WscIeLen);
+sta/assoc.c:		RTMPSetTimer(&pAd->MlmeAux.AssocTimer, Timeout);
+sta/assoc.c:		pAd->Mlme.AssocMachine.CurrState = ASSOC_WAIT_RSP;
+sta/assoc.c:		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/assoc.c:	if (pAd->StaCfg.bBlockAssoc == TRUE) {
+sta/assoc.c:		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/assoc.c:		RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer, &TimerCancelled);
+sta/assoc.c:			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/assoc.c:		COPY_MAC_ADDR(pAd->MlmeAux.Bssid, ApAddr);
+sta/assoc.c:							pAd->CurrentAddress,
+sta/assoc.c:				  1, &pAd->MlmeAux.SsidLen,
+sta/assoc.c:				  pAd->MlmeAux.SsidLen, pAd->MlmeAux.Ssid, 1,
+sta/assoc.c:				  &SupRateIe, 1, &pAd->MlmeAux.SupRateLen,
+sta/assoc.c:				  pAd->MlmeAux.SupRateLen, pAd->MlmeAux.SupRate,
+sta/assoc.c:		if (pAd->MlmeAux.ExtRateLen != 0) {
+sta/assoc.c:					  1, &pAd->MlmeAux.ExtRateLen,
+sta/assoc.c:					  pAd->MlmeAux.ExtRateLen,
+sta/assoc.c:					  pAd->MlmeAux.ExtRate, END_OF_ARGS);
+sta/assoc.c:		if (pAd->MlmeAux.APEdcaParm.bValid) {
+sta/assoc.c:			if (pAd->StaCfg.UapsdInfo.bAPSDCapable
+sta/assoc.c:			    && pAd->MlmeAux.APEdcaParm.bAPSDCapable) {
+sta/assoc.c:				QosInfo.UAPSD_AC_BE = pAd->CommonCfg.bAPSDAC_BE;
+sta/assoc.c:				QosInfo.UAPSD_AC_BK = pAd->CommonCfg.bAPSDAC_BK;
+sta/assoc.c:				QosInfo.UAPSD_AC_VI = pAd->CommonCfg.bAPSDAC_VI;
+sta/assoc.c:				QosInfo.UAPSD_AC_VO = pAd->CommonCfg.bAPSDAC_VO;
+sta/assoc.c:				    pAd->CommonCfg.MaxSPLength;
+sta/assoc.c:		if ((pAd->MlmeAux.HtCapabilityLen > 0)
+sta/assoc.c:		    && WMODE_CAP_N(pAd->CommonCfg.PhyMode)) {
+sta/assoc.c:			NdisMoveMemory(&HtCapabilityTmp, &pAd->MlmeAux.HtCapability, pAd->MlmeAux.HtCapabilityLen);
+sta/assoc.c:			pHtCapability = &pAd->MlmeAux.HtCapability;
+sta/assoc.c:			if (pAd->StaActive.SupportedPhyInfo.bPreNHt == TRUE) {
+sta/assoc.c:						  pAd->MlmeAux.HtCapabilityLen,
+sta/assoc.c:						  &pAd->MlmeAux.HtCapabilityLen,
+sta/assoc.c:						  pAd->MlmeAux.HtCapabilityLen,
+sta/assoc.c:			if (WMODE_CAP_AC(pAd->CommonCfg.PhyMode) &&
+sta/assoc.c:				(pAd->MlmeAux.Channel > 14) &&
+sta/assoc.c:				(pAd->MlmeAux.vht_cap_len)
+sta/assoc.c:				if (pAd->StaCfg.TdlsInfo.TdlsChSwitchSupp)
+sta/assoc.c:		if (pAd->CommonCfg.bAggregationCapable) {
+sta/assoc.c:			if ((pAd->CommonCfg.bPiggyBackCapable)
+sta/assoc.c:			    && ((pAd->MlmeAux.APRalinkIe & 0x00000003) == 3)) {
+sta/assoc.c:			} else if (pAd->MlmeAux.APRalinkIe & 0x00000001) {
+sta/assoc.c:		RTMPSetTimer(&pAd->MlmeAux.ReassocTimer, Timeout * 2);	/* in mSec */
+sta/assoc.c:		pAd->Mlme.AssocMachine.CurrState = REASSOC_WAIT_RSP;
+sta/assoc.c:		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/assoc.c:	if (pAd->CommonCfg.bDLSCapable) {
+sta/assoc.c:			if (pAd->StaCfg.DLSEntry[i].Valid
+sta/assoc.c:			    && (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH)) {
+sta/assoc.c:				RTMPSendDLSTearDownFrame(pAd, pAd->StaCfg.DLSEntry[i].MacAddr);
+sta/assoc.c:				pAd->StaCfg.DLSEntry[i].Status = DLS_NONE;
+sta/assoc.c:				pAd->StaCfg.DLSEntry[i].Valid = FALSE;
+sta/assoc.c:			if (pAd->StaCfg.DLSEntry[i].Valid
+sta/assoc.c:			    && (pAd->StaCfg.DLSEntry[i].Status == DLS_FINISH)) {
+sta/assoc.c:				RTMPSendDLSTearDownFrame(pAd, pAd->StaCfg.DLSEntry[i].MacAddr);
+sta/assoc.c:				pAd->StaCfg.DLSEntry[i].Status = DLS_NONE;
+sta/assoc.c:				pAd->StaCfg.DLSEntry[i].Valid = FALSE;
+sta/assoc.c:		if (pAd->StaCfg.bRadio == TRUE)
+sta/assoc.c:				pTDLS = &pAd->StaCfg.TdlsInfo.TDLSEntry[idx];
+sta/assoc.c:		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/assoc.c:			       pAd->StaCfg.AuthMode,
+sta/assoc.c:	RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer, &TimerCancelled);
+sta/assoc.c:						pAd->CurrentAddress,
+sta/assoc.c:	pAd->StaCfg.DisassocReason = REASON_DISASSOC_STA_LEAVING;
+sta/assoc.c:	COPY_MAC_ADDR(pAd->StaCfg.DisassocSta, pDisassocReq->Addr);
+sta/assoc.c:	RTMPSetTimer(&pAd->MlmeAux.DisassocTimer, Timeout);	/* in mSec */
+sta/assoc.c:	pAd->Mlme.AssocMachine.CurrState = DISASSOC_WAIT_RSP;
+sta/assoc.c:	if (pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE) {
+sta/assoc.c:		RtmpOSWrielessEventSend(pAd->net_dev, RT_WLAN_EVENT_CUSTOM,
+sta/assoc.c:		if (MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid)) {
+sta/assoc.c:				  pAd->MacTab.Content[BSSID_WCID].AMsduSize,
+sta/assoc.c:				  pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
+sta/assoc.c:			RTMPCancelTimer(&pAd->MlmeAux.AssocTimer, &TimerCancelled);
+sta/assoc.c:				pEntry = MacTableLookup(pAd, pAd->CommonCfg.Bssid);	
+sta/assoc.c:						    &pAd->MacTab.Content[BSSID_WCID],
+sta/assoc.c:								&pAd->MacTab.Content[BSSID_WCID],
+sta/assoc.c:			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/assoc.c:		        //        RT_CFG80211_CONN_RESULT_INFORM(pAd, pAd->MlmeAux.Bssid, NULL, 0,
+sta/assoc.c:		if (MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid)) {	/* The frame is for me ? */
+sta/assoc.c:			RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer,
+sta/assoc.c:				pEntry = MacTableLookup(pAd, pAd->CommonCfg.Bssid);	
+sta/assoc.c:						    &pAd->MacTab.Content[BSSID_WCID],
+sta/assoc.c:								&pAd->MacTab.Content[BSSID_WCID],
+sta/assoc.c:				if (pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_DISABLE) {
+sta/assoc.c:					SendAssocIEsToWpaSupplicant(pAd->net_dev,
+sta/assoc.c:								    pAd->StaCfg.ReqVarIEs,
+sta/assoc.c:								    pAd->StaCfg.ReqVarIELen);
+sta/assoc.c:					RtmpOSWrielessEventSend(pAd->net_dev,
+sta/assoc.c:					wext_notify_event_assoc(pAd->net_dev,
+sta/assoc.c:								pAd->StaCfg.ReqVarIEs,
+sta/assoc.c:								pAd->StaCfg.ReqVarIELen);
+sta/assoc.c:					RtmpOSWrielessEventSend(pAd->net_dev,
+sta/assoc.c:								&pAd->MlmeAux.Bssid[0], NULL,
+sta/assoc.c:			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/assoc.c:	pAd->MlmeAux.BssType = BSS_INFRA;
+sta/assoc.c:	COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pAddr2);
+sta/assoc.c:	pAd->MlmeAux.Aid = Aid;
+sta/assoc.c:	pAd->MlmeAux.CapabilityInfo = CapabilityInfo & SUPPORTED_CAPABILITY_INFO;
+sta/assoc.c:	NdisMoveMemory(&pAd->MlmeAux.APEdcaParm, pEdcaParm, sizeof (EDCA_PARM));
+sta/assoc.c:	pAd->MlmeAux.SupRateLen = SupRateLen;
+sta/assoc.c:	NdisMoveMemory(pAd->MlmeAux.SupRate, SupRate, SupRateLen);
+sta/assoc.c:	RTMPCheckRates(pAd, pAd->MlmeAux.SupRate, &pAd->MlmeAux.SupRateLen);
+sta/assoc.c:	pAd->MlmeAux.ExtRateLen = ExtRateLen;
+sta/assoc.c:	NdisMoveMemory(pAd->MlmeAux.ExtRate, ExtRate, ExtRateLen);
+sta/assoc.c:	RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate, &pAd->MlmeAux.ExtRateLen);
+sta/assoc.c:			pAd->MacTab.Content[BSSID_WCID].AMsduSize,
+sta/assoc.c:			pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
+sta/assoc.c:			pAd->MacTab.Content[BSSID_WCID].MmpsMode,
+sta/assoc.c:			pAd->MacTab.Content[BSSID_WCID].AMsduSize));
+sta/assoc.c:	Idx = BssTableSearch(&pAd->ScanTab, pAddr2, pAd->MlmeAux.Channel);
+sta/assoc.c:		pAd->MacTab.Content[BSSID_WCID].RSNIE_Len = 0;
+sta/assoc.c:		NdisZeroMemory(pAd->MacTab.Content[BSSID_WCID].RSN_IE, MAX_LEN_OF_RSNIE);
+sta/assoc.c:		if ((pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)
+sta/assoc.c:		    && (pAd->ScanTab.BssEntry[Idx].VarIELen != 0)) {
+sta/assoc.c:			pVIE = pAd->ScanTab.BssEntry[Idx].VarIEs;
+sta/assoc.c:			len = pAd->ScanTab.BssEntry[Idx].VarIELen;
+sta/assoc.c:				    && (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA
+sta/assoc.c:					|| pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK)) {
+sta/assoc.c:					NdisMoveMemory(pAd->MacTab.Content[BSSID_WCID].RSN_IE, pVIE, (pEid->Len + 2));
+sta/assoc.c:					pAd->MacTab.Content[BSSID_WCID].RSNIE_Len = (pEid->Len + 2);
+sta/assoc.c:					 && (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2
+sta/assoc.c:					     || pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)) {
+sta/assoc.c:					NdisMoveMemory(pAd->MacTab.Content[BSSID_WCID].RSN_IE, pVIE, (pEid->Len + 2));
+sta/assoc.c:					pAd->MacTab.Content[BSSID_WCID].RSNIE_Len = (pEid->Len + 2);
+sta/assoc.c:					 && (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAICERT
+sta/assoc.c:					     || pAd->StaCfg.AuthMode == Ndis802_11AuthModeWAIPSK)) {
+sta/assoc.c:					NdisMoveMemory(pAd->MacTab.Content[BSSID_WCID].RSN_IE, pVIE, (pEid->Len + 2));
+sta/assoc.c:					pAd->MacTab.Content[BSSID_WCID].RSNIE_Len = (pEid->Len + 2);
+sta/assoc.c:		if (pAd->MacTab.Content[BSSID_WCID].RSNIE_Len == 0) {
+sta/assoc.c:				 pAd->MacTab.Content[BSSID_WCID].RSN_IE,
+sta/assoc.c:				 pAd->MacTab.Content[BSSID_WCID].RSNIE_Len);
+sta/assoc.c:		    && MAC_ADDR_EQUAL(pAd->CommonCfg.Bssid, Addr2)) {
+sta/assoc.c:					       pAd->StaCfg.AuthMode,
+sta/assoc.c:			if (pAd->Mlme.CntlMachine.CurrState ==
+sta/assoc.c:			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/assoc.c:			if (pAd->StaCfg.WpaSupplicantUP !=
+sta/assoc.c:				RtmpOSWrielessEventSend(pAd->net_dev,
+sta/assoc.c:	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/assoc.c:	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/assoc.c:	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/assoc.c:		  pAd->Mlme.AssocMachine.CurrState));
+sta/assoc.c:	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/assoc.c:		  pAd->Mlme.AssocMachine.CurrState));
+sta/assoc.c:	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/assoc.c:		  pAd->Mlme.AssocMachine.CurrState));
+sta/assoc.c:	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+sta/assoc.c:						pAd->CurrentAddress,
+sta/assoc.c:						pAd->CommonCfg.Bssid);	/* patch peap ttls switching issue */
+sta/assoc.c:	pAd->StaCfg.DisassocReason = REASON_CLS3ERR;
+sta/assoc.c:	COPY_MAC_ADDR(pAd->StaCfg.DisassocSta, pAddr);
+sta/assoc.c:	if (WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_G)
+sta/assoc.c:	if (WMODE_HT_ONLY(pAd->CommonCfg.PhyMode)
+sta/assoc.c:	NdisAcquireSpinLock(&pAd->MacTabLock);
+sta/assoc.c:		    WMODE_EQUAL(pAd->CommonCfg.PhyMode, WMODE_B)) {
+sta/assoc.c:	if (((pAd->StaCfg.WepStatus != Ndis802_11WEPEnabled)
+sta/assoc.c:	     && (pAd->StaCfg.WepStatus != Ndis802_11Encryption2Enabled))
+sta/assoc.c:	    || (pAd->CommonCfg.HT_DisallowTKIP == FALSE)) {
+sta/assoc.c:		if ((pAd->StaCfg.BssType == BSS_INFRA) &&
+sta/assoc.c:		    WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+sta/assoc.c:		if ((pAd->StaCfg.BssType == BSS_ADHOC) &&
+sta/assoc.c:		    (pAd->StaCfg.bAdhocN == TRUE) &&
+sta/assoc.c:		    WMODE_CAP_N(pAd->CommonCfg.PhyMode))
+sta/assoc.c:		ht_mode_adjust(pAd, pEntry, pHtCapability, &pAd->CommonCfg.DesiredHtPhy);
+sta/assoc.c:		if (pAd->MlmeAux.bBwFallBack == TRUE)
+sta/assoc.c:		if (pAd->chipCap.FlgHwTxBfCap)
+sta/assoc.c:		pEntry->MaxHTPhyMode.field.MCS = get_ht_max_mcs(pAd, &pAd->StaCfg.DesiredHtPhyInfo.MCSSet[0], &pHtCapability->MCSSet[0]);
+sta/assoc.c:		if (pAd->StaCfg.DesiredTransmitSetting.field.MCS != MCS_AUTO)
+sta/assoc.c:			set_ht_fixed_mcs(pAd, pEntry, pAd->StaCfg.DesiredTransmitSetting.field.MCS, pAd->StaCfg.HTPhyMode.field.MCS);
+sta/assoc.c:		pEntry->MaxHTPhyMode.field.STBC = (pHtCapability->HtCapInfo.RxSTBC & (pAd->CommonCfg.DesiredHtPhy.TxSTBC));
+sta/assoc.c:		if (pAd->CommonCfg.DesiredHtPhy.AmsduEnable
+sta/assoc.c:		    && (pAd->CommonCfg.REGBACapability.field.AutoBA == FALSE))
+sta/assoc.c:		if (pAd->CommonCfg.bRdg
+sta/assoc.c:		if (WMODE_CAP_AC(pAd->CommonCfg.PhyMode) &&
+sta/assoc.c:		pAd->MacTab.fAnyStationIsLegacy = TRUE;
+sta/assoc.c:	if (pAd->StaCfg.bAutoTxRateSwitch == TRUE) {
+sta/assoc.c:		pEntry->HTPhyMode.field.MODE = pAd->StaCfg.HTPhyMode.field.MODE;
+sta/assoc.c:		pEntry->HTPhyMode.field.MCS = pAd->StaCfg.HTPhyMode.field.MCS;
+sta/assoc.c:		RTMPUpdateLegacyTxSetting((UCHAR)pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode, pEntry);
+sta/assoc.c:	pEntry->AuthMode = pAd->StaCfg.AuthMode;
+sta/assoc.c:	pEntry->WepStatus = pAd->StaCfg.WepStatus;
+sta/assoc.c:	if (pAd->StaCfg.BssType == BSS_INFRA) {
+sta/assoc.c:		HashIdx = MAC_ADDR_HASH_INDEX(pAd->MlmeAux.Bssid);
+sta/assoc.c:		if (pAd->MacTab.Hash[HashIdx] == NULL) {
+sta/assoc.c:			pAd->MacTab.Hash[HashIdx] = pEntry;
+sta/assoc.c:			pCurrEntry = pAd->MacTab.Hash[HashIdx];
+sta/assoc.c:		RTMPMoveMemory(pEntry->Addr, pAd->MlmeAux.Bssid, MAC_ADDR_LEN);
+sta/assoc.c:		pAd->MacTab.Size ++;
+sta/assoc.c:	NdisReleaseSpinLock(&pAd->MacTabLock);
+sta/assoc.c:	if (pAd->StaCfg.WpaSupplicantUP) {
+sta/assoc.c:		SendAssocIEsToWpaSupplicant(pAd->net_dev, pAd->StaCfg.ReqVarIEs,
+sta/assoc.c:					    pAd->StaCfg.ReqVarIELen);
+sta/assoc.c:		RtmpOSWrielessEventSend(pAd->net_dev, RT_WLAN_EVENT_CUSTOM,
+sta/assoc.c:		wext_notify_event_assoc(pAd->net_dev, pAd->StaCfg.ReqVarIEs,
+sta/assoc.c:					pAd->StaCfg.ReqVarIELen);
+sta/assoc.c:		RtmpOSWrielessEventSend(pAd->net_dev, RT_WLAN_EVENT_CGIWAP, -1,
+sta/assoc.c:					pAd->MlmeAux.Bssid, NULL, 0);
+sta/assoc.c:	if (pAd->StaCfg.BssType == BSS_INFRA)
+sta/assoc.c:		COPY_MAC_ADDR(pEntry->HdrAddr1, pAd->MlmeAux.Bssid);
+sta/assoc.c:	COPY_MAC_ADDR(pEntry->HdrAddr2, pAd->CurrentAddress);
+sta/assoc.c:	COPY_MAC_ADDR(pEntry->HdrAddr3, pAd->MlmeAux.Bssid);
