<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JSON → Form (vanilla)</title>
  <style>
    :root { color-scheme: light dark; --max: 800px; --pad: 12px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, Helvetica, "Apple Color Emoji", "Segoe UI Emoji"; margin: 0; }
    header, main, footer { max-width: var(--max); margin: 0 auto; padding: var(--pad); }
    header { border-bottom: 1px solid #ccc; }
    h1 { font-size: 1.25rem; margin: 0; }
    form { display: grid; gap: 10px; margin-top: 14px; }
    .field { display: grid; gap: 4px; }
    .field label { font-weight: 600; }
    .row { display: flex; gap: 10px; align-items: center; }
    input[type="text"], input[type="number"], textarea, select { width: 100%; box-sizing: border-box; padding: 8px; }
    input[type="checkbox"] { transform: scale(1.1); }
    .actions { display: flex; gap: 10px; align-items: center; }
    button { padding: 8px 12px; cursor: pointer; }
    .note { font-size: 0.9em; opacity: 0.8; }
    .status { font-size: 0.9em; }
    .hidden { display: none; }
    details { margin-top: 10px; }
    pre { overflow-x: auto; background: #0001; padding: 8px; border-radius: 6px; }
    .warning { color: #b45309; }
    .error { color: #b91c1c; }
    .success { color: #15803d; }
    .config { font-size: 0.9em; opacity: 0.85; }
  </style>
</head>
<body>
  <header>
    <h1>JSON → Form</h1>
    <div class="config">
      Use query params: <code>?url=GET_URL&update=POST_OR_PUT_URL&method=PUT</code>
      • Optional: <code>&auth=Bearer%20TOKEN</code> (sent as Authorization header)
    </div>
    <div id="corsHint" class="note warning hidden">Note: Remote server must allow CORS (GET and PUT/POST) for this page's origin.</div>
  </header>

  <main>
    <div id="loadStatus" class="status"></div>
    <form id="jsonForm" class="hidden"></form>
    <div id="formNote" class="note hidden">Rendering primitive leaf values using dot paths (e.g., a.b.0.c). Non-primitive structures remain visible in Raw JSON.</div>

    <details id="rawSection" class="hidden">
      <summary>Raw JSON</summary>
      <pre id="rawJson"></pre>
    </details>

    <section id="sseSection" class="hidden">
      <h3>Live updates (SSE)</h3>
      <div class="note">Configured via query: ?sse=EVENT_STREAM_URL[&sseEvent=message][&sseField=dot.path]</div>
      <div class="status" id="sseStatus">Idle</div>
      <pre id="sseValue"></pre>
    </section>

  </main>

  <footer>
    <div class="note">No dependencies. Pure HTML + vanilla JS. XHR used for saves.</div>
  </footer>

  <script>
    (function() {
      const qs = new URLSearchParams(location.search);
      const dataUrl = qs.get('url') || './data.json';
      const updateUrl = qs.get('update') || dataUrl;
      const method = (qs.get('method') || 'PUT').toUpperCase();
      const auth = qs.get('auth');
      const sseUrl = qs.get('sse');
      const sseEvent = qs.get('sseEvent') || 'message';
      const sseField = qs.get('sseField');

      const loadStatus = document.getElementById('loadStatus');
      const form = document.getElementById('jsonForm');
      const rawSection = document.getElementById('rawSection');
      const rawJsonEl = document.getElementById('rawJson');
      const formNote = document.getElementById('formNote');
      const corsHint = document.getElementById('corsHint');
      const sseSection = document.getElementById('sseSection');
      const sseStatus = document.getElementById('sseStatus');
      const sseValue = document.getElementById('sseValue');

      // Heuristic: if loading via file:// or different host, show CORS hint
      try {
        const a = document.createElement('a'); a.href = dataUrl;
        if (location.protocol === 'file:' || (a.host && a.host !== location.host)) {
          corsHint.classList.remove('hidden');
        }
      } catch {}

      function isPrimitive(v) {
        return v === null || ['string','number','boolean'].includes(typeof v);
      }

      function flattenPrimitives(obj) {
        const out = {};
        (function walk(cur, path) {
          if (isPrimitive(cur)) {
            if (path) out[path] = cur;
            return;
          }
          if (Array.isArray(cur)) {
            for (let i = 0; i < cur.length; i++) {
              walk(cur[i], path ? path + '.' + i : String(i));
            }
          } else if (cur && typeof cur === 'object') {
            for (const k of Object.keys(cur)) {
              walk(cur[k], path ? path + '.' + k : k);
            }
          }
        })(obj, '');
        return out;
      }

      function idFor(path) {
        return 'f_' + path.replace(/[^\w-]/g, '_');
      }

      function getByPath(obj, path) {
        if (!path) return obj;
        const parts = path.split('.');
        let cur = obj;
        for (const p of parts) {
          if (cur == null) return undefined;
          const idx = String(Number(p)) === p ? Number(p) : p;
          cur = cur[idx];
        }
        return cur;
      }

      function setByPath(obj, path, value) {
        if (!path) return;
        const parts = path.split('.');
        let cur = obj;
        for (let i = 0; i < parts.length - 1; i++) {
          const p = parts[i];
          const idx = String(Number(p)) === p ? Number(p) : p;
          cur = cur[idx];
        }
        const last = parts[parts.length - 1];
        const lastIdx = String(Number(last)) === last ? Number(last) : last;
        cur[lastIdx] = value;
      }

      function inputFor(key, value) {
        const wrap = document.createElement('div'); wrap.className = 'field';
        const label = document.createElement('label'); label.textContent = key; label.htmlFor = idFor(key);
        wrap.appendChild(label);

        let control;
        if (typeof value === 'boolean') {
          const row = document.createElement('div'); row.className = 'row';
          control = document.createElement('input'); control.type = 'checkbox'; control.id = idFor(key); control.checked = !!value;
          row.appendChild(control);
          wrap.appendChild(row);
        } else if (typeof value === 'number') {
          control = document.createElement('input'); control.type = 'number'; control.step = 'any'; control.id = idFor(key); control.value = String(value);
          wrap.appendChild(control);
        } else {
          control = document.createElement('input'); control.type = 'text'; control.id = idFor(key); control.value = value == null ? '' : String(value);
          wrap.appendChild(control);
        }
        control.dataset.key = key;
        return wrap;
      }

      function buildForm(data) {
        form.innerHTML = '';

        const flat = flattenPrimitives(data);
        const keys = Object.keys(flat);
        if (keys.length === 0) {
          const p = document.createElement('div');
          p.className = 'note';
          p.textContent = 'No primitive leaf fields detected to render as inputs.';
          form.appendChild(p);
        } else {
          for (const k of keys) form.appendChild(inputFor(k, flat[k]));
        }

        formNote.classList.remove('hidden');

        const actions = document.createElement('div'); actions.className = 'actions';
        const saveBtn = document.createElement('button'); saveBtn.type = 'submit'; saveBtn.textContent = 'Save';
        const resetBtn = document.createElement('button'); resetBtn.type = 'button'; resetBtn.textContent = 'Reset';
        const status = document.createElement('div'); status.className = 'status'; status.id = 'saveStatus';
        actions.append(saveBtn, resetBtn, status);
        form.appendChild(actions);

        form.addEventListener('submit', async (e) => {
          e.preventDefault();
          const payload = structuredClone(data);

          // write back primitive leaf fields via dot paths
          const inputs = form.querySelectorAll('[data-key]');
          inputs.forEach((el) => {
            const k = el.dataset.key;
            const orig = getByPath(data, k);
            let v;
            if (typeof orig === 'boolean') v = !!el.checked;
            else if (typeof orig === 'number') {
              const n = Number(el.value);
              v = Number.isFinite(n) ? n : null;
            } else if (orig === null) {
              v = el.value.trim() === '' ? null : el.value;
            } else {
              v = el.value;
            }
            setByPath(payload, k, v);
          });

          await saveJson(payload, status);
        });

        resetBtn.addEventListener('click', () => buildForm(data));
        form.classList.remove('hidden');

        rawJsonEl.textContent = JSON.stringify(data, null, 2);
        rawSection.classList.remove('hidden');
      }

      function xhr(method, url, body) {
        return new Promise((resolve) => {
          const req = new XMLHttpRequest();
          req.open(method, url, true);
          req.setRequestHeader('Content-Type', 'application/json');
          if (auth) req.setRequestHeader('Authorization', auth);
          req.onreadystatechange = () => {
            if (req.readyState === 4) resolve({ status: req.status, text: req.responseText });
          };
          req.onerror = () => resolve({ status: 0, text: 'Network error' });
          req.send(body);
        });
      }

      async function saveJson(obj, statusEl) {
        statusEl.textContent = 'Saving…'; statusEl.className = 'status';
        try {
          const { status, text } = await xhr(method, updateUrl, JSON.stringify(obj));
          if (status >= 200 && status < 300) {
            statusEl.textContent = `Saved (${status}).`;
            statusEl.classList.add('success');
          } else {
            statusEl.textContent = `Save failed (${status}). ${text || ''}`;
            statusEl.classList.add('error');
          }
        } catch (e) {
          statusEl.textContent = 'Save failed.';
          statusEl.classList.add('error');
        }
      }

      async function loadJson() {
        loadStatus.textContent = `Loading ${dataUrl} …`;
        try {
          const res = await fetch(dataUrl, { headers: auth ? { 'Authorization': auth } : undefined });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          loadStatus.textContent = '';
          buildForm(data);
        } catch (e) {
          loadStatus.innerHTML = `<span class="error">Failed to load JSON: ${e && e.message ? e.message : e}</span>`;
        }
      }

      function startSSE(url, eventName, fieldPath) {
        if (!window.EventSource) {
          sseStatus.textContent = 'EventSource not supported in this browser';
          sseStatus.classList.add('error');
          sseSection.classList.remove('hidden');
          return;
        }
        try {
          const a = document.createElement('a'); a.href = url;
          if (location.protocol === 'file:' || (a.host && a.host !== location.host)) {
            corsHint.classList.remove('hidden');
          }
        } catch {}
        const es = new EventSource(url);
        sseStatus.textContent = 'Connecting…';
        sseSection.classList.remove('hidden');
        es.onopen = () => { sseStatus.textContent = 'Connected'; sseStatus.className = 'status success'; };
        es.onerror = () => { sseStatus.textContent = 'Disconnected / error'; sseStatus.className = 'status error'; };
        const handler = (ev) => {
          let txt = ev.data, out = txt;
          try {
            const obj = JSON.parse(txt);
            out = fieldPath ? getByPath(obj, fieldPath) : obj;
            if (typeof out === 'object') out = JSON.stringify(out, null, 2);
          } catch {
            // non-JSON payload
          }
          sseValue.textContent = String(out ?? '');
        };
        if (eventName && eventName !== 'message') es.addEventListener(eventName, handler);
        else es.onmessage = handler;
      }

      loadJson();
      if (sseUrl) startSSE(sseUrl, sseEvent, sseField);
    })();
  </script>
</body>
</html>

