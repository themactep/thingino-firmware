#!/bin/sh

. /usr/share/common

SELF_NAME="$(basename "$0")"

if ! is_streamer_running; then
	echo_error "Streamer is not running"
	exit 1
fi

if is_streamer_disabled; then
	echo_error "Streamer disabled"
	exit 1
fi

hesitate() {
	echo_info "$1"
	sleep 5
	exit 0
}

fix_duration() {
	if [ "$1" -eq 60 ]; then
		echo $(expr "$1" - $(date +%S))
	elif [ $(expr "$1" % 60) -eq 0 ]; then
		m_inc=$(expr "$1" / 60)
		mpart=$(expr "$m_inc" - $(expr $(date +%M) % "$m_inc"))
		echo $(expr "$mpart" "*" 60)
	else
		echo "$1"
	fi
	# TODO: handle cases different than 60 second durations or videos longer than an hour
}

get_free_space() {
	available_space=$(df -k "$record_mount" | sed 1d | tr -d '\n' | awk 'END{print $4}') # in KiB
	echo_info "Space available: $available_space KiB"
}

get_occupied_space() {
	occupied_space=$(du -s "$record_storage" | awk '{print $1}') # in KiB
	echo_info "Space occupied: $occupied_space KiB"
}

# "path"
remove_oldest_file_in() {
	oldest_file="$(find "$1" -type f -exec ls -ltr {} + | head -n1 | awk '{print $9}')"
	oldest_file_dir="$(dirname $oldest_file)"
	rm -v "$oldest_file"
	[ -z "$(ls -A1 "$oldest_file_dir")" ] && rm -rv "$oldest_file_dir"
}

has_files() {
	[ "$(find "$1" -type f | wc -l)" -gt 0 ]
}

channel_state_file() {
	local channel="$1"
	echo "/run/prudynt/mp4ctl-ch${channel}.active"
}

wait_for_channel_idle() {
	local channel="$1"
	local timeout="$2"
	local waited=0
	local state_file
	state_file=$(channel_state_file "$channel")
	[ -z "$timeout" ] && timeout=0
	while : ; do
		if [ ! -f "$state_file" ]; then
			return 0
		fi
		if [ "$timeout" -gt 0 ] && [ "$waited" -ge "$timeout" ]; then
			return 1
		fi
		sleep 1
		waited=$((waited + 1))
	done
}

show_help() {
	usage "[<params>]
Where params are:
	-c <int>     Video channel index
	-t <int>     Duration in seconds
	-m <path>    Mount point for storing files
	-s <path>    Subdirectory for the device
	-n <string>  File name template (supports strftime format)
	-d <int>     Maximum disk usage, GiB
	-x           One-time run
"
}

singleton "$0"

RECORD_FLAG="/tmp/record.$$"

while getopts "c:d:f:h:m:n:p:s:t:u:v:w:xz:" flag; do
	case "$flag" in
		c) record_channel=$OPTARG ;;
		d) record_limit=$OPTARG ;;
		m) record_mount=$OPTARG ;;
		n) record_filename=$OPTARG ;;
		s) record_device_path=$OPTARG ;;
		t) record_duration=$OPTARG ;;
		x) one_time="true" ;;
		*) show_help && exit ;;
	esac
done
shift "$((OPTIND - 1))"

record_mount=${record_mount%/}
record_device_path=${record_device_path%/}

if [ -z "$record_mount" ]; then
	hesitate "Mountpoint record_mount is not set"
fi

if ! mountpoint -q "$record_mount"; then
	hesitate "Mountpoint $record_mount is not mounted"
fi

if [ ! -w "$record_mount" ]; then
	hesitate "Mountpoint $record_mount is not writable"
fi

if [ -z "$record_duration" ]; then
	record_duration=10
fi

if [ -z "$record_channel" ]; then
	record_channel=0
fi

if [ -z "$record_filename" ]; then
	record_filename="%hostname/%Y/%m/%d/%H-%M-%S"
fi

touch $RECORD_FLAG

record_storage="$record_mount/$record_device_path"
ensure_dir "$record_storage"

record_limit_kb=$((record_limit * 1024 * 1024)) # GiB to KiB
required_space=$((100 * record_duration)) # KiB

while : ; do
	[ -f $RECORD_FLAG ] || break

	get_free_space
	if [ "$available_space" -le "$required_space" ]; then
		echo_info "Space required: $required_space KiB"
		echo_warning "Not enough space: $required_space > $available_space"
		while [ "$available_space" -le "$required_space" ]; do
			remove_oldest_file_in "$record_storage"
			get_free_space
			if ! has_files "$record_storage"; then
				echo_error "$record_mount is empty yet no space!"
				exit 1
			fi
		done
	fi

	if [ "0$record_limit_kb" -gt 0 ]; then
		echo_info "Space limit: $record_limit_kb KiB"
		get_occupied_space
		while [ "$((occupied_space + required_space))" -gt "$record_limit_kb" ]; do
			echo_warning "Occupied space $occupied_space KiB exceeds limit $record_limit_kb KiB"
			remove_oldest_file_in "$record_storage"
			get_occupied_space
			if ! has_files "$record_storage"; then
				echo_error "$record_mount is empty yet no space!"
				exit 1
			fi
		done
	fi

	record_file="$record_storage/$(date +"$record_filename").mp4"
	ensure_dir "$(dirname $record_file)"

	real_duration=$(fix_duration $record_duration)
	[ -z "$real_duration" ] && real_duration=$record_duration

	controller_command="START $record_file $real_duration $record_channel"
	echo_command "$controller_command"
	echo "$controller_command" > /run/prudynt/mp4ctl
	wait_timeout=$((real_duration + 5))
	if ! wait_for_channel_idle "$record_channel" "$wait_timeout"; then
		echo_warning "Recorder on channel $record_channel still active after ${wait_timeout}s"
	fi

	[ "true" = "$one_time" ] && rm $RECORD_FLAG
done

echo_warning "Cannot find recording flag $RECORD_FLAG"
[ -n "$LEDD_FLAG" ] && [ -f "$LEDD_FLAG" ] && rm $LEDD_FLAG
echo_info "Exit"

exit 0
