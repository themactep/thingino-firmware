#!/bin/sh

. /usr/share/common

RTSP_URL="rtsp://thingino:thingino@127.0.0.1/ch0"
PID_FILE="/run/rtsp_watchdog.pid" # PID file to store the background process ID

# Interval to check the stream
INTERVAL=60

# Number of retries before declaring the stream down
RETRY_COUNT=3

# Delay in seconds between retry attempts
RETRY_DELAY=10

# Maximum number of restarts before alerting
RESTART_LIMIT=3

# Delay in seconds between restarts
RESTART_DELAY=10

# Seconds to wait for probe command
CHECK_TIMEOUT=10

RTSP_HOST=""
RTSP_PORT=""
PID=""
RESTART_COUNT=0

parse_rtsp_endpoint() {
	local url="${RTSP_URL#rtsp://}"
	local creds_trim="${url##*@}"
	local host_port="${creds_trim%%/*}"
	if [ -z "$host_port" ]; then
		return 1
	fi
	if echo "$host_port" | grep -q ':'; then
		RTSP_HOST="${host_port%%:*}"
		RTSP_PORT="${host_port##*:}"
	else
		RTSP_HOST="$host_port"
		RTSP_PORT=554
	fi
	[ -n "$RTSP_HOST" ] && [ -n "$RTSP_PORT" ]
}

check_with_curl() {
	curl -s --max-time "$CHECK_TIMEOUT" --fail -X OPTIONS "$RTSP_URL" >/dev/null 2>&1
}

check_with_nc() {
	[ -n "$RTSP_HOST" ] || parse_rtsp_endpoint || return 1
	local payload
	payload=$(printf 'OPTIONS %s RTSP/1.0\r\nCSeq: 1\r\nUser-Agent: stream-watchdog\r\n\r\n' "$RTSP_URL")
	printf '%s' "$payload" | timeout "$CHECK_TIMEOUT" nc -w "$CHECK_TIMEOUT" "$RTSP_HOST" "$RTSP_PORT" 2>/dev/null | grep -q "RTSP/1.0 200"
}

check_rtsp_stream() {
	if check_with_curl; then
		return 0
	fi

	if check_with_nc; then
		return 0
	fi

	return 1
}

# Handle signals
trap 'echo "Stream Watchdog: Stopping watchdog..."; cleanup; exit 0' INT TERM

cleanup() {
	# Kill any background processes and cleanup resources
	if [ -f "$PID_FILE" ]; then
		PID=$(cat "$PID_FILE")
		[ -n "$PID" ] && kill "$PID" 2>/dev/null || true
	fi
}

watch() {
	while true; do
		SUCCESS=false

		for i in $(seq 1 $RETRY_COUNT); do
			if check_rtsp_stream; then
				SUCCESS=true
				RESTART_COUNT=0  # Reset the restart count after a successful check
				break
			else
				echo_info "Attempt $i failed. Retrying in $RETRY_DELAY seconds..."
				sleep $RETRY_DELAY  # Delay before retrying
			fi
		done

		if ! $SUCCESS; then
			echo_warning "Stream stream is down, restarting server..."
			service restart prudynt

			RESTART_COUNT=$((RESTART_COUNT+1))

			# Delay before checking the stream again after a restart
			echo_info "Waiting $RESTART_DELAY seconds before rechecking..."
			sleep $RESTART_DELAY

			if [ $RESTART_COUNT -ge $RESTART_LIMIT ]; then
				echo_warning "Restart limit reached, nothing to log..."
				# ALERT!
				RESTART_COUNT=0  # Reset the count after escalation
			fi
		fi

		# Sleep for a defined interval before the next full check cycle
		sleep $INTERVAL
	done
}

start() {
	echo_title "Starting Stream Watchdog"

	if is_streamer_disabled; then
		echo_error "Streamer disabled"
		exit 1
	fi

	parse_rtsp_endpoint || true

	watch &
	PID=$!
	echo "$PID" > "$PID_FILE"  # Store the PID of the background process
}

stop() {
	echo_title "Stopping Stream Watchdog"

	if [ -f "$PID_FILE" ]; then
		PID=$(cat "$PID_FILE")
		if kill -0 "$PID" 2>/dev/null; then
			kill "$PID"
			echo_info "Watchdog process stopped."
			rm -f "$PID_FILE"  # Clean up the PID file
		else
			echo_info "No running watchdog process found."
		fi
	else
		echo_info "PID file not found."
	fi
}

case "$1" in
	start)
		start
		;;
	stop)
		stop
		;;
	restart)
		stop
		sleep 1
		start
		;;
	*)
		echo "Usage: $0 {start|stop|restart}"
		exit 1
		;;
esac

exit 0
