#!/bin/sh

die() { echo "$1" >&2; exit 1; }

PRUDYNT_CONFIG_FILE="/etc/prudynt.json"

show_help() {
	echo "Thingino Diagnostics Script
Generate diagnostics log

Usage: $0 [OPTIONS]
Options:
	-o -             Output to stdout
	-o /path/file    Output to specific file
	-u               Upload to server (tb.thingino.com)
	-j               Upload to server and return JSON with link
	-f               Force: skip consent prompt
	-h               Show this help

Legacy options:
	-l [path]        Save to local file (default: /tmp)

Default: Save to random temp file in /tmp/
"
	exit 0
}

header() {
	local len=$((73 - ${#1}))
	echo -en "\n\n===[ $1 ]"
	for i in $(seq 1 $len); do echo -n "="; done
	echo -e "\n\n"
}

infocat() {
	[ -f "$1" ] || return
	[ -n "$2" ] && header "$2"
	cat "$1"
}

inforun() {
	tmp=$(mktemp) || exit 1
	eval "$1" >"$tmp"
	if [ -s "$tmp" ]; then
		[ -n "$2" ] && header "$2"
		cat "$tmp"
	fi
	rm -f "$tmp"
}

output_mode="temp"  # temp, stdout, file, upload, json
output_file=""
upload_to_server="no"
force_mode="no"

while getopts ":o:l::ujfh" opt; do
	case $opt in
		o)
			if [ "$OPTARG" = "-" ]; then
				output_mode="stdout"
			else
				output_mode="file"
				output_file="$OPTARG"
				# Create directory if it doesn't exist
				output_dir=$(dirname "$output_file")
				[ -d "$output_dir" ] || mkdir -p "$output_dir" || die "Error: Cannot create directory $output_dir"
			fi
			;;
		l)
			# Legacy option: -l [path]
			output_mode="temp"
			if [ -n "$OPTARG" ]; then
				# Path specified with -l
				output_file="$OPTARG/thingino-diag-$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 4).log"
				output_mode="file"
				# Create directory if it doesn't exist
				[ -d "$OPTARG" ] || mkdir -p "$OPTARG" || die "Error: Cannot create directory $OPTARG"
			else
				# Check if next argument is a path (not starting with -)
				eval next_arg=\$${OPTIND}
				if [ -n "$next_arg" ] && [ "${next_arg#-}" = "$next_arg" ]; then
					output_file="$next_arg/thingino-diag-$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 4).log"
					output_mode="file"
					[ -d "$next_arg" ] || mkdir -p "$next_arg" || die "Error: Cannot create directory $next_arg"
					OPTIND=$((OPTIND + 1))
				fi
				# If no path specified, use default temp mode
			fi
			;;
		u)
			output_mode="upload"
			upload_to_server="yes"
			;;
		j)
			output_mode="json"
			upload_to_server="yes"
			;;
		f)
			force_mode="yes"
			;;
		h)
			show_help
			;;
		\?)
			echo "Invalid option: -$OPTARG" >&2
			show_help
			;;
		:)
			echo "Option -$OPTARG requires an argument." >&2
			show_help
			;;
	esac
done

# Determine output destination
case "$output_mode" in
	"stdout")
		output_file="/dev/stdout"
		;;
	"file")
		# output_file already set from -o option
		;;
	"upload")
		output_file=$(mktemp)
		;;
	"json")
		output_file=$(mktemp)
		;;
	"temp"|*)
		output_file="/tmp/thingino-diag-$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 4).log"
		;;
esac

# Interactive confirmation (except for stdout mode or force mode)
if [ -t 0 ] && [ "$output_mode" != "stdout" ] && [ "$force_mode" != "yes" ]; then
	echo "Thingino Diagnostics"
	[ "$upload_to_server" = "yes" ] && echo "This script requires network access."
	echo "
This script generates a log file for sharing with developers for diagnostic issues.
The log may contain sensitive information, please review it before sharing!
"
	[ "$upload_to_server" = "yes" ] && echo "Files uploaded to tb.thingino.com are stored for 1 week."
	read -p "Do you wish to proceed? (yes/no): " response
	[ "yes" = "$response" ] || die "Operation aborted by the user."
fi

# Start timing for total information gathering
diag_start_time=$(date +%s.%N 2>/dev/null || date +%s)

{
	inforun "date"
	inforun "uptime"
	inforun "uname -a"
	inforun "grep -a \"Thingino\" /dev/mtd0"
	infocat "/etc/os-release" "THINGINO"
	inforun "soc;soc -w" "SOC"

	header "ENV"
	fw_printenv | awk -F'=' '{if (/ethaddr|gatewayip|ipaddr|root_pw_hash|pwbackup|serverip|ssh_authorized_keys|sshkey|wlan_ssid|wlan_mac|wlan_pass|wg_dns|wg_address|wg_endpoint|wg_peerpub|wg_peerpsk|wg_allowed/) print $1 "=REDACTED"; else print}' | sort

	inforun "jct /etc/thingino.json print"

	infocat "/proc/cmdline" "CMDLINE"
	inforun "gpio list" "GPIO"
	inforun "df -h" "DF"
	inforun "ipcs" "IPC"
	inforun "find /sys -path '*mmc*vendor' -type f -exec sh -c 'echo \"Vendor: \$1\"; cat \"\$1\"; dev=\"\${1/vendor/device}\"; [ -f \"\$dev\" ] && { echo \"Device: \$dev\"; cat \"\$dev\"; }' _ {} \;" "MMC"

	inforun "lsmod" "KMOD"
	header "KMOD-2"
	for file in /etc/modules.d/*; do
		echo "== $file =="
		cat "$file"
	done

	[ -d /sys/bus/usb/devices/ ] && inforun "lsusb" "USB"

	inforun "free -h" "MEMORY"
	inforun "mount" "MOUNT"

	infocat "/proc/jz/clock/clocks" "CLOCKS"
	infocat "/proc/jz/isp/isp-fs" "isp-fs"
	infocat "/proc/jz/isp/isp-m0" "isp-m0"
	infocat "/proc/jz/isp/isp_info" "isp_info"
	infocat "/tmp/continuous_mem_info" "libimp meminfo"

	inforun "sensor -a" "sensor"

	inforun "ps" "PS"
	inforun "lsof" "LSOF"
	inforun "dmesg" "DMESG"
	inforun "logcat -t" "LOGCAT"
	inforun "logread" "SYSLOG"

	header "streamer"
	sed 's/"password": "[^"]*"/"password": "REDACTED"/g' $PRUDYNT_CONFIG_FILE
	infocat "/etc/cron/crontabs/root" "crontab"
} > "$output_file"

# Calculate and display total information gathering time
diag_end_time=$(date +%s.%N 2>/dev/null || date +%s)
if command -v bc >/dev/null 2>&1; then
	total_duration=$(echo "$diag_end_time - $diag_start_time" | bc 2>/dev/null || echo "0")
else
	total_duration=$(awk "BEGIN {print $diag_end_time - $diag_start_time}" 2>/dev/null || echo "0")
fi

# Post-process to redact sensitive information (except for stdout)
if [ "$output_mode" != "stdout" ]; then
	sed -E -i 's/(openRTSP -V -u) (\w*) (\w*) (.*)$/\1 REDACTED REDACTED \4/' "$output_file"
fi

# Handle different output modes
case "$output_mode" in
	"stdout")
		# Output already sent to stdout, nothing more to do
		;;
	"upload")
		url=$(send2termbin < "$output_file")
		rm -f "$output_file"
		[ -z "$url" ] && die "There was an error uploading the file."
		echo "Your diagnostics log link:"
		echo "$url"
		echo "Information gathering completed in ${total_duration}s"
		;;
	"json")
		url=$(send2termbin < "$output_file")
		rm -f "$output_file"
		[ -z "$url" ] && die "There was an error uploading the file."
		# Output JSON for web API consumption
		printf '{"status":"ok","link":"%s","duration":"%s"}\n' "$url" "${total_duration}s"
		;;
	"file"|"temp")
		echo "Diagnostics log saved at $output_file"
		echo "Information gathering completed in ${total_duration}s"
		;;
esac

exit 0
