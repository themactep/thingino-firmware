#!/bin/sh

# IRCUT controller that understands every gpio.ircut variant used in Thingino
# camera profiles (scalar pins, strings with o/O suffix, structured objects,
# lists of pins, and the /dev/tmi8152_ir_cut device shim).

. /usr/share/common

MODE_FILE="/tmp/ircutmode.txt"
: "${IRCUT_PULSE_US:=10000}"
CONFIG_ROOT="gpio.ircut"

: "${CONFIG_JSON:=/etc/thingino.json}"
: "${JCT_BIN:=$(command -v jct 2>/dev/null)}"

[ -f "$MODE_FILE" ] || echo "-1" > "$MODE_FILE"

pin1=""
pin2=""
pin1_active_low=0
pin2_active_low=0
pin_count=0
control_mode=""
ircut_disabled=0
disabled_reason=""

first_char() {
	printf '%s' "$1" | sed -n 's/^[[:space:]]*\(.\).*$/\1/p' | head -n 1
}

bool_flag() {
	case "${1:-}" in
		1|true|TRUE|on|ON|yes|YES)
			echo 1
			;;
		0|false|FALSE|off|OFF|no|NO)
			echo 0
			;;
		*)
			echo "${2:-0}"
			;;
	esac
}

jct_has() {
	[ -n "$JCT_BIN" ] || return 1
	[ -r "$CONFIG_JSON" ] || return 1
	"$JCT_BIN" "$CONFIG_JSON" get "$1" >/dev/null 2>&1
}

jct_get() {
	[ -n "$JCT_BIN" ] || return 1
	[ -r "$CONFIG_JSON" ] || return 1
	"$JCT_BIN" "$CONFIG_JSON" get "$1" 2>/dev/null
}

get_bool_or_default() {
	local key="$1" default="$2" raw
	raw=$(jct_get "$key") || {
		echo "$default"
		return
	}
	raw=$(printf '%s' "$raw" | tr -d '\r\n"')
	bool_flag "$raw" "$default"
}

register_pin() {
	local pin="$1" active_low="${2:-0}"
	[ "$ircut_disabled" -eq 0 ] || return 0
	case "$pin" in
		-1)
			ircut_disabled=1
			disabled_reason="IRCUT disabled in configuration"
			pin1=""
			pin2=""
			pin_count=0
			return 0
			;;
		""|*[!0-9])
			echo_warning "Ignoring invalid IRCUT pin '$pin'"
			return 0
			;;
	esac
	if [ -z "$pin1" ]; then
		pin1="$pin"
		pin1_active_low="$active_low"
		pin_count=1
		return 0
	fi
	if [ -z "$pin2" ]; then
		pin2="$pin"
		pin2_active_low="$active_low"
		pin_count=2
		return 0
	fi
	echo_warning "Ignoring extra IRCUT pin '$pin'"
}

parse_pin_token() {
	local token="$1" default_active="$2" suffix pin active
	[ -n "$token" ] || return 0
	case "$token" in
		999)
			register_pin 999 "$default_active"
			return 0
			;;
		-1)
			register_pin -1 "$default_active"
			return 0
			;;
	esac
	suffix=${token#${token%?}}
	case "$suffix" in
		o)
			pin=${token%?}
			active=1
			;;
		O)
			pin=${token%?}
			active=0
			;;
		*)
			pin="$token"
			active="$default_active"
			;;
	esac
	register_pin "$pin" "$active"
}

parse_scalar_tokens() {
	local raw="$1" default_active="$2" tokens
	tokens=$(printf '%s' "$raw" | tr '\r\n' ' ')
	set -- $tokens
	[ $# -gt 0 ] || return 1
	while [ $# -gt 0 ]; do
		parse_pin_token "$1" "$default_active"
		shift
		[ "$ircut_disabled" -eq 0 ] || break
	done
}

extract_node() {
	local key="$1" default_active="$2" node_active raw first idx
	[ "$ircut_disabled" -eq 0 ] || return 0
	node_active=$(get_bool_or_default "$key.active_low" "$default_active")
	if jct_has "$key.pin"; then
		extract_node "$key.pin" "$node_active"
		return 0
	fi
	raw=$(jct_get "$key") || return 1
	first=$(first_char "$raw")
	case "$first" in
		"[")
			idx=0
			while jct_has "$key.$idx"; do
				extract_node "$key.$idx" "$node_active"
				idx=$((idx + 1))
				[ "$ircut_disabled" -eq 0 ] || break
			done
			[ "$idx" -gt 0 ] || echo_warning "Empty IRCUT array at $key"
			;;
		"{")
			echo_warning "Unhandled IRCUT object at $key"
			;;
		*)
			parse_scalar_tokens "$raw" "$node_active"
			;;
	esac
}

load_ircut_config() {
	local default_active=0
	if [ -n "$JCT_BIN" ] && [ -r "$CONFIG_JSON" ] && jct_has "$CONFIG_ROOT"; then
		default_active=$(get_bool_or_default "$CONFIG_ROOT.active_low" 0)
		extract_node "$CONFIG_ROOT" "$default_active"
	fi
	if [ "$pin_count" -eq 0 ] && [ "$ircut_disabled" -eq 0 ] && [ -n "$gpio_ircut" ]; then
		echo_info "Falling back to gpio_ircut environment override"
		parse_scalar_tokens "$gpio_ircut" "$default_active"
	fi
}

calc_levels() {
	case "$control_mode" in
		single)
			if [ "$pin1_active_low" -eq 1 ]; then
				single_open_level=1
				single_close_level=0
			else
				single_open_level=0
				single_close_level=1
			fi
			;;
		dual)
			if [ "$pin1_active_low" -eq 1 ]; then
				pin1_assert=0
				pin1_idle=1
			else
				pin1_assert=1
				pin1_idle=0
			fi
			if [ "$pin2_active_low" -eq 1 ]; then
				pin2_assert=0
				pin2_idle=1
			else
				pin2_assert=1
				pin2_idle=0
			fi
			;;
	esac
}

gpio_set_level() {
	local pin="$1" level="$2"
	gpio set "$pin" "$level" >/dev/null
}

write_mode() {
	printf '%s\n' "$1" > "$MODE_FILE"
}

read_mode() {
	local value
	if [ -r "$MODE_FILE" ]; then
		value=$(sed -n '1p' "$MODE_FILE" 2>/dev/null | tr -d '\r\n ')
	fi
	case "$value" in
		0|1)
			echo "$value"
			return 0
			;;
		*)
			echo -1
			return 1
			;;
	esac
}

apply_single() {
	local target="$1" level label
	if [ "$target" -eq 0 ]; then
		level=$single_open_level
		label="night"
	else
		level=$single_close_level
		label="day"
	fi
	echo_info "Set IRCUT GPIO $pin1 to $level ($label)"
	gpio_set_level "$pin1" "$level"
}

apply_dual_open() {
	echo_info "IRCUT -> night (pin1 idle, pin2 assert)"
	gpio_set_level "$pin1" "$pin1_idle"
	gpio_set_level "$pin2" "$pin2_assert"
	usleep "$IRCUT_PULSE_US"
	gpio_set_level "$pin2" "$pin2_idle"
}

apply_dual_close() {
	echo_info "IRCUT -> day (pin1 assert, pin2 idle)"
	gpio_set_level "$pin2" "$pin2_idle"
	gpio_set_level "$pin1" "$pin1_assert"
	usleep "$IRCUT_PULSE_US"
	gpio_set_level "$pin1" "$pin1_idle"
}

apply_tmi() {
	local target="$1"
	[ -c /dev/tmi8152_ir_cut ] || {
		echo_error "Missing /dev/tmi8152_ir_cut"
		return 1
	}
	echo -n "$target" > /dev/tmi8152_ir_cut
}

apply_state() {
	local target="$1"
	case "$control_mode" in
		tmi)
			apply_tmi "$target" || return 1
			;;
		single)
			apply_single "$target" || return 1
			;;
		dual)
			if [ "$target" -eq 0 ]; then
				apply_dual_open || return 1
			else
				apply_dual_close || return 1
			fi
			;;
		*)
			echo_error "IRCUT control mode not initialized"
			return 1
			;;
	esac
	write_mode "$target"
}

show_status() {
	local state
	state=$(read_mode)
	case "$state" in
		0)
			echo_info "IRCUT filter is removed"
			;;
		1)
			echo_info "IRCUT filter is set"
			;;
		*)
			echo_info "IRCUT filter is in unknown state"
			;;
	esac
}

load_ircut_config

if [ "$ircut_disabled" -eq 1 ]; then
	echo_info "$disabled_reason"
	exit 0
fi

case "$pin_count" in
	0)
		echo_error "No IRCUT pins defined in configuration"
		exit 1
		;;
	1)
		if [ "$pin1" = "999" ]; then
			control_mode="tmi"
		else
			control_mode="single"
		fi
		;;
	2)
		control_mode="dual"
		;;
	*)
		control_mode="dual"
		;;
esac

if [ "$control_mode" != "tmi" ]; then
	ensure_command gpio
	ensure_command usleep
fi

calc_levels

case "$1" in
	0|off|night)
		apply_state 0 || exit 1
		;;
	1|on|day)
		apply_state 1 || exit 1
		;;
	~|toggle)
		if [ "$(read_mode)" = "0" ]; then
			apply_state 1 || exit 1
		else
			apply_state 0 || exit 1
		fi
		;;
	status)
		show_status
		;;
	\?|read)
		printf '%s' "$(read_mode)"
		;;
	*)
		echo "Usage: $0 [on|off|toggle|status|read]" >&2
		exit 1
		;;
esac

exit 0
